{
  "url": "https://py-pdf.github.io/fpdf2/fpdf/pattern.html",
  "title": "Module fpdf.pattern",
  "content": "Handles the creation of patterns and gradients\n\nUsage documentation at: https://py-pdf.github.io/fpdf2/Patterns.html\n\nReturn [(u, a)] with a∈[0,1]; missing alpha => 1.0.\n\nClamp/sort/merge, ensure endpoints at 0 and 1, coerce to single Device* colorspace.\n\nWhen return_raw is true, also returns a list of the original stop positions (prior to clamping to [0,1]) converted to the same device colorspace. The raw offsets are sorted and merged (last stop wins for near-duplicates) but no implicit 0/1 endpoints are synthesized.\n\nPiecewise-linear sampling in [0,1]. Assumes normalized/sorted stops incl. endpoints.\n\nCreate a linear gradient for a shape with SVG-like stops (offset in [0,1]). REPEAT/REFLECT are implemented by expanding stops to cover the bbox projection.\n\nCreate a radial gradient for a shape with SVG-like stops (offset in [0,1]). - (cx, cy, r): outer circle - (fx, fy, fr): focal/inner circle (defaults to center with radius 0) REPEAT/REFLECT are implemented by expanding stops to cover the bbox projection.\n\nApproximate a sweep (conic) gradient as a Type 4 mesh (triangles). We build a full 0..2π fan so PAD/REPEAT/REFLECT outside [0,1] are respected. Angles are expected in radians.\n\nMap u∈R -> [0,1] via PAD/REPEAT/REFLECT.\n\nHelper class that provides a standard way to create an ABC using inheritance.\n\nGrayscale Shading object representing the alpha ramp (for a soft mask).\n\nTrue if any stop carries alpha != 1.0.\n\nHelper class that provides a standard way to create an ABC using inheritance.\n\nA shading pattern that creates a linear (axial) gradient in a PDF.\n\nThe gradient is defined by two points: (from_x, from_y) and (to_x, to_y), along which the specified colors are interpolated. Optionally, you can set a background color, extend the gradient beyond its start or end, and specify custom color stop positions via bounds.\n\nInherited from: Gradient.get_alpha_shading_object\n\nGrayscale Shading object representing the alpha ramp (for a soft mask).\n\nInherited from: Gradient.has_alpha\n\nTrue if any stop carries alpha != 1.0.\n\nPDF Shading type 4 (free-form Gouraud triangle mesh) with per-vertex colors.\n\nType-4 mesh shadings don't use Function objects; return empty list for output.\n\nInherited from: PDFContentStream.content_stream\n\nSubclasses can override this method to indicate the presence of a content stream\n\nInherited from: PDFContentStream.serialize\n\nSerialize the PDF object as an obj<</>>endobj text block\n\nRepresents a PDF Pattern object.\n\nCurrently, this class supports only \"shading patterns\" (pattern_type 2), using either a linear or radial gradient. Tiling patterns (pattern_type 1) are not yet implemented.\n\nInherited from: PDFObject.content_stream\n\nSubclasses can override this method to indicate the presence of a content stream\n\nInherited from: PDFObject.serialize\n\nSerialize the PDF object as an obj<</>>endobj text block\n\nHelper class that provides a standard way to create an ABC using inheritance.\n\nA shading pattern that creates a radial (or circular/elliptical) gradient in a PDF.\n\nThe gradient is defined by two circles (start and end). Colors are blended from the start circle to the end circle, forming a radial gradient. You can optionally set a background color, extend the gradient beyond its circles, and provide custom color stop positions via bounds.\n\nInherited from: Gradient.get_alpha_shading_object\n\nGrayscale Shading object representing the alpha ramp (for a soft mask).\n\nInherited from: Gradient.has_alpha\n\nTrue if any stop carries alpha != 1.0.\n\nReference to the top-level function object for the shading dictionary.\n\nInherited from: PDFObject.content_stream\n\nSubclasses can override this method to indicate the presence of a content stream\n\nAll function objects used by this shading (Type2 segments + final Type3).\n\nReturn self, as this is already a shading object.\n\nInherited from: PDFObject.serialize\n\nSerialize the PDF object as an obj<</>>endobj text block\n\nConic/sweep gradient that materializes as a type-4 (mesh) Shading. Build is bbox-dependent, so we create the shading lazily at emit time.\n\nInherited from: PDFObject.content_stream\n\nSubclasses can override this method to indicate the presence of a content stream\n\nInherited from: PDFObject.serialize\n\nSerialize the PDF object as an obj<</>>endobj text block\n\nTransition between 2 colors\n\nInherited from: PDFObject.content_stream\n\nSubclasses can override this method to indicate the presence of a content stream\n\nInherited from: PDFObject.serialize\n\nSerialize the PDF object as an obj<</>>endobj text block\n\n1‑channel exponential interpolation for alpha/luminance ramps.\n\nInherited from: PDFObject.content_stream\n\nSubclasses can override this method to indicate the presence of a content stream\n\nInherited from: PDFObject.serialize\n\nSerialize the PDF object as an obj<</>>endobj text block\n\nWhen multiple colors are used, a type 3 function is necessary to stitch type 2 functions together and define the bounds between each color transition\n\nInherited from: PDFObject.content_stream\n\nSubclasses can override this method to indicate the presence of a content stream\n\nInherited from: PDFObject.serialize\n\nSerialize the PDF object as an obj<</>>endobj text block",
  "headings": [
    {
      "level": "h1",
      "text": "Module fpdf.pattern",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Functions",
      "id": "header-functions"
    },
    {
      "level": "h2",
      "text": "Classes",
      "id": "header-classes"
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Subclasses",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Static methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    }
  ],
  "code_samples": [
    {
      "code": "def extract_alpha_stops(\n    stops01: list[tuple[float, Color]],\n) -> list[tuple[float, float]]:\n    \"\"\"Return [(u, a)] with a∈[0,1]; missing alpha => 1.0.\"\"\"\n    out: list[tuple[float, float]] = []\n    for u, c in stops01:\n        a = getattr(c, \"a\", None)\n        out.append((u, 1.0 if a is None else float(a)))\n    return out",
      "language": "python"
    },
    {
      "code": "def lerp(a: float, b: float, t: float) -> float:\n    return a + (b - a) * t",
      "language": "python"
    },
    {
      "code": "def lerp_tuple(\n    a: tuple[float, ...], b: tuple[float, ...], t: float\n) -> tuple[float, ...]:\n    if len(a) != len(b):\n        raise ValueError(\"Mismatched color component counts\")\n    return tuple(lerp(a[i], b[i], t) for i in range(len(a)))",
      "language": "python"
    },
    {
      "code": "def merge_near_duplicates(\n    pairs: Sequence[tuple[float, Union[Color, str]]],\n) -> Sequence[tuple[float, Union[Color, str]]]:\n    out: list[tuple[float, Union[Color, str]]] = []\n    for u, col in pairs:\n        if out and abs(out[-1][0] - u) <= TOLERANCE:\n            prev_u, prev_col = out[-1]\n            if prev_col == col:\n                # identical color: keep the newest sample\n                out[-1] = (u, col)\n                continue\n\n            step = max(TOLERANCE * 10, 1e-6)\n            nudged_prev = prev_u - step\n            if nudged_prev >= -TOLERANCE:\n                out[-1] = (nudged_prev, prev_col)\n                out.append((u, col))\n            else:\n                nudged = u + step\n                if nudged > 1.0:\n                    nudged = 1.0\n                    out[-1] = (max(0.0, min(prev_u, nudged - step)), prev_col)\n                else:\n                    out[-1] = (prev_u, prev_col)\n                out.append((nudged, col))\n        else:\n            out.append((u, col))\n    return out",
      "language": "python"
    },
    {
      "code": "def normalize_stops(\n    stops: Sequence[tuple[float, Union[Color, str]]],\n    coerce_to_device: bool = True,\n    *,\n    return_raw: bool = False,\n) -> tuple[str, list[tuple[float, Color]], Optional[list[tuple[float, Color]]]]:\n    \"\"\"\n    Clamp/sort/merge, ensure endpoints at 0 and 1, coerce to single Device* colorspace.\n\n    When ``return_raw`` is true, also returns a list of the original stop positions\n    (prior to clamping to [0,1]) converted to the same device colorspace. The raw\n    offsets are sorted and merged (last stop wins for near-duplicates) but no\n    implicit 0/1 endpoints are synthesized.\n    \"\"\"\n\n    if not stops:\n        raise ValueError(\"At least one stop is required\")\n\n    raw_entries: list[tuple[float, Color]] = []\n    for off, col in stops:\n        raw_u = float(off)\n        c = (\n            convert_to_device_color(col)\n            if (coerce_to_device and not hasattr(col, \"colors\"))\n            else col\n        )\n        raw_entries.append((raw_u, c))  # type: ignore[arg-type]\n    raw_entries.sort(key=lambda t: t[0])\n\n    merged_raw: list[tuple[float, Color]] = []\n    for raw_u, color in raw_entries:\n        if merged_raw and abs(merged_raw[-1][0] - raw_u) <= TOLERANCE:\n            merged_raw[-1] = (raw_u, color)\n        else:\n            merged_raw.append((raw_u, color))\n\n    def _lerp_color(c0: Color, c1: Color, t: float) -> Color:\n        comps0 = c0.colors\n        comps1 = c1.colors\n        blended = lerp_tuple(comps0, comps1, t)\n        a0 = getattr(c0, \"a\", None)\n        a1 = getattr(c1, \"a\", None)\n        alpha = None\n        if a0 is not None or a1 is not None:\n            alpha = lerp(\n                1.0 if a0 is None else float(a0), 1.0 if a1 is None else float(a1), t\n            )\n\n        if isinstance(c0, DeviceGray):\n            return DeviceGray(blended[0], alpha)\n        if isinstance(c0, DeviceRGB):\n            return DeviceRGB(blended[0], blended[1], blended[2], alpha)\n        if isinstance(c0, DeviceCMYK):\n            return DeviceCMYK(blended[0], blended[1], blended[2], blended[3], alpha)\n        return c0\n\n    def _ensure_stop(target: float) -> None:\n        if not merged_raw:\n            return\n        if (\n            target < merged_raw[0][0] - TOLERANCE\n            or target > merged_raw[-1][0] + TOLERANCE\n        ):\n            return\n        for u, _ in merged_raw:\n            if abs(u - target) <= TOLERANCE:\n                return\n        for idx in range(1, len(merged_raw)):\n            u0, c0 = merged_raw[idx - 1]\n            u1, c1 = merged_raw[idx]\n            if u0 - TOLERANCE <= target <= u1 + TOLERANCE:\n                span = max(u1 - u0, TOLERANCE)\n                t = (target - u0) / span\n                merged_raw.insert(idx, (target, _lerp_color(c0, c1, t)))\n                return\n\n    _ensure_stop(0.0)\n    _ensure_stop(1.0)\n\n    clamped_entries: list[tuple[float, Color]] = []\n    for raw_u, color in merged_raw:\n        if raw_u < 0.0:\n            u = 0.0\n        elif raw_u > 1.0:\n            u = 1.0\n        else:\n            u = raw_u\n        clamped_entries.append((u, color))\n\n    clamped_entries.sort(key=lambda t: t[0])\n\n    merged_clamped: list[tuple[float, Color]] = []\n    for u, color in clamped_entries:\n        if merged_clamped and abs(merged_clamped[-1][0] - u) <= TOLERANCE:\n            merged_clamped[-1] = (u, color)\n        else:\n            merged_clamped.append((u, color))\n\n    if len(merged_clamped) == 1:\n        u, color = merged_clamped[0]\n        merged_clamped = [(0.0, color), (1.0, color)]\n    else:\n        if abs(merged_clamped[0][0] - 0.0) > TOLERANCE:\n            merged_clamped.insert(0, (0.0, merged_clamped[0][1]))\n        else:\n            merged_clamped[0] = (0.0, merged_clamped[0][1])\n        if abs(merged_clamped[-1][0] - 1.0) > TOLERANCE:\n            merged_clamped.append((1.0, merged_clamped[-1][1]))\n        else:\n            merged_clamped[-1] = (1.0, merged_clamped[-1][1])\n\n    space_name, palette = pick_colorspace_and_promote([c for _, c in merged_clamped])\n    normalized = [(u, p) for (u, _), p in zip(merged_clamped, palette)]\n\n    if not return_raw:\n        return space_name, normalized, None\n\n    def promote_raw(color: Color) -> Color:\n        if space_name == \"DeviceGray\":\n            if isinstance(color, DeviceGray):\n                return color\n            if isinstance(color, DeviceRGB):\n                return color.to_gray()\n            if isinstance(color, DeviceCMYK):\n                raise ValueError(\"Can't mix CMYK with non-CMYK gradients\")\n        if space_name == \"DeviceRGB\":\n            if isinstance(color, DeviceRGB):\n                return color\n            if isinstance(color, DeviceGray):\n                return DeviceRGB(color.g, color.g, color.g)\n        return color\n\n    raw_promoted = [(u, promote_raw(color)) for (u, color) in merged_raw]\n    return space_name, normalized, raw_promoted",
      "language": "python"
    },
    {
      "code": "def pick_colorspace_and_promote(colors: list[Color]) -> tuple[str, list[Color]]:\n    kinds = {type(c).__name__ for c in colors}\n    if \"DeviceCMYK\" in kinds and len(kinds) > 1:\n        raise ValueError(\"Can't mix CMYK with other color spaces.\")\n    if kinds == {\"DeviceGray\", \"DeviceRGB\"}:\n        # promote Gray -> RGB\n        promoted: list[Color] = [\n            DeviceRGB(c.g, c.g, c.g) if isinstance(c, DeviceGray) else c for c in colors\n        ]\n        return \"DeviceRGB\", promoted\n    if kinds == {\"DeviceGray\"}:\n        return \"DeviceGray\", colors\n    if kinds == {\"DeviceRGB\"}:\n        return \"DeviceRGB\", colors\n    return \"DeviceRGB\", colors",
      "language": "python"
    },
    {
      "code": "def sample_stops(stops01: list[tuple[float, Color]], u: float) -> tuple[float, ...]:\n    \"\"\"Piecewise-linear sampling in [0,1]. Assumes normalized/sorted stops incl. endpoints.\"\"\"\n    for i in range(1, len(stops01)):\n        u1, c1 = stops01[i]\n        if u <= u1 + TOLERANCE:\n            u0, c0 = stops01[i - 1]\n            span = max(u1 - u0, TOLERANCE)\n            t = (u - u0) / span\n            return lerp_tuple(c0.colors, c1.colors, t)\n    return stops01[-1][1].colors",
      "language": "python"
    },
    {
      "code": "def shape_linear_gradient(\n    x1: float,\n    y1: float,\n    x2: float,\n    y2: float,\n    stops: Sequence[tuple[float, Union[Color, str]]],\n    spread_method: Union[GradientSpreadMethod, str] = GradientSpreadMethod.PAD,\n    bbox: Optional[\"BoundingBox\"] = None,\n) -> LinearGradient:\n    \"\"\"\n    Create a linear gradient for a shape with SVG-like stops (offset in [0,1]).\n    REPEAT/REFLECT are implemented by expanding stops to cover the bbox projection.\n    \"\"\"\n    if not stops:\n        raise ValueError(\"At least one stop is required\")\n\n    spread_method = GradientSpreadMethod.coerce(spread_method)\n\n    _, normalized_stops, raw_stops = normalize_stops(stops, return_raw=True)\n\n    if spread_method == GradientSpreadMethod.PAD or bbox is None:\n        # if the spread_method is PAD this is the final gradient\n        # if the spread_method is REPEAT/REFLECT but no bbox is given, we can't expand yet\n        # gradient paint will call this method again with the bbox to replace the gradient\n        # at render time\n        colors = [color for _, color in normalized_stops]\n        bounds = [offset for offset, _ in normalized_stops[1:-1]]\n\n        gradient = LinearGradient(\n            from_x=x1,\n            from_y=y1,\n            to_x=x2,\n            to_y=y2,\n            colors=colors,\n            bounds=bounds,\n            extend_before=True,\n            extend_after=True,\n        )\n        gradient.raw_stops = raw_stops\n        return gradient\n\n    # 5) Expand for REPEAT / REFLECT\n    use_raw_period = raw_stops is not None and len(raw_stops) >= 2\n    tile_stops = raw_stops if use_raw_period else normalized_stops\n    assert tile_stops is not None  # pleasing mypy\n    base_start = tile_stops[0][0]\n    base_end = tile_stops[-1][0]\n    base_span = max(base_end - base_start, TOLERANCE)\n    if base_span <= TOLERANCE:\n        base_start = 0.0\n        base_span = 1.0\n        tile_stops = normalized_stops\n\n    tmin, tmax, L = bbox.project_interval_on_axis(x1, y1, x2, y2)\n    if L <= TOLERANCE:\n        # Degenerate axis: synthesize flat\n        c0, c1 = normalized_stops[0][1], normalized_stops[-1][1]\n        return LinearGradient(\n            from_x=x1,\n            from_y=y1,\n            to_x=x2,\n            to_y=y2,\n            colors=[c0, c1],\n            bounds=[],\n            extend_before=False,\n            extend_after=False,\n        )\n\n    tmin_norm = tmin / L\n    tmax_norm = tmax / L\n\n    start_tile = math.floor((tmin_norm - base_start) / base_span) - 1\n    end_tile = math.ceil((tmax_norm - base_start) / base_span) + 1\n\n    expanded: list[tuple[float, Union[Color, str]]] = []\n    for k in range(start_tile, end_tile + 1):\n        shift = k * base_span\n        if spread_method == GradientSpreadMethod.REPEAT or (k & 1) == 0:\n            # even tiles for REFLECT behave like REPEAT\n            for u, col in tile_stops:\n                expanded.append((shift + u, col))\n        else:\n            # REFLECT on odd tiles: reverse order + mirrored u\n            for u, col in reversed(tile_stops):\n                mirrored = shift + base_start + base_span - (u - base_start)\n                expanded.append((mirrored, col))\n\n    # Clip a bit beyond bbox for compactness\n    margin = max(base_span, 1.0)\n    a = tmin_norm - margin\n    b = tmax_norm + margin\n    clipped = [\n        (s, c) for (s, c) in expanded if a - TOLERANCE <= s <= b + TOLERANCE\n    ] or expanded\n\n    # Renormalize to [0..1] over synthetic span\n    s0 = clipped[0][0]\n    sN = clipped[-1][0]\n    span = max(sN - s0, TOLERANCE)\n    renorm = [((s - s0) / span, c) for (s, c) in clipped]\n\n    # Shift/scale the coords so u=0..1 aligns to absolute positions s0..sN\n    lam0 = s0  # in units of periods\n    lam1 = s0 + span\n    nx1 = x1 + lam0 * (x2 - x1)\n    ny1 = y1 + lam0 * (y2 - y1)\n    nx2 = x1 + lam1 * (x2 - x1)\n    ny2 = y1 + lam1 * (y2 - y1)\n\n    # Merge identical offsets after math\n    merged = merge_near_duplicates(renorm)\n\n    linear_gradient_colors = [c for _, c in merged]\n    linear_gradient_bounds = [o for o, _ in merged[1:-1]]\n\n    gradient = LinearGradient(\n        from_x=nx1,\n        from_y=ny1,\n        to_x=nx2,\n        to_y=ny2,\n        colors=linear_gradient_colors,\n        bounds=linear_gradient_bounds,\n        extend_before=False,\n        extend_after=False,\n    )\n    gradient.raw_stops = raw_stops\n    return gradient",
      "language": "python"
    },
    {
      "code": "def shape_radial_gradient(\n    cx: float,\n    cy: float,\n    r: float,\n    stops: Sequence[tuple[float, Union[Color, str]]],\n    fx: Optional[float] = None,\n    fy: Optional[float] = None,\n    fr: float = 0.0,\n    spread_method: Union[GradientSpreadMethod, str] = GradientSpreadMethod.PAD,\n    bbox: Optional[\"BoundingBox\"] = None,\n) -> RadialGradient:\n    \"\"\"\n    Create a radial gradient for a shape with SVG-like stops (offset in [0,1]).\n    - (cx, cy, r): outer circle\n    - (fx, fy, fr): focal/inner circle (defaults to center with radius 0)\n    REPEAT/REFLECT are implemented by expanding stops to cover the bbox projection.\n    \"\"\"\n    if not stops:\n        raise ValueError(\"At least one stop is required\")\n\n    spread_method = GradientSpreadMethod.coerce(spread_method)\n\n    _, normalized_stops, raw_stops = normalize_stops(stops, return_raw=True)\n\n    if r < 0:\n        raise ValueError(\"Outer radius r must be >= 0\")\n    if fr < 0:\n        fr = 0.0\n    if fx is None:\n        fx = cx\n    if fy is None:\n        fy = cy\n    # If inner radius exceeds outer, clamp\n    if fr > r:\n        fr = r\n\n    if spread_method == GradientSpreadMethod.PAD or bbox is None:\n        # if the spread_method is PAD this is the final gradient\n        # if the spread_method is REPEAT/REFLECT but no bbox is given, we can't expand yet\n        # gradient paint will call this method again with the bbox to replace the gradient\n        # at render time\n        colors = [color for _, color in normalized_stops]\n        bounds = [offset for offset, _ in normalized_stops[1:-1]]\n\n        gradient = RadialGradient(\n            start_circle_x=fx,\n            start_circle_y=fy,\n            start_circle_radius=fr,\n            end_circle_x=cx,\n            end_circle_y=cy,\n            end_circle_radius=r,\n            colors=colors,\n            bounds=bounds,\n            extend_before=True,\n            extend_after=True,\n        )\n        gradient.raw_stops = raw_stops\n        return gradient\n\n    # 5) Expand for REPEAT / REFLECT across rings\n    use_raw_period = raw_stops is not None and len(raw_stops) >= 2\n    tile_stops = raw_stops if use_raw_period else normalized_stops\n    assert tile_stops is not None  # pleasing mypy\n    base_start = tile_stops[0][0]\n    base_end = tile_stops[-1][0]\n    base_span = max(base_end - base_start, TOLERANCE)\n    if base_span <= TOLERANCE:\n        base_start = 0.0\n        base_span = 1.0\n        tile_stops = normalized_stops\n\n    # Degenerate gradients with no radial growth can't be meaningfully repeated\n    if abs(r - fr) <= TOLERANCE:\n        colors = [color for _, color in normalized_stops]\n        bounds = [offset for offset, _ in normalized_stops[1:-1]]\n        gradient = RadialGradient(\n            start_circle_x=fx,\n            start_circle_y=fy,\n            start_circle_radius=fr,\n            end_circle_x=cx,\n            end_circle_y=cy,\n            end_circle_radius=r,\n            colors=colors,\n            bounds=bounds,\n            extend_before=True,\n            extend_after=True,\n        )\n        gradient.raw_stops = raw_stops\n        return gradient\n\n    def sigma_to_lambda(sigma: float) -> float:\n        return (sigma - base_start) / base_span\n\n    def circle_at(lam: float) -> tuple[float, float, float]:\n        return (\n            lerp(fx, cx, lam),\n            lerp(fy, cy, lam),\n            lerp(fr, r, lam),\n        )\n\n    target_sigma = base_end\n    if bbox is not None:\n        max_tiles = 256\n        for _ in range(max_tiles):\n            lam = sigma_to_lambda(target_sigma)\n            cx_lam, cy_lam, r_lam = circle_at(lam)\n            if bbox.max_distance_to_point(cx_lam, cy_lam) <= r_lam + 1e-6:\n                break\n            target_sigma += base_span\n        else:\n            target_sigma = base_end + max_tiles * base_span\n\n    tiles_needed = 0\n    if target_sigma > base_end:\n        tiles_needed = math.ceil((target_sigma - base_end) / base_span)\n\n    expanded: list[tuple[float, Color]] = []\n    for k in range(tiles_needed + 1):\n        shift = k * base_span\n        if spread_method == GradientSpreadMethod.REPEAT or (k & 1) == 0:\n            for u, col in tile_stops:\n                expanded.append((shift + u, col))\n        else:\n            for u, col in reversed(tile_stops):\n                mirrored = shift + base_start + base_span - (u - base_start)\n                expanded.append((mirrored, col))\n\n    if not expanded:\n        expanded = tile_stops[:]\n\n    # Clip a little beyond the target span to keep the list tight while preserving continuity\n    clip_limit = target_sigma + base_span + 1e-6\n    expanded = [pair for pair in expanded if pair[0] <= clip_limit]\n\n    s0 = expanded[0][0]\n    sN = expanded[-1][0]\n    span = max(sN - s0, TOLERANCE)\n    renorm = [((s - s0) / span, c) for (s, c) in expanded]\n\n    lam0 = sigma_to_lambda(s0)\n    lam1 = sigma_to_lambda(sN)\n    sx, sy, sr = circle_at(lam0)\n    ex, ey, er = circle_at(lam1)\n\n    # Merge identical offsets after math\n    merged = merge_near_duplicates(renorm)\n\n    radial_gradient_colors = [c for _, c in merged]\n    radial_gradient_bounds = [o for o, _ in merged[1:-1]]\n\n    gradient = RadialGradient(\n        start_circle_x=sx,\n        start_circle_y=sy,\n        start_circle_radius=sr,\n        end_circle_x=ex,\n        end_circle_y=ey,\n        end_circle_radius=er,\n        colors=radial_gradient_colors,\n        bounds=radial_gradient_bounds,\n        extend_before=False,\n        extend_after=False,\n    )\n    gradient.raw_stops = raw_stops\n    return gradient",
      "language": "python"
    },
    {
      "code": "def shape_sweep_gradient_as_mesh(\n    cx: float,\n    cy: float,\n    start_angle: float,\n    end_angle: float,\n    stops: Sequence[tuple[float, Union[Color, str]]],\n    spread_method: GradientSpreadMethod,\n    bbox: \"BoundingBox\",\n    segments: Optional[int] = None,\n    inner_radius_factor: float = 0.002,\n) -> MeshShading:\n    \"\"\"\n    Approximate a sweep (conic) gradient as a Type 4 mesh (triangles).\n    We build a full 0..2π fan so PAD/REPEAT/REFLECT outside [0,1] are respected.\n    Angles are expected in radians.\n    \"\"\"\n    _, norm_stops, _ = normalize_stops(stops)\n    first_c = norm_stops[0][1]\n    if isinstance(first_c, DeviceGray):\n        color_space = \"DeviceGray\"\n        comp_count = 1\n    elif isinstance(first_c, DeviceRGB):\n        color_space = \"DeviceRGB\"\n        comp_count = 3\n    else:\n        color_space = \"DeviceCMYK\"\n        comp_count = 4\n\n    tau = 2.0 * math.pi\n    delta = end_angle - start_angle\n    if abs(delta) <= TOLERANCE:\n        delta = tau\n\n    if delta < 0.0:\n        start_angle, end_angle = end_angle, start_angle\n        norm_stops = [(1.0 - u, c) for (u, c) in norm_stops]\n        norm_stops.sort(key=lambda t: t[0])\n        delta = -delta\n\n    span = delta if delta > TOLERANCE else tau\n    cover_span = max(span, tau)\n\n    if segments is None:\n        base_segments = max(1024, len(norm_stops) * 96)\n    else:\n        base_segments = max(16, segments)\n    max_angle = cover_span / float(base_segments)\n    max_angle = max(min(max_angle, math.pi / 2.0), math.pi / 360.0)\n\n    r_outer = bbox.max_distance_to_point(cx, cy)\n    r_inner = max(min(bbox.width, bbox.height) * float(inner_radius_factor), TOLERANCE)\n\n    start_mod = math.fmod(start_angle, tau)\n    if start_mod < 0.0:\n        start_mod += tau\n    end_mod = math.fmod(start_mod + span, tau)\n    if end_mod < 0.0:\n        end_mod += tau\n    wraps = span < tau - TOLERANCE and end_mod < start_mod\n    span_covers_full_circle = span >= tau - TOLERANCE\n    seam_progress = (tau - start_mod) % tau\n    if seam_progress <= TOLERANCE:\n        seam_progress = cover_span\n\n    progress_candidates: list[float] = [0.0]\n    tile_count = int(math.floor(cover_span / span))\n    remainder = cover_span - tile_count * span\n    if remainder < TOLERANCE:\n        remainder = 0.0\n\n    for tile in range(tile_count):\n        base_progress = tile * span\n        for u, _ in norm_stops:\n            progress_candidates.append(base_progress + u * span)\n\n    if remainder > 0.0:\n        portion = remainder / span\n        base_progress = tile_count * span\n        for u, _ in norm_stops:\n            if u > portion + TOLERANCE:\n                break\n            progress_candidates.append(base_progress + u * span)\n        progress_candidates.append(cover_span)\n    else:\n        progress_candidates.append(cover_span)\n\n    if spread_method == GradientSpreadMethod.PAD and not span_covers_full_circle:\n        tail_length = max(cover_span - span, 0.0)\n        if TOLERANCE < seam_progress < cover_span + TOLERANCE:\n            progress_candidates.append(seam_progress)\n        if (\n            tail_length > TOLERANCE\n            and cover_span - TOLERANCE > seam_progress > span + TOLERANCE\n        ):\n            seam_eps = min(\n                max(span * 0.01, TOLERANCE),\n                seam_progress - span - TOLERANCE,\n                cover_span - seam_progress - TOLERANCE,\n            )\n            if seam_eps > TOLERANCE:\n                progress_candidates.append(seam_progress - seam_eps)\n\n    progress_candidates.sort()\n    progress_nodes: list[float] = []\n    for progress in progress_candidates:\n        if progress_nodes and abs(progress - progress_nodes[-1]) <= TOLERANCE:\n            progress_nodes[-1] = progress\n        else:\n            progress_nodes.append(progress)\n\n    if not progress_nodes:\n        progress_nodes = [0.0, cover_span]\n    elif len(progress_nodes) == 1:\n        progress_nodes.append(progress_nodes[0] + cover_span)\n\n    span_plus = start_mod + span\n    crosses_360 = span_plus > tau + TOLERANCE\n    limit_theta = start_angle + seam_progress\n\n    # pylint: disable=too-many-return-statements\n    def raw_from_progress(progress: float) -> float:\n        if span <= TOLERANCE:\n            return 0.0\n\n        theta = start_angle + progress\n\n        if progress >= cover_span - TOLERANCE:\n            if (\n                spread_method == GradientSpreadMethod.PAD\n                and not span_covers_full_circle\n                and cover_span > span + TOLERANCE\n            ):\n                return 0.0\n            return 1.0\n\n        if spread_method == GradientSpreadMethod.PAD:\n            if span_covers_full_circle:\n                return progress / span if span > TOLERANCE else 0.0\n\n            if not crosses_360:\n                angle_mod = math.fmod(theta, tau)\n                if angle_mod < 0.0:\n                    angle_mod += tau\n                end_limit = start_mod + span\n                if angle_mod < start_mod - TOLERANCE:\n                    return 0.0\n                if angle_mod <= end_limit + TOLERANCE:\n                    return (angle_mod - start_mod) / span\n                return 0.0\n\n            # crosses 360°: only sample up to the seam (start -> 360°)\n            visible = max(seam_progress, TOLERANCE)\n            if progress <= visible + TOLERANCE:\n                return progress / visible\n            return 0.0\n\n        return progress / span\n\n    fan_line_raw: list[tuple[float, float, tuple[float, ...]]] = []\n    for progress in progress_nodes:\n        if (\n            progress >= cover_span - TOLERANCE\n            and not span_covers_full_circle\n            and cover_span > span + TOLERANCE\n            and spread_method != GradientSpreadMethod.PAD\n        ):\n            continue\n        theta = start_angle + progress\n        raw = raw_from_progress(progress)\n        if spread_method == GradientSpreadMethod.PAD:\n            mapped = 0.0 if raw <= 0.0 else 1.0 if raw >= 1.0 else raw\n        else:\n            mapped = spread_map(raw, spread_method)\n        color = sample_stops(norm_stops, mapped)\n        fan_line_raw.append((theta, raw, color))\n\n    if not fan_line_raw:\n        fan_line: list[tuple[float, tuple[float, ...]]] = []\n    elif (\n        spread_method == GradientSpreadMethod.PAD\n        and not span_covers_full_circle\n        and wraps\n    ):\n        limit_theta = start_angle + seam_progress\n        pad_color = fan_line_raw[0][2]\n        fan_line = []\n        inserted = False\n        for theta, raw, color in fan_line_raw:\n            fan_line.append((theta, color))\n            if not inserted and abs(theta - limit_theta) <= TOLERANCE:\n                fan_line.append((theta + TOLERANCE, pad_color))\n                inserted = True\n        if not inserted:\n            fan_line.append((limit_theta + TOLERANCE, pad_color))\n    else:\n        fan_line = [(theta, color) for (theta, _, color) in fan_line_raw]\n\n    samples: list[tuple[float, tuple[float, ...]]] = []\n    start_color_components = norm_stops[0][1].colors\n    if fan_line:\n        samples.append(fan_line[0])\n        for idx in range(len(fan_line) - 1):\n            theta0, color0 = fan_line[idx]\n            theta1, color1 = fan_line[idx + 1]\n            delta_theta = theta1 - theta0\n            if delta_theta <= TOLERANCE:\n                if samples:\n                    samples[-1] = (theta1, color1)\n                else:\n                    samples.append((theta1, color1))\n                continue\n            if wraps and theta0 > limit_theta + TOLERANCE:\n                color0 = start_color_components\n                color1 = start_color_components\n            splits = max(1, int(math.ceil(delta_theta / max_angle)))\n            for s in range(1, splits + 1):\n                t = s / splits\n                theta = theta0 + t * delta_theta\n                color = tuple(\n                    color0[j] + (color1[j] - color0[j]) * t for j in range(comp_count)\n                )\n                samples.append((theta, color))\n\n    if len(samples) <= 1:\n        theta = fan_line[0][0] if fan_line else start_angle\n        base_color = fan_line[0][1] if fan_line else norm_stops[0][1].colors\n        samples = [\n            (theta, base_color),\n            (theta + cover_span, base_color),\n        ]\n\n    triangles: list[\n        tuple[tuple[float, float], tuple[float, float], tuple[float, float]]\n    ] = []\n    tri_colors: list[tuple[tuple[float, ...], tuple[float, ...], tuple[float, ...]]] = (\n        []\n    )\n\n    theta_prev, color_prev = samples[0]\n    x_prev_inner = cx + r_inner * math.cos(theta_prev)\n    y_prev_inner = cy + r_inner * math.sin(theta_prev)\n    x_prev_outer = cx + r_outer * math.cos(theta_prev)\n    y_prev_outer = cy + r_outer * math.sin(theta_prev)\n\n    for theta_next, color_next in samples[1:]:\n        x_next_inner = cx + r_inner * math.cos(theta_next)\n        y_next_inner = cy + r_inner * math.sin(theta_next)\n        x_next_outer = cx + r_outer * math.cos(theta_next)\n        y_next_outer = cy + r_outer * math.sin(theta_next)\n\n        triangles.append(\n            (\n                (x_prev_inner, y_prev_inner),\n                (x_prev_outer, y_prev_outer),\n                (x_next_outer, y_next_outer),\n            )\n        )\n        tri_colors.append((color_prev, color_prev, color_next))\n\n        triangles.append(\n            (\n                (x_prev_inner, y_prev_inner),\n                (x_next_outer, y_next_outer),\n                (x_next_inner, y_next_inner),\n            )\n        )\n        tri_colors.append((color_prev, color_next, color_next))\n\n        theta_prev, color_prev = theta_next, color_next\n        x_prev_inner, y_prev_inner = x_next_inner, y_next_inner\n        x_prev_outer, y_prev_outer = x_next_outer, y_next_outer\n\n    return MeshShading(\n        color_space=color_space,\n        bbox=bbox,\n        comp_count=comp_count,\n        triangles=triangles,\n        colors=tri_colors,\n        background=None,\n        anti_alias=True,\n    )",
      "language": "python"
    },
    {
      "code": "def spread_map(u: float, method: GradientSpreadMethod) -> float:\n    \"\"\"Map u∈R -> [0,1] via PAD/REPEAT/REFLECT.\"\"\"\n    if method == GradientSpreadMethod.PAD:\n        return 0.0 if u < 0.0 else 1.0 if u > 1.0 else u\n    if method == GradientSpreadMethod.REPEAT:\n        return u - math.floor(u)\n    # REFLECT: triangle wave\n    v = u % 2.0\n    return v if v <= 1.0 else 2.0 - v",
      "language": "python"
    },
    {
      "code": "class Gradient(ABC):\n    def __init__(\n        self,\n        colors: Sequence[ColorInput],\n        background: Optional[ColorInput],\n        extend_before: bool,\n        extend_after: bool,\n        bounds: Optional[Sequence[float]],\n    ):\n        self.color_space, self.colors, self._alphas = self._convert_colors(colors)\n        self.background = None\n        if background:\n            bg = (\n                convert_to_device_color(background)\n                if isinstance(background, (str, *ColorClass, *NumberClass))\n                else convert_to_device_color(*background)\n            )\n            # Re-map background to the chosen palette colorspace\n            if self.color_space == \"DeviceGray\":\n                if isinstance(bg, DeviceRGB):\n                    bg = bg.to_gray()\n                elif isinstance(bg, DeviceCMYK):\n                    raise ValueError(\"Can't mix CMYK background with non-CMYK gradient\")\n            elif self.color_space == \"DeviceRGB\":\n                if isinstance(bg, DeviceGray):\n                    bg = DeviceRGB(bg.g, bg.g, bg.g)\n                elif isinstance(bg, DeviceCMYK):\n                    raise ValueError(\"Can't mix CMYK background with non-CMYK gradient\")\n            self.background = bg\n        self.extend_before = extend_before\n        self.extend_after = extend_after\n        self.bounds = (\n            bounds\n            if bounds\n            else [(i + 1) / (len(self.colors) - 1) for i in range(len(self.colors) - 2)]\n        )\n        if len(self.bounds) != len(self.colors) - 2:\n            raise ValueError(\n                \"Bounds array length must be two less than the number of colors\"\n            )\n        self.functions = self._generate_functions()\n        self.pattern = Pattern(self)\n        self._shading_object: Optional[Shading] = None\n        self._alpha_shading_object: Optional[Shading] = None\n        self.coords: Optional[Sequence[float]] = None\n        self.shading_type = 0\n        self.raw_stops: Optional[list[tuple[float, Color]]] = None\n\n    @classmethod\n    def _convert_colors(\n        cls, colors: Sequence[ColorInput]\n    ) -> tuple[str, list[Color], list[float]]:\n        \"\"\"Normalize colors to a single device colorspace and capture per-stop alpha (default 1.0).\"\"\"\n        if len(colors) < 2:\n            raise ValueError(\"A gradient must have at least two colors\")\n\n        # 1) Convert everything to Device* instances\n        palette: list[Color] = []\n        spaces: set[str] = set()\n        alphas: list[float] = []\n        for color in colors:\n            dc = (\n                convert_to_device_color(color)\n                if isinstance(color, (str, *ColorClass, *NumberClass))\n                else convert_to_device_color(*color)\n            )\n            palette.append(dc)\n            spaces.add(type(dc).__name__)\n            a = getattr(dc, \"a\", None)\n            alphas.append(float(a) if a is not None else 1.0)\n\n        # 2) Disallow any CMYK mixture with others\n        if \"DeviceCMYK\" in spaces and len(spaces) > 1:\n            raise ValueError(\"Can't mix CMYK with other color spaces.\")\n\n        # 3) If we ended up with plain CMYK, we're done\n        if spaces == {\"DeviceCMYK\"}:\n            return \"DeviceCMYK\", palette, alphas\n\n        # 4) Promote mix of Gray+RGB to RGB\n        if spaces == {\"DeviceGray\", \"DeviceRGB\"}:\n            promoted: list[Color] = []\n            for c in palette:\n                if isinstance(c, DeviceGray):\n                    promoted.append(DeviceRGB(c.g, c.g, c.g))\n                else:\n                    assert isinstance(c, DeviceRGB)\n                    promoted.append(c)\n            return \"DeviceRGB\", promoted, alphas\n\n        # 5) All Gray: stay Gray\n        if spaces == {\"DeviceGray\"}:\n            return \"DeviceGray\", palette, alphas\n\n        # 6) All RGB: optionally downcast to Gray if all are achromatic\n        if spaces == {\"DeviceRGB\"}:\n            # changing palette to typed list to please mypy\n            rgb_palette: list[DeviceRGB] = [\n                c for c in palette if isinstance(c, DeviceRGB)\n            ]\n            if all(c.is_achromatic() for c in rgb_palette):\n                return \"DeviceGray\", [c.to_gray() for c in rgb_palette], alphas\n            return \"DeviceRGB\", palette, alphas\n\n        # Fallback: default to RGB\n        return \"DeviceRGB\", palette, alphas\n\n    def _generate_functions(\n        self,\n    ) -> list[Type2Function | Type2FunctionGray | Type3Function]:\n        if len(self.colors) < 2:\n            raise ValueError(\"A gradient must have at least two colors\")\n        if len(self.colors) == 2:\n            return [Type2Function(self.colors[0], self.colors[1])]\n        number_of_colors = len(self.colors)\n        functions: list[Type2Function | Type2FunctionGray | Type3Function] = []\n        for i in range(number_of_colors - 1):\n            functions.append(Type2Function(self.colors[i], self.colors[i + 1]))\n        functions.append(Type3Function(functions[:], self.bounds))\n        return functions\n\n    def get_functions(self) -> list[Type2Function | Type2FunctionGray | Type3Function]:\n        return self.functions\n\n    def get_shading_object(self) -> \"Shading\":\n        if not self._shading_object:\n            coords = (\n                \"\"\n                if self.coords is None\n                else PDFArray(\n                    [\n                        (\n                            format_number(value)\n                            if isinstance(value, (int, float))\n                            else value\n                        )\n                        for value in self.coords\n                    ]\n                ).serialize()\n            )\n            self._shading_object = Shading(\n                shading_type=self.shading_type,\n                background=self.background,\n                color_space=self.color_space,\n                coords=coords,\n                functions=self.functions,\n                extend_before=self.extend_before,\n                extend_after=self.extend_after,\n            )\n        return self._shading_object\n\n    def get_pattern(self) -> Pattern:\n        return self.pattern\n\n    def has_alpha(self) -> bool:\n        \"\"\"True if any stop carries alpha != 1.0.\"\"\"\n        return any(abs(a - 1.0) > TOLERANCE for a in self._alphas)\n\n    def _generate_alpha_functions(\n        self,\n    ) -> Sequence[Type2Function | Type2FunctionGray | Type3Function]:\n        \"\"\"Stitched Type2 gray functions mirroring the color ramp bounds.\"\"\"\n        if len(self._alphas) < 2:\n            raise ValueError(\"Alpha ramp requires at least two stops\")\n        if len(self._alphas) == 2:\n            return [Type2FunctionGray(self._alphas[0], self._alphas[1])]\n        functions: list[Type2FunctionGray | Type3Function] = []\n        for i in range(len(self._alphas) - 1):\n            functions.append(Type2FunctionGray(self._alphas[i], self._alphas[i + 1]))\n        functions.append(Type3Function(functions[:], self.bounds))\n        return functions\n\n    def get_alpha_shading_object(\n        self, _: Optional[\"BoundingBox\"] = None\n    ) -> Optional[\"Shading\"]:\n        \"\"\"Grayscale Shading object representing the alpha ramp (for a soft mask).\"\"\"\n        if not self.has_alpha():\n            return None\n        if not self._alpha_shading_object:\n            if (\n                self.coords is not None\n                and isinstance(self.coords, (list, tuple))\n                and len(self.coords) > 1\n            ):\n                coords = PDFArray(self.coords).serialize()\n            else:\n                coords = \"\"\n            self._alpha_shading_object = Shading(\n                shading_type=self.shading_type,\n                background=None,  # mask content should be pure coverage, no bg\n                color_space=\"DeviceGray\",\n                coords=coords,\n                functions=self._generate_alpha_functions(),\n                extend_before=self.extend_before,\n                extend_after=self.extend_after,\n            )\n        return self._alpha_shading_object",
      "language": "python"
    },
    {
      "code": "def get_alpha_shading_object(\n    self, _: Optional[\"BoundingBox\"] = None\n) -> Optional[\"Shading\"]:\n    \"\"\"Grayscale Shading object representing the alpha ramp (for a soft mask).\"\"\"\n    if not self.has_alpha():\n        return None\n    if not self._alpha_shading_object:\n        if (\n            self.coords is not None\n            and isinstance(self.coords, (list, tuple))\n            and len(self.coords) > 1\n        ):\n            coords = PDFArray(self.coords).serialize()\n        else:\n            coords = \"\"\n        self._alpha_shading_object = Shading(\n            shading_type=self.shading_type,\n            background=None,  # mask content should be pure coverage, no bg\n            color_space=\"DeviceGray\",\n            coords=coords,\n            functions=self._generate_alpha_functions(),\n            extend_before=self.extend_before,\n            extend_after=self.extend_after,\n        )\n    return self._alpha_shading_object",
      "language": "python"
    },
    {
      "code": "def get_functions(self) -> list[Type2Function | Type2FunctionGray | Type3Function]:\n    return self.functions",
      "language": "python"
    },
    {
      "code": "def get_pattern(self) -> Pattern:\n    return self.pattern",
      "language": "python"
    },
    {
      "code": "def get_shading_object(self) -> \"Shading\":\n    if not self._shading_object:\n        coords = (\n            \"\"\n            if self.coords is None\n            else PDFArray(\n                [\n                    (\n                        format_number(value)\n                        if isinstance(value, (int, float))\n                        else value\n                    )\n                    for value in self.coords\n                ]\n            ).serialize()\n        )\n        self._shading_object = Shading(\n            shading_type=self.shading_type,\n            background=self.background,\n            color_space=self.color_space,\n            coords=coords,\n            functions=self.functions,\n            extend_before=self.extend_before,\n            extend_after=self.extend_after,\n        )\n    return self._shading_object",
      "language": "python"
    },
    {
      "code": "def has_alpha(self) -> bool:\n    \"\"\"True if any stop carries alpha != 1.0.\"\"\"\n    return any(abs(a - 1.0) > TOLERANCE for a in self._alphas)",
      "language": "python"
    },
    {
      "code": "class LinearGradient(Gradient):\n    def __init__(\n        self,\n        from_x: float,\n        from_y: float,\n        to_x: float,\n        to_y: float,\n        colors: Sequence[ColorInput],\n        background: Optional[ColorInput] = None,\n        extend_before: bool = False,\n        extend_after: bool = False,\n        bounds: Optional[list[float]] = None,\n    ):\n        \"\"\"\n        A shading pattern that creates a linear (axial) gradient in a PDF.\n\n        The gradient is defined by two points: (from_x, from_y) and (to_x, to_y),\n        along which the specified colors are interpolated. Optionally, you can set\n        a background color, extend the gradient beyond its start or end, and\n        specify custom color stop positions via `bounds`.\n\n        Args:\n            from_x (int or float): The x-coordinate of the starting point of the gradient,\n                in user space units.\n            from_y (int or float): The y-coordinate of the starting point of the gradient,\n                in user space units.\n            to_x (int or float): The x-coordinate of the ending point of the gradient,\n                in user space units.\n            to_y (int or float): The y-coordinate of the ending point of the gradient,\n                in user space units.\n            colors (list[str or tuple[int, int, int]]): A list of colors along which the gradient\n                will be interpolated. Colors may be given as hex strings (e.g., \"#FF0000\") or\n                (R, G, B) tuples.\n            background (str or tuple[int, int, int], optional): A background color to use\n                if the gradient does not fully cover the region it is applied to.\n                Defaults to None (no background).\n            extend_before (bool, optional): Whether to extend the first color beyond the\n                starting point (from_x, from_y). Defaults to False.\n            extend_after (bool, optional): Whether to extend the last color beyond the\n                ending point (to_x, to_y). Defaults to False.\n            bounds (list[float], optional): An optional list of floats in the range (0, 1)\n                that represent gradient stops for color transitions. The number of bounds\n                should be two less than the number of colors (for multi-color gradients).\n                Defaults to None, which evenly distributes color stops.\n        \"\"\"\n        super().__init__(colors, background, extend_before, extend_after, bounds)\n        self.coords: tuple[  # pyright: ignore[reportIncompatibleVariableOverride]\n            float, float, float, float\n        ] = (\n            from_x,\n            from_y,\n            to_x,\n            to_y,\n        )\n        self.shading_type = 2",
      "language": "python"
    },
    {
      "code": "class MeshShading(PDFContentStream):\n    \"\"\"\n    PDF Shading type 4 (free-form Gouraud triangle mesh) with per-vertex colors.\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        color_space: str,\n        bbox: \"BoundingBox\",\n        comp_count: int,\n        triangles: list[\n            tuple[tuple[float, float], tuple[float, float], tuple[float, float]]\n        ],\n        colors: list[tuple[tuple[float, ...], tuple[float, ...], tuple[float, ...]]],\n        background: Optional[\"Color\"] = None,\n        anti_alias: bool = True,\n    ):\n        self.type = Name(\"Shading\")\n        self.shading_type = 4\n        self.color_space = Name(color_space)\n        self.background = (\n            f'[{\" \".join(format_number(c) for c in background.colors)}]'\n            if background\n            else None\n        )\n        self._bbox = bbox\n        self._triangles = triangles\n        self._triangle_colors = colors\n        self.anti_alias = anti_alias\n        self._comp_count = comp_count\n\n        # Fixed bit depths (simple encoder): use 16-bit components to reduce banding\n        self.bits_per_coordinate = 16\n        self.bits_per_component = 16\n        self.bits_per_flag = 8\n\n        # Decode = [xmin xmax ymin ymax  0 1 (per component)]\n        decode_values = [\n            bbox.x0,\n            bbox.x1,\n            bbox.y0,\n            bbox.y1,\n            *([0.0, 1.0] * comp_count),\n        ]\n        self.decode = PDFArray([format_number(value) for value in decode_values])\n\n        super().__init__(contents=self._encode_stream_raw(), compress=True)\n\n    # Let Pattern() accept MeshShading like other shadings\n    def get_shading_object(self) -> \"MeshShading\":\n        return self\n\n    def _encode_stream_raw(self) -> bytes:\n        xmin, xmax = self._bbox.x0, self._bbox.x1\n        ymin, ymax = self._bbox.y0, self._bbox.y1\n        maxc = (1 << self.bits_per_coordinate) - 1\n        sx = maxc / max(xmax - xmin, TOLERANCE)\n        sy = maxc / max(ymax - ymin, TOLERANCE)\n        max_comp = (1 << self.bits_per_component) - 1\n\n        def q16(u: float, umin: float, scale: float) -> int:\n            ui = int(round((u - umin) * scale))\n            return 0 if ui < 0 else maxc if ui > maxc else ui\n\n        def q_component(v: float) -> int:\n            iv = int(round(float(v) * max_comp))\n            return 0 if iv < 0 else max_comp if iv > max_comp else iv\n\n        comp_fmt = \"H\" if self.bits_per_component > 8 else \"B\"\n        vertex_fmt = \">BHH\" + (comp_fmt * self._comp_count)\n        out = bytearray()\n        for (v0, v1, v2), (c0, c1, c2) in zip(self._triangles, self._triangle_colors):\n            for (x, y), comps in ((v0, c0), (v1, c1), (v2, c2)):\n                component_bytes = [\n                    q_component(comps[i]) if i < len(comps) else 0\n                    for i in range(self._comp_count)\n                ]\n                out += struct.pack(\n                    vertex_fmt,\n                    0,  # flag = 0 (no reuse)\n                    q16(x, xmin, sx),  # x\n                    q16(y, ymin, sy),  # y\n                    *component_bytes,\n                )\n        return bytes(out)\n\n    @classmethod\n    def get_functions(\n        cls,\n    ) -> Sequence[Type2Function | Type2FunctionGray | Type3Function]:\n        \"\"\"Type-4 mesh shadings don't use Function objects; return empty list for output.\"\"\"\n        return []",
      "language": "python"
    },
    {
      "code": "def get_shading_object(self) -> \"MeshShading\":\n    return self",
      "language": "python"
    },
    {
      "code": "class Pattern(PDFObject):\n    \"\"\"\n    Represents a PDF Pattern object.\n\n    Currently, this class supports only \"shading patterns\" (pattern_type 2),\n    using either a linear or radial gradient. Tiling patterns (pattern_type 1)\n    are not yet implemented.\n    \"\"\"\n\n    def __init__(self, shading: Union[\"Gradient\", \"Shading\", \"MeshShading\"]):\n        super().__init__()\n        self.type = Name(\"Pattern\")\n        # 1 for a tiling pattern or type 2 for a shading pattern:\n        self.pattern_type = 2\n        self._shading = shading\n        self._matrix = Transform.identity()\n        # If True (default), OutputProducer will bake the page CTM into this pattern.\n        # For patterns used inside Form XObjects (e.g., soft masks), set to False.\n        self._apply_page_ctm = True\n\n    @property\n    def shading(self) -> str:\n        return f\"{self._shading.get_shading_object().id} 0 R\"\n\n    @property\n    def matrix(self) -> str:\n        return (\n            f\"[{format_number(self._matrix.a)} {format_number(self._matrix.b)} \"\n            f\"{format_number(self._matrix.c)} {format_number(self._matrix.d)} \"\n            f\"{format_number(self._matrix.e)} {format_number(self._matrix.f)}]\"\n        )\n\n    def set_matrix(self, matrix: Transform) -> \"Pattern\":\n        self._matrix = matrix\n        return self\n\n    def get_matrix(self) -> Transform:\n        return self._matrix\n\n    def set_apply_page_ctm(self, apply: bool) -> None:\n        self._apply_page_ctm = apply\n\n    def get_apply_page_ctm(self) -> bool:\n        return self._apply_page_ctm",
      "language": "python"
    },
    {
      "code": "@property\ndef matrix(self) -> str:\n    return (\n        f\"[{format_number(self._matrix.a)} {format_number(self._matrix.b)} \"\n        f\"{format_number(self._matrix.c)} {format_number(self._matrix.d)} \"\n        f\"{format_number(self._matrix.e)} {format_number(self._matrix.f)}]\"\n    )",
      "language": "python"
    },
    {
      "code": "@property\ndef shading(self) -> str:\n    return f\"{self._shading.get_shading_object().id} 0 R\"",
      "language": "python"
    },
    {
      "code": "def get_apply_page_ctm(self) -> bool:\n    return self._apply_page_ctm",
      "language": "python"
    },
    {
      "code": "def get_matrix(self) -> Transform:\n    return self._matrix",
      "language": "python"
    },
    {
      "code": "def set_apply_page_ctm(self, apply: bool) -> None:\n    self._apply_page_ctm = apply",
      "language": "python"
    },
    {
      "code": "def set_matrix(self, matrix: Transform) -> \"Pattern\":\n    self._matrix = matrix\n    return self",
      "language": "python"
    },
    {
      "code": "class RadialGradient(Gradient):\n    def __init__(\n        self,\n        start_circle_x: float,\n        start_circle_y: float,\n        start_circle_radius: float,\n        end_circle_x: float,\n        end_circle_y: float,\n        end_circle_radius: float,\n        colors: Sequence[ColorInput],\n        background: Optional[ColorInput] = None,\n        extend_before: bool = False,\n        extend_after: bool = False,\n        bounds: Optional[list[float]] = None,\n    ):\n        \"\"\"\n        A shading pattern that creates a radial (or circular/elliptical) gradient in a PDF.\n\n        The gradient is defined by two circles (start and end). Colors are blended from the\n        start circle to the end circle, forming a radial gradient. You can optionally set a\n        background color, extend the gradient beyond its circles, and provide custom color\n        stop positions via `bounds`.\n\n        Args:\n            start_circle_x (int or float): The x-coordinate of the inner circle's center,\n                in user space units.\n            start_circle_y (int or float): The y-coordinate of the inner circle's center,\n                in user space units.\n            start_circle_radius (int or float): The radius of the inner circle, in user space units.\n            end_circle_x (int or float): The x-coordinate of the outer circle's center,\n                in user space units.\n            end_circle_y (int or float): The y-coordinate of the outer circle's center,\n                in user space units.\n            end_circle_radius (int or float): The radius of the outer circle, in user space units.\n            colors (list[str or tuple[int, int, int]]): A list of colors along which the gradient\n                will be interpolated. Colors may be given as hex strings (e.g., \"#FF0000\") or\n                (R, G, B) tuples.\n            background (str or tuple[int, int, int], optional): A background color to display\n                if the gradient does not fully cover the region it's applied to. Defaults to None\n                (no background).\n            extend_before (bool, optional): Whether to extend the gradient beyond the start circle.\n                Defaults to False.\n            extend_after (bool, optional): Whether to extend the gradient beyond the end circle.\n                Defaults to False.\n            bounds (list[float], optional): An optional list of floats in the range (0, 1) that\n                represent gradient stops for color transitions. The number of bounds should be one\n                less than the number of colors (for multi-color gradients). Defaults to None,\n                which evenly distributes color stops.\n        \"\"\"\n        super().__init__(colors, background, extend_before, extend_after, bounds)\n        self.coords: tuple[  # pyright: ignore[reportIncompatibleVariableOverride]\n            float, float, float, float, float, float\n        ] = (\n            start_circle_x,\n            start_circle_y,\n            start_circle_radius,\n            end_circle_x,\n            end_circle_y,\n            end_circle_radius,\n        )\n        self.shading_type = 3",
      "language": "python"
    },
    {
      "code": "class Shading(PDFObject):\n    def __init__(\n        self,\n        shading_type: int,  # 2 for axial shading, 3 for radial shading\n        background: Optional[Color],\n        color_space: str,\n        coords: Sequence[float] | str,\n        functions: Sequence[Type2Function | Type2FunctionGray | Type3Function],\n        extend_before: bool,\n        extend_after: bool,\n    ):\n        super().__init__()\n        self.shading_type = shading_type\n        self.background = (\n            f'[{\" \".join(format_number(c) for c in background.colors)}]'\n            if background\n            else None\n        )\n        self.color_space = Name(color_space)\n        self.coords = coords\n        self._functions = functions\n        self.extend = f'[{\"true\" if extend_before else \"false\"} {\"true\" if extend_after else \"false\"}]'\n        self.anti_alias = True\n\n    @property\n    def function(self) -> str:\n        \"\"\"Reference to the *top-level* function object for the shading dictionary.\"\"\"\n        return f\"{self._functions[-1].id} 0 R\"\n\n    def get_functions(\n        self,\n    ) -> Sequence[Type2Function | Type2FunctionGray | Type3Function]:\n        \"\"\"All function objects used by this shading (Type2 segments + final Type3).\"\"\"\n        return self._functions\n\n    def get_shading_object(self) -> \"Shading\":\n        \"\"\"Return self, as this is already a shading object.\"\"\"\n        return self",
      "language": "python"
    },
    {
      "code": "@property\ndef function(self) -> str:\n    \"\"\"Reference to the *top-level* function object for the shading dictionary.\"\"\"\n    return f\"{self._functions[-1].id} 0 R\"",
      "language": "python"
    },
    {
      "code": "def get_functions(\n    self,\n) -> Sequence[Type2Function | Type2FunctionGray | Type3Function]:\n    \"\"\"All function objects used by this shading (Type2 segments + final Type3).\"\"\"\n    return self._functions",
      "language": "python"
    },
    {
      "code": "def get_shading_object(self) -> \"Shading\":\n    \"\"\"Return self, as this is already a shading object.\"\"\"\n    return self",
      "language": "python"
    },
    {
      "code": "class SweepGradient(PDFObject):\n    \"\"\"\n    Conic/sweep gradient that materializes as a type-4 (mesh) Shading.\n    Build is bbox-dependent, so we create the shading lazily at emit time.\n    \"\"\"\n\n    __slots__ = (\n        \"cx\",\n        \"cy\",\n        \"start_angle\",\n        \"end_angle\",\n        \"stops\",\n        \"spread_method\",\n        \"segments\",\n        \"inner_radius_factor\",\n        \"_cached_key\",\n        \"_shading\",\n        \"_alpha_shading\",\n    )\n\n    def __init__(\n        self,\n        cx: float,\n        cy: float,\n        start_angle: float,\n        end_angle: float,\n        stops: Sequence[tuple[float, Union[Color, str]]],\n        spread_method: Union[\"GradientSpreadMethod\", str] = GradientSpreadMethod.PAD,\n        segments: Optional[int] = None,\n        inner_radius_factor: float = 0.002,\n    ):\n        super().__init__()\n        self.cx, self.cy = float(cx), float(cy)\n        self.start_angle, self.end_angle = float(start_angle), float(end_angle)\n        self.stops = stops\n        self.spread_method = (\n            GradientSpreadMethod.coerce(spread_method)\n            if hasattr(GradientSpreadMethod, \"coerce\")\n            else GradientSpreadMethod(spread_method)\n        )\n        self.segments = segments\n        self.inner_radius_factor = inner_radius_factor\n        self._cached_key: Optional[\n            tuple[\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                Optional[int],\n                float,\n                str,\n            ]\n        ] = None\n        self._shading: Optional[MeshShading] = None\n        self._alpha_shading: Optional[MeshShading] = None\n\n    def has_alpha(self) -> bool:\n        # any stop carries alpha != 1\n        for _, c in self.stops:\n            dc = convert_to_device_color(c) if not hasattr(c, \"colors\") else c\n            a = getattr(dc, \"a\", None)\n            if a is not None and abs(float(a) - 1.0) > TOLERANCE:\n                return True\n        return False\n\n    def get_shading_object(self, bbox: \"BoundingBox\") -> \"MeshShading\":\n        key = (\n            bbox.x0,\n            bbox.y0,\n            bbox.x1,\n            bbox.y1,\n            self.cx,\n            self.cy,\n            self.start_angle,\n            self.end_angle,\n            self.segments,\n            self.inner_radius_factor,\n            self.spread_method.value,\n        )\n        if self._shading is not None and self._cached_key == key:\n            return self._shading\n        self._cached_key = key\n        self._shading = shape_sweep_gradient_as_mesh(\n            self.cx,\n            self.cy,\n            self.start_angle,\n            self.end_angle,\n            self.stops,\n            spread_method=self.spread_method,\n            bbox=bbox,\n            segments=self.segments,\n            inner_radius_factor=self.inner_radius_factor,\n        )\n        return self._shading\n\n    def get_alpha_shading_object(self, bbox: \"BoundingBox\") -> Optional[\"MeshShading\"]:\n        if not self.has_alpha():\n            return None\n\n        # Normalize color stops once, then extract alpha\n        _, stops01, _ = normalize_stops(self.stops)\n        alpha01 = extract_alpha_stops(stops01)\n        gray_stops: list[tuple[float, Color | str]] = [\n            (u, DeviceGray(a)) for (u, a) in alpha01\n        ]\n\n        key = (\n            \"alpha\",\n            bbox.x0,\n            bbox.y0,\n            bbox.x1,\n            bbox.y1,\n            self.cx,\n            self.cy,\n            self.start_angle,\n            self.end_angle,\n            self.segments,\n            self.inner_radius_factor,\n            self.spread_method.value,\n        )\n\n        if getattr(self, \"_alpha_cached_key\", None) == key:\n            return self._alpha_shading\n\n        self._alpha_shading = shape_sweep_gradient_as_mesh(\n            self.cx,\n            self.cy,\n            self.start_angle,\n            self.end_angle,\n            gray_stops,\n            spread_method=self.spread_method,\n            bbox=bbox,\n            segments=self.segments,\n            inner_radius_factor=self.inner_radius_factor,\n        )\n        self._alpha_cached_key = key\n        return self._alpha_shading",
      "language": "python"
    },
    {
      "code": "class SweepGradient(PDFObject):\n    \"\"\"\n    Conic/sweep gradient that materializes as a type-4 (mesh) Shading.\n    Build is bbox-dependent, so we create the shading lazily at emit time.\n    \"\"\"\n\n    __slots__ = (\n        \"cx\",\n        \"cy\",\n        \"start_angle\",\n        \"end_angle\",\n        \"stops\",\n        \"spread_method\",\n        \"segments\",\n        \"inner_radius_factor\",\n        \"_cached_key\",\n        \"_shading\",\n        \"_alpha_shading\",\n    )\n\n    def __init__(\n        self,\n        cx: float,\n        cy: float,\n        start_angle: float,\n        end_angle: float,\n        stops: Sequence[tuple[float, Union[Color, str]]],\n        spread_method: Union[\"GradientSpreadMethod\", str] = GradientSpreadMethod.PAD,\n        segments: Optional[int] = None,\n        inner_radius_factor: float = 0.002,\n    ):\n        super().__init__()\n        self.cx, self.cy = float(cx), float(cy)\n        self.start_angle, self.end_angle = float(start_angle), float(end_angle)\n        self.stops = stops\n        self.spread_method = (\n            GradientSpreadMethod.coerce(spread_method)\n            if hasattr(GradientSpreadMethod, \"coerce\")\n            else GradientSpreadMethod(spread_method)\n        )\n        self.segments = segments\n        self.inner_radius_factor = inner_radius_factor\n        self._cached_key: Optional[\n            tuple[\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                Optional[int],\n                float,\n                str,\n            ]\n        ] = None\n        self._shading: Optional[MeshShading] = None\n        self._alpha_shading: Optional[MeshShading] = None\n\n    def has_alpha(self) -> bool:\n        # any stop carries alpha != 1\n        for _, c in self.stops:\n            dc = convert_to_device_color(c) if not hasattr(c, \"colors\") else c\n            a = getattr(dc, \"a\", None)\n            if a is not None and abs(float(a) - 1.0) > TOLERANCE:\n                return True\n        return False\n\n    def get_shading_object(self, bbox: \"BoundingBox\") -> \"MeshShading\":\n        key = (\n            bbox.x0,\n            bbox.y0,\n            bbox.x1,\n            bbox.y1,\n            self.cx,\n            self.cy,\n            self.start_angle,\n            self.end_angle,\n            self.segments,\n            self.inner_radius_factor,\n            self.spread_method.value,\n        )\n        if self._shading is not None and self._cached_key == key:\n            return self._shading\n        self._cached_key = key\n        self._shading = shape_sweep_gradient_as_mesh(\n            self.cx,\n            self.cy,\n            self.start_angle,\n            self.end_angle,\n            self.stops,\n            spread_method=self.spread_method,\n            bbox=bbox,\n            segments=self.segments,\n            inner_radius_factor=self.inner_radius_factor,\n        )\n        return self._shading\n\n    def get_alpha_shading_object(self, bbox: \"BoundingBox\") -> Optional[\"MeshShading\"]:\n        if not self.has_alpha():\n            return None\n\n        # Normalize color stops once, then extract alpha\n        _, stops01, _ = normalize_stops(self.stops)\n        alpha01 = extract_alpha_stops(stops01)\n        gray_stops: list[tuple[float, Color | str]] = [\n            (u, DeviceGray(a)) for (u, a) in alpha01\n        ]\n\n        key = (\n            \"alpha\",\n            bbox.x0,\n            bbox.y0,\n            bbox.x1,\n            bbox.y1,\n            self.cx,\n            self.cy,\n            self.start_angle,\n            self.end_angle,\n            self.segments,\n            self.inner_radius_factor,\n            self.spread_method.value,\n        )\n\n        if getattr(self, \"_alpha_cached_key\", None) == key:\n            return self._alpha_shading\n\n        self._alpha_shading = shape_sweep_gradient_as_mesh(\n            self.cx,\n            self.cy,\n            self.start_angle,\n            self.end_angle,\n            gray_stops,\n            spread_method=self.spread_method,\n            bbox=bbox,\n            segments=self.segments,\n            inner_radius_factor=self.inner_radius_factor,\n        )\n        self._alpha_cached_key = key\n        return self._alpha_shading",
      "language": "python"
    },
    {
      "code": "class SweepGradient(PDFObject):\n    \"\"\"\n    Conic/sweep gradient that materializes as a type-4 (mesh) Shading.\n    Build is bbox-dependent, so we create the shading lazily at emit time.\n    \"\"\"\n\n    __slots__ = (\n        \"cx\",\n        \"cy\",\n        \"start_angle\",\n        \"end_angle\",\n        \"stops\",\n        \"spread_method\",\n        \"segments\",\n        \"inner_radius_factor\",\n        \"_cached_key\",\n        \"_shading\",\n        \"_alpha_shading\",\n    )\n\n    def __init__(\n        self,\n        cx: float,\n        cy: float,\n        start_angle: float,\n        end_angle: float,\n        stops: Sequence[tuple[float, Union[Color, str]]],\n        spread_method: Union[\"GradientSpreadMethod\", str] = GradientSpreadMethod.PAD,\n        segments: Optional[int] = None,\n        inner_radius_factor: float = 0.002,\n    ):\n        super().__init__()\n        self.cx, self.cy = float(cx), float(cy)\n        self.start_angle, self.end_angle = float(start_angle), float(end_angle)\n        self.stops = stops\n        self.spread_method = (\n            GradientSpreadMethod.coerce(spread_method)\n            if hasattr(GradientSpreadMethod, \"coerce\")\n            else GradientSpreadMethod(spread_method)\n        )\n        self.segments = segments\n        self.inner_radius_factor = inner_radius_factor\n        self._cached_key: Optional[\n            tuple[\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                Optional[int],\n                float,\n                str,\n            ]\n        ] = None\n        self._shading: Optional[MeshShading] = None\n        self._alpha_shading: Optional[MeshShading] = None\n\n    def has_alpha(self) -> bool:\n        # any stop carries alpha != 1\n        for _, c in self.stops:\n            dc = convert_to_device_color(c) if not hasattr(c, \"colors\") else c\n            a = getattr(dc, \"a\", None)\n            if a is not None and abs(float(a) - 1.0) > TOLERANCE:\n                return True\n        return False\n\n    def get_shading_object(self, bbox: \"BoundingBox\") -> \"MeshShading\":\n        key = (\n            bbox.x0,\n            bbox.y0,\n            bbox.x1,\n            bbox.y1,\n            self.cx,\n            self.cy,\n            self.start_angle,\n            self.end_angle,\n            self.segments,\n            self.inner_radius_factor,\n            self.spread_method.value,\n        )\n        if self._shading is not None and self._cached_key == key:\n            return self._shading\n        self._cached_key = key\n        self._shading = shape_sweep_gradient_as_mesh(\n            self.cx,\n            self.cy,\n            self.start_angle,\n            self.end_angle,\n            self.stops,\n            spread_method=self.spread_method,\n            bbox=bbox,\n            segments=self.segments,\n            inner_radius_factor=self.inner_radius_factor,\n        )\n        return self._shading\n\n    def get_alpha_shading_object(self, bbox: \"BoundingBox\") -> Optional[\"MeshShading\"]:\n        if not self.has_alpha():\n            return None\n\n        # Normalize color stops once, then extract alpha\n        _, stops01, _ = normalize_stops(self.stops)\n        alpha01 = extract_alpha_stops(stops01)\n        gray_stops: list[tuple[float, Color | str]] = [\n            (u, DeviceGray(a)) for (u, a) in alpha01\n        ]\n\n        key = (\n            \"alpha\",\n            bbox.x0,\n            bbox.y0,\n            bbox.x1,\n            bbox.y1,\n            self.cx,\n            self.cy,\n            self.start_angle,\n            self.end_angle,\n            self.segments,\n            self.inner_radius_factor,\n            self.spread_method.value,\n        )\n\n        if getattr(self, \"_alpha_cached_key\", None) == key:\n            return self._alpha_shading\n\n        self._alpha_shading = shape_sweep_gradient_as_mesh(\n            self.cx,\n            self.cy,\n            self.start_angle,\n            self.end_angle,\n            gray_stops,\n            spread_method=self.spread_method,\n            bbox=bbox,\n            segments=self.segments,\n            inner_radius_factor=self.inner_radius_factor,\n        )\n        self._alpha_cached_key = key\n        return self._alpha_shading",
      "language": "python"
    },
    {
      "code": "class SweepGradient(PDFObject):\n    \"\"\"\n    Conic/sweep gradient that materializes as a type-4 (mesh) Shading.\n    Build is bbox-dependent, so we create the shading lazily at emit time.\n    \"\"\"\n\n    __slots__ = (\n        \"cx\",\n        \"cy\",\n        \"start_angle\",\n        \"end_angle\",\n        \"stops\",\n        \"spread_method\",\n        \"segments\",\n        \"inner_radius_factor\",\n        \"_cached_key\",\n        \"_shading\",\n        \"_alpha_shading\",\n    )\n\n    def __init__(\n        self,\n        cx: float,\n        cy: float,\n        start_angle: float,\n        end_angle: float,\n        stops: Sequence[tuple[float, Union[Color, str]]],\n        spread_method: Union[\"GradientSpreadMethod\", str] = GradientSpreadMethod.PAD,\n        segments: Optional[int] = None,\n        inner_radius_factor: float = 0.002,\n    ):\n        super().__init__()\n        self.cx, self.cy = float(cx), float(cy)\n        self.start_angle, self.end_angle = float(start_angle), float(end_angle)\n        self.stops = stops\n        self.spread_method = (\n            GradientSpreadMethod.coerce(spread_method)\n            if hasattr(GradientSpreadMethod, \"coerce\")\n            else GradientSpreadMethod(spread_method)\n        )\n        self.segments = segments\n        self.inner_radius_factor = inner_radius_factor\n        self._cached_key: Optional[\n            tuple[\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                Optional[int],\n                float,\n                str,\n            ]\n        ] = None\n        self._shading: Optional[MeshShading] = None\n        self._alpha_shading: Optional[MeshShading] = None\n\n    def has_alpha(self) -> bool:\n        # any stop carries alpha != 1\n        for _, c in self.stops:\n            dc = convert_to_device_color(c) if not hasattr(c, \"colors\") else c\n            a = getattr(dc, \"a\", None)\n            if a is not None and abs(float(a) - 1.0) > TOLERANCE:\n                return True\n        return False\n\n    def get_shading_object(self, bbox: \"BoundingBox\") -> \"MeshShading\":\n        key = (\n            bbox.x0,\n            bbox.y0,\n            bbox.x1,\n            bbox.y1,\n            self.cx,\n            self.cy,\n            self.start_angle,\n            self.end_angle,\n            self.segments,\n            self.inner_radius_factor,\n            self.spread_method.value,\n        )\n        if self._shading is not None and self._cached_key == key:\n            return self._shading\n        self._cached_key = key\n        self._shading = shape_sweep_gradient_as_mesh(\n            self.cx,\n            self.cy,\n            self.start_angle,\n            self.end_angle,\n            self.stops,\n            spread_method=self.spread_method,\n            bbox=bbox,\n            segments=self.segments,\n            inner_radius_factor=self.inner_radius_factor,\n        )\n        return self._shading\n\n    def get_alpha_shading_object(self, bbox: \"BoundingBox\") -> Optional[\"MeshShading\"]:\n        if not self.has_alpha():\n            return None\n\n        # Normalize color stops once, then extract alpha\n        _, stops01, _ = normalize_stops(self.stops)\n        alpha01 = extract_alpha_stops(stops01)\n        gray_stops: list[tuple[float, Color | str]] = [\n            (u, DeviceGray(a)) for (u, a) in alpha01\n        ]\n\n        key = (\n            \"alpha\",\n            bbox.x0,\n            bbox.y0,\n            bbox.x1,\n            bbox.y1,\n            self.cx,\n            self.cy,\n            self.start_angle,\n            self.end_angle,\n            self.segments,\n            self.inner_radius_factor,\n            self.spread_method.value,\n        )\n\n        if getattr(self, \"_alpha_cached_key\", None) == key:\n            return self._alpha_shading\n\n        self._alpha_shading = shape_sweep_gradient_as_mesh(\n            self.cx,\n            self.cy,\n            self.start_angle,\n            self.end_angle,\n            gray_stops,\n            spread_method=self.spread_method,\n            bbox=bbox,\n            segments=self.segments,\n            inner_radius_factor=self.inner_radius_factor,\n        )\n        self._alpha_cached_key = key\n        return self._alpha_shading",
      "language": "python"
    },
    {
      "code": "class SweepGradient(PDFObject):\n    \"\"\"\n    Conic/sweep gradient that materializes as a type-4 (mesh) Shading.\n    Build is bbox-dependent, so we create the shading lazily at emit time.\n    \"\"\"\n\n    __slots__ = (\n        \"cx\",\n        \"cy\",\n        \"start_angle\",\n        \"end_angle\",\n        \"stops\",\n        \"spread_method\",\n        \"segments\",\n        \"inner_radius_factor\",\n        \"_cached_key\",\n        \"_shading\",\n        \"_alpha_shading\",\n    )\n\n    def __init__(\n        self,\n        cx: float,\n        cy: float,\n        start_angle: float,\n        end_angle: float,\n        stops: Sequence[tuple[float, Union[Color, str]]],\n        spread_method: Union[\"GradientSpreadMethod\", str] = GradientSpreadMethod.PAD,\n        segments: Optional[int] = None,\n        inner_radius_factor: float = 0.002,\n    ):\n        super().__init__()\n        self.cx, self.cy = float(cx), float(cy)\n        self.start_angle, self.end_angle = float(start_angle), float(end_angle)\n        self.stops = stops\n        self.spread_method = (\n            GradientSpreadMethod.coerce(spread_method)\n            if hasattr(GradientSpreadMethod, \"coerce\")\n            else GradientSpreadMethod(spread_method)\n        )\n        self.segments = segments\n        self.inner_radius_factor = inner_radius_factor\n        self._cached_key: Optional[\n            tuple[\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                Optional[int],\n                float,\n                str,\n            ]\n        ] = None\n        self._shading: Optional[MeshShading] = None\n        self._alpha_shading: Optional[MeshShading] = None\n\n    def has_alpha(self) -> bool:\n        # any stop carries alpha != 1\n        for _, c in self.stops:\n            dc = convert_to_device_color(c) if not hasattr(c, \"colors\") else c\n            a = getattr(dc, \"a\", None)\n            if a is not None and abs(float(a) - 1.0) > TOLERANCE:\n                return True\n        return False\n\n    def get_shading_object(self, bbox: \"BoundingBox\") -> \"MeshShading\":\n        key = (\n            bbox.x0,\n            bbox.y0,\n            bbox.x1,\n            bbox.y1,\n            self.cx,\n            self.cy,\n            self.start_angle,\n            self.end_angle,\n            self.segments,\n            self.inner_radius_factor,\n            self.spread_method.value,\n        )\n        if self._shading is not None and self._cached_key == key:\n            return self._shading\n        self._cached_key = key\n        self._shading = shape_sweep_gradient_as_mesh(\n            self.cx,\n            self.cy,\n            self.start_angle,\n            self.end_angle,\n            self.stops,\n            spread_method=self.spread_method,\n            bbox=bbox,\n            segments=self.segments,\n            inner_radius_factor=self.inner_radius_factor,\n        )\n        return self._shading\n\n    def get_alpha_shading_object(self, bbox: \"BoundingBox\") -> Optional[\"MeshShading\"]:\n        if not self.has_alpha():\n            return None\n\n        # Normalize color stops once, then extract alpha\n        _, stops01, _ = normalize_stops(self.stops)\n        alpha01 = extract_alpha_stops(stops01)\n        gray_stops: list[tuple[float, Color | str]] = [\n            (u, DeviceGray(a)) for (u, a) in alpha01\n        ]\n\n        key = (\n            \"alpha\",\n            bbox.x0,\n            bbox.y0,\n            bbox.x1,\n            bbox.y1,\n            self.cx,\n            self.cy,\n            self.start_angle,\n            self.end_angle,\n            self.segments,\n            self.inner_radius_factor,\n            self.spread_method.value,\n        )\n\n        if getattr(self, \"_alpha_cached_key\", None) == key:\n            return self._alpha_shading\n\n        self._alpha_shading = shape_sweep_gradient_as_mesh(\n            self.cx,\n            self.cy,\n            self.start_angle,\n            self.end_angle,\n            gray_stops,\n            spread_method=self.spread_method,\n            bbox=bbox,\n            segments=self.segments,\n            inner_radius_factor=self.inner_radius_factor,\n        )\n        self._alpha_cached_key = key\n        return self._alpha_shading",
      "language": "python"
    },
    {
      "code": "class SweepGradient(PDFObject):\n    \"\"\"\n    Conic/sweep gradient that materializes as a type-4 (mesh) Shading.\n    Build is bbox-dependent, so we create the shading lazily at emit time.\n    \"\"\"\n\n    __slots__ = (\n        \"cx\",\n        \"cy\",\n        \"start_angle\",\n        \"end_angle\",\n        \"stops\",\n        \"spread_method\",\n        \"segments\",\n        \"inner_radius_factor\",\n        \"_cached_key\",\n        \"_shading\",\n        \"_alpha_shading\",\n    )\n\n    def __init__(\n        self,\n        cx: float,\n        cy: float,\n        start_angle: float,\n        end_angle: float,\n        stops: Sequence[tuple[float, Union[Color, str]]],\n        spread_method: Union[\"GradientSpreadMethod\", str] = GradientSpreadMethod.PAD,\n        segments: Optional[int] = None,\n        inner_radius_factor: float = 0.002,\n    ):\n        super().__init__()\n        self.cx, self.cy = float(cx), float(cy)\n        self.start_angle, self.end_angle = float(start_angle), float(end_angle)\n        self.stops = stops\n        self.spread_method = (\n            GradientSpreadMethod.coerce(spread_method)\n            if hasattr(GradientSpreadMethod, \"coerce\")\n            else GradientSpreadMethod(spread_method)\n        )\n        self.segments = segments\n        self.inner_radius_factor = inner_radius_factor\n        self._cached_key: Optional[\n            tuple[\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                Optional[int],\n                float,\n                str,\n            ]\n        ] = None\n        self._shading: Optional[MeshShading] = None\n        self._alpha_shading: Optional[MeshShading] = None\n\n    def has_alpha(self) -> bool:\n        # any stop carries alpha != 1\n        for _, c in self.stops:\n            dc = convert_to_device_color(c) if not hasattr(c, \"colors\") else c\n            a = getattr(dc, \"a\", None)\n            if a is not None and abs(float(a) - 1.0) > TOLERANCE:\n                return True\n        return False\n\n    def get_shading_object(self, bbox: \"BoundingBox\") -> \"MeshShading\":\n        key = (\n            bbox.x0,\n            bbox.y0,\n            bbox.x1,\n            bbox.y1,\n            self.cx,\n            self.cy,\n            self.start_angle,\n            self.end_angle,\n            self.segments,\n            self.inner_radius_factor,\n            self.spread_method.value,\n        )\n        if self._shading is not None and self._cached_key == key:\n            return self._shading\n        self._cached_key = key\n        self._shading = shape_sweep_gradient_as_mesh(\n            self.cx,\n            self.cy,\n            self.start_angle,\n            self.end_angle,\n            self.stops,\n            spread_method=self.spread_method,\n            bbox=bbox,\n            segments=self.segments,\n            inner_radius_factor=self.inner_radius_factor,\n        )\n        return self._shading\n\n    def get_alpha_shading_object(self, bbox: \"BoundingBox\") -> Optional[\"MeshShading\"]:\n        if not self.has_alpha():\n            return None\n\n        # Normalize color stops once, then extract alpha\n        _, stops01, _ = normalize_stops(self.stops)\n        alpha01 = extract_alpha_stops(stops01)\n        gray_stops: list[tuple[float, Color | str]] = [\n            (u, DeviceGray(a)) for (u, a) in alpha01\n        ]\n\n        key = (\n            \"alpha\",\n            bbox.x0,\n            bbox.y0,\n            bbox.x1,\n            bbox.y1,\n            self.cx,\n            self.cy,\n            self.start_angle,\n            self.end_angle,\n            self.segments,\n            self.inner_radius_factor,\n            self.spread_method.value,\n        )\n\n        if getattr(self, \"_alpha_cached_key\", None) == key:\n            return self._alpha_shading\n\n        self._alpha_shading = shape_sweep_gradient_as_mesh(\n            self.cx,\n            self.cy,\n            self.start_angle,\n            self.end_angle,\n            gray_stops,\n            spread_method=self.spread_method,\n            bbox=bbox,\n            segments=self.segments,\n            inner_radius_factor=self.inner_radius_factor,\n        )\n        self._alpha_cached_key = key\n        return self._alpha_shading",
      "language": "python"
    },
    {
      "code": "class SweepGradient(PDFObject):\n    \"\"\"\n    Conic/sweep gradient that materializes as a type-4 (mesh) Shading.\n    Build is bbox-dependent, so we create the shading lazily at emit time.\n    \"\"\"\n\n    __slots__ = (\n        \"cx\",\n        \"cy\",\n        \"start_angle\",\n        \"end_angle\",\n        \"stops\",\n        \"spread_method\",\n        \"segments\",\n        \"inner_radius_factor\",\n        \"_cached_key\",\n        \"_shading\",\n        \"_alpha_shading\",\n    )\n\n    def __init__(\n        self,\n        cx: float,\n        cy: float,\n        start_angle: float,\n        end_angle: float,\n        stops: Sequence[tuple[float, Union[Color, str]]],\n        spread_method: Union[\"GradientSpreadMethod\", str] = GradientSpreadMethod.PAD,\n        segments: Optional[int] = None,\n        inner_radius_factor: float = 0.002,\n    ):\n        super().__init__()\n        self.cx, self.cy = float(cx), float(cy)\n        self.start_angle, self.end_angle = float(start_angle), float(end_angle)\n        self.stops = stops\n        self.spread_method = (\n            GradientSpreadMethod.coerce(spread_method)\n            if hasattr(GradientSpreadMethod, \"coerce\")\n            else GradientSpreadMethod(spread_method)\n        )\n        self.segments = segments\n        self.inner_radius_factor = inner_radius_factor\n        self._cached_key: Optional[\n            tuple[\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                Optional[int],\n                float,\n                str,\n            ]\n        ] = None\n        self._shading: Optional[MeshShading] = None\n        self._alpha_shading: Optional[MeshShading] = None\n\n    def has_alpha(self) -> bool:\n        # any stop carries alpha != 1\n        for _, c in self.stops:\n            dc = convert_to_device_color(c) if not hasattr(c, \"colors\") else c\n            a = getattr(dc, \"a\", None)\n            if a is not None and abs(float(a) - 1.0) > TOLERANCE:\n                return True\n        return False\n\n    def get_shading_object(self, bbox: \"BoundingBox\") -> \"MeshShading\":\n        key = (\n            bbox.x0,\n            bbox.y0,\n            bbox.x1,\n            bbox.y1,\n            self.cx,\n            self.cy,\n            self.start_angle,\n            self.end_angle,\n            self.segments,\n            self.inner_radius_factor,\n            self.spread_method.value,\n        )\n        if self._shading is not None and self._cached_key == key:\n            return self._shading\n        self._cached_key = key\n        self._shading = shape_sweep_gradient_as_mesh(\n            self.cx,\n            self.cy,\n            self.start_angle,\n            self.end_angle,\n            self.stops,\n            spread_method=self.spread_method,\n            bbox=bbox,\n            segments=self.segments,\n            inner_radius_factor=self.inner_radius_factor,\n        )\n        return self._shading\n\n    def get_alpha_shading_object(self, bbox: \"BoundingBox\") -> Optional[\"MeshShading\"]:\n        if not self.has_alpha():\n            return None\n\n        # Normalize color stops once, then extract alpha\n        _, stops01, _ = normalize_stops(self.stops)\n        alpha01 = extract_alpha_stops(stops01)\n        gray_stops: list[tuple[float, Color | str]] = [\n            (u, DeviceGray(a)) for (u, a) in alpha01\n        ]\n\n        key = (\n            \"alpha\",\n            bbox.x0,\n            bbox.y0,\n            bbox.x1,\n            bbox.y1,\n            self.cx,\n            self.cy,\n            self.start_angle,\n            self.end_angle,\n            self.segments,\n            self.inner_radius_factor,\n            self.spread_method.value,\n        )\n\n        if getattr(self, \"_alpha_cached_key\", None) == key:\n            return self._alpha_shading\n\n        self._alpha_shading = shape_sweep_gradient_as_mesh(\n            self.cx,\n            self.cy,\n            self.start_angle,\n            self.end_angle,\n            gray_stops,\n            spread_method=self.spread_method,\n            bbox=bbox,\n            segments=self.segments,\n            inner_radius_factor=self.inner_radius_factor,\n        )\n        self._alpha_cached_key = key\n        return self._alpha_shading",
      "language": "python"
    },
    {
      "code": "class SweepGradient(PDFObject):\n    \"\"\"\n    Conic/sweep gradient that materializes as a type-4 (mesh) Shading.\n    Build is bbox-dependent, so we create the shading lazily at emit time.\n    \"\"\"\n\n    __slots__ = (\n        \"cx\",\n        \"cy\",\n        \"start_angle\",\n        \"end_angle\",\n        \"stops\",\n        \"spread_method\",\n        \"segments\",\n        \"inner_radius_factor\",\n        \"_cached_key\",\n        \"_shading\",\n        \"_alpha_shading\",\n    )\n\n    def __init__(\n        self,\n        cx: float,\n        cy: float,\n        start_angle: float,\n        end_angle: float,\n        stops: Sequence[tuple[float, Union[Color, str]]],\n        spread_method: Union[\"GradientSpreadMethod\", str] = GradientSpreadMethod.PAD,\n        segments: Optional[int] = None,\n        inner_radius_factor: float = 0.002,\n    ):\n        super().__init__()\n        self.cx, self.cy = float(cx), float(cy)\n        self.start_angle, self.end_angle = float(start_angle), float(end_angle)\n        self.stops = stops\n        self.spread_method = (\n            GradientSpreadMethod.coerce(spread_method)\n            if hasattr(GradientSpreadMethod, \"coerce\")\n            else GradientSpreadMethod(spread_method)\n        )\n        self.segments = segments\n        self.inner_radius_factor = inner_radius_factor\n        self._cached_key: Optional[\n            tuple[\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                Optional[int],\n                float,\n                str,\n            ]\n        ] = None\n        self._shading: Optional[MeshShading] = None\n        self._alpha_shading: Optional[MeshShading] = None\n\n    def has_alpha(self) -> bool:\n        # any stop carries alpha != 1\n        for _, c in self.stops:\n            dc = convert_to_device_color(c) if not hasattr(c, \"colors\") else c\n            a = getattr(dc, \"a\", None)\n            if a is not None and abs(float(a) - 1.0) > TOLERANCE:\n                return True\n        return False\n\n    def get_shading_object(self, bbox: \"BoundingBox\") -> \"MeshShading\":\n        key = (\n            bbox.x0,\n            bbox.y0,\n            bbox.x1,\n            bbox.y1,\n            self.cx,\n            self.cy,\n            self.start_angle,\n            self.end_angle,\n            self.segments,\n            self.inner_radius_factor,\n            self.spread_method.value,\n        )\n        if self._shading is not None and self._cached_key == key:\n            return self._shading\n        self._cached_key = key\n        self._shading = shape_sweep_gradient_as_mesh(\n            self.cx,\n            self.cy,\n            self.start_angle,\n            self.end_angle,\n            self.stops,\n            spread_method=self.spread_method,\n            bbox=bbox,\n            segments=self.segments,\n            inner_radius_factor=self.inner_radius_factor,\n        )\n        return self._shading\n\n    def get_alpha_shading_object(self, bbox: \"BoundingBox\") -> Optional[\"MeshShading\"]:\n        if not self.has_alpha():\n            return None\n\n        # Normalize color stops once, then extract alpha\n        _, stops01, _ = normalize_stops(self.stops)\n        alpha01 = extract_alpha_stops(stops01)\n        gray_stops: list[tuple[float, Color | str]] = [\n            (u, DeviceGray(a)) for (u, a) in alpha01\n        ]\n\n        key = (\n            \"alpha\",\n            bbox.x0,\n            bbox.y0,\n            bbox.x1,\n            bbox.y1,\n            self.cx,\n            self.cy,\n            self.start_angle,\n            self.end_angle,\n            self.segments,\n            self.inner_radius_factor,\n            self.spread_method.value,\n        )\n\n        if getattr(self, \"_alpha_cached_key\", None) == key:\n            return self._alpha_shading\n\n        self._alpha_shading = shape_sweep_gradient_as_mesh(\n            self.cx,\n            self.cy,\n            self.start_angle,\n            self.end_angle,\n            gray_stops,\n            spread_method=self.spread_method,\n            bbox=bbox,\n            segments=self.segments,\n            inner_radius_factor=self.inner_radius_factor,\n        )\n        self._alpha_cached_key = key\n        return self._alpha_shading",
      "language": "python"
    },
    {
      "code": "class SweepGradient(PDFObject):\n    \"\"\"\n    Conic/sweep gradient that materializes as a type-4 (mesh) Shading.\n    Build is bbox-dependent, so we create the shading lazily at emit time.\n    \"\"\"\n\n    __slots__ = (\n        \"cx\",\n        \"cy\",\n        \"start_angle\",\n        \"end_angle\",\n        \"stops\",\n        \"spread_method\",\n        \"segments\",\n        \"inner_radius_factor\",\n        \"_cached_key\",\n        \"_shading\",\n        \"_alpha_shading\",\n    )\n\n    def __init__(\n        self,\n        cx: float,\n        cy: float,\n        start_angle: float,\n        end_angle: float,\n        stops: Sequence[tuple[float, Union[Color, str]]],\n        spread_method: Union[\"GradientSpreadMethod\", str] = GradientSpreadMethod.PAD,\n        segments: Optional[int] = None,\n        inner_radius_factor: float = 0.002,\n    ):\n        super().__init__()\n        self.cx, self.cy = float(cx), float(cy)\n        self.start_angle, self.end_angle = float(start_angle), float(end_angle)\n        self.stops = stops\n        self.spread_method = (\n            GradientSpreadMethod.coerce(spread_method)\n            if hasattr(GradientSpreadMethod, \"coerce\")\n            else GradientSpreadMethod(spread_method)\n        )\n        self.segments = segments\n        self.inner_radius_factor = inner_radius_factor\n        self._cached_key: Optional[\n            tuple[\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                Optional[int],\n                float,\n                str,\n            ]\n        ] = None\n        self._shading: Optional[MeshShading] = None\n        self._alpha_shading: Optional[MeshShading] = None\n\n    def has_alpha(self) -> bool:\n        # any stop carries alpha != 1\n        for _, c in self.stops:\n            dc = convert_to_device_color(c) if not hasattr(c, \"colors\") else c\n            a = getattr(dc, \"a\", None)\n            if a is not None and abs(float(a) - 1.0) > TOLERANCE:\n                return True\n        return False\n\n    def get_shading_object(self, bbox: \"BoundingBox\") -> \"MeshShading\":\n        key = (\n            bbox.x0,\n            bbox.y0,\n            bbox.x1,\n            bbox.y1,\n            self.cx,\n            self.cy,\n            self.start_angle,\n            self.end_angle,\n            self.segments,\n            self.inner_radius_factor,\n            self.spread_method.value,\n        )\n        if self._shading is not None and self._cached_key == key:\n            return self._shading\n        self._cached_key = key\n        self._shading = shape_sweep_gradient_as_mesh(\n            self.cx,\n            self.cy,\n            self.start_angle,\n            self.end_angle,\n            self.stops,\n            spread_method=self.spread_method,\n            bbox=bbox,\n            segments=self.segments,\n            inner_radius_factor=self.inner_radius_factor,\n        )\n        return self._shading\n\n    def get_alpha_shading_object(self, bbox: \"BoundingBox\") -> Optional[\"MeshShading\"]:\n        if not self.has_alpha():\n            return None\n\n        # Normalize color stops once, then extract alpha\n        _, stops01, _ = normalize_stops(self.stops)\n        alpha01 = extract_alpha_stops(stops01)\n        gray_stops: list[tuple[float, Color | str]] = [\n            (u, DeviceGray(a)) for (u, a) in alpha01\n        ]\n\n        key = (\n            \"alpha\",\n            bbox.x0,\n            bbox.y0,\n            bbox.x1,\n            bbox.y1,\n            self.cx,\n            self.cy,\n            self.start_angle,\n            self.end_angle,\n            self.segments,\n            self.inner_radius_factor,\n            self.spread_method.value,\n        )\n\n        if getattr(self, \"_alpha_cached_key\", None) == key:\n            return self._alpha_shading\n\n        self._alpha_shading = shape_sweep_gradient_as_mesh(\n            self.cx,\n            self.cy,\n            self.start_angle,\n            self.end_angle,\n            gray_stops,\n            spread_method=self.spread_method,\n            bbox=bbox,\n            segments=self.segments,\n            inner_radius_factor=self.inner_radius_factor,\n        )\n        self._alpha_cached_key = key\n        return self._alpha_shading",
      "language": "python"
    },
    {
      "code": "def get_alpha_shading_object(self, bbox: \"BoundingBox\") -> Optional[\"MeshShading\"]:\n    if not self.has_alpha():\n        return None\n\n    # Normalize color stops once, then extract alpha\n    _, stops01, _ = normalize_stops(self.stops)\n    alpha01 = extract_alpha_stops(stops01)\n    gray_stops: list[tuple[float, Color | str]] = [\n        (u, DeviceGray(a)) for (u, a) in alpha01\n    ]\n\n    key = (\n        \"alpha\",\n        bbox.x0,\n        bbox.y0,\n        bbox.x1,\n        bbox.y1,\n        self.cx,\n        self.cy,\n        self.start_angle,\n        self.end_angle,\n        self.segments,\n        self.inner_radius_factor,\n        self.spread_method.value,\n    )\n\n    if getattr(self, \"_alpha_cached_key\", None) == key:\n        return self._alpha_shading\n\n    self._alpha_shading = shape_sweep_gradient_as_mesh(\n        self.cx,\n        self.cy,\n        self.start_angle,\n        self.end_angle,\n        gray_stops,\n        spread_method=self.spread_method,\n        bbox=bbox,\n        segments=self.segments,\n        inner_radius_factor=self.inner_radius_factor,\n    )\n    self._alpha_cached_key = key\n    return self._alpha_shading",
      "language": "python"
    },
    {
      "code": "def get_shading_object(self, bbox: \"BoundingBox\") -> \"MeshShading\":\n    key = (\n        bbox.x0,\n        bbox.y0,\n        bbox.x1,\n        bbox.y1,\n        self.cx,\n        self.cy,\n        self.start_angle,\n        self.end_angle,\n        self.segments,\n        self.inner_radius_factor,\n        self.spread_method.value,\n    )\n    if self._shading is not None and self._cached_key == key:\n        return self._shading\n    self._cached_key = key\n    self._shading = shape_sweep_gradient_as_mesh(\n        self.cx,\n        self.cy,\n        self.start_angle,\n        self.end_angle,\n        self.stops,\n        spread_method=self.spread_method,\n        bbox=bbox,\n        segments=self.segments,\n        inner_radius_factor=self.inner_radius_factor,\n    )\n    return self._shading",
      "language": "python"
    },
    {
      "code": "def has_alpha(self) -> bool:\n    # any stop carries alpha != 1\n    for _, c in self.stops:\n        dc = convert_to_device_color(c) if not hasattr(c, \"colors\") else c\n        a = getattr(dc, \"a\", None)\n        if a is not None and abs(float(a) - 1.0) > TOLERANCE:\n            return True\n    return False",
      "language": "python"
    },
    {
      "code": "class Type2Function(PDFObject):\n    \"\"\"Transition between 2 colors\"\"\"\n\n    def __init__(self, color_1: Color, color_2: Color):\n        super().__init__()\n        # 0: Sampled function; 2: Exponential interpolation function; 3: Stitching function; 4: PostScript calculator function\n        self.function_type = 2\n        self.domain = \"[0 1]\"\n        c1 = self._get_color_components(color_1)\n        c2 = self._get_color_components(color_2)\n        if len(c1) != len(c2):\n            raise ValueError(\"Type2Function endpoints must have same component count\")\n        self.c0 = f'[{\" \".join(format_number(c) for c in c1)}]'\n        self.c1 = f'[{\" \".join(format_number(c) for c in c2)}]'\n        self.n = 1\n\n    @classmethod\n    def _get_color_components(cls, color: Color) -> tuple[float, ...]:\n        if isinstance(color, DeviceGray):\n            return (color.g,)\n        return color.colors",
      "language": "python"
    },
    {
      "code": "class Type2FunctionGray(PDFObject):\n    \"\"\"1‑channel exponential interpolation for alpha/luminance ramps.\"\"\"\n\n    def __init__(self, g0: float, g1: float):\n        super().__init__()\n        self.function_type = 2\n        self.domain = \"[0 1]\"\n        self.c0 = f\"[{format_number(g0)}]\"\n        self.c1 = f\"[{format_number(g1)}]\"\n        self.n = 1",
      "language": "python"
    },
    {
      "code": "class Type3Function(PDFObject):\n    \"\"\"When multiple colors are used, a type 3 function is necessary to stitch type 2 functions together\n    and define the bounds between each color transition\"\"\"\n\n    def __init__(\n        self,\n        functions: Sequence[Union[Type2Function, Type2FunctionGray, \"Type3Function\"]],\n        bounds: Sequence[float],\n    ):\n        super().__init__()\n        # 0: Sampled function; 2: Exponential interpolation function; 3: Stitching function; 4: PostScript calculator function\n        self.function_type = 3\n        self.domain = \"[0 1]\"\n        self._functions = functions\n        self.bounds = f\"[{' '.join(format_number(bound) for bound in bounds)}]\"\n        self.encode = f\"[{' '.join('0 1' for _ in functions)}]\"\n\n    @property\n    def functions(self) -> str:\n        return f\"[{' '.join(f'{f.id} 0 R' for f in self._functions)}]\"",
      "language": "python"
    },
    {
      "code": "@property\ndef functions(self) -> str:\n    return f\"[{' '.join(f'{f.id} 0 R' for f in self._functions)}]\"",
      "language": "python"
    }
  ],
  "patterns": [],
  "links": [
    "https://py-pdf.github.io/fpdf2/Patterns.html",
    "https://py-pdf.github.io/fpdf2/fpdf/drawing_primitives.html",
    "https://py-pdf.github.io/fpdf2/fpdf/enums.html",
    "https://py-pdf.github.io/fpdf2/fpdf/pattern.html",
    "https://py-pdf.github.io/fpdf2/fpdf/syntax.html",
    "https://py-pdf.github.io/fpdf2/fpdf/index.html"
  ]
}