{
  "url": "https://py-pdf.github.io/fpdf2/fpdf/svg.html",
  "title": "Module fpdf.svg",
  "content": "Utilities to parse SVG graphics into fpdf.drawing objects.\n\nThe contents of this module are internal to fpdf2, and not part of the public API. They may change at any time without prior warning or any deprecation period, in non-backward-compatible ways.\n\nUsage documentation at: https://py-pdf.github.io/fpdf2/SVG.html\n\nApply the known styles from svg_element to the pdf path/group stylable.\n\nConvert SVG/CSS transform functions into PDF transforms.\n\nConvert an angle value to our canonical angle unit, radians\n\nConvert a length unit to our canonical length unit, pt.\n\nRemove the xmlns namespace from a qualified XML tag name\n\nCreate an XML namespace string representation for the given tag name.\n\nCreate a lookup for the given name in the given XML namespace.\n\nclass to represent percentage values\n\nSVGImage(href, x, y, width, height, svg_obj)\n\nAlias for field number 4\n\nAlias for field number 0\n\nAlias for field number 5\n\nAlias for field number 3\n\nAlias for field number 1\n\nAlias for field number 2\n\nA representation of an SVG that has been converted to a PDF representation.\n\nCreate an SVGObject from the contents of the file at filename.\n\nA converted SVGObject.\n\nHandle nested items within a group tag.\n\nConvert an SVG tag into a PDF path object.\n\nConvert an SVG shape tag into a PDF path object. Necessary to make xref (because ShapeBuilder doesn't have access to this object.)\n\nConvert (and simple ) into a PaintedPath with Text runs. - Uses Text baseline at (x,y) - Honors x/y and dx/dy on and direct child - Flattens nested tspans; advanced per-character positioning is not implemented\n\nResolve a cross-reference to an already-seen SVG element by ID.\n\nConvert the graphics contained in the SVG into the PDF representation.\n\nDirectly draw the converted SVG to the given PDF's current page.\n\nThe page viewport is used for sizing the SVG.\n\nCollect shape info from the given SVG.\n\nProduce lookups for groups and paths inside the tag\n\nSize the converted SVG paths to the page viewport.\n\nThe SVG document size can be specified relative to the rendering viewport (e.g. width=50%). If the converted SVG sizes are relative units, then this computes the appropriate scale transform to size the SVG to the correct dimensions for a page in the current PDF document.\n\nIf the SVG document size is specified in absolute units, then it is not scaled.\n\nThe same thing as SVGObject.transform_to_rect_viewport().\n\nSize the converted SVG paths to an arbitrarily sized viewport.\n\nThe SVG document size can be specified relative to the rendering viewport (e.g. width=50%). If the converted SVG sizes are relative units, then this computes the appropriate scale transform to size the SVG to the correct dimensions for a page in the current PDF document.\n\nA tuple of (width, height, GraphicsContext), where width and height are the resolved width and height (they may be 0. If 0, the returned GraphicsContext will be empty). The GraphicsContext contains all of the paths that were converted from the SVG, scaled to the given viewport size.\n\nA namespace within which methods for converting basic shapes can be looked up.\n\nConvert an SVG into a PDF path.\n\nConvert an SVG into a PDF path.\n\nConvert an SVG into a PDF path.\n\nCreate a new path with the appropriate styles.\n\nConvert an SVG into a PDF path.\n\nConvert an SVG into a PDF path.\n\nConvert an SVG into a PDF path.",
  "headings": [
    {
      "level": "h1",
      "text": "Module fpdf.svg",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Functions",
      "id": "header-functions"
    },
    {
      "level": "h2",
      "text": "Classes",
      "id": "header-classes"
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Static methods",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Returns",
      "id": "returns"
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Returns",
      "id": "returns"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Returns",
      "id": "returns"
    },
    {
      "level": "h3",
      "text": "Static methods",
      "id": ""
    }
  ],
  "code_samples": [
    {
      "code": "@force_nodocument\ndef apply_styles(\n    stylable: PaintedPath | GraphicsContext,\n    svg_element: \"Element\",\n    computed_style: Optional[dict[str, Any]] = None,\n) -> None:\n    \"\"\"Apply the known styles from `svg_element` to the pdf path/group `stylable`.\"\"\"\n    if computed_style is not None:\n        style = computed_style\n    else:\n        style = {}\n        for key, value in html.parse_css_style(\n            svg_element.attrib.get(\"style\", \"\")\n        ).items():\n            norm_value = _normalize_css_value(value)\n            if norm_value is not None:\n                style[key] = norm_value\n    stylable.style.auto_close = False\n\n    for attr_name, converter in svg_attr_map.items():\n        attr_value = _normalize_css_value(style.get(attr_name))\n        if attr_value is None:\n            attr_value = _normalize_css_value(svg_element.attrib.get(attr_name))\n        if attr_value is not None:\n            setattr(stylable.style, *converter(attr_value))\n\n    # handle this separately for now\n    opacity_str = _normalize_css_value(style.get(\"opacity\"))\n    if opacity_str is None:\n        opacity_str = _normalize_css_value(svg_element.attrib.get(\"opacity\"))\n    if opacity_str is not None:\n        opacity = float(opacity_str)\n        stylable.style.fill_opacity = opacity\n        stylable.style.stroke_opacity = opacity\n\n    tfstr = svg_element.attrib.get(\"transform\")\n    if tfstr:\n        stylable.transform = convert_transforms(tfstr)",
      "language": "python"
    },
    {
      "code": "@force_nodocument\ndef clamp_float(min_val: float, max_val: float) -> Callable[[str], float]:\n    def converter(value: str) -> float:\n        val = float(value)\n        if val < min_val:\n            return min_val\n        if val > max_val:\n            return max_val\n        return val\n\n    return converter",
      "language": "python"
    },
    {
      "code": "@force_nodocument\ndef convert_miterlimit(incoming: str) -> float:\n    val = float(incoming)\n    if val < 1.0:\n        raise ValueError(f\"miter limit {incoming} cannot be less than 1\")\n    return val",
      "language": "python"
    },
    {
      "code": "@force_nodocument\ndef convert_stroke_width(incoming: str) -> Optional[float]:\n    val = resolve_length(incoming)\n    if val < 0:\n        raise ValueError(f\"stroke width {incoming} cannot be negative\")\n    if val == 0:\n        return None\n    return val",
      "language": "python"
    },
    {
      "code": "@force_nodocument\ndef convert_transforms(tfstr: str) -> Transform:\n    \"\"\"Convert SVG/CSS transform functions into PDF transforms.\"\"\"\n\n    # SVG 2 uses CSS transforms. SVG 1.1 transforms are slightly different. I'm really\n    # not sure if it is worth it to try to support SVG 2 because it is significantly\n    # more entangled with The HTML Disaster than SVG 1.1, which makes it astronomically\n    # harder to support.\n    # https://drafts.csswg.org/css-transforms/#two-d-transform-functions\n    parsed = TRANSFORM_GETTER.findall(tfstr)\n    # pylint: disable=redefined-loop-name\n    transform = Transform.identity()\n    for tf_type, args in parsed:\n        args = args.strip()\n        if tf_type == \"matrix\":\n            a, b, c, d, e, f = tuple(float(n) for n in NUMBER_SPLIT.split(args))\n            transform = Transform(a, b, c, d, e, f) @ transform\n\n        elif tf_type == \"rotate\":\n            theta, *about = NUMBER_SPLIT.split(args)\n            theta = resolve_angle(theta)\n            rotation = Transform.rotation(theta=theta)\n            if about:\n                # this is an SVG 1.1 feature. SVG 2 uses the transform-origin property.\n                # see: https://www.w3.org/TR/SVG11/coords.html#TransformAttribute\n                if len(about) == 2:\n                    rotation = rotation.about(float(about[0]), float(about[1]))\n                else:\n                    raise ValueError(\n                        f\"rotation transform {tf_type}({args}) is malformed\"\n                    )\n\n            transform = rotation @ transform\n\n        elif tf_type == \"scale\":\n            # if sy is not provided, it takes a value equal to sx\n            args = NUMBER_SPLIT.split(args)\n            if len(args) == 2:\n                sx = float(args[0])\n                sy = float(args[1])\n            elif len(args) == 1:\n                sx = sy = float(args[0])\n            else:\n                raise ValueError(f\"bad scale transform {tfstr}\")\n\n            transform = Transform.scaling(x=sx, y=sy) @ transform\n\n        elif tf_type == \"scaleX\":  # SVG 2\n            transform = Transform.scaling(x=float(args), y=1) @ transform\n\n        elif tf_type == \"scaleY\":  # SVG 2\n            transform = Transform.scaling(x=1, y=float(args)) @ transform\n\n        elif tf_type == \"skew\":  # SVG 2, not the same as skewX@skewY\n            # if sy is not provided, it takes a value equal to 0\n            args = NUMBER_SPLIT.split(args)\n            if len(args) == 2:\n                sx = resolve_angle(args[0])\n                sy = resolve_angle(args[1])\n            elif len(args) == 1:\n                sx = resolve_angle(args[0])\n                sy = 0\n            else:\n                raise ValueError(f\"bad skew transform {tfstr}\")\n\n            transform = Transform.shearing(x=math.tan(sx), y=math.tan(sy)) @ transform\n\n        elif tf_type == \"skewX\":\n            transform = (\n                Transform.shearing(x=math.tan(resolve_angle(args)), y=0) @ transform\n            )\n\n        elif tf_type == \"skewY\":\n            transform = (\n                Transform.shearing(x=0, y=math.tan(resolve_angle(args))) @ transform\n            )\n\n        elif tf_type == \"translate\":\n            # if y is not provided, it takes a value equal to 0\n            args = NUMBER_SPLIT.split(args)\n            if len(args) == 2:\n                x = resolve_length(args[0])\n                y = resolve_length(args[1])\n            elif len(args) == 1:\n                x = resolve_length(args[0])\n                y = 0\n            else:\n                raise ValueError(f\"bad translation transform {tfstr}\")\n\n            transform = Transform.translation(x=x, y=y) @ transform\n\n        elif tf_type == \"translateX\":  # SVG 2\n            transform = Transform.translation(x=resolve_length(args), y=0) @ transform\n\n        elif tf_type == \"translateY\":  # SVG 2\n            transform = Transform.translation(x=0, y=resolve_length(args)) @ transform\n\n    return transform",
      "language": "python"
    },
    {
      "code": "@force_nodocument\ndef inheritable(\n    value: str, converter: Callable[[str], Any] = lambda value: value\n) -> Any:\n    if value in (\"inherit\", \"currentColor\"):\n        return GraphicsStyle.INHERIT\n    return converter(value)",
      "language": "python"
    },
    {
      "code": "@force_nodocument\ndef optional(\n    value: Optional[str], converter: Callable[[str], Any] = lambda noop: noop\n) -> Any:\n    # Treat missing/empty/whitespace exactly like \"not set\"\n    if value is None:\n        return None\n    if isinstance(value, str) and not value.strip():\n        return None\n    if value == \"none\":\n        return None\n    return inheritable(value, converter)",
      "language": "python"
    },
    {
      "code": "@force_nodocument\ndef resolve_angle(angle_str: str, default_unit: str = \"deg\") -> float:\n    \"\"\"Convert an angle value to our canonical angle unit, radians\"\"\"\n    m = unit_splitter.match(angle_str)\n    value: str | float\n    if m is not None:\n        value, unit = m.groups()\n    else:\n        value = angle_str\n    if not unit:  # pyright: ignore[reportPossiblyUnboundVariable]\n        unit = default_unit\n\n    try:\n        return float(value) * angle_units[unit]\n    except KeyError:\n        raise ValueError(f\"angle {angle_str} has unknown unit {unit}\") from None",
      "language": "python"
    },
    {
      "code": "@force_nodocument\ndef resolve_length(length_str: str, default_unit: str = \"pt\") -> float:\n    \"\"\"Convert a length unit to our canonical length unit, pt.\"\"\"\n    match = unit_splitter.match(length_str)\n    if match is None:\n        raise ValueError(f\"Unable to parse '{length_str}' as a length\") from None\n    value, unit = match.groups()\n    if not unit:\n        unit = default_unit\n\n    try:\n        return float(value) * absolute_length_units[unit]\n    except KeyError:\n        if unit in relative_length_units:\n            raise ValueError(\n                f\"{length_str} uses unsupported relative length {unit}\"\n            ) from None\n\n        raise ValueError(f\"{length_str} contains unrecognized unit {unit}\") from None",
      "language": "python"
    },
    {
      "code": "@force_nodocument\ndef svg_path_converter(pdf_path: PaintedPath, svg_path: str) -> None:\n    pen = PathPen(pdf_path)\n    parse_path(svg_path, pen)\n    if not pen.first_is_move:\n        raise ValueError(\"Path does not start with move item\")",
      "language": "python"
    },
    {
      "code": "@force_nodocument\ndef svgcolor(colorstr: str) -> DeviceRGB | DeviceGray:\n    try:\n        colorstr = html.COLOR_DICT[colorstr]\n    except KeyError:\n        pass\n\n    if colorstr.startswith(\"#\"):\n        return color_from_hex_string(colorstr)\n\n    if colorstr.startswith(\"rgb\"):\n        return color_from_rgb_string(colorstr)\n\n    raise ValueError(f\"unsupported color specification {colorstr}\")",
      "language": "python"
    },
    {
      "code": "@force_nodocument\ndef without_ns(qualified_tag: str) -> str:\n    \"\"\"Remove the xmlns namespace from a qualified XML tag name\"\"\"\n    i = qualified_tag.index(\"}\")\n    if i >= 0:\n        return qualified_tag[i + 1 :]\n    return qualified_tag",
      "language": "python"
    },
    {
      "code": "@force_nodocument\ndef xmlns(space: str, name: str) -> str:\n    \"\"\"Create an XML namespace string representation for the given tag name.\"\"\"\n    try:\n        space = f\"{{{_HANDY_NAMESPACES[space]}}}\"\n    except KeyError:\n        space = \"\"\n\n    return f\"{space}{name}\"",
      "language": "python"
    },
    {
      "code": "@force_nodocument\ndef xmlns_lookup(space: str, *names: str) -> dict[str, str]:\n    \"\"\"Create a lookup for the given name in the given XML namespace.\"\"\"\n\n    result = {}\n    for name in names:\n        result[xmlns(space, name)] = name\n        result[name] = name\n\n    return result  # pyright: ignore[reportUnknownVariableType]",
      "language": "python"
    },
    {
      "code": "@force_nodocument\nclass Percent(float):\n    \"\"\"class to represent percentage values\"\"\"",
      "language": "python"
    },
    {
      "code": "class SVGImage(NamedTuple):\n    href: str\n    x: float\n    y: float\n    width: float\n    height: float\n    svg_obj: SVGObject\n\n    def __deepcopy__(self: \"SVGImage\", _memo: dict[int, Any]) -> \"SVGImage\":\n        # Defining this method is required to avoid the .svg_obj reference to be cloned:\n        return SVGImage(\n            href=self.href,\n            x=self.x,\n            y=self.y,\n            width=self.width,\n            height=self.height,\n            svg_obj=self.svg_obj,\n        )\n\n    # pylint: disable=unused-argument\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: \"Renderable\",\n        initial_point: Point,\n    ) -> tuple[str, \"Renderable\", Point]:\n        image_cache = self.svg_obj and self.svg_obj.image_cache\n        if not image_cache:\n            raise AssertionError(\n                \"fpdf2 bug - Cannot render a raster image without a SVGObject.image_cache\"\n            )\n\n        # We lazy-import this function to circumvent a circular import problem:\n        # pylint: disable=cyclic-import,import-outside-toplevel\n        from .image_parsing import preload_image\n\n        _, _, info = preload_image(image_cache, self.href)\n        if isinstance(info, VectorImageInfo):\n            LOGGER.warning(\n                \"Inserting .svg vector graphics in <image> tags is currently not supported (contributions are welcome to add support for it)\"\n            )\n            return \"\", last_item, initial_point\n        w, h = info.size_in_document_units(self.width, self.height)\n        stream_content = stream_content_for_raster_image(\n            info=info,\n            x=self.x,\n            y=self.y,\n            w=w,\n            h=h,\n            keep_aspect_ratio=True,\n        )\n        return stream_content, last_item, initial_point\n\n    @property\n    def end_point(self) -> Point:\n        return Point(self.x, self.y)\n\n    # pylint: disable=unused-argument\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        x0 = self.x\n        y0 = self.y\n        x1 = self.x + self.width\n        y1 = self.y + self.height\n\n        bbox = BoundingBox.from_points(\n            [\n                Point(x0, y0),\n                Point(x1, y0),\n                Point(x0, y1),\n                Point(x1, y1),\n            ]\n        )\n        return bbox, Point(self.x, self.y)",
      "language": "python"
    },
    {
      "code": "@property\ndef end_point(self) -> Point:\n    return Point(self.x, self.y)",
      "language": "python"
    },
    {
      "code": "class SVGImage(NamedTuple):\n    href: str\n    x: float\n    y: float\n    width: float\n    height: float\n    svg_obj: SVGObject\n\n    def __deepcopy__(self: \"SVGImage\", _memo: dict[int, Any]) -> \"SVGImage\":\n        # Defining this method is required to avoid the .svg_obj reference to be cloned:\n        return SVGImage(\n            href=self.href,\n            x=self.x,\n            y=self.y,\n            width=self.width,\n            height=self.height,\n            svg_obj=self.svg_obj,\n        )\n\n    # pylint: disable=unused-argument\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: \"Renderable\",\n        initial_point: Point,\n    ) -> tuple[str, \"Renderable\", Point]:\n        image_cache = self.svg_obj and self.svg_obj.image_cache\n        if not image_cache:\n            raise AssertionError(\n                \"fpdf2 bug - Cannot render a raster image without a SVGObject.image_cache\"\n            )\n\n        # We lazy-import this function to circumvent a circular import problem:\n        # pylint: disable=cyclic-import,import-outside-toplevel\n        from .image_parsing import preload_image\n\n        _, _, info = preload_image(image_cache, self.href)\n        if isinstance(info, VectorImageInfo):\n            LOGGER.warning(\n                \"Inserting .svg vector graphics in <image> tags is currently not supported (contributions are welcome to add support for it)\"\n            )\n            return \"\", last_item, initial_point\n        w, h = info.size_in_document_units(self.width, self.height)\n        stream_content = stream_content_for_raster_image(\n            info=info,\n            x=self.x,\n            y=self.y,\n            w=w,\n            h=h,\n            keep_aspect_ratio=True,\n        )\n        return stream_content, last_item, initial_point\n\n    @property\n    def end_point(self) -> Point:\n        return Point(self.x, self.y)\n\n    # pylint: disable=unused-argument\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        x0 = self.x\n        y0 = self.y\n        x1 = self.x + self.width\n        y1 = self.y + self.height\n\n        bbox = BoundingBox.from_points(\n            [\n                Point(x0, y0),\n                Point(x1, y0),\n                Point(x0, y1),\n                Point(x1, y1),\n            ]\n        )\n        return bbox, Point(self.x, self.y)",
      "language": "python"
    },
    {
      "code": "class SVGImage(NamedTuple):\n    href: str\n    x: float\n    y: float\n    width: float\n    height: float\n    svg_obj: SVGObject\n\n    def __deepcopy__(self: \"SVGImage\", _memo: dict[int, Any]) -> \"SVGImage\":\n        # Defining this method is required to avoid the .svg_obj reference to be cloned:\n        return SVGImage(\n            href=self.href,\n            x=self.x,\n            y=self.y,\n            width=self.width,\n            height=self.height,\n            svg_obj=self.svg_obj,\n        )\n\n    # pylint: disable=unused-argument\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: \"Renderable\",\n        initial_point: Point,\n    ) -> tuple[str, \"Renderable\", Point]:\n        image_cache = self.svg_obj and self.svg_obj.image_cache\n        if not image_cache:\n            raise AssertionError(\n                \"fpdf2 bug - Cannot render a raster image without a SVGObject.image_cache\"\n            )\n\n        # We lazy-import this function to circumvent a circular import problem:\n        # pylint: disable=cyclic-import,import-outside-toplevel\n        from .image_parsing import preload_image\n\n        _, _, info = preload_image(image_cache, self.href)\n        if isinstance(info, VectorImageInfo):\n            LOGGER.warning(\n                \"Inserting .svg vector graphics in <image> tags is currently not supported (contributions are welcome to add support for it)\"\n            )\n            return \"\", last_item, initial_point\n        w, h = info.size_in_document_units(self.width, self.height)\n        stream_content = stream_content_for_raster_image(\n            info=info,\n            x=self.x,\n            y=self.y,\n            w=w,\n            h=h,\n            keep_aspect_ratio=True,\n        )\n        return stream_content, last_item, initial_point\n\n    @property\n    def end_point(self) -> Point:\n        return Point(self.x, self.y)\n\n    # pylint: disable=unused-argument\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        x0 = self.x\n        y0 = self.y\n        x1 = self.x + self.width\n        y1 = self.y + self.height\n\n        bbox = BoundingBox.from_points(\n            [\n                Point(x0, y0),\n                Point(x1, y0),\n                Point(x0, y1),\n                Point(x1, y1),\n            ]\n        )\n        return bbox, Point(self.x, self.y)",
      "language": "python"
    },
    {
      "code": "class SVGImage(NamedTuple):\n    href: str\n    x: float\n    y: float\n    width: float\n    height: float\n    svg_obj: SVGObject\n\n    def __deepcopy__(self: \"SVGImage\", _memo: dict[int, Any]) -> \"SVGImage\":\n        # Defining this method is required to avoid the .svg_obj reference to be cloned:\n        return SVGImage(\n            href=self.href,\n            x=self.x,\n            y=self.y,\n            width=self.width,\n            height=self.height,\n            svg_obj=self.svg_obj,\n        )\n\n    # pylint: disable=unused-argument\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: \"Renderable\",\n        initial_point: Point,\n    ) -> tuple[str, \"Renderable\", Point]:\n        image_cache = self.svg_obj and self.svg_obj.image_cache\n        if not image_cache:\n            raise AssertionError(\n                \"fpdf2 bug - Cannot render a raster image without a SVGObject.image_cache\"\n            )\n\n        # We lazy-import this function to circumvent a circular import problem:\n        # pylint: disable=cyclic-import,import-outside-toplevel\n        from .image_parsing import preload_image\n\n        _, _, info = preload_image(image_cache, self.href)\n        if isinstance(info, VectorImageInfo):\n            LOGGER.warning(\n                \"Inserting .svg vector graphics in <image> tags is currently not supported (contributions are welcome to add support for it)\"\n            )\n            return \"\", last_item, initial_point\n        w, h = info.size_in_document_units(self.width, self.height)\n        stream_content = stream_content_for_raster_image(\n            info=info,\n            x=self.x,\n            y=self.y,\n            w=w,\n            h=h,\n            keep_aspect_ratio=True,\n        )\n        return stream_content, last_item, initial_point\n\n    @property\n    def end_point(self) -> Point:\n        return Point(self.x, self.y)\n\n    # pylint: disable=unused-argument\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        x0 = self.x\n        y0 = self.y\n        x1 = self.x + self.width\n        y1 = self.y + self.height\n\n        bbox = BoundingBox.from_points(\n            [\n                Point(x0, y0),\n                Point(x1, y0),\n                Point(x0, y1),\n                Point(x1, y1),\n            ]\n        )\n        return bbox, Point(self.x, self.y)",
      "language": "python"
    },
    {
      "code": "class SVGImage(NamedTuple):\n    href: str\n    x: float\n    y: float\n    width: float\n    height: float\n    svg_obj: SVGObject\n\n    def __deepcopy__(self: \"SVGImage\", _memo: dict[int, Any]) -> \"SVGImage\":\n        # Defining this method is required to avoid the .svg_obj reference to be cloned:\n        return SVGImage(\n            href=self.href,\n            x=self.x,\n            y=self.y,\n            width=self.width,\n            height=self.height,\n            svg_obj=self.svg_obj,\n        )\n\n    # pylint: disable=unused-argument\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: \"Renderable\",\n        initial_point: Point,\n    ) -> tuple[str, \"Renderable\", Point]:\n        image_cache = self.svg_obj and self.svg_obj.image_cache\n        if not image_cache:\n            raise AssertionError(\n                \"fpdf2 bug - Cannot render a raster image without a SVGObject.image_cache\"\n            )\n\n        # We lazy-import this function to circumvent a circular import problem:\n        # pylint: disable=cyclic-import,import-outside-toplevel\n        from .image_parsing import preload_image\n\n        _, _, info = preload_image(image_cache, self.href)\n        if isinstance(info, VectorImageInfo):\n            LOGGER.warning(\n                \"Inserting .svg vector graphics in <image> tags is currently not supported (contributions are welcome to add support for it)\"\n            )\n            return \"\", last_item, initial_point\n        w, h = info.size_in_document_units(self.width, self.height)\n        stream_content = stream_content_for_raster_image(\n            info=info,\n            x=self.x,\n            y=self.y,\n            w=w,\n            h=h,\n            keep_aspect_ratio=True,\n        )\n        return stream_content, last_item, initial_point\n\n    @property\n    def end_point(self) -> Point:\n        return Point(self.x, self.y)\n\n    # pylint: disable=unused-argument\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        x0 = self.x\n        y0 = self.y\n        x1 = self.x + self.width\n        y1 = self.y + self.height\n\n        bbox = BoundingBox.from_points(\n            [\n                Point(x0, y0),\n                Point(x1, y0),\n                Point(x0, y1),\n                Point(x1, y1),\n            ]\n        )\n        return bbox, Point(self.x, self.y)",
      "language": "python"
    },
    {
      "code": "class SVGImage(NamedTuple):\n    href: str\n    x: float\n    y: float\n    width: float\n    height: float\n    svg_obj: SVGObject\n\n    def __deepcopy__(self: \"SVGImage\", _memo: dict[int, Any]) -> \"SVGImage\":\n        # Defining this method is required to avoid the .svg_obj reference to be cloned:\n        return SVGImage(\n            href=self.href,\n            x=self.x,\n            y=self.y,\n            width=self.width,\n            height=self.height,\n            svg_obj=self.svg_obj,\n        )\n\n    # pylint: disable=unused-argument\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: \"Renderable\",\n        initial_point: Point,\n    ) -> tuple[str, \"Renderable\", Point]:\n        image_cache = self.svg_obj and self.svg_obj.image_cache\n        if not image_cache:\n            raise AssertionError(\n                \"fpdf2 bug - Cannot render a raster image without a SVGObject.image_cache\"\n            )\n\n        # We lazy-import this function to circumvent a circular import problem:\n        # pylint: disable=cyclic-import,import-outside-toplevel\n        from .image_parsing import preload_image\n\n        _, _, info = preload_image(image_cache, self.href)\n        if isinstance(info, VectorImageInfo):\n            LOGGER.warning(\n                \"Inserting .svg vector graphics in <image> tags is currently not supported (contributions are welcome to add support for it)\"\n            )\n            return \"\", last_item, initial_point\n        w, h = info.size_in_document_units(self.width, self.height)\n        stream_content = stream_content_for_raster_image(\n            info=info,\n            x=self.x,\n            y=self.y,\n            w=w,\n            h=h,\n            keep_aspect_ratio=True,\n        )\n        return stream_content, last_item, initial_point\n\n    @property\n    def end_point(self) -> Point:\n        return Point(self.x, self.y)\n\n    # pylint: disable=unused-argument\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        x0 = self.x\n        y0 = self.y\n        x1 = self.x + self.width\n        y1 = self.y + self.height\n\n        bbox = BoundingBox.from_points(\n            [\n                Point(x0, y0),\n                Point(x1, y0),\n                Point(x0, y1),\n                Point(x1, y1),\n            ]\n        )\n        return bbox, Point(self.x, self.y)",
      "language": "python"
    },
    {
      "code": "class SVGImage(NamedTuple):\n    href: str\n    x: float\n    y: float\n    width: float\n    height: float\n    svg_obj: SVGObject\n\n    def __deepcopy__(self: \"SVGImage\", _memo: dict[int, Any]) -> \"SVGImage\":\n        # Defining this method is required to avoid the .svg_obj reference to be cloned:\n        return SVGImage(\n            href=self.href,\n            x=self.x,\n            y=self.y,\n            width=self.width,\n            height=self.height,\n            svg_obj=self.svg_obj,\n        )\n\n    # pylint: disable=unused-argument\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: \"Renderable\",\n        initial_point: Point,\n    ) -> tuple[str, \"Renderable\", Point]:\n        image_cache = self.svg_obj and self.svg_obj.image_cache\n        if not image_cache:\n            raise AssertionError(\n                \"fpdf2 bug - Cannot render a raster image without a SVGObject.image_cache\"\n            )\n\n        # We lazy-import this function to circumvent a circular import problem:\n        # pylint: disable=cyclic-import,import-outside-toplevel\n        from .image_parsing import preload_image\n\n        _, _, info = preload_image(image_cache, self.href)\n        if isinstance(info, VectorImageInfo):\n            LOGGER.warning(\n                \"Inserting .svg vector graphics in <image> tags is currently not supported (contributions are welcome to add support for it)\"\n            )\n            return \"\", last_item, initial_point\n        w, h = info.size_in_document_units(self.width, self.height)\n        stream_content = stream_content_for_raster_image(\n            info=info,\n            x=self.x,\n            y=self.y,\n            w=w,\n            h=h,\n            keep_aspect_ratio=True,\n        )\n        return stream_content, last_item, initial_point\n\n    @property\n    def end_point(self) -> Point:\n        return Point(self.x, self.y)\n\n    # pylint: disable=unused-argument\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        x0 = self.x\n        y0 = self.y\n        x1 = self.x + self.width\n        y1 = self.y + self.height\n\n        bbox = BoundingBox.from_points(\n            [\n                Point(x0, y0),\n                Point(x1, y0),\n                Point(x0, y1),\n                Point(x1, y1),\n            ]\n        )\n        return bbox, Point(self.x, self.y)",
      "language": "python"
    },
    {
      "code": "def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n    x0 = self.x\n    y0 = self.y\n    x1 = self.x + self.width\n    y1 = self.y + self.height\n\n    bbox = BoundingBox.from_points(\n        [\n            Point(x0, y0),\n            Point(x1, y0),\n            Point(x0, y1),\n            Point(x1, y1),\n        ]\n    )\n    return bbox, Point(self.x, self.y)",
      "language": "python"
    },
    {
      "code": "@force_nodocument\ndef render(\n    self,\n    resource_registry: \"ResourceCatalog\",\n    style: GraphicsStyle,\n    last_item: \"Renderable\",\n    initial_point: Point,\n) -> tuple[str, \"Renderable\", Point]:\n    image_cache = self.svg_obj and self.svg_obj.image_cache\n    if not image_cache:\n        raise AssertionError(\n            \"fpdf2 bug - Cannot render a raster image without a SVGObject.image_cache\"\n        )\n\n    # We lazy-import this function to circumvent a circular import problem:\n    # pylint: disable=cyclic-import,import-outside-toplevel\n    from .image_parsing import preload_image\n\n    _, _, info = preload_image(image_cache, self.href)\n    if isinstance(info, VectorImageInfo):\n        LOGGER.warning(\n            \"Inserting .svg vector graphics in <image> tags is currently not supported (contributions are welcome to add support for it)\"\n        )\n        return \"\", last_item, initial_point\n    w, h = info.size_in_document_units(self.width, self.height)\n    stream_content = stream_content_for_raster_image(\n        info=info,\n        x=self.x,\n        y=self.y,\n        w=w,\n        h=h,\n        keep_aspect_ratio=True,\n    )\n    return stream_content, last_item, initial_point",
      "language": "python"
    },
    {
      "code": "class SVGObject:\n    \"\"\"\n    A representation of an SVG that has been converted to a PDF representation.\n    \"\"\"\n\n    @classmethod\n    def from_file(\n        cls,\n        filename: str | PathLike[str],\n        *args: Any,\n        encoding: str = \"utf-8\",\n        **kwargs: Any,\n    ) -> \"SVGObject\":\n        \"\"\"\n        Create an `SVGObject` from the contents of the file at `filename`.\n\n        Args:\n            filename (path-like): the path to a file containing SVG data.\n            *args: forwarded directly to the SVGObject initializer. For subclass use.\n            encoding (str): optional charset encoding to use when reading the file.\n            **kwargs: forwarded directly to the SVGObject initializer. For subclass use.\n\n        Returns:\n            A converted `SVGObject`.\n        \"\"\"\n        with open(filename, \"r\", encoding=encoding) as svgfile:\n            return cls(svgfile.read(), *args, **kwargs)\n\n    def __init__(\n        self, svg_text: str | bytes, image_cache: Optional[ImageCache] = None\n    ) -> None:\n        self.image_cache = image_cache  # Needed to render images\n        self.cross_references: dict[str, Any] = {}\n        self.css_class_styles: dict[str, dict[str, Any]] = {}\n        self.gradient_definitions: dict[str, GradientPaint] = (\n            {}\n        )  # Store parsed gradients by ID\n        self.width: Optional[Percent | float] = None\n        self.height: Optional[Percent | float] = None\n        # disabling bandit rule as we use defusedxml:\n        svg_tree: \"Element\" = parse_xml_str(svg_text)  # nosec B314\n\n        if svg_tree.tag not in xmlns_lookup(\"svg\", \"svg\"):\n            raise ValueError(f\"root tag must be svg, not {svg_tree.tag}\")\n\n        self._collect_css_styles(svg_tree)\n        self.extract_shape_info(svg_tree)\n        self.convert_graphics(svg_tree)\n\n    @force_nodocument\n    def update_xref(self, key: Optional[str], referenced: Any) -> None:\n        if key:\n            key = \"#\" + key if not key.startswith(\"#\") else key\n            self.cross_references[key] = referenced\n\n    def _collect_css_styles(self, root_tag: \"Element\") -> None:\n        for node in root_tag.iter():\n            if node.tag in xmlns_lookup(\"svg\", \"style\"):\n                css_text = \"\".join(node.itertext() or [])\n                for class_name, declarations in _extract_css_class_styles(css_text):\n                    existing = self.css_class_styles.setdefault(class_name, {})\n                    existing.update(declarations)\n\n    def _style_map_for(self, tag: \"Element\") -> dict[str, Any]:\n        style_map: dict[str, Any] = {}\n        if self.css_class_styles:\n            class_attr = tag.attrib.get(\"class\")\n            if class_attr:\n                for class_name in class_attr.split():\n                    class_styles = self.css_class_styles.get(class_name)\n                    if class_styles:\n                        style_map.update(class_styles)\n        inline = html.parse_css_style(tag.attrib.get(\"style\", \"\"))\n        for key, value in inline.items():\n            norm_value = _normalize_css_value(value)\n            if norm_value is not None:\n                style_map[key] = norm_value\n            elif key in style_map:\n                style_map.pop(key, None)\n        inheritable_attrs = (\n            \"font-family\",\n            \"font-size\",\n            \"font-style\",\n            \"font-weight\",\n            \"text-anchor\",\n            \"white-space\",\n        )\n        for attr in inheritable_attrs:\n            if attr in tag.attrib:\n                norm_value = _normalize_css_value(tag.attrib.get(attr))\n                if norm_value is not None:\n                    style_map.setdefault(attr, norm_value)\n        return style_map\n\n    @force_nodocument\n    @staticmethod\n    def _convert_gradient_coordinate(value: str, default: str = \"0\") -> float:\n        \"\"\"Convert SVG gradient coordinate (percentage or number) to float.\"\"\"\n        if value is None or value == \"\":\n            value = default\n\n        value = value.strip()\n\n        if value.endswith(\"%\"):\n            return float(value[:-1]) / 100.0\n\n        try:\n            return float(value)\n        except ValueError:\n            try:\n                return resolve_length(value)\n            except ValueError:\n                LOGGER.warning(\n                    \"Could not parse gradient coordinate '%s', using 0\", value\n                )\n                return 0.0\n\n    @force_nodocument\n    @staticmethod\n    def _parse_gradient_stops(\n        gradient_element: \"Element\",\n    ) -> list[tuple[float, DeviceRGB | DeviceGray]]:\n        \"\"\"Parse <stop> children of a gradient element.\"\"\"\n        stops: list[tuple[float, DeviceRGB | DeviceGray]] = []\n\n        for stop_element in gradient_element:\n            tag_name = without_ns(stop_element.tag)\n            if tag_name != \"stop\":\n                continue\n\n            offset_str = stop_element.attrib.get(\"offset\")\n            if offset_str is None:\n                LOGGER.warning(\"Found <stop> without offset, skipping\")\n                continue\n\n            offset_str = offset_str.strip()\n            if offset_str.endswith(\"%\"):\n                offset = float(offset_str[:-1]) / 100.0\n            else:\n                offset = float(offset_str)\n\n            offset = max(0.0, min(1.0, offset))\n\n            stop_color = None\n            stop_opacity = 1.0\n\n            style = stop_element.attrib.get(\"style\", \"\")\n            if style:\n                style_dict = html.parse_css_style(style)\n                stop_color = style_dict.get(\"stop-color\")\n                stop_opacity_str = style_dict.get(\"stop-opacity\")\n                if stop_opacity_str:\n                    try:\n                        stop_opacity = float(stop_opacity_str)\n                    except ValueError:\n                        LOGGER.warning(\n                            \"Invalid stop-opacity value: %s\", stop_opacity_str\n                        )\n\n            if stop_color is None:\n                stop_color = stop_element.attrib.get(\"stop-color\", \"black\")\n\n            if \"stop-opacity\" in stop_element.attrib:\n                try:\n                    stop_opacity = float(stop_element.attrib.get(\"stop-opacity\") or \"1\")\n                except ValueError:\n                    pass\n\n            try:\n                color_obj = svgcolor(stop_color)\n\n                if stop_opacity < 1.0:\n                    if isinstance(color_obj, DeviceRGB):\n                        color_obj = DeviceRGB(\n                            color_obj.r, color_obj.g, color_obj.b, stop_opacity\n                        )\n                    if isinstance(color_obj, DeviceGray):\n                        color_obj = DeviceGray(color_obj.g, stop_opacity)\n                stops.append((offset, color_obj))\n\n            except (ValueError, KeyError) as e:\n                LOGGER.warning(\"Could not parse stop color '%s': %s\", stop_color, e)\n                continue\n\n        return stops\n\n    @force_nodocument\n    @staticmethod\n    def _extract_gradient_id(url_value: Optional[str]) -> Optional[str]:\n        \"\"\"Extract gradient ID from url(#id) format.\"\"\"\n        if not url_value or not isinstance(url_value, str):\n            return None\n        match = re.search(r'url\\(\\s*[\"\\']?\\s*#([^)\"\\'\\s]+)', url_value)\n        if match:\n            return \"#\" + match.group(1)\n        return None\n\n    @force_nodocument\n    def _parse_linear_gradient(self, grad_element: \"Element\") -> None:\n        \"\"\"Parse a <linearGradient> element and store it in gradient_definitions.\"\"\"\n        grad_id: Optional[str] = grad_element.attrib.get(\"id\")\n        if not grad_id:\n            LOGGER.warning(\"Found <linearGradient> without id attribute, skipping\")\n            return\n\n        if not grad_id.startswith(\"#\"):\n            grad_id = \"#\" + grad_id\n\n        x1 = grad_element.attrib.get(\"x1\", \"0%\")\n        y1 = grad_element.attrib.get(\"y1\", \"0%\")\n        x2 = grad_element.attrib.get(\"x2\", \"100%\")\n        y2 = grad_element.attrib.get(\"y2\", \"0%\")\n\n        x1_val = self._convert_gradient_coordinate(x1, \"0\")\n        y1_val = self._convert_gradient_coordinate(y1, \"0\")\n        x2_val = self._convert_gradient_coordinate(x2, \"1\")\n        y2_val = self._convert_gradient_coordinate(y2, \"0\")\n\n        units_str = grad_element.attrib.get(\"gradientUnits\", \"objectBoundingBox\")\n        if units_str == \"userSpaceOnUse\":\n            units = GradientUnits.USER_SPACE_ON_USE\n        else:\n            units = GradientUnits.OBJECT_BOUNDING_BOX\n\n        spread_str = grad_element.attrib.get(\"spreadMethod\", \"pad\")\n        try:\n            spread_method = GradientSpreadMethod.coerce(spread_str)\n        except (ValueError, AttributeError):\n            spread_method = GradientSpreadMethod.PAD\n            LOGGER.warning(\"Invalid spreadMethod '%s', using PAD\", spread_str)\n\n        transform = None\n        transform_str = grad_element.attrib.get(\"gradientTransform\")\n        if transform_str:\n            try:\n                transform = convert_transforms(transform_str)\n            except (ValueError, AttributeError, TypeError) as e:\n                LOGGER.warning(\"Could not parse gradientTransform: %s\", e)\n\n        stops = self._parse_gradient_stops(grad_element)\n\n        if not stops:\n            LOGGER.warning(\"Linear gradient '%s' has no valid stops, skipping\", grad_id)\n            return\n\n        gradient = shape_linear_gradient(\n            x1=x1_val,\n            y1=y1_val,\n            x2=x2_val,\n            y2=y2_val,\n            stops=stops,\n            spread_method=spread_method,\n        )\n\n        gradient_paint = GradientPaint(\n            gradient=gradient,\n            units=units,\n            gradient_transform=transform or Transform.identity(),\n            spread_method=spread_method,\n        )\n\n        self.gradient_definitions[grad_id] = gradient_paint\n\n        LOGGER.debug(\"Parsed linear gradient '%s' with %d stops\", grad_id, len(stops))\n\n    @force_nodocument\n    def _parse_radial_gradient(self, grad_element: \"Element\") -> None:\n        \"\"\"Parse a <radialGradient> element and store it in gradient_definitions.\"\"\"\n        grad_id = grad_element.attrib.get(\"id\")\n        if not grad_id:\n            LOGGER.warning(\"Found <radialGradient> without id attribute, skipping\")\n            return\n\n        if not grad_id.startswith(\"#\"):\n            grad_id = \"#\" + grad_id\n\n        cx = grad_element.attrib.get(\"cx\", \"50%\")\n        cy = grad_element.attrib.get(\"cy\", \"50%\")\n        r = grad_element.attrib.get(\"r\", \"50%\")\n        fx = grad_element.attrib.get(\"fx\", cx)\n        fy = grad_element.attrib.get(\"fy\", cy)\n        fr = grad_element.attrib.get(\"fr\", \"0%\")\n\n        cx_val = self._convert_gradient_coordinate(cx, \"0.5\")\n        cy_val = self._convert_gradient_coordinate(cy, \"0.5\")\n        r_val = self._convert_gradient_coordinate(r, \"0.5\")\n        fx_val = self._convert_gradient_coordinate(fx, str(cx_val))\n        fy_val = self._convert_gradient_coordinate(fy, str(cy_val))\n        fr_val = self._convert_gradient_coordinate(fr, \"0\")\n\n        if r_val <= 0:\n            LOGGER.warning(\n                \"Radial gradient '%s' has invalid radius %s, skipping\", grad_id, r_val\n            )\n            return\n\n        units_str = grad_element.attrib.get(\"gradientUnits\", \"objectBoundingBox\")\n        units = (\n            GradientUnits.USER_SPACE_ON_USE\n            if units_str == \"userSpaceOnUse\"\n            else GradientUnits.OBJECT_BOUNDING_BOX\n        )\n\n        spread_str = grad_element.attrib.get(\"spreadMethod\", \"pad\")\n        try:\n            spread_method = GradientSpreadMethod.coerce(spread_str)\n        except (ValueError, AttributeError):\n            spread_method = GradientSpreadMethod.PAD\n\n        transform = None\n        transform_str = grad_element.attrib.get(\"gradientTransform\")\n        if transform_str:\n            try:\n                transform = convert_transforms(transform_str)\n            except (ValueError, AttributeError, TypeError) as e:\n                LOGGER.warning(\"Could not parse gradientTransform: %s\", e)\n\n        stops = self._parse_gradient_stops(grad_element)\n        if not stops:\n            LOGGER.warning(\"Radial gradient '%s' has no valid stops, skipping\", grad_id)\n            return\n\n        gradient = shape_radial_gradient(\n            cx=cx_val,\n            cy=cy_val,\n            r=r_val,\n            stops=stops,\n            fx=fx_val,\n            fy=fy_val,\n            fr=fr_val,\n            spread_method=spread_method,\n        )\n\n        gradient_paint = GradientPaint(\n            gradient=gradient,\n            units=units,\n            gradient_transform=transform or Transform.identity(),\n            spread_method=spread_method,\n        )\n\n        self.gradient_definitions[grad_id] = gradient_paint\n        LOGGER.debug(\"Parsed radial gradient '%s' with %d stops\", grad_id, len(stops))\n\n    @force_nodocument\n    def _apply_gradient_paint(\n        self,\n        stylable: PaintedPath,\n        svg_element: \"Element\",\n        style_map: Optional[dict[str, Any]] = None,\n    ) -> None:\n        \"\"\"Apply gradient paint to fill or stroke if a url(#gradientId) reference is found.\"\"\"\n        fill_value = _get_attr_or_style(svg_element, \"fill\", style_map)\n        if fill_value:\n            grad_id = self._extract_gradient_id(fill_value)\n            if grad_id and grad_id in self.gradient_definitions:\n                stylable.style.fill_color = self.gradient_definitions[grad_id]\n                LOGGER.debug(\"Applied gradient %s to fill\", grad_id)\n\n        stroke_value = _get_attr_or_style(svg_element, \"stroke\", style_map)\n        if stroke_value:\n            grad_id = self._extract_gradient_id(stroke_value)\n            if grad_id and grad_id in self.gradient_definitions:\n                stylable.style.stroke_color = self.gradient_definitions[grad_id]\n                LOGGER.debug(\"Applied gradient %s to stroke\", grad_id)\n\n    @force_nodocument\n    def extract_shape_info(self, root_tag: \"Element\") -> None:\n        \"\"\"Collect shape info from the given SVG.\"\"\"\n\n        width_str = root_tag.get(\"width\")\n        height_str = root_tag.get(\"height\")\n        viewbox = root_tag.get(\"viewBox\")\n        # we don't fully support this, just check for its existence\n        preserve_ar = root_tag.get(\"preserveAspectRatio\", True)\n        if preserve_ar == \"none\":\n            self.preserve_ar = None\n        else:\n            self.preserve_ar = True\n\n        self.width = None\n        if width_str is not None:\n            width_str.strip()\n            if width_str.endswith(\"%\"):\n                self.width = Percent(width_str[:-1])\n            else:\n                self.width = resolve_length(width_str)\n\n        self.height = None\n        if height_str is not None:\n            height_str.strip()\n            if height_str.endswith(\"%\"):\n                self.height = Percent(height_str[:-1])\n            else:\n                self.height = resolve_length(height_str)\n\n        if viewbox is None:\n            self.viewbox = None\n        else:\n            viewbox = viewbox.strip()\n            vx, vy, vw, vh = [float(num) for num in NUMBER_SPLIT.split(viewbox)]\n            if (vw < 0) or (vh < 0):\n                raise ValueError(f\"invalid negative width/height in viewbox {viewbox}\")\n\n            self.viewbox = [vx, vy, vw, vh]\n\n    @force_nodocument\n    def convert_graphics(self, root_tag: \"Element\") -> None:\n        \"\"\"Convert the graphics contained in the SVG into the PDF representation.\"\"\"\n        base_group = GraphicsContext()\n        base_group.style.stroke_width = None\n        base_group.style.auto_close = False\n        base_group.style.stroke_cap_style = StrokeCapStyle.BUTT\n\n        self.build_group(root_tag, base_group)\n\n        self.base_group = base_group\n\n    def transform_to_page_viewport(\n        self, pdf: \"FPDF\", align_viewbox: bool = True\n    ) -> tuple[float, float, GraphicsContext]:\n        \"\"\"\n        Size the converted SVG paths to the page viewport.\n\n        The SVG document size can be specified relative to the rendering viewport\n        (e.g. width=50%). If the converted SVG sizes are relative units, then this\n        computes the appropriate scale transform to size the SVG to the correct\n        dimensions for a page in the current PDF document.\n\n        If the SVG document size is specified in absolute units, then it is not scaled.\n\n        Args:\n            pdf (fpdf.fpdf.FPDF): the pdf to use the page size of.\n            align_viewbox (bool): if True, mimic some of the SVG alignment rules if the\n                viewbox aspect ratio does not match that of the viewport.\n\n        Returns:\n            The same thing as `SVGObject.transform_to_rect_viewport`.\n        \"\"\"\n\n        return self.transform_to_rect_viewport(pdf.k, pdf.epw, pdf.eph, align_viewbox)\n\n    def transform_to_rect_viewport(\n        self,\n        scale: float,\n        width: float | Percent,\n        height: float | Percent,\n        align_viewbox: bool = True,\n        ignore_svg_top_attrs: bool = False,\n    ) -> tuple[float, float, GraphicsContext]:\n        \"\"\"\n        Size the converted SVG paths to an arbitrarily sized viewport.\n\n        The SVG document size can be specified relative to the rendering viewport\n        (e.g. width=50%). If the converted SVG sizes are relative units, then this\n        computes the appropriate scale transform to size the SVG to the correct\n        dimensions for a page in the current PDF document.\n\n        Args:\n            scale (Number): the scale factor from document units to PDF points.\n            width (Number): the width of the viewport to scale to in document units.\n            height (Number): the height of the viewport to scale to in document units.\n            align_viewbox (bool): if True, mimic some of the SVG alignment rules if the\n                viewbox aspect ratio does not match that of the viewport.\n            ignore_svg_top_attrs (bool): ignore <svg> top attributes like \"width\", \"height\"\n                or \"preserveAspectRatio\" when figuring the image dimensions.\n                Require width & height to be provided as parameters.\n\n        Returns:\n            A tuple of (width, height, `fpdf.drawing.GraphicsContext`), where width and\n            height are the resolved width and height (they may be 0. If 0, the returned\n            `fpdf.drawing.GraphicsContext` will be empty). The\n            `fpdf.drawing.GraphicsContext` contains all of the paths that were\n            converted from the SVG, scaled to the given viewport size.\n        \"\"\"\n        vp_width: float\n        vp_height: float\n\n        if ignore_svg_top_attrs:\n            # width/height may be Percent when passed from FPDF.image; resolve to float\n            if isinstance(width, Percent):\n                vp_width = float(width)\n            else:\n                vp_width = float(width)\n        elif isinstance(self.width, Percent):\n            if not width:\n                raise ValueError(\n                    'SVG \"width\" is a percentage, hence a viewport width is required'\n                )\n            vp_width = self.width * width / 100\n        else:\n            vp_width = self.width or width\n\n        if ignore_svg_top_attrs:\n            if isinstance(height, Percent):\n                vp_height = float(height)\n            else:\n                vp_height = float(height)\n        elif isinstance(self.height, Percent):\n            if not height:\n                raise ValueError(\n                    'SVG \"height\" is a percentage, hence a viewport height is required'\n                )\n            vp_height = self.height * height / 100\n        else:\n            vp_height = self.height or height\n\n        if scale == 1:\n            transform = Transform.identity()\n        else:\n            transform = Transform.scaling(1 / scale)\n\n        if self.viewbox:\n            vx, vy, vw, vh = self.viewbox\n\n            if (vw == 0) or (vh == 0):\n                return 0, 0, GraphicsContext()\n\n            w_ratio = vp_width / vw\n            h_ratio = vp_height / vh\n\n            if not ignore_svg_top_attrs and self.preserve_ar and (w_ratio != h_ratio):\n                w_ratio = h_ratio = min(w_ratio, h_ratio)\n\n            transform = (\n                transform\n                @ Transform.translation(x=-vx, y=-vy)\n                @ Transform.scaling(x=w_ratio, y=h_ratio)\n            )\n\n            if align_viewbox:\n                transform = transform @ Transform.translation(\n                    x=vp_width / 2 - (vw / 2) * w_ratio,\n                    y=vp_height / 2 - (vh / 2) * h_ratio,\n                )\n\n        self.base_group.transform = transform\n\n        return vp_width / scale, vp_height / scale, self.base_group\n\n    def draw_to_page(\n        self,\n        pdf: \"FPDF\",\n        x: Optional[float] = None,\n        y: Optional[float] = None,\n        debug_stream: Optional[bool] = None,\n    ) -> None:\n        \"\"\"\n        Directly draw the converted SVG to the given PDF's current page.\n\n        The page viewport is used for sizing the SVG.\n\n        Args:\n            pdf (fpdf.fpdf.FPDF): the document to which the converted SVG is rendered.\n            x (Number): abscissa of the converted SVG's top-left corner.\n            y (Number): ordinate of the converted SVG's top-left corner.\n            debug_stream (io.TextIO): *DEPRECATED* the stream to which rendering debug info will be\n                written.\n        \"\"\"\n        self.image_cache = pdf.image_cache  # Needed to render images\n        _, _, path = self.transform_to_page_viewport(pdf)\n\n        old_x, old_y = pdf.x, pdf.y\n        try:\n            if x is not None and y is not None:\n                pdf.set_xy(0, 0)\n                assert path.transform is not None\n                path.transform = path.transform @ Transform.translation(x, y)\n\n            pdf.draw_path(path, debug_stream)\n\n        finally:\n            pdf.set_xy(old_x, old_y)\n\n    # defs paths are not drawn immediately but are added to xrefs and can be referenced\n    # later to be drawn.\n    @force_nodocument\n    def handle_defs(self, defs: \"Element\") -> None:\n        \"\"\"Produce lookups for groups and paths inside the <defs> tag\"\"\"\n        for child in defs:\n            if child.tag in xmlns_lookup(\"svg\", \"g\"):\n                self.build_group(child)\n            elif child.tag in xmlns_lookup(\"svg\", \"a\"):\n                # <a> tags aren't supported but we need to recurse into them to\n                # render nested elements.\n                LOGGER.warning(\n                    \"Ignoring unsupported SVG tag: <a> (contributions are welcome to add support for it)\",\n                )\n                self.build_group(child)\n            elif child.tag in xmlns_lookup(\"svg\", \"path\"):\n                self.build_path(child)\n            elif child.tag in xmlns_lookup(\"svg\", \"image\"):\n                self.build_image(child)\n            elif child.tag in shape_tags:\n                self.build_shape(child)\n            elif child.tag in xmlns_lookup(\"svg\", \"linearGradient\"):\n                self._parse_linear_gradient(child)\n            elif child.tag in xmlns_lookup(\"svg\", \"radialGradient\"):\n                self._parse_radial_gradient(child)\n            elif child.tag in xmlns_lookup(\"svg\", \"clipPath\"):\n                try:\n                    clip_id = child.attrib[\"id\"]\n                except KeyError:\n                    clip_id = None\n                for child_ in child:\n                    self.build_clipping_path(child_, clip_id)\n            elif child.tag in xmlns_lookup(\"svg\", \"style\"):\n                # Styles handled globally during parsing\n                continue\n            else:\n                LOGGER.warning(\n                    \"Ignoring unsupported SVG tag: <%s> (contributions are welcome to add support for it)\",\n                    without_ns(child.tag),\n                )\n\n    # this assumes xrefs only reference already-defined ids.\n    # I don't know if this is required by the SVG spec.\n    @force_nodocument\n    def build_xref(self, xref: \"Element\") -> GraphicsContext:\n        \"\"\"Resolve a cross-reference to an already-seen SVG element by ID.\"\"\"\n        style_map = self._style_map_for(xref)\n        pdf_group = GraphicsContext()\n        apply_styles(pdf_group, xref, style_map)\n\n        for candidate in xmlns_lookup(\"xlink\", \"href\", \"id\"):\n            try:\n                ref = xref.attrib[candidate]\n                break\n            except KeyError:\n                pass\n        else:\n            raise ValueError(f\"use {xref} doesn't contain known xref attribute\")\n\n        try:\n            pdf_group.add_item(self.cross_references[ref])\n        except KeyError:\n            raise ValueError(\n                f\"use {xref} references nonexistent ref id {ref}\"\n            ) from None\n\n        if \"x\" in xref.attrib or \"y\" in xref.attrib:\n            # Quoting the SVG spec - 5.6.2. Layout of re-used graphics:\n            # > The x and y properties define an additional transformation translate(x,y)\n            x, y = float(xref.attrib.get(\"x\", 0)), float(xref.attrib.get(\"y\", 0))\n            pdf_group.transform = Transform.translation(x=x, y=y)\n        # Note that we currently do not support \"width\" & \"height\" in <use>\n\n        return pdf_group\n\n    @force_nodocument\n    def build_group(\n        self,\n        group: \"Element\",\n        pdf_group: Optional[GraphicsContext] = None,\n        inherited_style: Optional[dict[str, Any]] = None,\n    ) -> GraphicsContext:\n        \"\"\"Handle nested items within a group <g> tag.\"\"\"\n        local_style = self._style_map_for(group)\n        merged_style = dict(inherited_style or {})\n        merged_style.update(local_style)\n        if pdf_group is None:\n            pdf_group = GraphicsContext()\n        apply_styles(pdf_group, group, merged_style)\n\n        # handle defs before anything else\n        for child in [\n            child for child in group if child.tag in xmlns_lookup(\"svg\", \"defs\")\n        ]:\n            self.handle_defs(child)\n\n        for child in group:\n            if child.tag in xmlns_lookup(\"svg\", \"defs\"):\n                self.handle_defs(child)\n            elif child.tag in xmlns_lookup(\"svg\", \"style\"):\n                # Stylesheets already parsed globally.\n                continue\n            elif child.tag in xmlns_lookup(\"svg\", \"g\"):\n                pdf_group.add_item(self.build_group(child, None, merged_style), False)\n            elif child.tag in xmlns_lookup(\"svg\", \"a\"):\n                # <a> tags aren't supported but we need to recurse into them to\n                # render nested elements.\n                LOGGER.warning(\n                    \"Ignoring unsupported SVG tag: <a> (contributions are welcome to add support for it)\",\n                )\n                pdf_group.add_item(self.build_group(child, None, merged_style), False)\n            elif child.tag in xmlns_lookup(\"svg\", \"path\"):\n                pdf_group.add_item(self.build_path(child), False)\n            elif child.tag in shape_tags:\n                pdf_group.add_item(self.build_shape(child), False)\n            elif child.tag in xmlns_lookup(\"svg\", \"use\"):\n                pdf_group.add_item(self.build_xref(child), False)\n            elif child.tag in xmlns_lookup(\"svg\", \"image\"):\n                pdf_group.add_item(self.build_image(child), False)\n            elif child.tag in xmlns_lookup(\"svg\", \"text\"):\n                text_path = self.build_text(child, merged_style)\n                if text_path:\n                    pdf_group.add_item(text_path, False)\n            else:\n                LOGGER.warning(\n                    \"Ignoring unsupported SVG tag: <%s> (contributions are welcome to add support for it)\",\n                    without_ns(child.tag),\n                )\n\n        self.update_xref(group.attrib.get(\"id\"), pdf_group)\n\n        return pdf_group\n\n    @force_nodocument\n    def build_path(self, path: \"Element\") -> PaintedPath:\n        \"\"\"Convert an SVG <path> tag into a PDF path object.\"\"\"\n        style_map = self._style_map_for(path)\n        pdf_path = PaintedPath()\n        apply_styles(pdf_path, path, style_map)\n        self._apply_gradient_paint(pdf_path, path, style_map)\n        self.apply_clipping_path(pdf_path, path, style_map)\n        svg_path = path.attrib.get(\"d\")\n        if svg_path is not None:\n            svg_path_converter(pdf_path, svg_path)\n        self.update_xref(path.attrib.get(\"id\"), pdf_path)\n        return pdf_path\n\n    @force_nodocument\n    def build_shape(self, shape: \"Element\") -> PaintedPath:\n        \"\"\"Convert an SVG shape tag into a PDF path object. Necessary to make xref (because ShapeBuilder doesn't have access to this object.)\"\"\"\n        style_map = self._style_map_for(shape)\n        shape_builder = getattr(ShapeBuilder, shape_tags[shape.tag])\n        shape_path = shape_builder(shape)\n        assert isinstance(shape_path, PaintedPath)\n        apply_styles(shape_path, shape, style_map)\n        self._apply_gradient_paint(shape_path, shape, style_map)\n        self.apply_clipping_path(shape_path, shape, style_map)\n        self.update_xref(shape.attrib.get(\"id\"), shape_path)\n        return shape_path\n\n    @force_nodocument\n    def build_clipping_path(self, shape: \"Element\", clip_id: Optional[str]) -> None:\n        if shape.tag in shape_tags:\n            style_map = self._style_map_for(shape)\n            shape_builder = getattr(ShapeBuilder, shape_tags[shape.tag])\n            clipping_path_shape = shape_builder(shape, True)\n            apply_styles(clipping_path_shape, shape, style_map)\n        elif shape.tag in xmlns_lookup(\"svg\", \"path\"):\n            style_map = self._style_map_for(shape)\n            clipping_path_shape = PaintedPath()\n            apply_styles(clipping_path_shape, shape, style_map)\n            clipping_path_shape.paint_rule = PathPaintRule.DONT_PAINT\n            svg_path = shape.attrib.get(\"d\")\n            if svg_path is not None:\n                svg_path_converter(clipping_path_shape, svg_path)\n        else:\n            LOGGER.warning(\n                \"Ignoring unsupported <clipPath> child tag: <%s> (contributions are welcome to add support for it)\",\n                without_ns(shape.tag),\n            )\n            return\n        self.update_xref(clip_id, clipping_path_shape)\n\n    @force_nodocument\n    def apply_clipping_path(\n        self,\n        stylable: PaintedPath,\n        svg_element: \"Element\",\n        style_map: Optional[dict[str, Any]] = None,\n    ) -> None:\n        clip_value = None\n        if style_map and \"clip-path\" in style_map:\n            clip_value = style_map[\"clip-path\"]\n        if clip_value is None:\n            clip_value = svg_element.attrib.get(\"clip-path\")\n        if clip_value:\n            clipping_path_id = re.search(r\"url\\((\\#\\w+)\\)\", clip_value)\n            assert clipping_path_id is not None\n            stylable.clipping_path = self.cross_references[clipping_path_id[1]]\n\n    @force_nodocument\n    def build_image(self, image: \"Element\") -> \"SVGImage\":\n        href = None\n        for key in xmlns_lookup(\"xlink\", \"href\"):\n            if key in image.attrib:\n                href = image.attrib[key]\n                break\n        if not href:\n            raise ValueError(\"<image> is missing a href attribute\")\n        width = float(image.attrib.get(\"width\", 0))\n        height = float(image.attrib.get(\"height\", 0))\n        if \"preserveAspectRatio\" in image.attrib:\n            LOGGER.warning(\n                '\"preserveAspectRatio\" defined on <image> is currently not supported (contributions are welcome to add support for it)'\n            )\n        if \"style\" in image.attrib:\n            LOGGER.warning(\n                '\"style\" defined on <image> is currently not supported (contributions are welcome to add support for it)'\n            )\n        if \"transform\" in image.attrib:\n            LOGGER.warning(\n                '\"transform\" defined on <image> is currently not supported (contributions are welcome to add support for it)'\n            )\n        # Note: at this moment, self.image_cache is not set yet:\n        svg_image = SVGImage(\n            href=href,\n            x=float(image.attrib.get(\"x\", \"0\")),\n            y=float(image.attrib.get(\"y\", \"0\")),\n            width=width,\n            height=height,\n            svg_obj=self,\n        )\n        self.update_xref(image.attrib.get(\"id\"), svg_image)\n        return svg_image\n\n    @force_nodocument\n    def build_text(\n        self, text_tag: \"Element\", inherited_style: Optional[dict[str, Any]] = None\n    ) -> Optional[PaintedPath]:\n        \"\"\"\n        Convert <text> (and simple <tspan>) into a PaintedPath with Text runs.\n        - Uses Text baseline at (x,y)\n        - Honors x/y and dx/dy on <text> and direct child <tspan>\n        - Flattens nested tspans; advanced per-character positioning is not implemented\n        \"\"\"\n        local_style = self._style_map_for(text_tag)\n        effective_style = dict(inherited_style or {})\n        effective_style.update(local_style)\n        path = PaintedPath()\n        apply_styles(path, text_tag, local_style)\n        self.apply_clipping_path(path, text_tag, effective_style)\n\n        preserve_parent = _preserve_ws(effective_style, text_tag)\n\n        base_family, base_emph, base_size, base_anchor = _parse_font_attrs(\n            text_tag, effective_style\n        )\n        if base_family is None:\n            base_family = \"sans-serif\"\n        default_font_size = (\n            base_size if base_size is not None else resolve_length(\"16px\")\n        )\n        base_x, base_y, base_dx, base_dy = _parse_xy_delta(\n            text_tag, effective_style, font_size=default_font_size\n        )\n        anchor_x = base_x + base_dx\n        anchor_y = base_y + base_dy\n\n        text_runs: list[TextRun] = []\n        pending_dx = 0.0\n        pending_dy = 0.0\n\n        def _style_for_run(\n            tag: Optional[\"Element\"], style_map_for_tag: Optional[dict[str, Any]]\n        ) -> Optional[GraphicsStyle]:\n            if tag is None or style_map_for_tag is None:\n                return None\n            context = GraphicsContext()\n            apply_styles(context, tag, style_map_for_tag)\n            context.style.auto_close = GraphicsStyle.INHERIT\n            overrides = any(\n                getattr(context.style, prop) is not GraphicsStyle.INHERIT\n                for prop in GraphicsStyle.MERGE_PROPERTIES\n            )\n            if not overrides:\n                return None\n            return deepcopy(context.style)\n\n        def _add_run(\n            raw_text: str,\n            family: Optional[str],\n            emphasis: Optional[str],\n            size: Optional[float],\n            preserve: bool,\n            dx_extra: float = 0.0,\n            dy_extra: float = 0.0,\n            abs_x: Optional[float] = None,\n            abs_y: Optional[float] = None,\n            style_tag: Optional[\"Element\"] = None,\n            style_map_for_tag: Optional[dict[str, Any]] = None,\n        ) -> None:\n            nonlocal pending_dx, pending_dy\n            raw = raw_text or \"\"\n            collapsed = _collapse_ws(raw, preserve=preserve)\n            if preserve:\n                content = collapsed\n            else:\n                trimmed = collapsed.strip()\n                if trimmed:\n                    content = trimmed\n                    if raw[:1].isspace():\n                        content = \" \" + content\n                    if raw[-1:].isspace():\n                        content = content + \" \"\n                else:\n                    if (raw[:1].isspace() or raw[-1:].isspace()) and text_runs:\n                        content = \" \"\n                    else:\n                        content = \"\"\n            if not content:\n                pending_dx += dx_extra\n                pending_dy += dy_extra\n                return\n\n            run_size = size if size is not None else default_font_size\n            run_family = family or base_family or \"sans-serif\"\n            run_emphasis = (emphasis if emphasis is not None else base_emph) or \"\"\n            run_dx = pending_dx + dx_extra\n            run_dy = pending_dy + dy_extra\n            pending_dx = 0.0\n            pending_dy = 0.0\n            run_style = _style_for_run(style_tag, style_map_for_tag)\n\n            text_runs.append(\n                TextRun(\n                    text=content,\n                    family=run_family,\n                    emphasis=run_emphasis,\n                    size=run_size,\n                    dx=run_dx,\n                    dy=run_dy,\n                    abs_x=abs_x,\n                    abs_y=abs_y,\n                    run_style=run_style,\n                )\n            )\n\n        # Leading text (before child <tspan>)\n        _add_run(\n            text_tag.text or \"\",\n            base_family,\n            base_emph,\n            base_size,\n            preserve=preserve_parent,\n            style_tag=None,\n            style_map_for_tag=None,\n        )\n\n        for child in text_tag:\n            if child.tag in xmlns_lookup(\"svg\", \"tspan\"):\n                child_local_style = self._style_map_for(child)\n                child_effective_style = dict(effective_style)\n                child_effective_style.update(child_local_style)\n                fam, emph, size, _anchor = _parse_font_attrs(\n                    child, child_effective_style\n                )\n                run_font_size = size if size is not None else default_font_size\n                x, y, dx, dy = _parse_xy_delta(\n                    child, child_effective_style, font_size=run_font_size\n                )\n\n                child_preserve = _preserve_ws(child_effective_style, child)\n                raw_itertext = \"\".join(child.itertext())\n                tail_text = child.tail or \"\"\n                if tail_text and raw_itertext.endswith(tail_text):\n                    run_text = raw_itertext[: -len(tail_text)]\n                else:\n                    run_text = raw_itertext\n                abs_x = None\n                abs_y = None\n                if \"x\" in child.attrib or (\n                    child_local_style is not None and \"x\" in child_local_style\n                ):\n                    abs_x = x\n                if \"y\" in child.attrib or (\n                    child_local_style is not None and \"y\" in child_local_style\n                ):\n                    abs_y = y\n\n                _add_run(\n                    run_text,\n                    fam,\n                    emph,\n                    size,\n                    preserve=child_preserve,\n                    dx_extra=dx,\n                    dy_extra=dy,\n                    abs_x=abs_x,\n                    abs_y=abs_y,\n                    style_tag=child,\n                    style_map_for_tag=child_local_style,\n                )\n\n                # Text between tspans inherits parent style\n                _add_run(\n                    child.tail or \"\",\n                    base_family,\n                    base_emph,\n                    base_size,\n                    preserve=preserve_parent,\n                    style_tag=None,\n                    style_map_for_tag=None,\n                )\n            else:\n                # other child tags are ignored (already logged elsewhere)\n                pass\n\n        if text_runs:\n            path.add_path_element(\n                Text(\n                    x=anchor_x,\n                    y=anchor_y,\n                    text_runs=tuple(text_runs),\n                    text_anchor=base_anchor,\n                ),\n                clone=False,\n            )\n\n        self.update_xref(text_tag.attrib.get(\"id\"), path)\n        return path",
      "language": "python"
    },
    {
      "code": "@force_nodocument\ndef apply_clipping_path(\n    self,\n    stylable: PaintedPath,\n    svg_element: \"Element\",\n    style_map: Optional[dict[str, Any]] = None,\n) -> None:\n    clip_value = None\n    if style_map and \"clip-path\" in style_map:\n        clip_value = style_map[\"clip-path\"]\n    if clip_value is None:\n        clip_value = svg_element.attrib.get(\"clip-path\")\n    if clip_value:\n        clipping_path_id = re.search(r\"url\\((\\#\\w+)\\)\", clip_value)\n        assert clipping_path_id is not None\n        stylable.clipping_path = self.cross_references[clipping_path_id[1]]",
      "language": "python"
    },
    {
      "code": "@force_nodocument\ndef build_clipping_path(self, shape: \"Element\", clip_id: Optional[str]) -> None:\n    if shape.tag in shape_tags:\n        style_map = self._style_map_for(shape)\n        shape_builder = getattr(ShapeBuilder, shape_tags[shape.tag])\n        clipping_path_shape = shape_builder(shape, True)\n        apply_styles(clipping_path_shape, shape, style_map)\n    elif shape.tag in xmlns_lookup(\"svg\", \"path\"):\n        style_map = self._style_map_for(shape)\n        clipping_path_shape = PaintedPath()\n        apply_styles(clipping_path_shape, shape, style_map)\n        clipping_path_shape.paint_rule = PathPaintRule.DONT_PAINT\n        svg_path = shape.attrib.get(\"d\")\n        if svg_path is not None:\n            svg_path_converter(clipping_path_shape, svg_path)\n    else:\n        LOGGER.warning(\n            \"Ignoring unsupported <clipPath> child tag: <%s> (contributions are welcome to add support for it)\",\n            without_ns(shape.tag),\n        )\n        return\n    self.update_xref(clip_id, clipping_path_shape)",
      "language": "python"
    },
    {
      "code": "@force_nodocument\ndef build_group(\n    self,\n    group: \"Element\",\n    pdf_group: Optional[GraphicsContext] = None,\n    inherited_style: Optional[dict[str, Any]] = None,\n) -> GraphicsContext:\n    \"\"\"Handle nested items within a group <g> tag.\"\"\"\n    local_style = self._style_map_for(group)\n    merged_style = dict(inherited_style or {})\n    merged_style.update(local_style)\n    if pdf_group is None:\n        pdf_group = GraphicsContext()\n    apply_styles(pdf_group, group, merged_style)\n\n    # handle defs before anything else\n    for child in [\n        child for child in group if child.tag in xmlns_lookup(\"svg\", \"defs\")\n    ]:\n        self.handle_defs(child)\n\n    for child in group:\n        if child.tag in xmlns_lookup(\"svg\", \"defs\"):\n            self.handle_defs(child)\n        elif child.tag in xmlns_lookup(\"svg\", \"style\"):\n            # Stylesheets already parsed globally.\n            continue\n        elif child.tag in xmlns_lookup(\"svg\", \"g\"):\n            pdf_group.add_item(self.build_group(child, None, merged_style), False)\n        elif child.tag in xmlns_lookup(\"svg\", \"a\"):\n            # <a> tags aren't supported but we need to recurse into them to\n            # render nested elements.\n            LOGGER.warning(\n                \"Ignoring unsupported SVG tag: <a> (contributions are welcome to add support for it)\",\n            )\n            pdf_group.add_item(self.build_group(child, None, merged_style), False)\n        elif child.tag in xmlns_lookup(\"svg\", \"path\"):\n            pdf_group.add_item(self.build_path(child), False)\n        elif child.tag in shape_tags:\n            pdf_group.add_item(self.build_shape(child), False)\n        elif child.tag in xmlns_lookup(\"svg\", \"use\"):\n            pdf_group.add_item(self.build_xref(child), False)\n        elif child.tag in xmlns_lookup(\"svg\", \"image\"):\n            pdf_group.add_item(self.build_image(child), False)\n        elif child.tag in xmlns_lookup(\"svg\", \"text\"):\n            text_path = self.build_text(child, merged_style)\n            if text_path:\n                pdf_group.add_item(text_path, False)\n        else:\n            LOGGER.warning(\n                \"Ignoring unsupported SVG tag: <%s> (contributions are welcome to add support for it)\",\n                without_ns(child.tag),\n            )\n\n    self.update_xref(group.attrib.get(\"id\"), pdf_group)\n\n    return pdf_group",
      "language": "python"
    },
    {
      "code": "@force_nodocument\ndef build_image(self, image: \"Element\") -> \"SVGImage\":\n    href = None\n    for key in xmlns_lookup(\"xlink\", \"href\"):\n        if key in image.attrib:\n            href = image.attrib[key]\n            break\n    if not href:\n        raise ValueError(\"<image> is missing a href attribute\")\n    width = float(image.attrib.get(\"width\", 0))\n    height = float(image.attrib.get(\"height\", 0))\n    if \"preserveAspectRatio\" in image.attrib:\n        LOGGER.warning(\n            '\"preserveAspectRatio\" defined on <image> is currently not supported (contributions are welcome to add support for it)'\n        )\n    if \"style\" in image.attrib:\n        LOGGER.warning(\n            '\"style\" defined on <image> is currently not supported (contributions are welcome to add support for it)'\n        )\n    if \"transform\" in image.attrib:\n        LOGGER.warning(\n            '\"transform\" defined on <image> is currently not supported (contributions are welcome to add support for it)'\n        )\n    # Note: at this moment, self.image_cache is not set yet:\n    svg_image = SVGImage(\n        href=href,\n        x=float(image.attrib.get(\"x\", \"0\")),\n        y=float(image.attrib.get(\"y\", \"0\")),\n        width=width,\n        height=height,\n        svg_obj=self,\n    )\n    self.update_xref(image.attrib.get(\"id\"), svg_image)\n    return svg_image",
      "language": "python"
    },
    {
      "code": "@force_nodocument\ndef build_path(self, path: \"Element\") -> PaintedPath:\n    \"\"\"Convert an SVG <path> tag into a PDF path object.\"\"\"\n    style_map = self._style_map_for(path)\n    pdf_path = PaintedPath()\n    apply_styles(pdf_path, path, style_map)\n    self._apply_gradient_paint(pdf_path, path, style_map)\n    self.apply_clipping_path(pdf_path, path, style_map)\n    svg_path = path.attrib.get(\"d\")\n    if svg_path is not None:\n        svg_path_converter(pdf_path, svg_path)\n    self.update_xref(path.attrib.get(\"id\"), pdf_path)\n    return pdf_path",
      "language": "python"
    },
    {
      "code": "@force_nodocument\ndef build_shape(self, shape: \"Element\") -> PaintedPath:\n    \"\"\"Convert an SVG shape tag into a PDF path object. Necessary to make xref (because ShapeBuilder doesn't have access to this object.)\"\"\"\n    style_map = self._style_map_for(shape)\n    shape_builder = getattr(ShapeBuilder, shape_tags[shape.tag])\n    shape_path = shape_builder(shape)\n    assert isinstance(shape_path, PaintedPath)\n    apply_styles(shape_path, shape, style_map)\n    self._apply_gradient_paint(shape_path, shape, style_map)\n    self.apply_clipping_path(shape_path, shape, style_map)\n    self.update_xref(shape.attrib.get(\"id\"), shape_path)\n    return shape_path",
      "language": "python"
    },
    {
      "code": "@force_nodocument\ndef build_text(\n    self, text_tag: \"Element\", inherited_style: Optional[dict[str, Any]] = None\n) -> Optional[PaintedPath]:\n    \"\"\"\n    Convert <text> (and simple <tspan>) into a PaintedPath with Text runs.\n    - Uses Text baseline at (x,y)\n    - Honors x/y and dx/dy on <text> and direct child <tspan>\n    - Flattens nested tspans; advanced per-character positioning is not implemented\n    \"\"\"\n    local_style = self._style_map_for(text_tag)\n    effective_style = dict(inherited_style or {})\n    effective_style.update(local_style)\n    path = PaintedPath()\n    apply_styles(path, text_tag, local_style)\n    self.apply_clipping_path(path, text_tag, effective_style)\n\n    preserve_parent = _preserve_ws(effective_style, text_tag)\n\n    base_family, base_emph, base_size, base_anchor = _parse_font_attrs(\n        text_tag, effective_style\n    )\n    if base_family is None:\n        base_family = \"sans-serif\"\n    default_font_size = (\n        base_size if base_size is not None else resolve_length(\"16px\")\n    )\n    base_x, base_y, base_dx, base_dy = _parse_xy_delta(\n        text_tag, effective_style, font_size=default_font_size\n    )\n    anchor_x = base_x + base_dx\n    anchor_y = base_y + base_dy\n\n    text_runs: list[TextRun] = []\n    pending_dx = 0.0\n    pending_dy = 0.0\n\n    def _style_for_run(\n        tag: Optional[\"Element\"], style_map_for_tag: Optional[dict[str, Any]]\n    ) -> Optional[GraphicsStyle]:\n        if tag is None or style_map_for_tag is None:\n            return None\n        context = GraphicsContext()\n        apply_styles(context, tag, style_map_for_tag)\n        context.style.auto_close = GraphicsStyle.INHERIT\n        overrides = any(\n            getattr(context.style, prop) is not GraphicsStyle.INHERIT\n            for prop in GraphicsStyle.MERGE_PROPERTIES\n        )\n        if not overrides:\n            return None\n        return deepcopy(context.style)\n\n    def _add_run(\n        raw_text: str,\n        family: Optional[str],\n        emphasis: Optional[str],\n        size: Optional[float],\n        preserve: bool,\n        dx_extra: float = 0.0,\n        dy_extra: float = 0.0,\n        abs_x: Optional[float] = None,\n        abs_y: Optional[float] = None,\n        style_tag: Optional[\"Element\"] = None,\n        style_map_for_tag: Optional[dict[str, Any]] = None,\n    ) -> None:\n        nonlocal pending_dx, pending_dy\n        raw = raw_text or \"\"\n        collapsed = _collapse_ws(raw, preserve=preserve)\n        if preserve:\n            content = collapsed\n        else:\n            trimmed = collapsed.strip()\n            if trimmed:\n                content = trimmed\n                if raw[:1].isspace():\n                    content = \" \" + content\n                if raw[-1:].isspace():\n                    content = content + \" \"\n            else:\n                if (raw[:1].isspace() or raw[-1:].isspace()) and text_runs:\n                    content = \" \"\n                else:\n                    content = \"\"\n        if not content:\n            pending_dx += dx_extra\n            pending_dy += dy_extra\n            return\n\n        run_size = size if size is not None else default_font_size\n        run_family = family or base_family or \"sans-serif\"\n        run_emphasis = (emphasis if emphasis is not None else base_emph) or \"\"\n        run_dx = pending_dx + dx_extra\n        run_dy = pending_dy + dy_extra\n        pending_dx = 0.0\n        pending_dy = 0.0\n        run_style = _style_for_run(style_tag, style_map_for_tag)\n\n        text_runs.append(\n            TextRun(\n                text=content,\n                family=run_family,\n                emphasis=run_emphasis,\n                size=run_size,\n                dx=run_dx,\n                dy=run_dy,\n                abs_x=abs_x,\n                abs_y=abs_y,\n                run_style=run_style,\n            )\n        )\n\n    # Leading text (before child <tspan>)\n    _add_run(\n        text_tag.text or \"\",\n        base_family,\n        base_emph,\n        base_size,\n        preserve=preserve_parent,\n        style_tag=None,\n        style_map_for_tag=None,\n    )\n\n    for child in text_tag:\n        if child.tag in xmlns_lookup(\"svg\", \"tspan\"):\n            child_local_style = self._style_map_for(child)\n            child_effective_style = dict(effective_style)\n            child_effective_style.update(child_local_style)\n            fam, emph, size, _anchor = _parse_font_attrs(\n                child, child_effective_style\n            )\n            run_font_size = size if size is not None else default_font_size\n            x, y, dx, dy = _parse_xy_delta(\n                child, child_effective_style, font_size=run_font_size\n            )\n\n            child_preserve = _preserve_ws(child_effective_style, child)\n            raw_itertext = \"\".join(child.itertext())\n            tail_text = child.tail or \"\"\n            if tail_text and raw_itertext.endswith(tail_text):\n                run_text = raw_itertext[: -len(tail_text)]\n            else:\n                run_text = raw_itertext\n            abs_x = None\n            abs_y = None\n            if \"x\" in child.attrib or (\n                child_local_style is not None and \"x\" in child_local_style\n            ):\n                abs_x = x\n            if \"y\" in child.attrib or (\n                child_local_style is not None and \"y\" in child_local_style\n            ):\n                abs_y = y\n\n            _add_run(\n                run_text,\n                fam,\n                emph,\n                size,\n                preserve=child_preserve,\n                dx_extra=dx,\n                dy_extra=dy,\n                abs_x=abs_x,\n                abs_y=abs_y,\n                style_tag=child,\n                style_map_for_tag=child_local_style,\n            )\n\n            # Text between tspans inherits parent style\n            _add_run(\n                child.tail or \"\",\n                base_family,\n                base_emph,\n                base_size,\n                preserve=preserve_parent,\n                style_tag=None,\n                style_map_for_tag=None,\n            )\n        else:\n            # other child tags are ignored (already logged elsewhere)\n            pass\n\n    if text_runs:\n        path.add_path_element(\n            Text(\n                x=anchor_x,\n                y=anchor_y,\n                text_runs=tuple(text_runs),\n                text_anchor=base_anchor,\n            ),\n            clone=False,\n        )\n\n    self.update_xref(text_tag.attrib.get(\"id\"), path)\n    return path",
      "language": "python"
    },
    {
      "code": "@force_nodocument\ndef build_xref(self, xref: \"Element\") -> GraphicsContext:\n    \"\"\"Resolve a cross-reference to an already-seen SVG element by ID.\"\"\"\n    style_map = self._style_map_for(xref)\n    pdf_group = GraphicsContext()\n    apply_styles(pdf_group, xref, style_map)\n\n    for candidate in xmlns_lookup(\"xlink\", \"href\", \"id\"):\n        try:\n            ref = xref.attrib[candidate]\n            break\n        except KeyError:\n            pass\n    else:\n        raise ValueError(f\"use {xref} doesn't contain known xref attribute\")\n\n    try:\n        pdf_group.add_item(self.cross_references[ref])\n    except KeyError:\n        raise ValueError(\n            f\"use {xref} references nonexistent ref id {ref}\"\n        ) from None\n\n    if \"x\" in xref.attrib or \"y\" in xref.attrib:\n        # Quoting the SVG spec - 5.6.2. Layout of re-used graphics:\n        # > The x and y properties define an additional transformation translate(x,y)\n        x, y = float(xref.attrib.get(\"x\", 0)), float(xref.attrib.get(\"y\", 0))\n        pdf_group.transform = Transform.translation(x=x, y=y)\n    # Note that we currently do not support \"width\" & \"height\" in <use>\n\n    return pdf_group",
      "language": "python"
    },
    {
      "code": "@force_nodocument\ndef convert_graphics(self, root_tag: \"Element\") -> None:\n    \"\"\"Convert the graphics contained in the SVG into the PDF representation.\"\"\"\n    base_group = GraphicsContext()\n    base_group.style.stroke_width = None\n    base_group.style.auto_close = False\n    base_group.style.stroke_cap_style = StrokeCapStyle.BUTT\n\n    self.build_group(root_tag, base_group)\n\n    self.base_group = base_group",
      "language": "python"
    },
    {
      "code": "def draw_to_page(\n    self,\n    pdf: \"FPDF\",\n    x: Optional[float] = None,\n    y: Optional[float] = None,\n    debug_stream: Optional[bool] = None,\n) -> None:\n    \"\"\"\n    Directly draw the converted SVG to the given PDF's current page.\n\n    The page viewport is used for sizing the SVG.\n\n    Args:\n        pdf (fpdf.fpdf.FPDF): the document to which the converted SVG is rendered.\n        x (Number): abscissa of the converted SVG's top-left corner.\n        y (Number): ordinate of the converted SVG's top-left corner.\n        debug_stream (io.TextIO): *DEPRECATED* the stream to which rendering debug info will be\n            written.\n    \"\"\"\n    self.image_cache = pdf.image_cache  # Needed to render images\n    _, _, path = self.transform_to_page_viewport(pdf)\n\n    old_x, old_y = pdf.x, pdf.y\n    try:\n        if x is not None and y is not None:\n            pdf.set_xy(0, 0)\n            assert path.transform is not None\n            path.transform = path.transform @ Transform.translation(x, y)\n\n        pdf.draw_path(path, debug_stream)\n\n    finally:\n        pdf.set_xy(old_x, old_y)",
      "language": "python"
    },
    {
      "code": "@force_nodocument\ndef extract_shape_info(self, root_tag: \"Element\") -> None:\n    \"\"\"Collect shape info from the given SVG.\"\"\"\n\n    width_str = root_tag.get(\"width\")\n    height_str = root_tag.get(\"height\")\n    viewbox = root_tag.get(\"viewBox\")\n    # we don't fully support this, just check for its existence\n    preserve_ar = root_tag.get(\"preserveAspectRatio\", True)\n    if preserve_ar == \"none\":\n        self.preserve_ar = None\n    else:\n        self.preserve_ar = True\n\n    self.width = None\n    if width_str is not None:\n        width_str.strip()\n        if width_str.endswith(\"%\"):\n            self.width = Percent(width_str[:-1])\n        else:\n            self.width = resolve_length(width_str)\n\n    self.height = None\n    if height_str is not None:\n        height_str.strip()\n        if height_str.endswith(\"%\"):\n            self.height = Percent(height_str[:-1])\n        else:\n            self.height = resolve_length(height_str)\n\n    if viewbox is None:\n        self.viewbox = None\n    else:\n        viewbox = viewbox.strip()\n        vx, vy, vw, vh = [float(num) for num in NUMBER_SPLIT.split(viewbox)]\n        if (vw < 0) or (vh < 0):\n            raise ValueError(f\"invalid negative width/height in viewbox {viewbox}\")\n\n        self.viewbox = [vx, vy, vw, vh]",
      "language": "python"
    },
    {
      "code": "@force_nodocument\ndef handle_defs(self, defs: \"Element\") -> None:\n    \"\"\"Produce lookups for groups and paths inside the <defs> tag\"\"\"\n    for child in defs:\n        if child.tag in xmlns_lookup(\"svg\", \"g\"):\n            self.build_group(child)\n        elif child.tag in xmlns_lookup(\"svg\", \"a\"):\n            # <a> tags aren't supported but we need to recurse into them to\n            # render nested elements.\n            LOGGER.warning(\n                \"Ignoring unsupported SVG tag: <a> (contributions are welcome to add support for it)\",\n            )\n            self.build_group(child)\n        elif child.tag in xmlns_lookup(\"svg\", \"path\"):\n            self.build_path(child)\n        elif child.tag in xmlns_lookup(\"svg\", \"image\"):\n            self.build_image(child)\n        elif child.tag in shape_tags:\n            self.build_shape(child)\n        elif child.tag in xmlns_lookup(\"svg\", \"linearGradient\"):\n            self._parse_linear_gradient(child)\n        elif child.tag in xmlns_lookup(\"svg\", \"radialGradient\"):\n            self._parse_radial_gradient(child)\n        elif child.tag in xmlns_lookup(\"svg\", \"clipPath\"):\n            try:\n                clip_id = child.attrib[\"id\"]\n            except KeyError:\n                clip_id = None\n            for child_ in child:\n                self.build_clipping_path(child_, clip_id)\n        elif child.tag in xmlns_lookup(\"svg\", \"style\"):\n            # Styles handled globally during parsing\n            continue\n        else:\n            LOGGER.warning(\n                \"Ignoring unsupported SVG tag: <%s> (contributions are welcome to add support for it)\",\n                without_ns(child.tag),\n            )",
      "language": "python"
    },
    {
      "code": "def transform_to_page_viewport(\n    self, pdf: \"FPDF\", align_viewbox: bool = True\n) -> tuple[float, float, GraphicsContext]:\n    \"\"\"\n    Size the converted SVG paths to the page viewport.\n\n    The SVG document size can be specified relative to the rendering viewport\n    (e.g. width=50%). If the converted SVG sizes are relative units, then this\n    computes the appropriate scale transform to size the SVG to the correct\n    dimensions for a page in the current PDF document.\n\n    If the SVG document size is specified in absolute units, then it is not scaled.\n\n    Args:\n        pdf (fpdf.fpdf.FPDF): the pdf to use the page size of.\n        align_viewbox (bool): if True, mimic some of the SVG alignment rules if the\n            viewbox aspect ratio does not match that of the viewport.\n\n    Returns:\n        The same thing as `SVGObject.transform_to_rect_viewport`.\n    \"\"\"\n\n    return self.transform_to_rect_viewport(pdf.k, pdf.epw, pdf.eph, align_viewbox)",
      "language": "python"
    },
    {
      "code": "def transform_to_rect_viewport(\n    self,\n    scale: float,\n    width: float | Percent,\n    height: float | Percent,\n    align_viewbox: bool = True,\n    ignore_svg_top_attrs: bool = False,\n) -> tuple[float, float, GraphicsContext]:\n    \"\"\"\n    Size the converted SVG paths to an arbitrarily sized viewport.\n\n    The SVG document size can be specified relative to the rendering viewport\n    (e.g. width=50%). If the converted SVG sizes are relative units, then this\n    computes the appropriate scale transform to size the SVG to the correct\n    dimensions for a page in the current PDF document.\n\n    Args:\n        scale (Number): the scale factor from document units to PDF points.\n        width (Number): the width of the viewport to scale to in document units.\n        height (Number): the height of the viewport to scale to in document units.\n        align_viewbox (bool): if True, mimic some of the SVG alignment rules if the\n            viewbox aspect ratio does not match that of the viewport.\n        ignore_svg_top_attrs (bool): ignore <svg> top attributes like \"width\", \"height\"\n            or \"preserveAspectRatio\" when figuring the image dimensions.\n            Require width & height to be provided as parameters.\n\n    Returns:\n        A tuple of (width, height, `fpdf.drawing.GraphicsContext`), where width and\n        height are the resolved width and height (they may be 0. If 0, the returned\n        `fpdf.drawing.GraphicsContext` will be empty). The\n        `fpdf.drawing.GraphicsContext` contains all of the paths that were\n        converted from the SVG, scaled to the given viewport size.\n    \"\"\"\n    vp_width: float\n    vp_height: float\n\n    if ignore_svg_top_attrs:\n        # width/height may be Percent when passed from FPDF.image; resolve to float\n        if isinstance(width, Percent):\n            vp_width = float(width)\n        else:\n            vp_width = float(width)\n    elif isinstance(self.width, Percent):\n        if not width:\n            raise ValueError(\n                'SVG \"width\" is a percentage, hence a viewport width is required'\n            )\n        vp_width = self.width * width / 100\n    else:\n        vp_width = self.width or width\n\n    if ignore_svg_top_attrs:\n        if isinstance(height, Percent):\n            vp_height = float(height)\n        else:\n            vp_height = float(height)\n    elif isinstance(self.height, Percent):\n        if not height:\n            raise ValueError(\n                'SVG \"height\" is a percentage, hence a viewport height is required'\n            )\n        vp_height = self.height * height / 100\n    else:\n        vp_height = self.height or height\n\n    if scale == 1:\n        transform = Transform.identity()\n    else:\n        transform = Transform.scaling(1 / scale)\n\n    if self.viewbox:\n        vx, vy, vw, vh = self.viewbox\n\n        if (vw == 0) or (vh == 0):\n            return 0, 0, GraphicsContext()\n\n        w_ratio = vp_width / vw\n        h_ratio = vp_height / vh\n\n        if not ignore_svg_top_attrs and self.preserve_ar and (w_ratio != h_ratio):\n            w_ratio = h_ratio = min(w_ratio, h_ratio)\n\n        transform = (\n            transform\n            @ Transform.translation(x=-vx, y=-vy)\n            @ Transform.scaling(x=w_ratio, y=h_ratio)\n        )\n\n        if align_viewbox:\n            transform = transform @ Transform.translation(\n                x=vp_width / 2 - (vw / 2) * w_ratio,\n                y=vp_height / 2 - (vh / 2) * h_ratio,\n            )\n\n    self.base_group.transform = transform\n\n    return vp_width / scale, vp_height / scale, self.base_group",
      "language": "python"
    },
    {
      "code": "@force_nodocument\ndef update_xref(self, key: Optional[str], referenced: Any) -> None:\n    if key:\n        key = \"#\" + key if not key.startswith(\"#\") else key\n        self.cross_references[key] = referenced",
      "language": "python"
    },
    {
      "code": "@force_nodocument\nclass ShapeBuilder:\n    \"\"\"A namespace within which methods for converting basic shapes can be looked up.\"\"\"\n\n    @staticmethod\n    def new_path(tag: \"Element\", clipping_path: bool = False) -> PaintedPath:\n        \"\"\"Create a new path with the appropriate styles.\"\"\"\n        path = PaintedPath()\n        if clipping_path:\n            path = ClippingPath()\n        apply_styles(path, tag)\n        return path\n\n    @classmethod\n    def rect(cls, tag: \"Element\", clipping_path: bool = False) -> PaintedPath:\n        \"\"\"Convert an SVG <rect> into a PDF path.\"\"\"\n        # svg rect is wound clockwise\n        x = resolve_length(tag.attrib.get(\"x\", \"0\"))\n        y = resolve_length(tag.attrib.get(\"y\", \"0\"))\n        width_str = tag.attrib.get(\"width\") or \"0\"\n        if width_str.endswith(\"%\"):\n            width: Percent | float = Percent(width_str[:-1])\n        else:\n            width = resolve_length(width_str)\n        height_str = tag.attrib.get(\"height\") or \"0\"\n        if height_str.endswith(\"%\"):\n            height: Percent | float = Percent(height_str[:-1])\n        else:\n            height = resolve_length(height_str)\n        rx_str = tag.attrib.get(\"rx\") or \"auto\"\n        ry_str = tag.attrib.get(\"ry\") or \"auto\"\n\n        if rx_str == \"none\":\n            rx_str = \"0\"\n        if ry_str == \"none\":\n            ry_str = \"0\"\n\n        rx: float\n        ry: float\n\n        if rx_str == ry_str == \"auto\":\n            rx = ry = 0\n        elif rx_str == \"auto\":\n            rx = ry = float(ry_str)\n        elif ry_str == \"auto\":\n            ry = rx = float(rx_str)\n        else:\n            rx = float(rx_str)\n            ry = float(ry_str)\n\n        if (width < 0) or (height < 0) or (rx < 0) or (ry < 0):\n            raise ValueError(f\"bad rect {tag}\")\n\n        if (width == 0) or (height == 0):\n            return PaintedPath()\n\n        if rx > (width / 2):\n            rx = width / 2\n        if ry > (height / 2):\n            ry = height / 2\n\n        path = cls.new_path(tag, clipping_path)\n        path.rectangle(x, y, width, height, rx, ry)\n        return path\n\n    @classmethod\n    def circle(cls, tag: \"Element\", clipping_path: bool = False) -> PaintedPath:\n        \"\"\"Convert an SVG <circle> into a PDF path.\"\"\"\n        cx = float(tag.attrib.get(\"cx\", 0))\n        cy = float(tag.attrib.get(\"cy\", 0))\n        r = float(tag.attrib[\"r\"])\n\n        path = cls.new_path(tag, clipping_path)\n        path.circle(cx, cy, r)\n        return path\n\n    @classmethod\n    def ellipse(cls, tag: \"Element\", clipping_path: bool = False) -> PaintedPath:\n        \"\"\"Convert an SVG <ellipse> into a PDF path.\"\"\"\n        cx = float(tag.attrib.get(\"cx\", 0))\n        cy = float(tag.attrib.get(\"cy\", 0))\n\n        rx_str = tag.attrib.get(\"rx\") or \"auto\"\n        ry_str = tag.attrib.get(\"ry\") or \"auto\"\n\n        path = cls.new_path(tag, clipping_path)\n\n        if (rx_str == ry_str == \"auto\") or (rx_str == \"0\") or (ry_str == \"0\"):\n            return path\n\n        if rx_str == \"auto\":\n            rx = ry = float(ry_str)\n        elif ry_str == \"auto\":\n            rx = ry = float(rx_str)\n        else:\n            rx = float(rx_str)\n            ry = float(ry_str)\n\n        path.ellipse(cx, cy, rx, ry)\n        return path\n\n    @classmethod\n    def line(cls, tag: \"Element\") -> PaintedPath:\n        \"\"\"Convert an SVG <line> into a PDF path.\"\"\"\n        x1 = float(tag.attrib[\"x1\"])\n        y1 = float(tag.attrib[\"y1\"])\n        x2 = float(tag.attrib[\"x2\"])\n        y2 = float(tag.attrib[\"y2\"])\n\n        path = cls.new_path(tag)\n        path.move_to(x1, y1)\n        path.line_to(x2, y2)\n        return path\n\n    @classmethod\n    def polyline(cls, tag: \"Element\") -> PaintedPath:\n        \"\"\"Convert an SVG <polyline> into a PDF path.\"\"\"\n        path = cls.new_path(tag)\n        points = \"M\" + tag.attrib[\"points\"]\n        svg_path_converter(path, points)\n        return path\n\n    @classmethod\n    def polygon(cls, tag: \"Element\", clipping_path: bool = False) -> PaintedPath:\n        \"\"\"Convert an SVG <polygon> into a PDF path.\"\"\"\n        path = cls.new_path(tag, clipping_path)\n        points = \"M\" + tag.attrib[\"points\"] + \"Z\"\n        svg_path_converter(path, points)\n        return path",
      "language": "python"
    },
    {
      "code": "@staticmethod\ndef new_path(tag: \"Element\", clipping_path: bool = False) -> PaintedPath:\n    \"\"\"Create a new path with the appropriate styles.\"\"\"\n    path = PaintedPath()\n    if clipping_path:\n        path = ClippingPath()\n    apply_styles(path, tag)\n    return path",
      "language": "python"
    }
  ],
  "patterns": [],
  "links": [
    "https://py-pdf.github.io/fpdf2/SVG.html",
    "https://py-pdf.github.io/fpdf2/fpdf/drawing.html",
    "https://py-pdf.github.io/fpdf2/fpdf/drawing_primitives.html",
    "https://py-pdf.github.io/fpdf2/fpdf/svg.html",
    "https://py-pdf.github.io/fpdf2/fpdf/image_datastructures.html",
    "https://py-pdf.github.io/fpdf2/fpdf/fpdf.html",
    "https://py-pdf.github.io/fpdf2/fpdf/index.html"
  ]
}