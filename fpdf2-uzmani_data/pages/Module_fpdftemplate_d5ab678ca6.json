{
  "url": "https://py-pdf.github.io/fpdf2/fpdf/template.html",
  "title": "Module fpdf.template",
  "content": "PDF template helpers for fpdf2.\n\nUsage documentation at: https://py-pdf.github.io/fpdf2/Templates.html\n\nA flexible templating class.\n\nAllows to apply one or several template definitions to any page of a document in any combination.\n\nUsage documentation at: https://py-pdf.github.io/fpdf2/Templates.html\n\nLoad a template definition.\n\nLoad the template definition from a CSV file.\n\nLoad the template definition from a JSON file. The data must be structured as an array of objects, with names and values exactly equivalent to what would get supplied to load_elements(),\n\nAdd the contents of the template to the PDF document.\n\nSplit a string between words, for the parts to fit into a given element width. Additional splits will be made replacing any '\\n' characters.\n\nA list of substrings, each of which will fit into the element width when rendered in the element font style and size.\n\nA simple templating class.\n\nAllows to apply a single template definition to all pages of a document.\n\nUsage documentation at: https://py-pdf.github.io/fpdf2/Templates.html\n\nFinish the current page, and proceed to the next one.\n\nInherited from: FlexTemplate.load_elements\n\nLoad a template definition …\n\nInherited from: FlexTemplate.parse_csv\n\nLoad the template definition from a CSV file …\n\nInherited from: FlexTemplate.parse_json\n\nLoad the template definition from a JSON file. The data must be structured as an array of objects, with names and values exactly equivalent to what …\n\nFinish the document and process all pending data.\n\nInherited from: FlexTemplate.split_multicell\n\nSplit a string between words, for the parts to fit into a given element width. Additional splits will be made replacing any '\\n' characters …",
  "headings": [
    {
      "level": "h1",
      "text": "Module fpdf.template",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Classes",
      "id": "header-classes"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h3",
      "text": "Subclasses",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Returns",
      "id": "returns"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    }
  ],
  "code_samples": [
    {
      "code": "class FlexTemplate:\n    \"\"\"\n    A flexible templating class.\n\n    Allows to apply one or several template definitions to any page of\n    a document in any combination.\n\n    Usage documentation at: <https://py-pdf.github.io/fpdf2/Templates.html>\n    \"\"\"\n\n    def __init__(\n        self, pdf: FPDF, elements: Optional[Sequence[dict[str, Any]]] = None\n    ) -> None:\n        \"\"\"\n        Args:\n            pdf (fpdf.fpdf.FPDF): All content will be added to this `FPDF` instance.\n            elements (list[dict]): A template definition in a list of dicts.\n                If you omit this, then you need to call either load_elements()\n                or parse_csv() before doing anything else.\n        \"\"\"\n        if not isinstance(pdf, FPDF):\n            raise TypeError(\"'pdf' must be an instance of fpdf.FPDF()\")\n        self.pdf = pdf\n        self.splitting_pdf: Optional[FPDF] = None  # for split_multicell()\n        if elements:\n            self.load_elements(elements)\n        self.handlers = {\n            \"T\": self._text,\n            \"L\": self._line,\n            \"I\": self._image,\n            \"B\": self._rect,\n            \"E\": self._ellipse,\n            \"BC\": self._barcode,\n            \"C39\": self._code39,\n            \"W\": self._write,\n        }\n        self.texts: dict[str, Any] = {}\n\n    def load_elements(self, elements: Sequence[dict[str, Any]]) -> None:\n        \"\"\"\n        Load a template definition.\n\n        Args:\n            elements (list of dicts): A template definition in a list of dicts\n        \"\"\"\n        key_config = {\n            # key: type\n            \"name\": (str, type(None)),\n            \"type\": (str, type(None)),\n            \"x1\": (int, float),\n            \"y1\": (int, float),\n            \"x2\": (int, float),\n            \"y2\": (int, float),\n            \"font\": (str, type(None)),\n            \"size\": (int, float),\n            \"bold\": object,  # \"bool or equivalent\"\n            \"italic\": object,\n            \"underline\": object,\n            \"foreground\": int,\n            \"background\": int,\n            \"align\": (str, type(None)),\n            \"text\": (str, type(None)),\n            \"priority\": int,\n            \"multiline\": (bool, type(None)),\n            \"rotate\": (int, float),\n            \"wrapmode\": (str, type(None)),\n            \"dash_pattern\": (dict, type(None)),\n        }\n\n        self.elements: Sequence[dict[str, Any]] = elements\n        self.keys: list[str] = []\n        for e in elements:\n            # priority is optional, but we need a default for sorting.\n            if not \"priority\" in e:\n                e[\"priority\"] = 0\n            for k in (\"name\", \"type\", \"x1\", \"y1\", \"y2\"):\n                if k not in e:\n                    if e[\"type\"] == \"C39\":\n                        # lots of legacy special casing.\n                        # We need to do that here, so that rotation and scaling\n                        # still work.\n                        if k == \"x1\" and \"x\" in e:\n                            e[\"x1\"] = e[\"x\"]\n                            continue\n                        if k == \"y1\" and \"y\" in e:\n                            e[\"y1\"] = e[\"y\"]\n                            continue\n                        if k == \"y2\" and \"h\" in e:\n                            e[\"y2\"] = e[\"y1\"] + e[\"h\"]\n                            continue\n                    raise KeyError(f\"Mandatory key '{k}' missing in input data\")\n            # x2 is optional for barcode types, but needed for offset rendering\n            if \"x2\" not in e:\n                if e[\"type\"] in [\"BC\", \"C39\"]:\n                    e[\"x2\"] = 0\n                else:\n                    raise KeyError(\"Mandatory key 'x2' missing in input data\")\n            if not \"size\" in e and e[\"type\"] == \"C39\":\n                if \"w\" in e:\n                    e[\"size\"] = e[\"w\"]\n            if \"dash_pattern\" in e:\n                for k in e[\"dash_pattern\"].keys():\n                    if k not in (\"dash\", \"gap\", \"phase\"):\n                        raise KeyError(f\"Invalid key '{k}' in dash_pattern\")\n                if \"dash\" not in e[\"dash_pattern\"]:\n                    e[\"dash_pattern\"][\"dash\"] = 0\n                if \"gap\" not in e[\"dash_pattern\"]:\n                    e[\"dash_pattern\"][\"gap\"] = e[\"dash_pattern\"][\"dash\"]\n                if \"phase\" not in e[\"dash_pattern\"]:\n                    e[\"dash_pattern\"][\"phase\"] = 0\n\n            for k, t in key_config.items():\n                if k in e and not isinstance(e[k], t):  # type: ignore[arg-type]\n                    ttype = (\n                        t.__name__\n                        if isinstance(t, type)\n                        else \" or \".join([f\"'{x.__name__}'\" for x in t])  # type: ignore[attr-defined]\n                    )\n                    raise TypeError(\n                        f\"Value of element item '{k}' must be {ttype}, not '{type(e[k]).__name__}'.\"\n                    )\n            self.keys.append(e[\"name\"].lower())\n\n    @staticmethod\n    def _parse_colorcode(s: str) -> int:\n        \"\"\"Allow hex and oct values for colors\"\"\"\n        if s[:2] in [\"0x\", \"0X\"]:\n            return int(s, 16)\n        if s[0] == \"0\":\n            return int(s, 8)\n        return int(s)\n\n    @staticmethod\n    def _parse_multiline(s: str) -> Optional[bool]:\n        i = int(s)\n        if i > 0:\n            return True\n        if i < 0:\n            return False\n        return None\n\n    def parse_json(self, infile: os.PathLike[str], encoding: str = \"utf-8\") -> None:\n        \"\"\"\n        Load the template definition from a JSON file.\n        The data must be structured as an array of objects, with names and values exactly\n        equivalent to what would get supplied to load_elements(),\n\n        Args:\n            infile (str, path-like object): The filepath of the JSON file.\n            encoding (str): The character encoding of the file. Default is UTF-8.\n        \"\"\"\n        with open(infile, encoding=encoding) as f:\n            data = json.load(f)\n            for d in data:\n                fgval = d.get(\"foreground\")\n                if fgval and isinstance(fgval, str):\n                    if fgval.lower().startswith(\"#\"):\n                        d[\"foreground\"] = int(fgval[1:], 16)\n                    else:\n                        raise ValueError(\n                            \"If foreground is a string, it must have the form '#rrggbb'.\"\n                        )\n                bgval = d.get(\"background\")\n                if bgval and isinstance(bgval, str):\n                    if bgval.lower().startswith(\"#\"):\n                        d[\"background\"] = int(bgval[1:], 16)\n                    else:\n                        raise ValueError(\n                            \"If background is a string, it must have the form '#rrggbb'.\"\n                        )\n            self.load_elements(data)\n\n    def parse_csv(\n        self,\n        infile: os.PathLike[str],\n        delimiter: str = \",\",\n        decimal_sep: str = \".\",\n        encoding: Optional[str] = None,\n    ) -> None:\n        \"\"\"\n        Load the template definition from a CSV file.\n\n        Args:\n            infile (str, path-like object): The filepath of the CSV file.\n            delimiter (str): The character that separates the fields in the CSV file:\n                Usually a comma, semicolon, or tab.\n            decimal_sep (str): The decimal separator used in the file.\n                Usually either a point or a comma.\n            encoding (str): The character encoding of the file.\n                Default is the system default encoding.\n        \"\"\"\n\n        def _varsep_float(s: str, default: str = \"0\") -> float:\n            \"\"\"Convert to float with given decimal separator\"\"\"\n            # glad to have nonlocal scoping...\n            return float((s.strip() or default).replace(decimal_sep, \".\"))\n\n        key_config = (\n            # key, converter, mandatory\n            (\"name\", str, True),\n            (\"type\", str, True),\n            (\"x1\", _varsep_float, True),\n            (\"y1\", _varsep_float, True),\n            (\"x2\", _varsep_float, True),\n            (\"y2\", _varsep_float, True),\n            (\"font\", str, False),\n            (\"size\", _varsep_float, False),\n            (\"bold\", int, False),\n            (\"italic\", int, False),\n            (\"underline\", int, False),\n            (\"foreground\", self._parse_colorcode, False),\n            (\"background\", self._parse_colorcode, False),\n            (\"align\", str, False),\n            (\"text\", str, False),\n            (\"priority\", int, False),\n            (\"multiline\", self._parse_multiline, False),\n            (\"rotate\", _varsep_float, False),\n            (\"wrapmode\", str, False),\n        )\n        self.elements = []\n        if encoding is None:\n            encoding = locale.getpreferredencoding()\n        with open(infile, encoding=encoding) as f:\n            for row in csv.reader(f, delimiter=delimiter):\n                # fill in blanks for any missing items\n                row.extend([\"\"] * (len(key_config) - len(row)))\n                kargs: dict[str, Any] = {}\n                for val, cfg in zip(row, key_config):\n                    vs = val.strip()\n                    if not vs:\n                        if cfg[2]:  # mandatory\n                            if cfg[0] == \"x2\" and row[1] in [\"BC\", \"C39\"]:\n                                # two types don't need x2, but offset rendering does\n                                pass\n                            else:\n                                raise FPDFException(\n                                    f\"Mandatory value '{cfg[0]}' missing in csv data\"\n                                )\n                        elif cfg[0] == \"priority\":\n                            # formally optional, but we need some value for sorting\n                            kargs[\"priority\"] = 0\n                        # otherwise, let the type handlers use their own defaults\n                    else:\n                        kargs[cfg[0]] = cfg[1](vs)  # type: ignore[operator]\n                self.elements.append(kargs)\n        self.keys = [val[\"name\"].lower() for val in self.elements]\n\n    def __setitem__(self, name: str, value: Any) -> None:\n        assert isinstance(\n            name, str\n        ), f\"name must be of type 'str', not '{type(name).__name__}'.\"\n        # value has too many valid types to reasonably check here\n        if name.lower() not in self.keys:\n            raise FPDFException(f\"Element not loaded, cannot set item: {name}\")\n        self.texts[name.lower()] = value\n\n    # setitem shortcut (may be further extended)\n    set = __setitem__\n\n    def __contains__(self, name: str) -> bool:\n        assert isinstance(\n            name, str\n        ), f\"name must be of type 'str', not '{type(name).__name__}'.\"\n        return name.lower() in self.keys\n\n    def __getitem__(self, name: str) -> Any:\n        assert isinstance(\n            name, str\n        ), f\"name must be of type 'str', not '{type(name).__name__}'.\"\n        if name not in self.keys:\n            raise KeyError(name)\n        key = name.lower()\n        if key in self.texts:\n            # text for this page:\n            return self.texts[key]\n        # find first element for default text:\n        return next(\n            (x[\"text\"] for x in self.elements if x[\"name\"].lower() == key), None\n        )\n\n    def split_multicell(self, text: str, element_name: str) -> list[str]:\n        \"\"\"\n        Split a string between words, for the parts to fit into a given element\n        width. Additional splits will be made replacing any '\\\\n' characters.\n\n        Args:\n            text (str): The input text string.\n            element_name (str): The name of the template element to fit the text inside.\n\n        Returns:\n            A list of substrings, each of which will fit into the element width\n            when rendered in the element font style and size.\n        \"\"\"\n        element = next(\n            element\n            for element in self.elements\n            if element[\"name\"].lower() == element_name.lower()\n        )\n        if not self.splitting_pdf:\n            self.splitting_pdf = FPDF()\n            self.splitting_pdf.add_page()\n        assert self.splitting_pdf is not None\n        style = \"\"\n        if element.get(\"bold\"):\n            style += \"B\"\n        if element.get(\"italic\"):\n            style += \"I\"\n        if element.get(\"underline\"):\n            style += \"U\"\n        self.splitting_pdf.set_font(element[\"font\"], style, element[\"size\"])\n        return self.splitting_pdf.multi_cell(  # type: ignore[return-value]\n            w=element[\"x2\"] - element[\"x1\"],\n            h=element[\"y2\"] - element[\"y1\"],\n            text=str(text),\n            align=element.get(\"align\", \"\"),\n            dry_run=True,\n            output=\"LINES\",\n            wrapmode=element.get(\"wrapmode\", \"WORD\"),\n        )\n\n    def _text(\n        self,\n        *_: Any,\n        x1: float = 0,\n        y1: float = 0,\n        x2: float = 0,\n        y2: float = 0,\n        text: str = \"\",\n        font: str = \"helvetica\",\n        size: float = 10,\n        scale: float = 1.0,\n        bold: bool = False,\n        italic: bool = False,\n        underline: bool = False,\n        align: str = \"\",\n        foreground: int = 0,\n        background: Optional[int] = None,\n        multiline: Optional[bool] = None,\n        wrapmode: str = \"WORD\",\n        **__: Any,\n    ) -> None:\n        if not text:\n            return\n        pdf = self.pdf\n        if pdf.text_color != _rgb_as_str(foreground):  # type: ignore[comparison-overlap]\n            pdf.set_text_color(*_rgb(foreground))\n        if background is None:\n            fill = False\n        else:\n            fill = True\n            if pdf.fill_color != _rgb_as_str(background):  # type: ignore[comparison-overlap]\n                pdf.set_fill_color(*_rgb(background))\n\n        font = font.strip().lower()\n        style = \"\"\n        for tag in \"B\", \"I\", \"U\":\n            if text.startswith(f\"<{tag}>\") and text.endswith(f\"</{tag}>\"):\n                text = text[3:-4]\n                style += tag\n        if bold:\n            style += \"B\"\n        if italic:\n            style += \"I\"\n        if underline:\n            style += \"U\"\n        pdf.set_font(font, style, size * scale)\n        pdf.set_xy(x1, y1)\n        width, height = x2 - x1, y2 - y1\n        if multiline is None:  # write without wrapping/trimming (default)\n            pdf.cell(w=width, h=height, text=text, border=0, align=align, fill=fill)\n        elif multiline:  # automatic word - warp\n            pdf.multi_cell(\n                w=width,\n                h=height,\n                text=text,\n                border=0,\n                align=align,\n                fill=fill,\n                wrapmode=WrapMode.coerce(wrapmode),\n            )\n        else:  # trim to fit exactly the space defined\n            text = pdf.multi_cell(  # type: ignore[index,assignment]\n                w=width,\n                h=height,\n                text=text,\n                align=align,\n                wrapmode=WrapMode.coerce(wrapmode),\n                dry_run=True,\n                output=\"LINES\",\n            )[0]\n            pdf.cell(w=width, h=height, text=text, border=0, align=align, fill=fill)\n\n    def _line(\n        self,\n        *_: Any,\n        x1: float = 0,\n        y1: float = 0,\n        x2: float = 0,\n        y2: float = 0,\n        size: float = 0,\n        scale: float = 1.0,\n        foreground: int = 0,\n        dash_pattern: Optional[tuple[float, float, float]] = None,\n        **__: Any,\n    ) -> None:\n        assert self.pdf.draw_color is not None\n        if self.pdf.draw_color.serialize().lower() != _rgb_as_str(foreground):\n            self.pdf.set_draw_color(*_rgb(foreground))\n        self.pdf.set_line_width(size * scale)\n        if dash_pattern is not None:\n            # Save dash_pattern to restore after this line\n            restore_dash_pattern = self.pdf.dash_pattern\n            if isinstance(dash_pattern, dict):\n                self.pdf.set_dash_pattern(\n                    dash_pattern.get(  # pyright: ignore[reportUnknownMemberType, reportUnknownArgumentType]\n                        \"dash\", 0\n                    ),\n                    dash_pattern.get(  # pyright: ignore[reportUnknownMemberType, reportUnknownArgumentType]\n                        \"gap\", 0\n                    ),\n                    dash_pattern.get(  # pyright: ignore[reportUnknownMemberType, reportUnknownArgumentType]\n                        \"phase\", 0\n                    ),\n                )\n            else:\n                self.pdf.set_dash_pattern(\n                    dash_pattern[0], dash_pattern[1], dash_pattern[2]\n                )\n        self.pdf.line(x1, y1, x2, y2)\n        if dash_pattern is not None:\n            self.pdf.set_dash_pattern(\n                **restore_dash_pattern  # pyright: ignore[reportPossiblyUnboundVariable]\n            )\n\n    def _rect(\n        self,\n        *_: Any,\n        x1: float = 0,\n        y1: float = 0,\n        x2: float = 0,\n        y2: float = 0,\n        size: float = 0,\n        scale: float = 1.0,\n        foreground: int = 0,\n        background: Optional[int] = None,\n        dash_pattern: Optional[tuple[float, float, float]] = None,\n        **__: Any,\n    ) -> None:\n        pdf = self.pdf\n        assert pdf.draw_color is not None\n        if pdf.draw_color.serialize().lower() != _rgb_as_str(foreground):\n            pdf.set_draw_color(*_rgb(foreground))\n        if background is None:\n            style = \"D\"\n        else:\n            style = \"FD\"\n            if pdf.fill_color != _rgb_as_str(background):  # type: ignore[comparison-overlap]\n                pdf.set_fill_color(*_rgb(background))\n        pdf.set_line_width(size * scale)\n        if dash_pattern is not None:\n            # Save dash_pattern to restore after this rect\n            restore_dash_pattern = self.pdf.dash_pattern\n            if isinstance(dash_pattern, dict):\n                pdf.set_dash_pattern(\n                    dash_pattern.get(  # pyright: ignore[reportUnknownMemberType, reportUnknownArgumentType]\n                        \"dash\", 0\n                    ),\n                    dash_pattern.get(  # pyright: ignore[reportUnknownMemberType, reportUnknownArgumentType]\n                        \"gap\", 0\n                    ),\n                    dash_pattern.get(  # pyright: ignore[reportUnknownMemberType, reportUnknownArgumentType]\n                        \"phase\", 0\n                    ),\n                )\n            else:\n                pdf.set_dash_pattern(dash_pattern[0], dash_pattern[1], dash_pattern[2])\n        pdf.rect(x1, y1, x2 - x1, y2 - y1, style=style)\n        if dash_pattern is not None:\n            self.pdf.set_dash_pattern(\n                **restore_dash_pattern  # pyright: ignore[reportPossiblyUnboundVariable]\n            )\n\n    def _ellipse(\n        self,\n        *_: Any,\n        x1: float = 0,\n        y1: float = 0,\n        x2: float = 0,\n        y2: float = 0,\n        size: float = 0,\n        scale: float = 1.0,\n        foreground: int = 0,\n        background: Optional[int] = None,\n        dash_pattern: Optional[tuple[float, float, float]] = None,\n        **__: Any,\n    ) -> None:\n        pdf = self.pdf\n        assert pdf.draw_color is not None\n        if pdf.draw_color.serialize().lower() != _rgb_as_str(foreground):\n            pdf.set_draw_color(*_rgb(foreground))\n        if background is None:\n            style = \"D\"\n        else:\n            style = \"FD\"\n            if pdf.fill_color != _rgb_as_str(background):  # type: ignore[comparison-overlap]\n                pdf.set_fill_color(*_rgb(background))\n        pdf.set_line_width(size * scale)\n        if dash_pattern is not None:\n            # Save dash_pattern to restore after this ellipse\n            restore_dash_pattern = self.pdf.dash_pattern\n            if isinstance(dash_pattern, dict):\n                pdf.set_dash_pattern(\n                    dash_pattern.get(  # pyright: ignore[reportUnknownMemberType, reportUnknownArgumentType]\n                        \"dash\", 0\n                    ),\n                    dash_pattern.get(  # pyright: ignore[reportUnknownMemberType, reportUnknownArgumentType]\n                        \"gap\", 0\n                    ),\n                    dash_pattern.get(  # pyright: ignore[reportUnknownMemberType, reportUnknownArgumentType]\n                        \"phase\", 0\n                    ),\n                )\n            else:\n                pdf.set_dash_pattern(dash_pattern[0], dash_pattern[1], dash_pattern[2])\n        pdf.ellipse(x1, y1, x2 - x1, y2 - y1, style=style)\n        if dash_pattern is not None:\n            self.pdf.set_dash_pattern(\n                **restore_dash_pattern  # pyright: ignore[reportPossiblyUnboundVariable]\n            )\n\n    def _image(\n        self,\n        *_: Any,\n        x1: float = 0,\n        y1: float = 0,\n        x2: float = 0,\n        y2: float = 0,\n        text: str = \"\",\n        **__: Any,\n    ) -> None:\n        if text:\n            self.pdf.image(text, x1, y1, w=x2 - x1, h=y2 - y1, link=\"\")\n\n    def _barcode(\n        self,\n        *_: Any,\n        x1: float = 0,\n        y1: float = 0,\n        x2: float = 0,\n        y2: float = 0,\n        text: str = \"\",\n        font: str = \"interleaved 2of5 nt\",\n        size: float = 1,\n        scale: float = 1.0,\n        foreground: int = 0,\n        **__: Any,\n    ) -> None:\n        # pylint: disable=unused-argument\n        pdf = self.pdf\n        assert pdf.fill_color is not None\n        if pdf.fill_color.serialize().lower() != _rgb_as_str(foreground):\n            pdf.set_fill_color(*_rgb(foreground))\n        font = font.lower().strip()\n        if font == \"interleaved 2of5 nt\":\n            pdf.interleaved2of5(text, x1, y1, w=size * scale, h=y2 - y1)\n\n    def _code39(\n        self,\n        *_: Any,\n        x1: float = 0,\n        y1: float = 0,\n        y2: float = 0,\n        text: str = \"\",\n        size: float = 1.5,\n        scale: float = 1.0,\n        foreground: int = 0,\n        x: Optional[float] = None,\n        y: Optional[float] = None,\n        w: Optional[float] = None,\n        h: Optional[float] = None,\n        **__: Any,\n    ) -> None:\n        if x is not None or y is not None or w is not None or h is not None:\n            warnings.warn(\n                (\n                    \"code39 arguments x/y/w/h are deprecated since v2.4.4,\"\n                    \" please use x1/y1/y2/size instead\"\n                ),\n                DeprecationWarning,\n                stacklevel=get_stack_level(),\n            )\n        pdf = self.pdf\n        assert pdf.fill_color is not None\n        if pdf.fill_color.serialize().lower() != _rgb_as_str(foreground):\n            pdf.set_fill_color(*_rgb(foreground))\n        h = y2 - y1\n        if h <= 0:\n            h = 5\n        pdf.code39(text, x1, y1, size * scale, h)\n\n    # Added by Derek Schwalenberg Schwalenberg1013@gmail.com to allow (url) links in\n    # templates (using write method) 2014-02-22\n    def _write(\n        self,\n        *_: Any,\n        x1: float = 0,\n        y1: float = 0,\n        x2: float = 0,\n        y2: float = 0,\n        text: str = \"\",\n        font: str = \"helvetica\",\n        size: float = 10,\n        scale: float = 1.0,\n        bold: bool = False,\n        italic: bool = False,\n        underline: bool = False,\n        link: Optional[int | str] = \"\",\n        foreground: int = 0,\n        **__: Any,\n    ) -> None:\n        # pylint: disable=unused-argument\n        if not text:\n            return\n        pdf = self.pdf\n        if pdf.text_color != _rgb_as_str(foreground):  # type: ignore[comparison-overlap]\n            pdf.set_text_color(*_rgb(foreground))\n        font = font.strip().lower()\n        style = \"\"\n        for tag in \"B\", \"I\", \"U\":\n            if text.startswith(f\"<{tag}>\") and text.endswith(f\"</{tag}>\"):\n                text = text[3:-4]\n                style += tag\n        if bold:\n            style += \"B\"\n        if italic:\n            style += \"I\"\n        if underline:\n            style += \"U\"\n        pdf.set_font(font, style, size * scale)\n        pdf.set_xy(x1, y1)\n        pdf.write(5, text, link)\n\n    def render(\n        self,\n        offsetx: float = 0.0,\n        offsety: float = 0.0,\n        rotate: float = 0.0,\n        scale: float = 1.0,\n    ) -> None:\n        \"\"\"\n        Add the contents of the template to the PDF document.\n\n        Args:\n            offsetx, offsety (float): Place the template to move its origin to the given coordinates.\n            rotate (float): Rotate the inserted template around its (offset) origin.\n            scale (float): Scale the inserted template by this factor.\n        \"\"\"\n        sorted_elements = sorted(self.elements, key=lambda x: x[\"priority\"])\n        with self.pdf.local_context():\n            for element in sorted_elements:\n                ele = element.copy()  # don't want to modify the callers original\n                ele[\"text\"] = self.texts.get(ele[\"name\"].lower(), ele.get(\"text\", \"\"))\n                if scale != 1.0:\n                    ele[\"x1\"] = ele[\"x1\"] * scale\n                    ele[\"y1\"] = ele[\"y1\"] * scale\n                    ele[\"x2\"] = ele[\"x1\"] + ((ele[\"x2\"] - element[\"x1\"]) * scale)\n                    ele[\"y2\"] = ele[\"y1\"] + ((ele[\"y2\"] - element[\"y1\"]) * scale)\n                if offsetx:\n                    ele[\"x1\"] = ele[\"x1\"] + offsetx\n                    ele[\"x2\"] = ele[\"x2\"] + offsetx\n                if offsety:\n                    ele[\"y1\"] = ele[\"y1\"] + offsety\n                    ele[\"y2\"] = ele[\"y2\"] + offsety\n                ele[\"scale\"] = scale\n                handler_name = ele[\"type\"].upper()\n                if rotate:  # don't rotate by 0.0 degrees\n                    with self.pdf.rotation(rotate, offsetx, offsety):\n                        if \"rotate\" in ele and ele[\"rotate\"]:\n                            with self.pdf.rotation(ele[\"rotate\"], ele[\"x1\"], ele[\"y1\"]):\n                                self.handlers[handler_name](**ele)  # type: ignore[operator]\n                        else:\n                            self.handlers[handler_name](**ele)  # type: ignore[operator]\n                else:\n                    if \"rotate\" in ele and ele[\"rotate\"]:\n                        with self.pdf.rotation(ele[\"rotate\"], ele[\"x1\"], ele[\"y1\"]):\n                            self.handlers[handler_name](**ele)  # type: ignore[operator]\n                    else:\n                        self.handlers[handler_name](**ele)  # type: ignore[operator]\n        self.texts = {}  # reset modified entries for the next page",
      "language": "python"
    },
    {
      "code": "def load_elements(self, elements: Sequence[dict[str, Any]]) -> None:\n    \"\"\"\n    Load a template definition.\n\n    Args:\n        elements (list of dicts): A template definition in a list of dicts\n    \"\"\"\n    key_config = {\n        # key: type\n        \"name\": (str, type(None)),\n        \"type\": (str, type(None)),\n        \"x1\": (int, float),\n        \"y1\": (int, float),\n        \"x2\": (int, float),\n        \"y2\": (int, float),\n        \"font\": (str, type(None)),\n        \"size\": (int, float),\n        \"bold\": object,  # \"bool or equivalent\"\n        \"italic\": object,\n        \"underline\": object,\n        \"foreground\": int,\n        \"background\": int,\n        \"align\": (str, type(None)),\n        \"text\": (str, type(None)),\n        \"priority\": int,\n        \"multiline\": (bool, type(None)),\n        \"rotate\": (int, float),\n        \"wrapmode\": (str, type(None)),\n        \"dash_pattern\": (dict, type(None)),\n    }\n\n    self.elements: Sequence[dict[str, Any]] = elements\n    self.keys: list[str] = []\n    for e in elements:\n        # priority is optional, but we need a default for sorting.\n        if not \"priority\" in e:\n            e[\"priority\"] = 0\n        for k in (\"name\", \"type\", \"x1\", \"y1\", \"y2\"):\n            if k not in e:\n                if e[\"type\"] == \"C39\":\n                    # lots of legacy special casing.\n                    # We need to do that here, so that rotation and scaling\n                    # still work.\n                    if k == \"x1\" and \"x\" in e:\n                        e[\"x1\"] = e[\"x\"]\n                        continue\n                    if k == \"y1\" and \"y\" in e:\n                        e[\"y1\"] = e[\"y\"]\n                        continue\n                    if k == \"y2\" and \"h\" in e:\n                        e[\"y2\"] = e[\"y1\"] + e[\"h\"]\n                        continue\n                raise KeyError(f\"Mandatory key '{k}' missing in input data\")\n        # x2 is optional for barcode types, but needed for offset rendering\n        if \"x2\" not in e:\n            if e[\"type\"] in [\"BC\", \"C39\"]:\n                e[\"x2\"] = 0\n            else:\n                raise KeyError(\"Mandatory key 'x2' missing in input data\")\n        if not \"size\" in e and e[\"type\"] == \"C39\":\n            if \"w\" in e:\n                e[\"size\"] = e[\"w\"]\n        if \"dash_pattern\" in e:\n            for k in e[\"dash_pattern\"].keys():\n                if k not in (\"dash\", \"gap\", \"phase\"):\n                    raise KeyError(f\"Invalid key '{k}' in dash_pattern\")\n            if \"dash\" not in e[\"dash_pattern\"]:\n                e[\"dash_pattern\"][\"dash\"] = 0\n            if \"gap\" not in e[\"dash_pattern\"]:\n                e[\"dash_pattern\"][\"gap\"] = e[\"dash_pattern\"][\"dash\"]\n            if \"phase\" not in e[\"dash_pattern\"]:\n                e[\"dash_pattern\"][\"phase\"] = 0\n\n        for k, t in key_config.items():\n            if k in e and not isinstance(e[k], t):  # type: ignore[arg-type]\n                ttype = (\n                    t.__name__\n                    if isinstance(t, type)\n                    else \" or \".join([f\"'{x.__name__}'\" for x in t])  # type: ignore[attr-defined]\n                )\n                raise TypeError(\n                    f\"Value of element item '{k}' must be {ttype}, not '{type(e[k]).__name__}'.\"\n                )\n        self.keys.append(e[\"name\"].lower())",
      "language": "python"
    },
    {
      "code": "def parse_csv(\n    self,\n    infile: os.PathLike[str],\n    delimiter: str = \",\",\n    decimal_sep: str = \".\",\n    encoding: Optional[str] = None,\n) -> None:\n    \"\"\"\n    Load the template definition from a CSV file.\n\n    Args:\n        infile (str, path-like object): The filepath of the CSV file.\n        delimiter (str): The character that separates the fields in the CSV file:\n            Usually a comma, semicolon, or tab.\n        decimal_sep (str): The decimal separator used in the file.\n            Usually either a point or a comma.\n        encoding (str): The character encoding of the file.\n            Default is the system default encoding.\n    \"\"\"\n\n    def _varsep_float(s: str, default: str = \"0\") -> float:\n        \"\"\"Convert to float with given decimal separator\"\"\"\n        # glad to have nonlocal scoping...\n        return float((s.strip() or default).replace(decimal_sep, \".\"))\n\n    key_config = (\n        # key, converter, mandatory\n        (\"name\", str, True),\n        (\"type\", str, True),\n        (\"x1\", _varsep_float, True),\n        (\"y1\", _varsep_float, True),\n        (\"x2\", _varsep_float, True),\n        (\"y2\", _varsep_float, True),\n        (\"font\", str, False),\n        (\"size\", _varsep_float, False),\n        (\"bold\", int, False),\n        (\"italic\", int, False),\n        (\"underline\", int, False),\n        (\"foreground\", self._parse_colorcode, False),\n        (\"background\", self._parse_colorcode, False),\n        (\"align\", str, False),\n        (\"text\", str, False),\n        (\"priority\", int, False),\n        (\"multiline\", self._parse_multiline, False),\n        (\"rotate\", _varsep_float, False),\n        (\"wrapmode\", str, False),\n    )\n    self.elements = []\n    if encoding is None:\n        encoding = locale.getpreferredencoding()\n    with open(infile, encoding=encoding) as f:\n        for row in csv.reader(f, delimiter=delimiter):\n            # fill in blanks for any missing items\n            row.extend([\"\"] * (len(key_config) - len(row)))\n            kargs: dict[str, Any] = {}\n            for val, cfg in zip(row, key_config):\n                vs = val.strip()\n                if not vs:\n                    if cfg[2]:  # mandatory\n                        if cfg[0] == \"x2\" and row[1] in [\"BC\", \"C39\"]:\n                            # two types don't need x2, but offset rendering does\n                            pass\n                        else:\n                            raise FPDFException(\n                                f\"Mandatory value '{cfg[0]}' missing in csv data\"\n                            )\n                    elif cfg[0] == \"priority\":\n                        # formally optional, but we need some value for sorting\n                        kargs[\"priority\"] = 0\n                    # otherwise, let the type handlers use their own defaults\n                else:\n                    kargs[cfg[0]] = cfg[1](vs)  # type: ignore[operator]\n            self.elements.append(kargs)\n    self.keys = [val[\"name\"].lower() for val in self.elements]",
      "language": "python"
    },
    {
      "code": "def parse_json(self, infile: os.PathLike[str], encoding: str = \"utf-8\") -> None:\n    \"\"\"\n    Load the template definition from a JSON file.\n    The data must be structured as an array of objects, with names and values exactly\n    equivalent to what would get supplied to load_elements(),\n\n    Args:\n        infile (str, path-like object): The filepath of the JSON file.\n        encoding (str): The character encoding of the file. Default is UTF-8.\n    \"\"\"\n    with open(infile, encoding=encoding) as f:\n        data = json.load(f)\n        for d in data:\n            fgval = d.get(\"foreground\")\n            if fgval and isinstance(fgval, str):\n                if fgval.lower().startswith(\"#\"):\n                    d[\"foreground\"] = int(fgval[1:], 16)\n                else:\n                    raise ValueError(\n                        \"If foreground is a string, it must have the form '#rrggbb'.\"\n                    )\n            bgval = d.get(\"background\")\n            if bgval and isinstance(bgval, str):\n                if bgval.lower().startswith(\"#\"):\n                    d[\"background\"] = int(bgval[1:], 16)\n                else:\n                    raise ValueError(\n                        \"If background is a string, it must have the form '#rrggbb'.\"\n                    )\n        self.load_elements(data)",
      "language": "python"
    },
    {
      "code": "def render(\n    self,\n    offsetx: float = 0.0,\n    offsety: float = 0.0,\n    rotate: float = 0.0,\n    scale: float = 1.0,\n) -> None:\n    \"\"\"\n    Add the contents of the template to the PDF document.\n\n    Args:\n        offsetx, offsety (float): Place the template to move its origin to the given coordinates.\n        rotate (float): Rotate the inserted template around its (offset) origin.\n        scale (float): Scale the inserted template by this factor.\n    \"\"\"\n    sorted_elements = sorted(self.elements, key=lambda x: x[\"priority\"])\n    with self.pdf.local_context():\n        for element in sorted_elements:\n            ele = element.copy()  # don't want to modify the callers original\n            ele[\"text\"] = self.texts.get(ele[\"name\"].lower(), ele.get(\"text\", \"\"))\n            if scale != 1.0:\n                ele[\"x1\"] = ele[\"x1\"] * scale\n                ele[\"y1\"] = ele[\"y1\"] * scale\n                ele[\"x2\"] = ele[\"x1\"] + ((ele[\"x2\"] - element[\"x1\"]) * scale)\n                ele[\"y2\"] = ele[\"y1\"] + ((ele[\"y2\"] - element[\"y1\"]) * scale)\n            if offsetx:\n                ele[\"x1\"] = ele[\"x1\"] + offsetx\n                ele[\"x2\"] = ele[\"x2\"] + offsetx\n            if offsety:\n                ele[\"y1\"] = ele[\"y1\"] + offsety\n                ele[\"y2\"] = ele[\"y2\"] + offsety\n            ele[\"scale\"] = scale\n            handler_name = ele[\"type\"].upper()\n            if rotate:  # don't rotate by 0.0 degrees\n                with self.pdf.rotation(rotate, offsetx, offsety):\n                    if \"rotate\" in ele and ele[\"rotate\"]:\n                        with self.pdf.rotation(ele[\"rotate\"], ele[\"x1\"], ele[\"y1\"]):\n                            self.handlers[handler_name](**ele)  # type: ignore[operator]\n                    else:\n                        self.handlers[handler_name](**ele)  # type: ignore[operator]\n            else:\n                if \"rotate\" in ele and ele[\"rotate\"]:\n                    with self.pdf.rotation(ele[\"rotate\"], ele[\"x1\"], ele[\"y1\"]):\n                        self.handlers[handler_name](**ele)  # type: ignore[operator]\n                else:\n                    self.handlers[handler_name](**ele)  # type: ignore[operator]\n    self.texts = {}  # reset modified entries for the next page",
      "language": "python"
    },
    {
      "code": "def __setitem__(self, name: str, value: Any) -> None:\n    assert isinstance(\n        name, str\n    ), f\"name must be of type 'str', not '{type(name).__name__}'.\"\n    # value has too many valid types to reasonably check here\n    if name.lower() not in self.keys:\n        raise FPDFException(f\"Element not loaded, cannot set item: {name}\")\n    self.texts[name.lower()] = value",
      "language": "python"
    },
    {
      "code": "def split_multicell(self, text: str, element_name: str) -> list[str]:\n    \"\"\"\n    Split a string between words, for the parts to fit into a given element\n    width. Additional splits will be made replacing any '\\\\n' characters.\n\n    Args:\n        text (str): The input text string.\n        element_name (str): The name of the template element to fit the text inside.\n\n    Returns:\n        A list of substrings, each of which will fit into the element width\n        when rendered in the element font style and size.\n    \"\"\"\n    element = next(\n        element\n        for element in self.elements\n        if element[\"name\"].lower() == element_name.lower()\n    )\n    if not self.splitting_pdf:\n        self.splitting_pdf = FPDF()\n        self.splitting_pdf.add_page()\n    assert self.splitting_pdf is not None\n    style = \"\"\n    if element.get(\"bold\"):\n        style += \"B\"\n    if element.get(\"italic\"):\n        style += \"I\"\n    if element.get(\"underline\"):\n        style += \"U\"\n    self.splitting_pdf.set_font(element[\"font\"], style, element[\"size\"])\n    return self.splitting_pdf.multi_cell(  # type: ignore[return-value]\n        w=element[\"x2\"] - element[\"x1\"],\n        h=element[\"y2\"] - element[\"y1\"],\n        text=str(text),\n        align=element.get(\"align\", \"\"),\n        dry_run=True,\n        output=\"LINES\",\n        wrapmode=element.get(\"wrapmode\", \"WORD\"),\n    )",
      "language": "python"
    },
    {
      "code": "class Template(FlexTemplate):\n    \"\"\"\n    A simple templating class.\n\n    Allows to apply a single template definition to all pages of a document.\n\n    Usage documentation at: <https://py-pdf.github.io/fpdf2/Templates.html>\n    \"\"\"\n\n    # Disabling this check due to the \"format\" parameter below:\n    # pylint: disable=redefined-builtin\n    def __init__(\n        self,\n        infile: Optional[os.PathLike[str]] = None,\n        elements: Optional[Sequence[dict[str, Any]]] = None,\n        format: str = \"A4\",\n        orientation: str = \"portrait\",\n        unit: str = \"mm\",\n        title: str = \"\",\n        author: str = \"\",\n        subject: str = \"\",\n        creator: str = \"\",\n        keywords: str = \"\",\n    ) -> None:\n        \"\"\"\n        Args:\n            infile (str): [**DEPRECATED since 2.2.0**] unused, will be removed in a later version\n            elements (list[dict]): A template definition in a list of dicts.\n                If you omit this, then you need to call either load_elements()\n                or parse_csv() before doing anything else.\n            format (str): The page format of the document (eg. \"A4\" or \"letter\").\n            orientation (str): The orientation of the document.\n                Possible values are \"portrait\"/\"P\" or \"landscape\"/\"L\"\n            unit (str): The units used in the template definition.\n                One of \"mm\", \"cm\", \"in\", \"pt\", or a number for points per unit.\n            title (str): The title of the document.\n            author (str): The author of the document.\n            subject (str): The subject matter of the document.\n            creator (str): The creator of the document.\n        \"\"\"\n        if infile:\n            warnings.warn(\n                '\"infile\" is deprecated since v2.2.0, unused and will soon be removed',\n                DeprecationWarning,\n                stacklevel=get_stack_level(),\n            )\n        for arg in (\n            \"format\",\n            \"orientation\",\n            \"unit\",\n            \"title\",\n            \"author\",\n            \"subject\",\n            \"creator\",\n            \"keywords\",\n        ):\n            # nosemgrep: python.lang.security.dangerous-globals-use.dangerous-globals-use\n            if not isinstance(locals()[arg], str):\n                raise TypeError(f'Argument \"{arg}\" must be of type str.')\n        pdf = FPDF(format=format, orientation=orientation, unit=unit)\n        pdf.set_title(title)\n        pdf.set_author(author)\n        pdf.set_creator(creator)\n        pdf.set_subject(subject)\n        pdf.set_keywords(keywords)\n        super().__init__(pdf=pdf, elements=elements)\n\n    def add_page(self) -> None:\n        \"\"\"Finish the current page, and proceed to the next one.\"\"\"\n        if self.pdf.page:\n            self.render()\n        self.pdf.add_page()\n\n    # pylint: disable=arguments-differ\n    def render(self, outfile: Optional[str] = None, dest: Optional[str] = None) -> None:  # type: ignore[override]\n        \"\"\"\n        Finish the document and process all pending data.\n\n        Args:\n            outfile (str): If given, the PDF file will be written to this file name.\n                Alternatively, the `.pdf.output()` method can be manually called.\n            dest (str): [**DEPRECATED since 2.2.0**] unused, will be removed in a later version.\n        \"\"\"\n        if dest:\n            warnings.warn(\n                '\"dest\" is deprecated since v2.2.0, unused and will soon be removed',\n                DeprecationWarning,\n                stacklevel=get_stack_level(),\n            )\n        self.pdf.set_font(\"helvetica\", style=\"B\", size=16)\n        self.pdf.set_auto_page_break(False, margin=0)\n        super().render()\n        if outfile:\n            self.pdf.output(outfile)",
      "language": "python"
    },
    {
      "code": "def add_page(self) -> None:\n    \"\"\"Finish the current page, and proceed to the next one.\"\"\"\n    if self.pdf.page:\n        self.render()\n    self.pdf.add_page()",
      "language": "python"
    },
    {
      "code": "def render(self, outfile: Optional[str] = None, dest: Optional[str] = None) -> None:  # type: ignore[override]\n    \"\"\"\n    Finish the document and process all pending data.\n\n    Args:\n        outfile (str): If given, the PDF file will be written to this file name.\n            Alternatively, the `.pdf.output()` method can be manually called.\n        dest (str): [**DEPRECATED since 2.2.0**] unused, will be removed in a later version.\n    \"\"\"\n    if dest:\n        warnings.warn(\n            '\"dest\" is deprecated since v2.2.0, unused and will soon be removed',\n            DeprecationWarning,\n            stacklevel=get_stack_level(),\n        )\n    self.pdf.set_font(\"helvetica\", style=\"B\", size=16)\n    self.pdf.set_auto_page_break(False, margin=0)\n    super().render()\n    if outfile:\n        self.pdf.output(outfile)",
      "language": "python"
    }
  ],
  "patterns": [],
  "links": [
    "https://py-pdf.github.io/fpdf2/Templates.html",
    "https://py-pdf.github.io/fpdf2/fpdf/fpdf.html",
    "https://py-pdf.github.io/fpdf2/fpdf/template.html",
    "https://py-pdf.github.io/fpdf2/fpdf/index.html"
  ]
}