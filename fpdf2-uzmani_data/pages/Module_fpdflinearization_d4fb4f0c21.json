{
  "url": "https://py-pdf.github.io/fpdf2/fpdf/linearization.html",
  "title": "Module fpdf.linearization",
  "content": "This module is in work-in-progress state. Hint tables / hint streams have not been implemented yet, and there are a few \"TODO\" comment remaining. cf. https://github.com/py-pdf/fpdf2/issues/62\n\nGenerates the final bytearray representing the PDF document, based on a FPDF instance.\n\nInherited from: OutputProducer.bufferize\n\nThis method alters the target FPDF instance by assigning IDs to all PDF objects, plus a few other properties on PDFPage instances\n\nInherited from: PDFContentStream.content_stream\n\nSubclasses can override this method to indicate the presence of a content stream\n\nInherited from: PDFContentStream.serialize\n\nSerialize the PDF object as an obj<</>>endobj text block\n\nInherited from: PDFObject.content_stream\n\nSubclasses can override this method to indicate the presence of a content stream\n\nInherited from: PDFObject.serialize\n\nSerialize the PDF object as an obj<</>>endobj text block\n\nHelper class that provides a standard way to create an ABC using inheritance.\n\nThe type of the None singleton.",
  "headings": [
    {
      "level": "h1",
      "text": "Module fpdf.linearization",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Classes",
      "id": "header-classes"
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Class variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    }
  ],
  "code_samples": [
    {
      "code": "class LinearizedOutputProducer(OutputProducer):\n    def bufferize(self) -> bytearray:\n        fpdf = self.fpdf\n\n        # 1. Setup - Insert all PDF objects\n        #    (in the order required to build a linearized PDF),\n        #    and assign unique consecutive numeric IDs to all of them\n\n        # Part 1: Header\n        self.pdf_objs.append(PDFHeader(fpdf.pdf_version))\n        # Part 2: Linearization parameter dictionary\n        linearization_obj = PDFLinearization(fpdf.pages_count)\n        self._add_pdf_obj(linearization_obj)\n        # Part 3: First-page cross-reference table and trailer\n        first_xref = PDFXrefAndTrailer(self)\n        self.pdf_objs.append(first_xref)\n        # Part 4: Document catalogue and other required document-level objects\n        catalog_obj = self._add_catalog()\n        # Part 5: Primary hint stream (may precede or follow part 6)\n        hint_stream_obj = PDFHintStream(\"\".encode(\"latin-1\"))  # TODO\n        self.pdf_objs.append(hint_stream_obj)\n        # Part 6: First-page section (may precede or follow part 5)\n        page_objs = self._add_pages(slice(0, 1))\n        # The following objects shall be contained in the first-page section:\n        #   + This page object shall explicitly specify all required attributes, e.g. Resources, MediaBox\n        #   + The entire outline hierarchy, if the PageMode entry in the catalogue is UseOutlines\n        #   + All objects that the page object refers to [including] Contents, Resources, Annots\n        # TODO\n\n        first_xref.count = self.obj_id + 1\n        first_xref_pdf_objs = list(self.pdf_objs)\n        self.obj_id = 0\n\n        # Part 7: Remaining pages\n        page_objs.extend(self._add_pages(slice(1, None)))\n        # Part 8: Shared objects for all pages except the first\n        # = resources, that are referenced from more than one page but [not] from the first page\n        pages_root_obj = self._add_pages_root()\n        sig_annotation_obj = self._add_annotations_as_objects()\n        img_objs_per_index = self._add_images()\n        gfxstate_objs_per_name = self._add_gfxstates()\n        shading_objs_per_name = self._add_shadings()\n        pattern_objs_per_name = self._add_patterns()\n        font_objs_per_index = self._add_fonts(\n            img_objs_per_index,\n            gfxstate_objs_per_name,\n            pattern_objs_per_name,\n        )\n        resources_dict_obj = self._add_resources_dict(\n            font_objs_per_index,\n            img_objs_per_index,\n            gfxstate_objs_per_name,\n            shading_objs_per_name,\n            pattern_objs_per_name,\n        )\n        # Part 9: Objects not associated with pages, if any\n        for embedded_file in fpdf.embedded_files:\n            self._add_pdf_obj(embedded_file, \"embedded_files\")\n        struct_tree_root_obj = self._add_structure_tree()\n        outline_dict_obj, outline_items = self._add_document_outline()\n        xmp_metadata_obj = self._add_xmp_metadata()\n        info_obj = self._add_info()\n        # Part 11: Main cross-reference table and trailer\n        main_xref = PDFXrefAndTrailer(self)\n        self.pdf_objs.append(main_xref)\n\n        # Re-assigning IDs of all PDF objects in the 1st xref table:\n        first_xref.start_obj_id = self.obj_id + 1\n        for pdf_obj in first_xref_pdf_objs:\n            if (\n                not isinstance(pdf_obj, ContentWithoutID)\n                and pdf_obj is not hint_stream_obj\n            ):\n                self.obj_id += 1\n                pdf_obj.id = self.obj_id\n        # The hint streams shall be assigned the last object numbers in the file:\n        self.obj_id += 1\n        hint_stream_obj.id = self.obj_id\n\n        # 2. Plumbing - Inject all PDF object references required:\n        linearization_obj.o = page_objs[0].id  # type: ignore[assignment]\n        pages_root_obj.kids = PDFArray(page_objs)\n        self._finalize_catalog(\n            catalog_obj,\n            pages_root_obj=pages_root_obj,\n            first_page_obj=page_objs[0],\n            sig_annotation_obj=sig_annotation_obj,\n            xmp_metadata_obj=xmp_metadata_obj,\n            struct_tree_root_obj=struct_tree_root_obj,\n            outline_dict_obj=outline_dict_obj,\n        )\n        dests: list[DestinationXYZ] = []\n        for page_obj in page_objs:\n            page_obj.parent = pages_root_obj\n            page_obj.resources = resources_dict_obj\n            assert page_obj.annots is not None\n            for annot in page_obj.annots:\n                if annot.dest:\n                    dests.append(annot.dest)\n                if annot.a and hasattr(annot.a, \"dest\"):\n                    dests.append(annot.a.dest)\n            if not page_obj.annots:\n                # Avoid serializing an empty PDFArray:\n                page_obj.annots = None\n        for outline_item in outline_items:\n            if outline_item.dest is not None:\n                dests.append(outline_item.dest)\n        # Assigning the .page_ref property of all Destination objects:\n        for dest in dests:\n            dest.page_ref = pdf_ref(  # pyright: ignore[reportAttributeAccessIssue]\n                page_objs[\n                    dest.page_number - 1  # pyright: ignore[reportAttributeAccessIssue]\n                ].id\n            )\n        for struct_elem in fpdf.struct_builder.doc_struct_elem.k:\n            struct_elem.pg = page_objs[struct_elem.page_number() - 1]\n        main_xref.first_xref = first_xref\n        first_xref.main_xref = main_xref\n        for xref in [main_xref, first_xref]:\n            xref.catalog_obj = catalog_obj\n            xref.info_obj = info_obj\n\n        # 3. Serializing - Append all PDF objects to the buffer:\n        assert (\n            not self.buffer\n        ), f\"Nothing should have been appended to the .buffer at this stage: {self.buffer}\"\n        assert (\n            not self.offsets\n        ), f\"No offset should have been set at this stage: {len(self.offsets)}\"\n        for pdf_obj in self.pdf_objs:\n            if isinstance(pdf_obj, ContentWithoutID):\n                # top header, xref table & trailer:\n                trace_label = None\n            else:\n                self.offsets[pdf_obj.id] = len(self.buffer)\n                trace_label = self.trace_labels_per_obj_id.get(pdf_obj.id)\n            if trace_label:\n                with self._trace_size(trace_label):\n                    self._out(pdf_obj.serialize())\n            else:\n                self._out(pdf_obj.serialize())\n        self._log_final_sections_sizes()\n\n        # Now that the file size & all the offsets are known,\n        # substitute the values of the Linearization properties:\n        hs1_offset = self.offsets[hint_stream_obj.id]\n        hs1_length = len(hint_stream_obj.serialize())\n        self.buffer = buffer_subst(\n            self.buffer,\n            HINT_STREAM_OFFSET_LENGTH_PLACEHOLDER,\n            f\"[{hs1_offset: 12d} {hs1_length: 12d}]\",\n        )\n        self.buffer = buffer_subst(\n            self.buffer,\n            FIRST_PAGE_END_OFFSET_PLACEHOLDER,\n            f\"{self.offsets[page_objs[0].id + 1]: 12d}\",\n        )\n        self.buffer = buffer_subst(\n            self.buffer,\n            MAIN_XREF_1ST_ENTRY_OFFSET_PLACEHOLDER,\n            f\"{self.offsets[main_xref.start_obj_id]: 12d}\",\n        )\n        self.buffer = buffer_subst(\n            self.buffer,\n            FILE_LENGTH_PLACEHOLDER,\n            f\"{len(self.buffer): 12d}\",\n        )\n\n        if fpdf._sign_key:  # pyright: ignore[reportPrivateUsage]\n            self.buffer = sign_content(\n                signer,  # pyright: ignore[reportArgumentType]\n                self.buffer,\n                fpdf._sign_key,  # pyright: ignore[reportPrivateUsage]\n                fpdf._sign_cert,  # pyright: ignore[reportPrivateUsage]\n                fpdf._sign_extra_certs,  # pyright: ignore[reportPrivateUsage]\n                fpdf._sign_hashalgo,  # pyright: ignore[reportPrivateUsage]\n                fpdf._sign_time,  # pyright: ignore[reportPrivateUsage]\n            )\n\n        return self.buffer",
      "language": "python"
    },
    {
      "code": "def bufferize(self) -> bytearray:\n    fpdf = self.fpdf\n\n    # 1. Setup - Insert all PDF objects\n    #    (in the order required to build a linearized PDF),\n    #    and assign unique consecutive numeric IDs to all of them\n\n    # Part 1: Header\n    self.pdf_objs.append(PDFHeader(fpdf.pdf_version))\n    # Part 2: Linearization parameter dictionary\n    linearization_obj = PDFLinearization(fpdf.pages_count)\n    self._add_pdf_obj(linearization_obj)\n    # Part 3: First-page cross-reference table and trailer\n    first_xref = PDFXrefAndTrailer(self)\n    self.pdf_objs.append(first_xref)\n    # Part 4: Document catalogue and other required document-level objects\n    catalog_obj = self._add_catalog()\n    # Part 5: Primary hint stream (may precede or follow part 6)\n    hint_stream_obj = PDFHintStream(\"\".encode(\"latin-1\"))  # TODO\n    self.pdf_objs.append(hint_stream_obj)\n    # Part 6: First-page section (may precede or follow part 5)\n    page_objs = self._add_pages(slice(0, 1))\n    # The following objects shall be contained in the first-page section:\n    #   + This page object shall explicitly specify all required attributes, e.g. Resources, MediaBox\n    #   + The entire outline hierarchy, if the PageMode entry in the catalogue is UseOutlines\n    #   + All objects that the page object refers to [including] Contents, Resources, Annots\n    # TODO\n\n    first_xref.count = self.obj_id + 1\n    first_xref_pdf_objs = list(self.pdf_objs)\n    self.obj_id = 0\n\n    # Part 7: Remaining pages\n    page_objs.extend(self._add_pages(slice(1, None)))\n    # Part 8: Shared objects for all pages except the first\n    # = resources, that are referenced from more than one page but [not] from the first page\n    pages_root_obj = self._add_pages_root()\n    sig_annotation_obj = self._add_annotations_as_objects()\n    img_objs_per_index = self._add_images()\n    gfxstate_objs_per_name = self._add_gfxstates()\n    shading_objs_per_name = self._add_shadings()\n    pattern_objs_per_name = self._add_patterns()\n    font_objs_per_index = self._add_fonts(\n        img_objs_per_index,\n        gfxstate_objs_per_name,\n        pattern_objs_per_name,\n    )\n    resources_dict_obj = self._add_resources_dict(\n        font_objs_per_index,\n        img_objs_per_index,\n        gfxstate_objs_per_name,\n        shading_objs_per_name,\n        pattern_objs_per_name,\n    )\n    # Part 9: Objects not associated with pages, if any\n    for embedded_file in fpdf.embedded_files:\n        self._add_pdf_obj(embedded_file, \"embedded_files\")\n    struct_tree_root_obj = self._add_structure_tree()\n    outline_dict_obj, outline_items = self._add_document_outline()\n    xmp_metadata_obj = self._add_xmp_metadata()\n    info_obj = self._add_info()\n    # Part 11: Main cross-reference table and trailer\n    main_xref = PDFXrefAndTrailer(self)\n    self.pdf_objs.append(main_xref)\n\n    # Re-assigning IDs of all PDF objects in the 1st xref table:\n    first_xref.start_obj_id = self.obj_id + 1\n    for pdf_obj in first_xref_pdf_objs:\n        if (\n            not isinstance(pdf_obj, ContentWithoutID)\n            and pdf_obj is not hint_stream_obj\n        ):\n            self.obj_id += 1\n            pdf_obj.id = self.obj_id\n    # The hint streams shall be assigned the last object numbers in the file:\n    self.obj_id += 1\n    hint_stream_obj.id = self.obj_id\n\n    # 2. Plumbing - Inject all PDF object references required:\n    linearization_obj.o = page_objs[0].id  # type: ignore[assignment]\n    pages_root_obj.kids = PDFArray(page_objs)\n    self._finalize_catalog(\n        catalog_obj,\n        pages_root_obj=pages_root_obj,\n        first_page_obj=page_objs[0],\n        sig_annotation_obj=sig_annotation_obj,\n        xmp_metadata_obj=xmp_metadata_obj,\n        struct_tree_root_obj=struct_tree_root_obj,\n        outline_dict_obj=outline_dict_obj,\n    )\n    dests: list[DestinationXYZ] = []\n    for page_obj in page_objs:\n        page_obj.parent = pages_root_obj\n        page_obj.resources = resources_dict_obj\n        assert page_obj.annots is not None\n        for annot in page_obj.annots:\n            if annot.dest:\n                dests.append(annot.dest)\n            if annot.a and hasattr(annot.a, \"dest\"):\n                dests.append(annot.a.dest)\n        if not page_obj.annots:\n            # Avoid serializing an empty PDFArray:\n            page_obj.annots = None\n    for outline_item in outline_items:\n        if outline_item.dest is not None:\n            dests.append(outline_item.dest)\n    # Assigning the .page_ref property of all Destination objects:\n    for dest in dests:\n        dest.page_ref = pdf_ref(  # pyright: ignore[reportAttributeAccessIssue]\n            page_objs[\n                dest.page_number - 1  # pyright: ignore[reportAttributeAccessIssue]\n            ].id\n        )\n    for struct_elem in fpdf.struct_builder.doc_struct_elem.k:\n        struct_elem.pg = page_objs[struct_elem.page_number() - 1]\n    main_xref.first_xref = first_xref\n    first_xref.main_xref = main_xref\n    for xref in [main_xref, first_xref]:\n        xref.catalog_obj = catalog_obj\n        xref.info_obj = info_obj\n\n    # 3. Serializing - Append all PDF objects to the buffer:\n    assert (\n        not self.buffer\n    ), f\"Nothing should have been appended to the .buffer at this stage: {self.buffer}\"\n    assert (\n        not self.offsets\n    ), f\"No offset should have been set at this stage: {len(self.offsets)}\"\n    for pdf_obj in self.pdf_objs:\n        if isinstance(pdf_obj, ContentWithoutID):\n            # top header, xref table & trailer:\n            trace_label = None\n        else:\n            self.offsets[pdf_obj.id] = len(self.buffer)\n            trace_label = self.trace_labels_per_obj_id.get(pdf_obj.id)\n        if trace_label:\n            with self._trace_size(trace_label):\n                self._out(pdf_obj.serialize())\n        else:\n            self._out(pdf_obj.serialize())\n    self._log_final_sections_sizes()\n\n    # Now that the file size & all the offsets are known,\n    # substitute the values of the Linearization properties:\n    hs1_offset = self.offsets[hint_stream_obj.id]\n    hs1_length = len(hint_stream_obj.serialize())\n    self.buffer = buffer_subst(\n        self.buffer,\n        HINT_STREAM_OFFSET_LENGTH_PLACEHOLDER,\n        f\"[{hs1_offset: 12d} {hs1_length: 12d}]\",\n    )\n    self.buffer = buffer_subst(\n        self.buffer,\n        FIRST_PAGE_END_OFFSET_PLACEHOLDER,\n        f\"{self.offsets[page_objs[0].id + 1]: 12d}\",\n    )\n    self.buffer = buffer_subst(\n        self.buffer,\n        MAIN_XREF_1ST_ENTRY_OFFSET_PLACEHOLDER,\n        f\"{self.offsets[main_xref.start_obj_id]: 12d}\",\n    )\n    self.buffer = buffer_subst(\n        self.buffer,\n        FILE_LENGTH_PLACEHOLDER,\n        f\"{len(self.buffer): 12d}\",\n    )\n\n    if fpdf._sign_key:  # pyright: ignore[reportPrivateUsage]\n        self.buffer = sign_content(\n            signer,  # pyright: ignore[reportArgumentType]\n            self.buffer,\n            fpdf._sign_key,  # pyright: ignore[reportPrivateUsage]\n            fpdf._sign_cert,  # pyright: ignore[reportPrivateUsage]\n            fpdf._sign_extra_certs,  # pyright: ignore[reportPrivateUsage]\n            fpdf._sign_hashalgo,  # pyright: ignore[reportPrivateUsage]\n            fpdf._sign_time,  # pyright: ignore[reportPrivateUsage]\n        )\n\n    return self.buffer",
      "language": "python"
    },
    {
      "code": "class PDFHintStream(PDFContentStream):\n    def __init__(self, contents: bytes, compress: bool = False) -> None:\n        super().__init__(contents=contents, compress=compress)\n        self.s = None  # (Required) Shared object hint table\n        self.t = None  # (Present only if thumbnail images exist) Thumbnail hint table\n        self.o = None  # (Present only if a document outline exists) Outline hint table\n        self.a = None  # (Present only if article threads exist) Thread information hint table\n        self.e = None  # (Present only if named destinations exist) Named destination hint table\n        self.v = None  # (Present only if an interactive form dictionary exists) Interactive form hint table\n        self.i = None  # (Present only if a document information dictionary exists) Information dictionary hint table\n        self.c = None  # (Present only if a logical structure hierarchy exists; PDF 1.3) Logical structure hint table\n        self.l = None  # (PDF 1.3) Page label hint table\n        self.r = None  # (Present only if a renditions name tree exists; PDF 1.5) Renditions name tree hint table\n        self.b = None  # (Present only if embedded file streams exist; PDF 1.5) Embedded file stream hint table",
      "language": "python"
    },
    {
      "code": "class PDFLinearization(PDFObject):\n    def __init__(self, pages_count: int) -> None:\n        super().__init__()\n        self.linearized = \"1\"  # Version\n        self.n = pages_count\n        # Primary hint stream offset and length (part 5):\n        self.h = HINT_STREAM_OFFSET_LENGTH_PLACEHOLDER\n        self.o = None  # Object number of first pageâ€™s page object (part 6)\n        self.e = FIRST_PAGE_END_OFFSET_PLACEHOLDER  # Offset of end of first page\n        # Offset of first entry in main cross-reference table (part 11):\n        self.t = MAIN_XREF_1ST_ENTRY_OFFSET_PLACEHOLDER\n        self.l = FILE_LENGTH_PLACEHOLDER  # The length of the entire file in bytes",
      "language": "python"
    },
    {
      "code": "class PDFXrefAndTrailer(ContentWithoutID):\n    PREV_MAIN_XREF_START_PLACEHOLDER = \"0%1*2+3-2/1^\"\n\n    def __init__(self, output_builder: OutputProducer) -> None:\n        self.output_builder = output_builder\n        self.count = output_builder.obj_id + 1\n        self.start_obj_id = 1\n        # Must be set before the call to serialize():\n        self.catalog_obj: Optional[PDFCatalog] = None\n        self.info_obj: Optional[PDFInfo] = None\n        self.first_xref: Optional[\"PDFXrefAndTrailer\"] = None\n        self.main_xref: Optional[\"PDFXrefAndTrailer\"] = None\n        # Computed at serialize() time based on output_builder.buffer size:\n        self.startxref: Optional[str] = None\n\n    @property\n    def is_first_xref(self) -> bool:\n        return bool(self.main_xref)\n\n    @property\n    def is_main_xref(self) -> bool:\n        return bool(self.first_xref)\n\n    def serialize(\n        self, _security_handler: Optional[\"StandardSecurityHandler\"] = None\n    ) -> str:\n        builder = self.output_builder\n        assert builder is not None\n        assert builder.buffer is not None\n        out: list[str] = []\n        self.startxref = str(len(builder.buffer))\n        if self.is_main_xref:\n            builder.buffer = buffer_subst(\n                builder.buffer,\n                self.PREV_MAIN_XREF_START_PLACEHOLDER,\n                self.startxref.rjust(12, \" \"),\n            )\n        out.append(\"xref\")\n        out.append(f\"{0 if self.start_obj_id == 1 else self.start_obj_id} {self.count}\")\n        if not self.is_first_xref:\n            out.append(\"0000000000 65535 f \")\n        assert (\n            len(builder.offsets) > 1\n        ), \"TODO: how to know the offsets in the 1st xref at this stage?\"\n        for obj_id in range(self.start_obj_id, self.start_obj_id + self.count):\n            out.append(f\"{builder.offsets[obj_id]:010} 00000 n \")\n        out.append(\"trailer\")\n        out.append(\"<<\")\n        if self.is_main_xref:\n            assert self.first_xref is not None\n            out.append(f\"/Size {self.count - self.first_xref.count}\")\n        else:\n            if self.is_first_xref:\n                assert self.main_xref is not None\n                out.append(f\"/Size {self.main_xref.count}\")\n                out.append(f\"/Prev {self.PREV_MAIN_XREF_START_PLACEHOLDER}\")\n            else:\n                out.append(f\"/Size {self.count}\")\n            assert self.catalog_obj is not None\n            assert self.info_obj is not None\n            out.append(f\"/Root {pdf_ref(self.catalog_obj.id)}\")\n            out.append(f\"/Info {pdf_ref(self.info_obj.id)}\")\n            fpdf = builder.fpdf\n            file_id = fpdf.file_id()\n            if file_id == -1:\n                file_id = fpdf._default_file_id(  # pyright: ignore[reportPrivateUsage]\n                    builder.buffer\n                )\n            if file_id:\n                out.append(f\"/ID [{file_id}]\")\n        out.append(\">>\")\n        out.append(\"startxref\")\n        startxref = self.startxref\n        if self.is_main_xref:\n            assert self.first_xref is not None\n            startxref = str(self.first_xref.startxref or \"0\")\n        if self.is_first_xref:\n            startxref = \"0\"\n        out.append(startxref)\n        out.append(\"%%EOF\")\n        return \"\\n\".join(out)",
      "language": "python"
    },
    {
      "code": "@property\ndef is_first_xref(self) -> bool:\n    return bool(self.main_xref)",
      "language": "python"
    },
    {
      "code": "@property\ndef is_main_xref(self) -> bool:\n    return bool(self.first_xref)",
      "language": "python"
    },
    {
      "code": "def serialize(\n    self, _security_handler: Optional[\"StandardSecurityHandler\"] = None\n) -> str:\n    builder = self.output_builder\n    assert builder is not None\n    assert builder.buffer is not None\n    out: list[str] = []\n    self.startxref = str(len(builder.buffer))\n    if self.is_main_xref:\n        builder.buffer = buffer_subst(\n            builder.buffer,\n            self.PREV_MAIN_XREF_START_PLACEHOLDER,\n            self.startxref.rjust(12, \" \"),\n        )\n    out.append(\"xref\")\n    out.append(f\"{0 if self.start_obj_id == 1 else self.start_obj_id} {self.count}\")\n    if not self.is_first_xref:\n        out.append(\"0000000000 65535 f \")\n    assert (\n        len(builder.offsets) > 1\n    ), \"TODO: how to know the offsets in the 1st xref at this stage?\"\n    for obj_id in range(self.start_obj_id, self.start_obj_id + self.count):\n        out.append(f\"{builder.offsets[obj_id]:010} 00000 n \")\n    out.append(\"trailer\")\n    out.append(\"<<\")\n    if self.is_main_xref:\n        assert self.first_xref is not None\n        out.append(f\"/Size {self.count - self.first_xref.count}\")\n    else:\n        if self.is_first_xref:\n            assert self.main_xref is not None\n            out.append(f\"/Size {self.main_xref.count}\")\n            out.append(f\"/Prev {self.PREV_MAIN_XREF_START_PLACEHOLDER}\")\n        else:\n            out.append(f\"/Size {self.count}\")\n        assert self.catalog_obj is not None\n        assert self.info_obj is not None\n        out.append(f\"/Root {pdf_ref(self.catalog_obj.id)}\")\n        out.append(f\"/Info {pdf_ref(self.info_obj.id)}\")\n        fpdf = builder.fpdf\n        file_id = fpdf.file_id()\n        if file_id == -1:\n            file_id = fpdf._default_file_id(  # pyright: ignore[reportPrivateUsage]\n                builder.buffer\n            )\n        if file_id:\n            out.append(f\"/ID [{file_id}]\")\n    out.append(\">>\")\n    out.append(\"startxref\")\n    startxref = self.startxref\n    if self.is_main_xref:\n        assert self.first_xref is not None\n        startxref = str(self.first_xref.startxref or \"0\")\n    if self.is_first_xref:\n        startxref = \"0\"\n    out.append(startxref)\n    out.append(\"%%EOF\")\n    return \"\\n\".join(out)",
      "language": "python"
    }
  ],
  "patterns": [],
  "links": [
    "https://py-pdf.github.io/fpdf2/fpdf/output.html",
    "https://py-pdf.github.io/fpdf2/fpdf/syntax.html",
    "https://py-pdf.github.io/fpdf2/fpdf/index.html",
    "https://py-pdf.github.io/fpdf2/fpdf/linearization.html"
  ]
}