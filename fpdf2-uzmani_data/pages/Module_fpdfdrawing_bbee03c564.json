{
  "url": "https://py-pdf.github.io/fpdf2/fpdf/drawing.html",
  "title": "Module fpdf.drawing",
  "content": "Vector drawing: managing colors, graphics states, paths, transforms…\n\nThe contents of this module are internal to fpdf2, and not part of the public API. They may change at any time without prior warning or any deprecation period, in non-backward-compatible ways.\n\nUsage documentation at: https://py-pdf.github.io/fpdf2/Drawing.html\n\nAn elliptical arc path element.\n\nThe arc is drawn from the end of the current path element to its specified end point using a number of parameters to determine how it is constructed.\n\nSee: PaintedPath.arc_to()\n\nA generator that subdivides a swept angle into segments no larger than a quarter turn.\n\nAny sweep that is larger than a quarter turn is subdivided into as many equally sized segments as necessary to prevent any individual segment from being larger than a quarter turn.\n\nThis is used for approximating a circular curve segment using cubic Bézier curves. This computes the parameters used for the Bézier approximation up front, as well as the transform necessary to place the segment in the correct position.\n\nA tuple of (ctrl1, ctrl2, end) representing the control and end points of the cubic Bézier curve approximating the segment as a unit circle centered at the origin.\n\nThe end point of the arc.\n\nThe end point of this path element.\n\nIf True, sweep the arc over an angle greater than or equal to 180 degrees.\n\nThe x- and y-radii of the arc. If radii.x == radii.y the arc will be circular.\n\nThe rotation of the arc's major/minor axes relative to the coordinate frame.\n\nIf True, the arc is swept in the positive angular direction.\n\nCompute the bounding box of this arc by approximating it with a series of Bezier curves and aggregating their bounding boxes.\n\nRender this path element to its PDF representation.\n\na tuple of (str, new_last_item), where new_last_item is a resolved BezierCurve.\n\nA cubic Bézier curve path element.\n\nThis draws a Bézier curve parameterized by the end point of the previous path element, two off-curve control points, and an end point.\n\nSee: PaintedPath.curve_to()\n\nThe curve's first control point.\n\nThe curve's second control point.\n\nThe curve's end point.\n\nThe end point of this path element.\n\nCompute the bounding box of this cubic Bézier curve.\n\nRender this path element to its PDF representation.\n\na tuple of (str, new_last_item), where new_last_item is self\n\nRepresents a bounding box, with utility methods for creating and manipulating them.\n\nReturn an 'empty' bounding box with extreme values that collapse on merge.\n\nGiven a list of points, create a bounding box that encloses them all.\n\nReturn the height of the bounding box.\n\nReturn the width of the bounding box.\n\nAlias for field number 0\n\nAlias for field number 2\n\nAlias for field number 1\n\nAlias for field number 3\n\nClockwise corners (x,y): (x0,y0),(x1,y0),(x1,y1),(x0,y1).\n\nReturn a new bounding box expanded by the given amounts in each direction.\n\nExpand this bbox to include stroke coverage, given a graphics style.\n\nReturn True if the bounding box is not empty.\n\nMax Euclidean distance from (cx,cy) to any bbox corner.\n\nExpand this bounding box to include another one.\n\nProject bbox corners onto the axis from (x1,y1) to (x2,y2). Returns (tmin, tmax, L) where: - L is the axis length - t are distances along the axis with t=0 at (x1,y1)\n\nConvert bounding box to a PDF array string.\n\nConvert bounding box to a 4-tuple.\n\nReturn a new bounding box resulting from applying a transform to this one.\n\nThe PaintedPath API but to be used to create clipping paths.\n\nUnless you really know what you're doing, changing attributes of the clipping path style is likely to produce unexpected results. This is because the clipping path styles override implicit style inheritance of the PaintedPath it applies to.\n\nFor example, clippath.style.stroke_width = 2 can unexpectedly override paintpath.style.stroke_width = GraphicsStyle.INHERIT and cause the painted path to be rendered with a stroke of 2 instead of what it would have normally inherited. Because a ClippingPath can be painted like a normal PaintedPath, it would be overly restrictive to remove the ability to style it, so instead this warning is here.\n\nInherited from: PaintedPath.auto_close\n\nIf true, the path should automatically close itself before painting.\n\nInherited from: PaintedPath.clipping_path\n\nSet the clipping path for this path.\n\nInherited from: PaintedPath.paint_rule\n\nManually specify the PathPaintRule to use for rendering the path.\n\nInherited from: PaintedPath.style\n\nThe GraphicsStyle applied to all elements of this path.\n\nInherited from: PaintedPath.transform\n\nThe Transform that applies to all of the elements of this path.\n\nInherited from: PaintedPath.add_path_element\n\nAdd the given element as a path item of this path …\n\nInherited from: PaintedPath.arc_relative\n\nAppend an elliptical arc from the end of the previous path point to an offset point …\n\nInherited from: PaintedPath.arc_to\n\nAppend an elliptical arc from the end of the previous path point to the specified end point …\n\nInherited from: PaintedPath.bounding_box\n\nCompute the bounding box of this painted path, including nested contexts and transformations.\n\nInherited from: PaintedPath.circle\n\nAppend a circle as a closed subpath to the current path …\n\nInherited from: PaintedPath.close\n\nExplicitly close the current (sub)path.\n\nInherited from: PaintedPath.curve_relative\n\nAppend a cubic Bézier curve whose points are expressed relative to the end point of the previous path element …\n\nInherited from: PaintedPath.curve_to\n\nAppend a cubic Bézier curve to this path …\n\nInherited from: PaintedPath.ellipse\n\nAppend an ellipse as a closed subpath to the current path …\n\nInherited from: PaintedPath.horizontal_line_relative\n\nAppend a straight horizontal line to the given offset from the previous path element. The ordinate is retrieved from the end point of the previous …\n\nInherited from: PaintedPath.horizontal_line_to\n\nAppend a straight horizontal line to the given abscissa. The ordinate is retrieved from the end point of the previous path element …\n\nInherited from: PaintedPath.line_relative\n\nAppend a straight line whose end is computed as an offset from the end of the previous path element …\n\nInherited from: PaintedPath.line_to\n\nAppend a straight line to this path …\n\nInherited from: PaintedPath.move_relative\n\nStart a new subpath or move the path start point relative to the previous point …\n\nInherited from: PaintedPath.move_to\n\nStart a new subpath or move the path starting point …\n\nInherited from: PaintedPath.quadratic_curve_relative\n\nAppend a cubic Bézier curve mimicking the specified quadratic Bézier curve …\n\nInherited from: PaintedPath.quadratic_curve_to\n\nAppend a cubic Bézier curve mimicking the specified quadratic Bézier curve …\n\nInherited from: PaintedPath.rectangle\n\nAppend a rectangle as a closed subpath to the current path …\n\nInherited from: PaintedPath.text\n\nAppend a text run at (x, y) to this path …\n\nInherited from: PaintedPath.transform_group\n\nApply the provided Transform to all points added within this context.\n\nInherited from: PaintedPath.vertical_line_relative\n\nAppend a straight vertical line to the given offset from the previous path element. The abscissa is retrieved from the end point of the previous path …\n\nInherited from: PaintedPath.vertical_line_to\n\nAppend a straight vertical line to the given ordinate. The abscissa is retrieved from the end point of the previous path element …\n\nA path close element.\n\nInstructs the renderer to draw a straight line from the end of the last path element to the start of the current path.\n\nSee: PaintedPath.close()\n\nThe end point of a Close is undefined; return (0, 0).\n\nReturn an empty bounding box; Close does not affect the geometry.\n\nRender this path element to its PDF representation.\n\na tuple of (str, new_last_item), where new_last_item is whatever the old last_item was.\n\nBase context for a drawing in a PDF\n\nThis context is not stylable and is mainly responsible for transforming path drawing coordinates into user coordinates (i.e. it ensures that the output drawing is correctly scaled).\n\nAppend an item to this drawing context\n\nRender the drawing context to PDF format.\n\nA string composed of the PDF representation of all the paths and groups in this context (an empty string is returned if there are no paths or groups)\n\nSee: PaintedPath.ellipse()\n\nThe abscissa and ordinate of the center of the ellipse\n\nThe x- and y-radii of the ellipse\n\nCompute the bounding box of this ellipse by decomposing it and merging the bounding boxes of its components.\n\nRender this path element to its PDF representation.\n\na tuple of (str, new_last_item), where new_last_item is a resolved Move to the center of the ellipse.\n\nA pen that can be used to draw glyphs into a PaintedPath.\n\nTakes a 'glyphSet' argument (dict), in which the glyphs that are referenced as components are looked up by their name.\n\nIf the optional 'reverseFlipped' argument is True, components whose transformation matrix has a negative determinant will be decomposed with a reversed path direction to compensate for the flip.\n\nThe optional 'skipMissingComponents' argument can be set to True/False to override the homonymous class attribute for a given pen instance.\n\nFill/stroke paint using a gradient\n\nPage-level container that collects drawable items and renders them into a PDF content stream.\n\nConverts model coordinates to PDF user space by applying the provided scale and a vertical flip so (0, 0) is the top-left of the page.\n\nWraps output in a saved graphics state (q … Q) and registers any required resources (graphics state dictionaries, soft masks, dash pattern).\n\nChild items are typically GraphicsContext, PaintedPath, or PaintComposite objects added via add_item(). By default, items are deep-copied on insert to avoid later mutations affecting the emitted stream.\n\nThe ClippingPath for this graphics context.\n\nAdd a path element to this graphics context.\n\nCompute bbox of all path items. We: 1) recurse with accumulated CTM, 2) merge child bboxes already transformed to this level, 3) at the end, expand once for stroke using the worst-case CTM row norms.\n\nBuild a list composed of all all the individual elements rendered.\n\nThis is used by PaintedPath and ClippingPath to reuse the GraphicsContext rendering process while still being able to inject some path specific items (e.g. the painting directive) before the render is collapsed into a single string.\n\ntuple[list[str], last_item] where last_item is the past path element in this GraphicsContext\n\nCopy another GraphicsContext's path items into this one.\n\nA class representing various style attributes that determine drawing appearance.\n\nThis class uses the convention that the global Python singleton ellipsis (…) is exclusively used to represent values that are inherited from the parent style. This is to disambiguate the value None which is used for several values to signal an explicitly disabled style. An example of this is the fill/stroke color styles, which use None as hints to the auto paint style detection code.\n\nSingleton specifying a style parameter should be inherited from the parent context.\n\nAn ordered collection of properties to use when merging two GraphicsStyles.\n\nAn ordered collection of keys to directly emit when serializing the style.\n\nAn ordered collection of attributes not to emit in no transparency mode.\n\nMerge parent and child into a single GraphicsStyle.\n\nThe result contains the properties of the parent as overridden by any properties explicitly set on the child. If both the parent and the child specify to inherit a given property, that property will preserve the inherit value.\n\nIf True, unclosed paths will be automatically closed before stroking.\n\nThe desired blend mode for this path/group.\n\nThe desired fill color for this path/group.\n\nWhen setting this property, if the color specifies an opacity value, that will be used to set the fill_opacity property as well.\n\nThe desired fill opacity for this path/group.\n\nThe desired intersection rule for this path/group.\n\nThe paint rule to use for this path/group.\n\nThe desired stroke cap style for this path/group.\n\nThe desired stroke color for this path/group.\n\nWhen setting this property, if the color specifies an opacity value, that will be used to set the fill_opacity property as well.\n\nThe desired stroke dash pattern for this path/group.\n\nThe desired stroke dash pattern phase offset for this path/group.\n\nThe desired stroke join style for this path/group.\n\nThe desired stroke miter limit for this path/group.\n\nThe desired stroke opacity for this path/group.\n\nThe desired stroke width for this path/group.\n\nResolve PathPaintRule.AUTO to a real paint rule based on this style.\n\nthe resolved PathPaintRule.\n\nConvert this style object to a PDF dictionary with appropriate style keys.\n\nOnly explicitly specified values are emitted.\n\nA path line element that takes its ordinate from the end of the previous element.\n\nSee: PaintedPath.horizontal_line_to()\n\nThe abscissa of the horizontal line's end point.\n\nCompute the bounding box of a horizontal line from the start point to the new x.\n\nRender this path element to its PDF representation.\n\na tuple of (str, new_last_item), where new_last_item is the resolved Line.\n\nA path close element that is conditionally rendered depending on the value of GraphicsStyle.auto_close.\n\nReturn an empty bounding box; Close does not affect the geometry.\n\nRender this path element to its PDF representation.\n\na tuple of (str, new_last_item), where new_last_item is whatever the old last_item was.\n\nThis draws a straight line from the end point of the previous path element to the point specified by pt.\n\nSee: PaintedPath.line_to()\n\nThe end point of this path element.\n\nThe point to which the line is drawn.\n\nCompute the bounding box of a line from the start point to the end point.\n\nRender this path element to its PDF representation.\n\na tuple of (str, new_last_item), where new_last_item is self\n\nIf a path has been created but not yet painted, this will create a new subpath.\n\nSee: PaintedPath.move_to()\n\nThe end point of this path element.\n\nThe point to which to move.\n\nRender this path element to its PDF representation.\n\na tuple of (str, new_last_item), where new_last_item is self\n\nWraps a vector path as a PDF soft mask (SMask) that can be attached to a graphics state.\n\nThe provided mask_path is deep-copied and forced to render as an opaque grayscale fill (white, alpha=1, nonzero rule, transparency disabled). During rendering, the mask’s content stream is generated and its resource dictionary is collected so it can be embedded as a Form XObject and referenced from an ExtGState.\n\nBuild a GraphicsContext that encodes the alpha ramps contributed by any GradientPaint used by node. Each contributing PaintedPath yields one rectangle covering its content-space bounding box; that rectangle is filled with an _AlphaGradientPaint (the gradient’s alpha channel only). Rectangles are stacked with BM=Multiply so multiple alpha sources combine multiplicatively.\n\nReturn a deep-copied version of node whose appearance encodes only its geometric coverage: every shape is converted to an opaque white fill (nonzero rule), with no stroke, no soft mask, and inherited blend mode.\n\nThe transform/clipping/structure of the original node is preserved; only paint-related attributes are normalized. This is intended for building the “B” term of soft-mask expressions (coverage), where inside = 1 and outside = 0.\n\nConstruct a luminosity soft mask from two ingredients:\n\nThe mask luminance is: - A × B when invert = False - A × (1 − B) when invert = True\n\nImplementation outline: 1. Compute the union bbox of A and B (no stroke expansion). 2. Paint a background rectangle: black for A×B or white for A×(1−B). 3. Paint B; when invert=True, set BM=Difference to obtain 1−B from the white background. 4. If A is present, paint it with BM=Multiply to apply the alpha ramp. 5. Wrap the result as a Form XObject and attach it as /SMask with /S /Luminosity.\n\nBuild the resource dictionary for this soft mask, resolving GS & Pattern ids.\n\nA path to be drawn by the PDF renderer.\n\nA painted path is defined by a style and an arbitrary sequence of path elements, which include the primitive path elements (Move, Line, BezierCurve, …) as well as arbitrarily nested GraphicsContext containing their own sequence of primitive path elements and GraphicsContext.\n\nIf true, the path should automatically close itself before painting.\n\nSet the clipping path for this path.\n\nManually specify the PathPaintRule to use for rendering the path.\n\nThe GraphicsStyle applied to all elements of this path.\n\nThe Transform that applies to all of the elements of this path.\n\nAdd the given element as a path item of this path.\n\nAppend an elliptical arc from the end of the previous path point to an offset point.\n\nThe arc is approximated using Bézier curves, so it is not perfectly accurate. However, the error is small enough to not be noticeable at any reasonable (and even most unreasonable) scales, with a worst-case deviation of around 3‱.\n\nAppend an elliptical arc from the end of the previous path point to the specified end point.\n\nThe arc is approximated using Bézier curves, so it is not perfectly accurate. However, the error is small enough to not be noticeable at any reasonable (and even most unreasonable) scales, with a worst-case deviation of around 3‱.\n\nCompute the bounding box of this painted path, including nested contexts and transformations.\n\nAppend a circle as a closed subpath to the current path.\n\nThe path, to allow chaining method calls.\n\nExplicitly close the current (sub)path.\n\nAppend a cubic Bézier curve whose points are expressed relative to the end point of the previous path element.\n\nE.g. with a start point of (0, 0), given (1, 1), (2, 2), (3, 3), the output curve would have the points:\n\n(0, 0) c1 (1, 1) c2 (3, 3) e (6, 6)\n\nThe path, to allow chaining method calls.\n\nAppend a cubic Bézier curve to this path.\n\nThe path, to allow chaining method calls.\n\nAppend an ellipse as a closed subpath to the current path.\n\nThe path, to allow chaining method calls.\n\nAppend a straight horizontal line to the given offset from the previous path element. The ordinate is retrieved from the end point of the previous path element.\n\nThe path, to allow chaining method calls.\n\nAppend a straight horizontal line to the given abscissa. The ordinate is retrieved from the end point of the previous path element.\n\nThe path, to allow chaining method calls.\n\nAppend a straight line whose end is computed as an offset from the end of the previous path element.\n\nThe path, to allow chaining method calls.\n\nAppend a straight line to this path.\n\nThe path, to allow chaining method calls.\n\nStart a new subpath or move the path start point relative to the previous point.\n\nIf no path elements have been added yet, this will change the path starting point. If path elements have been added, this will insert an implicit close in order to start a new subpath.\n\nThis will overwrite an absolute move_to as long as no non-move path items have been appended. The relative position is resolved from the previous item when the path is being rendered, or from 0, 0 if it is the first item.\n\nStart a new subpath or move the path starting point.\n\nIf no path elements have been added yet, this will change the path starting point. If path elements have been added, this will insert an implicit close in order to start a new subpath.\n\nThe path, to allow chaining method calls.\n\nAppend a cubic Bézier curve mimicking the specified quadratic Bézier curve.\n\nThe path, to allow chaining method calls.\n\nAppend a cubic Bézier curve mimicking the specified quadratic Bézier curve.\n\nThe path, to allow chaining method calls.\n\nAppend a rectangle as a closed subpath to the current path.\n\nIf the width or the height are 0, the rectangle will be collapsed to a line (unless they're both 0, in which case it's collapsed to nothing).\n\nThe path, to allow chaining method calls.\n\nAppend a text run at (x, y) to this path.\n\nThe baseline is at (x, y). text_anchor controls alignment about x. font_style accepts \"\", \"B\", \"I\", or \"BI\". font_family can be a single name or a comma-separated fallback list (handled at render-time).\n\nself (to allow chaining)\n\nApply the provided Transform to all points added within this context.\n\nAppend a straight vertical line to the given offset from the previous path element. The abscissa is retrieved from the end point of the previous path element.\n\nThe path, to allow chaining method calls.\n\nAppend a straight vertical line to the given ordinate. The abscissa is retrieved from the end point of the previous path element.\n\nThe path, to allow chaining method calls.\n\nBase class for drawing pens. You must override _moveTo, _lineTo and _curveToOne. You may additionally override _closePath, _endPath, addComponent, addVarComponent, and/or _qCurveToOne. You should not override any other methods.\n\nTakes a 'glyphSet' argument (dict), in which the glyphs that are referenced as components are looked up by their name.\n\nIf the optional 'reverseFlipped' argument is True, components whose transformation matrix has a negative determinant will be decomposed with a reversed path direction to compensate for the flip.\n\nThe optional 'skipMissingComponents' argument can be set to True/False to override the homonymous class attribute for a given pen instance.\n\nA quadratic Bézier curve path element.\n\nThis draws a Bézier curve parameterized by the end point of the previous path element, one off-curve control point, and an end point.\n\nSee: PaintedPath.quadratic_curve_to()\n\nThe curve's control point.\n\nThe curve's end point.\n\nThe end point of this path element.\n\nCompute the bounding box of this quadratic Bézier curve by converting it to a cubic Bézier.\n\nRender this path element to its PDF representation.\n\na tuple of (str, new_last_item), where new_last_item is self.\n\nA pdf primitive rectangle.\n\nThe end point of a rectangle is the origin.\n\nThe top-left corner of the rectangle.\n\nThe width and height of the rectangle.\n\nCompute the bounding box of this rectangle.\n\nRender this path element to its PDF representation.\n\na tuple of (str, new_last_item), where new_last_item is a Line back to the rectangle's origin.\n\nAn elliptical arc path element.\n\nThe arc is drawn from the end of the current path element to its specified end point using a number of parameters to determine how it is constructed.\n\nSee: PaintedPath.arc_relative()\n\nThe end point of the arc relative to the end of the previous path element.\n\nIf True, sweep the arc over an angle greater than or equal to 180 degrees.\n\nThe x- and y-radii of the arc. If radii.x == radii.y the arc will be circular.\n\nThe rotation of the arc's major/minor axes relative to the coordinate frame.\n\nIf True, the arc is swept in the positive angular direction.\n\nCompute the bounding box of the resolved arc from the given start point.\n\nRender this path element to its PDF representation.\n\na tuple of (str, new_last_item), where new_last_item is a resolved BezierCurve.\n\nA cubic Bézier curve path element whose points are specified relative to the end point of the previous path element.\n\nSee: PaintedPath.curve_relative()\n\nThe curve's first control point relative to the end of the previous path element.\n\nThe curve's second control point relative to the end of the previous path element.\n\nThe curve's end point relative to the end of the previous path element.\n\nCompute the bounding box of this relative cubic Bézier curve.\n\nA tuple containing: - BoundingBox: the axis-aligned bounding box containing the entire curve. - Point: the end point of the curve.\n\nRender this path element to its PDF representation.\n\na tuple of (str, new_last_item), where new_last_item is the resolved BezierCurve.\n\nA path line element that takes its ordinate from the end of the previous element and computes its abscissa offset from the end of that element.\n\nSee: PaintedPath.horizontal_line_relative()\n\nThe abscissa of the horizontal line's end point relative to the abscissa of the previous path element.\n\nCompute the bounding box of a relative horizontal line.\n\nRender this path element to its PDF representation.\n\na tuple of (str, new_last_item), where new_last_item is the resolved Line.\n\nA path line element with an endpoint relative to the end of the previous element.\n\nThis draws a straight line from the end point of the previous path element to the point specified by last_item.end_point + pt. The absolute coordinates of the end point are resolved during the rendering process.\n\nSee: PaintedPath.line_relative()\n\nThe endpoint of the line relative to the previous path element.\n\nCompute the bounding box of a relative line from the start point to the new end point.\n\nRender this path element to its PDF representation.\n\na tuple of (str, new_last_item), where new_last_item is the resolved Line.\n\nA path move element with an end point relative to the end of the previous path element.\n\nIf a path has been created but not yet painted, this will create a new subpath.\n\nSee: PaintedPath.move_relative()\n\nThe offset by which to move.\n\nRelativeMove doesn't draw anything, so it has no bounding box.\n\nRender this path element to its PDF representation.\n\na tuple of (str, new_last_item), where new_last_item is the resolved Move\n\nA quadratic Bézier curve path element whose points are specified relative to the end point of the previous path element.\n\nSee: PaintedPath.quadratic_curve_relative()\n\nThe curve's control point relative to the end of the previous path element.\n\nThe curve's end point relative to the end of the previous path element.\n\nCompute the bounding box of this relative quadratic Bézier curve.\n\nRender this path element to its PDF representation.\n\na tuple of (str, new_last_item), where new_last_item is the resolved QuadraticBezierCurve.\n\nA path line element that takes its abscissa from the end of the previous element and computes its ordinate offset from the end of that element.\n\nSee: PaintedPath.vertical_line_relative()\n\nThe ordinate of the vertical line's end point relative to the ordinate of the previous path element.\n\nCompute the bounding box of this relative vertical line.\n\nRender this path element to its PDF representation.\n\na tuple of (str, new_last_item), where new_last_item is the resolved Line.\n\nStructural type for things that can render themselves into PDF operators and report a geometric bounding box.\n\nA rectangle with rounded corners.\n\nSee: PaintedPath.rectangle()\n\nThe x- and y-radius of the corners.\n\nThe top-left corner of the rectangle.\n\nThe width and height of the rectangle.\n\nCompute the bounding box of this rounded rectangle by decomposing into primitives and merging their individual bounding boxes.\n\nRender this path element to its PDF representation.\n\na tuple of (str, new_last_item), where new_last_item is a resolved Line.\n\nSVG-like text renderable. Stores the anchor position (x, y) and one or more TextRuns that include relative positioning offsets. Accurate glyph positioning is resolved during rendering once font metrics are available.\n\nAlias for field number 3\n\nAlias for field number 2\n\nAlias for field number 0\n\nAlias for field number 1\n\nCompute a conservative bbox for the text.\n\nFont metrics are not available at this stage so the layout relies on approximate glyph widths proportional to the run font size. The actual layout is computed precisely in render().\n\nEmit PDF text operators:\n\nBT Tf Tr (map from GraphicsStyle->PathPaintRule) 1 0 0 1 x y Tm (escaped-text) Tj ET\n\nTextRun(text, family, emphasis, size, dx, dy, abs_x, abs_y, transform, run_style)\n\nAlias for field number 6\n\nAlias for field number 7\n\nAlias for field number 4\n\nAlias for field number 5\n\nAlias for field number 2\n\nAlias for field number 1\n\nAlias for field number 9\n\nAlias for field number 3\n\nAlias for field number 0\n\nAlias for field number 8\n\nA path line element that takes its abscissa from the end of the previous element.\n\nSee: PaintedPath.vertical_line_to()\n\nThe ordinate of the vertical line's end point.\n\nCompute the bounding box of this vertical line.\n\nRender this path element to its PDF representation.\n\na tuple of (str, new_last_item), where new_last_item is the resolved Line.",
  "headings": [
    {
      "level": "h1",
      "text": "Module fpdf.drawing",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Functions",
      "id": "header-functions"
    },
    {
      "level": "h2",
      "text": "Classes",
      "id": "header-classes"
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Static methods",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Yields",
      "id": "yields"
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Returns",
      "id": "returns"
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Returns",
      "id": "returns"
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Static methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Returns",
      "id": "returns"
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Returns",
      "id": "returns"
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Returns",
      "id": "returns"
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Subclasses",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Returns",
      "id": "returns"
    },
    {
      "level": "h3",
      "text": "Class variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Static methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Returns",
      "id": "returns"
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Returns",
      "id": "returns"
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Returns",
      "id": "returns"
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Returns",
      "id": "returns"
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Returns",
      "id": "returns"
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Static methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Subclasses",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Notes",
      "id": "notes"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Notes",
      "id": "notes"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Returns",
      "id": "returns"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Returns",
      "id": "returns"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Returns",
      "id": "returns"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Returns",
      "id": "returns"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Returns",
      "id": "returns"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Returns",
      "id": "returns"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Returns",
      "id": "returns"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Returns",
      "id": "returns"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Returns",
      "id": "returns"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Returns",
      "id": "returns"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Returns",
      "id": "returns"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Returns",
      "id": "returns"
    },
    {
      "level": "h2",
      "text": "Returns",
      "id": "returns"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Returns",
      "id": "returns"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Returns",
      "id": "returns"
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Subclasses",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Returns",
      "id": "returns"
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Returns",
      "id": "returns"
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Returns",
      "id": "returns"
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Returns",
      "id": "returns"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Returns",
      "id": "returns"
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Returns",
      "id": "returns"
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Returns",
      "id": "returns"
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Returns",
      "id": "returns"
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Returns",
      "id": "returns"
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Returns",
      "id": "returns"
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Returns",
      "id": "returns"
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Returns",
      "id": "returns"
    }
  ],
  "code_samples": [
    {
      "code": "def clone_structure(\n    node: GraphicsContext | PaintedPath,\n) -> GraphicsContext | PaintedPath:\n    new: GraphicsContext | PaintedPath\n    if isinstance(node, GraphicsContext):\n        new = GraphicsContext()\n        new.style = deepcopy(node.style)\n        new.transform = node.transform\n        new.clipping_path = node.clipping_path\n        new.path_items = [\n            (\n                clone_structure(ch)\n                if isinstance(ch, (GraphicsContext, PaintedPath))\n                else ch\n            )\n            for ch in node.path_items\n        ]\n        return new\n\n    new = PaintedPath.__new__(PaintedPath)\n    root = clone_structure(node.get_graphics_context())\n    object.__setattr__(new, \"_root_graphics_context\", root)\n    object.__setattr__(new, \"_graphics_context\", root)\n    object.__setattr__(\n        new, \"_closed\", node._closed  # pyright: ignore[reportPrivateUsage]\n    )\n    object.__setattr__(new, \"_close_context\", root)\n    object.__setattr__(\n        new,\n        \"_starter_move\",\n        node._starter_move,  # pyright: ignore[reportPrivateUsage]\n    )\n    return new",
      "language": "python"
    },
    {
      "code": "class Arc(NamedTuple):\n    \"\"\"\n    An elliptical arc path element.\n\n    The arc is drawn from the end of the current path element to its specified end point\n    using a number of parameters to determine how it is constructed.\n\n    See: `PaintedPath.arc_to`\n    \"\"\"\n\n    radii: Point\n    \"\"\"\n    The x- and y-radii of the arc. If `radii.x == radii.y` the arc will be circular.\n    \"\"\"\n    rotation: Number\n    \"\"\"The rotation of the arc's major/minor axes relative to the coordinate frame.\"\"\"\n    large: bool\n    \"\"\"If True, sweep the arc over an angle greater than or equal to 180 degrees.\"\"\"\n    sweep: bool\n    \"\"\"If True, the arc is swept in the positive angular direction.\"\"\"\n    end: Point\n    \"\"\"The end point of the arc.\"\"\"\n\n    @property\n    def end_point(self) -> Point:\n        \"\"\"The end point of this path element.\"\"\"\n        return self.end\n\n    @staticmethod\n    @force_nodocument\n    def subdivide_sweep(\n        sweep_angle: float,\n    ) -> Generator[tuple[Point, Point, Point], None, None]:\n        \"\"\"\n        A generator that subdivides a swept angle into segments no larger than a quarter\n        turn.\n\n        Any sweep that is larger than a quarter turn is subdivided into as many equally\n        sized segments as necessary to prevent any individual segment from being larger\n        than a quarter turn.\n\n        This is used for approximating a circular curve segment using cubic Bézier\n        curves. This computes the parameters used for the Bézier approximation up\n        front, as well as the transform necessary to place the segment in the correct\n        position.\n\n        Args:\n            sweep_angle (float): the angle to subdivide.\n\n        Yields:\n            A tuple of (ctrl1, ctrl2, end) representing the control and end points of\n            the cubic Bézier curve approximating the segment as a unit circle centered\n            at the origin.\n        \"\"\"\n        sweep_angle = abs(sweep_angle)\n        sweep_left = sweep_angle\n\n        quarterturn = math.pi / 2\n        chunks = math.ceil(sweep_angle / quarterturn)\n\n        sweep_segment = sweep_angle / chunks\n        cos_t = math.cos(sweep_segment)\n        sin_t = math.sin(sweep_segment)\n        kappa = 4 / 3 * math.tan(sweep_segment / 4)\n\n        ctrl1 = Point(1, kappa)\n        ctrl2 = Point(cos_t + kappa * sin_t, sin_t - kappa * cos_t)\n        end = Point(cos_t, sin_t)\n\n        for _ in range(chunks):\n            offset = sweep_angle - sweep_left\n\n            transform = Transform.rotation(offset)\n            yield ctrl1 @ transform, ctrl2 @ transform, end @ transform\n\n            sweep_left -= sweep_segment\n\n    def _approximate_arc(self, last_item: Renderable) -> list[BezierCurve]:\n        \"\"\"\n        Approximate this arc with a sequence of `BezierCurve`.\n\n        Args:\n            last_item: the previous path element (used for its end point)\n\n        Returns:\n            a list of `BezierCurve`.\n        \"\"\"\n        radii = self.radii\n\n        reverse = Transform.rotation(-self.rotation)\n        forward = Transform.rotation(self.rotation)\n\n        prime = ((last_item.end_point - self.end) * 0.5) @ reverse\n\n        lam_da = (prime.x / radii.x) ** 2 + (prime.y / radii.y) ** 2\n\n        if lam_da > 1:\n            radii = Point(x=(lam_da**0.5) * radii.x, y=(lam_da**0.5) * radii.y)\n\n        sign = (self.large != self.sweep) - (self.large == self.sweep)\n        rxry2 = (radii.x * radii.y) ** 2\n        rxpy2 = (radii.x * prime.y) ** 2\n        rypx2 = (radii.y * prime.x) ** 2\n\n        centerprime = (\n            sign\n            * math.sqrt(round(rxry2 - rxpy2 - rypx2, 8) / (rxpy2 + rypx2))\n            * Point(\n                x=radii.x * prime.y / radii.y,\n                y=-radii.y * prime.x / radii.x,\n            )\n        )\n\n        center = (centerprime @ forward) + ((last_item.end_point + self.end) * 0.5)\n\n        arcstart = Point(\n            x=(prime.x - centerprime.x) / radii.x,\n            y=(prime.y - centerprime.y) / radii.y,\n        )\n        arcend = Point(\n            x=(-prime.x - centerprime.x) / radii.x,\n            y=(-prime.y - centerprime.y) / radii.y,\n        )\n\n        theta = Point(1, 0).angle(arcstart)\n        deltatheta = arcstart.angle(arcend)\n\n        if (self.sweep is False) and (deltatheta > 0):\n            deltatheta -= math.tau\n        elif (self.sweep is True) and (deltatheta < 0):\n            deltatheta += math.tau\n\n        sweep_sign = (deltatheta >= 0) - (deltatheta < 0)\n        final_tf = (\n            Transform.scaling(x=1, y=sweep_sign)  # flip negative sweeps\n            .rotate(theta)  # rotate start of arc to correct position\n            .scale(radii.x, radii.y)  # scale unit circle into the final ellipse shape\n            .rotate(self.rotation)  # rotate the ellipse the specified angle\n            .translate(center.x, center.y)  # translate to the final coordinates\n        )\n\n        curves: list[BezierCurve] = []\n\n        for ctrl1, ctrl2, end in self.subdivide_sweep(deltatheta):\n            curves.append(\n                BezierCurve(ctrl1 @ final_tf, ctrl2 @ final_tf, end @ final_tf)\n            )\n\n        return curves\n\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        \"\"\"\n        Compute the bounding box of this arc by approximating it with a series of\n        Bezier curves and aggregating their bounding boxes.\n        \"\"\"\n        bbox = BoundingBox.empty()\n        prev: Renderable = Move(start)\n\n        for curve in self._approximate_arc(prev):\n            segment_bbox, _ = curve.bounding_box(prev.end_point)\n            bbox = bbox.merge(segment_bbox)\n            prev = curve\n\n        return bbox, self.end\n\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        \"\"\"\n        Render this path element to its PDF representation.\n\n        Args:\n            resource_registry (ResourceCatalog): the owner's graphics state\n                dictionary registry.\n            style (GraphicsStyle): the current resolved graphics style\n            last_item: the previous path element.\n            initial_point: last position set by a \"M\" or \"m\" command\n\n        Returns:\n            a tuple of `(str, new_last_item)`, where `new_last_item` is a resolved\n            `BezierCurve`.\n        \"\"\"\n        curves = self._approximate_arc(last_item)\n\n        if not curves:\n            return \"\", last_item, initial_point\n\n        return (\n            \" \".join(\n                curve.render(resource_registry, style, prev, initial_point)[0]\n                for prev, curve in zip([last_item, *curves[:-1]], curves)\n            ),\n            curves[-1],\n            initial_point,\n        )",
      "language": "python"
    },
    {
      "code": "@staticmethod\n@force_nodocument\ndef subdivide_sweep(\n    sweep_angle: float,\n) -> Generator[tuple[Point, Point, Point], None, None]:\n    \"\"\"\n    A generator that subdivides a swept angle into segments no larger than a quarter\n    turn.\n\n    Any sweep that is larger than a quarter turn is subdivided into as many equally\n    sized segments as necessary to prevent any individual segment from being larger\n    than a quarter turn.\n\n    This is used for approximating a circular curve segment using cubic Bézier\n    curves. This computes the parameters used for the Bézier approximation up\n    front, as well as the transform necessary to place the segment in the correct\n    position.\n\n    Args:\n        sweep_angle (float): the angle to subdivide.\n\n    Yields:\n        A tuple of (ctrl1, ctrl2, end) representing the control and end points of\n        the cubic Bézier curve approximating the segment as a unit circle centered\n        at the origin.\n    \"\"\"\n    sweep_angle = abs(sweep_angle)\n    sweep_left = sweep_angle\n\n    quarterturn = math.pi / 2\n    chunks = math.ceil(sweep_angle / quarterturn)\n\n    sweep_segment = sweep_angle / chunks\n    cos_t = math.cos(sweep_segment)\n    sin_t = math.sin(sweep_segment)\n    kappa = 4 / 3 * math.tan(sweep_segment / 4)\n\n    ctrl1 = Point(1, kappa)\n    ctrl2 = Point(cos_t + kappa * sin_t, sin_t - kappa * cos_t)\n    end = Point(cos_t, sin_t)\n\n    for _ in range(chunks):\n        offset = sweep_angle - sweep_left\n\n        transform = Transform.rotation(offset)\n        yield ctrl1 @ transform, ctrl2 @ transform, end @ transform\n\n        sweep_left -= sweep_segment",
      "language": "python"
    },
    {
      "code": "class Arc(NamedTuple):\n    \"\"\"\n    An elliptical arc path element.\n\n    The arc is drawn from the end of the current path element to its specified end point\n    using a number of parameters to determine how it is constructed.\n\n    See: `PaintedPath.arc_to`\n    \"\"\"\n\n    radii: Point\n    \"\"\"\n    The x- and y-radii of the arc. If `radii.x == radii.y` the arc will be circular.\n    \"\"\"\n    rotation: Number\n    \"\"\"The rotation of the arc's major/minor axes relative to the coordinate frame.\"\"\"\n    large: bool\n    \"\"\"If True, sweep the arc over an angle greater than or equal to 180 degrees.\"\"\"\n    sweep: bool\n    \"\"\"If True, the arc is swept in the positive angular direction.\"\"\"\n    end: Point\n    \"\"\"The end point of the arc.\"\"\"\n\n    @property\n    def end_point(self) -> Point:\n        \"\"\"The end point of this path element.\"\"\"\n        return self.end\n\n    @staticmethod\n    @force_nodocument\n    def subdivide_sweep(\n        sweep_angle: float,\n    ) -> Generator[tuple[Point, Point, Point], None, None]:\n        \"\"\"\n        A generator that subdivides a swept angle into segments no larger than a quarter\n        turn.\n\n        Any sweep that is larger than a quarter turn is subdivided into as many equally\n        sized segments as necessary to prevent any individual segment from being larger\n        than a quarter turn.\n\n        This is used for approximating a circular curve segment using cubic Bézier\n        curves. This computes the parameters used for the Bézier approximation up\n        front, as well as the transform necessary to place the segment in the correct\n        position.\n\n        Args:\n            sweep_angle (float): the angle to subdivide.\n\n        Yields:\n            A tuple of (ctrl1, ctrl2, end) representing the control and end points of\n            the cubic Bézier curve approximating the segment as a unit circle centered\n            at the origin.\n        \"\"\"\n        sweep_angle = abs(sweep_angle)\n        sweep_left = sweep_angle\n\n        quarterturn = math.pi / 2\n        chunks = math.ceil(sweep_angle / quarterturn)\n\n        sweep_segment = sweep_angle / chunks\n        cos_t = math.cos(sweep_segment)\n        sin_t = math.sin(sweep_segment)\n        kappa = 4 / 3 * math.tan(sweep_segment / 4)\n\n        ctrl1 = Point(1, kappa)\n        ctrl2 = Point(cos_t + kappa * sin_t, sin_t - kappa * cos_t)\n        end = Point(cos_t, sin_t)\n\n        for _ in range(chunks):\n            offset = sweep_angle - sweep_left\n\n            transform = Transform.rotation(offset)\n            yield ctrl1 @ transform, ctrl2 @ transform, end @ transform\n\n            sweep_left -= sweep_segment\n\n    def _approximate_arc(self, last_item: Renderable) -> list[BezierCurve]:\n        \"\"\"\n        Approximate this arc with a sequence of `BezierCurve`.\n\n        Args:\n            last_item: the previous path element (used for its end point)\n\n        Returns:\n            a list of `BezierCurve`.\n        \"\"\"\n        radii = self.radii\n\n        reverse = Transform.rotation(-self.rotation)\n        forward = Transform.rotation(self.rotation)\n\n        prime = ((last_item.end_point - self.end) * 0.5) @ reverse\n\n        lam_da = (prime.x / radii.x) ** 2 + (prime.y / radii.y) ** 2\n\n        if lam_da > 1:\n            radii = Point(x=(lam_da**0.5) * radii.x, y=(lam_da**0.5) * radii.y)\n\n        sign = (self.large != self.sweep) - (self.large == self.sweep)\n        rxry2 = (radii.x * radii.y) ** 2\n        rxpy2 = (radii.x * prime.y) ** 2\n        rypx2 = (radii.y * prime.x) ** 2\n\n        centerprime = (\n            sign\n            * math.sqrt(round(rxry2 - rxpy2 - rypx2, 8) / (rxpy2 + rypx2))\n            * Point(\n                x=radii.x * prime.y / radii.y,\n                y=-radii.y * prime.x / radii.x,\n            )\n        )\n\n        center = (centerprime @ forward) + ((last_item.end_point + self.end) * 0.5)\n\n        arcstart = Point(\n            x=(prime.x - centerprime.x) / radii.x,\n            y=(prime.y - centerprime.y) / radii.y,\n        )\n        arcend = Point(\n            x=(-prime.x - centerprime.x) / radii.x,\n            y=(-prime.y - centerprime.y) / radii.y,\n        )\n\n        theta = Point(1, 0).angle(arcstart)\n        deltatheta = arcstart.angle(arcend)\n\n        if (self.sweep is False) and (deltatheta > 0):\n            deltatheta -= math.tau\n        elif (self.sweep is True) and (deltatheta < 0):\n            deltatheta += math.tau\n\n        sweep_sign = (deltatheta >= 0) - (deltatheta < 0)\n        final_tf = (\n            Transform.scaling(x=1, y=sweep_sign)  # flip negative sweeps\n            .rotate(theta)  # rotate start of arc to correct position\n            .scale(radii.x, radii.y)  # scale unit circle into the final ellipse shape\n            .rotate(self.rotation)  # rotate the ellipse the specified angle\n            .translate(center.x, center.y)  # translate to the final coordinates\n        )\n\n        curves: list[BezierCurve] = []\n\n        for ctrl1, ctrl2, end in self.subdivide_sweep(deltatheta):\n            curves.append(\n                BezierCurve(ctrl1 @ final_tf, ctrl2 @ final_tf, end @ final_tf)\n            )\n\n        return curves\n\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        \"\"\"\n        Compute the bounding box of this arc by approximating it with a series of\n        Bezier curves and aggregating their bounding boxes.\n        \"\"\"\n        bbox = BoundingBox.empty()\n        prev: Renderable = Move(start)\n\n        for curve in self._approximate_arc(prev):\n            segment_bbox, _ = curve.bounding_box(prev.end_point)\n            bbox = bbox.merge(segment_bbox)\n            prev = curve\n\n        return bbox, self.end\n\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        \"\"\"\n        Render this path element to its PDF representation.\n\n        Args:\n            resource_registry (ResourceCatalog): the owner's graphics state\n                dictionary registry.\n            style (GraphicsStyle): the current resolved graphics style\n            last_item: the previous path element.\n            initial_point: last position set by a \"M\" or \"m\" command\n\n        Returns:\n            a tuple of `(str, new_last_item)`, where `new_last_item` is a resolved\n            `BezierCurve`.\n        \"\"\"\n        curves = self._approximate_arc(last_item)\n\n        if not curves:\n            return \"\", last_item, initial_point\n\n        return (\n            \" \".join(\n                curve.render(resource_registry, style, prev, initial_point)[0]\n                for prev, curve in zip([last_item, *curves[:-1]], curves)\n            ),\n            curves[-1],\n            initial_point,\n        )",
      "language": "python"
    },
    {
      "code": "@property\ndef end_point(self) -> Point:\n    \"\"\"The end point of this path element.\"\"\"\n    return self.end",
      "language": "python"
    },
    {
      "code": "class Arc(NamedTuple):\n    \"\"\"\n    An elliptical arc path element.\n\n    The arc is drawn from the end of the current path element to its specified end point\n    using a number of parameters to determine how it is constructed.\n\n    See: `PaintedPath.arc_to`\n    \"\"\"\n\n    radii: Point\n    \"\"\"\n    The x- and y-radii of the arc. If `radii.x == radii.y` the arc will be circular.\n    \"\"\"\n    rotation: Number\n    \"\"\"The rotation of the arc's major/minor axes relative to the coordinate frame.\"\"\"\n    large: bool\n    \"\"\"If True, sweep the arc over an angle greater than or equal to 180 degrees.\"\"\"\n    sweep: bool\n    \"\"\"If True, the arc is swept in the positive angular direction.\"\"\"\n    end: Point\n    \"\"\"The end point of the arc.\"\"\"\n\n    @property\n    def end_point(self) -> Point:\n        \"\"\"The end point of this path element.\"\"\"\n        return self.end\n\n    @staticmethod\n    @force_nodocument\n    def subdivide_sweep(\n        sweep_angle: float,\n    ) -> Generator[tuple[Point, Point, Point], None, None]:\n        \"\"\"\n        A generator that subdivides a swept angle into segments no larger than a quarter\n        turn.\n\n        Any sweep that is larger than a quarter turn is subdivided into as many equally\n        sized segments as necessary to prevent any individual segment from being larger\n        than a quarter turn.\n\n        This is used for approximating a circular curve segment using cubic Bézier\n        curves. This computes the parameters used for the Bézier approximation up\n        front, as well as the transform necessary to place the segment in the correct\n        position.\n\n        Args:\n            sweep_angle (float): the angle to subdivide.\n\n        Yields:\n            A tuple of (ctrl1, ctrl2, end) representing the control and end points of\n            the cubic Bézier curve approximating the segment as a unit circle centered\n            at the origin.\n        \"\"\"\n        sweep_angle = abs(sweep_angle)\n        sweep_left = sweep_angle\n\n        quarterturn = math.pi / 2\n        chunks = math.ceil(sweep_angle / quarterturn)\n\n        sweep_segment = sweep_angle / chunks\n        cos_t = math.cos(sweep_segment)\n        sin_t = math.sin(sweep_segment)\n        kappa = 4 / 3 * math.tan(sweep_segment / 4)\n\n        ctrl1 = Point(1, kappa)\n        ctrl2 = Point(cos_t + kappa * sin_t, sin_t - kappa * cos_t)\n        end = Point(cos_t, sin_t)\n\n        for _ in range(chunks):\n            offset = sweep_angle - sweep_left\n\n            transform = Transform.rotation(offset)\n            yield ctrl1 @ transform, ctrl2 @ transform, end @ transform\n\n            sweep_left -= sweep_segment\n\n    def _approximate_arc(self, last_item: Renderable) -> list[BezierCurve]:\n        \"\"\"\n        Approximate this arc with a sequence of `BezierCurve`.\n\n        Args:\n            last_item: the previous path element (used for its end point)\n\n        Returns:\n            a list of `BezierCurve`.\n        \"\"\"\n        radii = self.radii\n\n        reverse = Transform.rotation(-self.rotation)\n        forward = Transform.rotation(self.rotation)\n\n        prime = ((last_item.end_point - self.end) * 0.5) @ reverse\n\n        lam_da = (prime.x / radii.x) ** 2 + (prime.y / radii.y) ** 2\n\n        if lam_da > 1:\n            radii = Point(x=(lam_da**0.5) * radii.x, y=(lam_da**0.5) * radii.y)\n\n        sign = (self.large != self.sweep) - (self.large == self.sweep)\n        rxry2 = (radii.x * radii.y) ** 2\n        rxpy2 = (radii.x * prime.y) ** 2\n        rypx2 = (radii.y * prime.x) ** 2\n\n        centerprime = (\n            sign\n            * math.sqrt(round(rxry2 - rxpy2 - rypx2, 8) / (rxpy2 + rypx2))\n            * Point(\n                x=radii.x * prime.y / radii.y,\n                y=-radii.y * prime.x / radii.x,\n            )\n        )\n\n        center = (centerprime @ forward) + ((last_item.end_point + self.end) * 0.5)\n\n        arcstart = Point(\n            x=(prime.x - centerprime.x) / radii.x,\n            y=(prime.y - centerprime.y) / radii.y,\n        )\n        arcend = Point(\n            x=(-prime.x - centerprime.x) / radii.x,\n            y=(-prime.y - centerprime.y) / radii.y,\n        )\n\n        theta = Point(1, 0).angle(arcstart)\n        deltatheta = arcstart.angle(arcend)\n\n        if (self.sweep is False) and (deltatheta > 0):\n            deltatheta -= math.tau\n        elif (self.sweep is True) and (deltatheta < 0):\n            deltatheta += math.tau\n\n        sweep_sign = (deltatheta >= 0) - (deltatheta < 0)\n        final_tf = (\n            Transform.scaling(x=1, y=sweep_sign)  # flip negative sweeps\n            .rotate(theta)  # rotate start of arc to correct position\n            .scale(radii.x, radii.y)  # scale unit circle into the final ellipse shape\n            .rotate(self.rotation)  # rotate the ellipse the specified angle\n            .translate(center.x, center.y)  # translate to the final coordinates\n        )\n\n        curves: list[BezierCurve] = []\n\n        for ctrl1, ctrl2, end in self.subdivide_sweep(deltatheta):\n            curves.append(\n                BezierCurve(ctrl1 @ final_tf, ctrl2 @ final_tf, end @ final_tf)\n            )\n\n        return curves\n\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        \"\"\"\n        Compute the bounding box of this arc by approximating it with a series of\n        Bezier curves and aggregating their bounding boxes.\n        \"\"\"\n        bbox = BoundingBox.empty()\n        prev: Renderable = Move(start)\n\n        for curve in self._approximate_arc(prev):\n            segment_bbox, _ = curve.bounding_box(prev.end_point)\n            bbox = bbox.merge(segment_bbox)\n            prev = curve\n\n        return bbox, self.end\n\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        \"\"\"\n        Render this path element to its PDF representation.\n\n        Args:\n            resource_registry (ResourceCatalog): the owner's graphics state\n                dictionary registry.\n            style (GraphicsStyle): the current resolved graphics style\n            last_item: the previous path element.\n            initial_point: last position set by a \"M\" or \"m\" command\n\n        Returns:\n            a tuple of `(str, new_last_item)`, where `new_last_item` is a resolved\n            `BezierCurve`.\n        \"\"\"\n        curves = self._approximate_arc(last_item)\n\n        if not curves:\n            return \"\", last_item, initial_point\n\n        return (\n            \" \".join(\n                curve.render(resource_registry, style, prev, initial_point)[0]\n                for prev, curve in zip([last_item, *curves[:-1]], curves)\n            ),\n            curves[-1],\n            initial_point,\n        )",
      "language": "python"
    },
    {
      "code": "class Arc(NamedTuple):\n    \"\"\"\n    An elliptical arc path element.\n\n    The arc is drawn from the end of the current path element to its specified end point\n    using a number of parameters to determine how it is constructed.\n\n    See: `PaintedPath.arc_to`\n    \"\"\"\n\n    radii: Point\n    \"\"\"\n    The x- and y-radii of the arc. If `radii.x == radii.y` the arc will be circular.\n    \"\"\"\n    rotation: Number\n    \"\"\"The rotation of the arc's major/minor axes relative to the coordinate frame.\"\"\"\n    large: bool\n    \"\"\"If True, sweep the arc over an angle greater than or equal to 180 degrees.\"\"\"\n    sweep: bool\n    \"\"\"If True, the arc is swept in the positive angular direction.\"\"\"\n    end: Point\n    \"\"\"The end point of the arc.\"\"\"\n\n    @property\n    def end_point(self) -> Point:\n        \"\"\"The end point of this path element.\"\"\"\n        return self.end\n\n    @staticmethod\n    @force_nodocument\n    def subdivide_sweep(\n        sweep_angle: float,\n    ) -> Generator[tuple[Point, Point, Point], None, None]:\n        \"\"\"\n        A generator that subdivides a swept angle into segments no larger than a quarter\n        turn.\n\n        Any sweep that is larger than a quarter turn is subdivided into as many equally\n        sized segments as necessary to prevent any individual segment from being larger\n        than a quarter turn.\n\n        This is used for approximating a circular curve segment using cubic Bézier\n        curves. This computes the parameters used for the Bézier approximation up\n        front, as well as the transform necessary to place the segment in the correct\n        position.\n\n        Args:\n            sweep_angle (float): the angle to subdivide.\n\n        Yields:\n            A tuple of (ctrl1, ctrl2, end) representing the control and end points of\n            the cubic Bézier curve approximating the segment as a unit circle centered\n            at the origin.\n        \"\"\"\n        sweep_angle = abs(sweep_angle)\n        sweep_left = sweep_angle\n\n        quarterturn = math.pi / 2\n        chunks = math.ceil(sweep_angle / quarterturn)\n\n        sweep_segment = sweep_angle / chunks\n        cos_t = math.cos(sweep_segment)\n        sin_t = math.sin(sweep_segment)\n        kappa = 4 / 3 * math.tan(sweep_segment / 4)\n\n        ctrl1 = Point(1, kappa)\n        ctrl2 = Point(cos_t + kappa * sin_t, sin_t - kappa * cos_t)\n        end = Point(cos_t, sin_t)\n\n        for _ in range(chunks):\n            offset = sweep_angle - sweep_left\n\n            transform = Transform.rotation(offset)\n            yield ctrl1 @ transform, ctrl2 @ transform, end @ transform\n\n            sweep_left -= sweep_segment\n\n    def _approximate_arc(self, last_item: Renderable) -> list[BezierCurve]:\n        \"\"\"\n        Approximate this arc with a sequence of `BezierCurve`.\n\n        Args:\n            last_item: the previous path element (used for its end point)\n\n        Returns:\n            a list of `BezierCurve`.\n        \"\"\"\n        radii = self.radii\n\n        reverse = Transform.rotation(-self.rotation)\n        forward = Transform.rotation(self.rotation)\n\n        prime = ((last_item.end_point - self.end) * 0.5) @ reverse\n\n        lam_da = (prime.x / radii.x) ** 2 + (prime.y / radii.y) ** 2\n\n        if lam_da > 1:\n            radii = Point(x=(lam_da**0.5) * radii.x, y=(lam_da**0.5) * radii.y)\n\n        sign = (self.large != self.sweep) - (self.large == self.sweep)\n        rxry2 = (radii.x * radii.y) ** 2\n        rxpy2 = (radii.x * prime.y) ** 2\n        rypx2 = (radii.y * prime.x) ** 2\n\n        centerprime = (\n            sign\n            * math.sqrt(round(rxry2 - rxpy2 - rypx2, 8) / (rxpy2 + rypx2))\n            * Point(\n                x=radii.x * prime.y / radii.y,\n                y=-radii.y * prime.x / radii.x,\n            )\n        )\n\n        center = (centerprime @ forward) + ((last_item.end_point + self.end) * 0.5)\n\n        arcstart = Point(\n            x=(prime.x - centerprime.x) / radii.x,\n            y=(prime.y - centerprime.y) / radii.y,\n        )\n        arcend = Point(\n            x=(-prime.x - centerprime.x) / radii.x,\n            y=(-prime.y - centerprime.y) / radii.y,\n        )\n\n        theta = Point(1, 0).angle(arcstart)\n        deltatheta = arcstart.angle(arcend)\n\n        if (self.sweep is False) and (deltatheta > 0):\n            deltatheta -= math.tau\n        elif (self.sweep is True) and (deltatheta < 0):\n            deltatheta += math.tau\n\n        sweep_sign = (deltatheta >= 0) - (deltatheta < 0)\n        final_tf = (\n            Transform.scaling(x=1, y=sweep_sign)  # flip negative sweeps\n            .rotate(theta)  # rotate start of arc to correct position\n            .scale(radii.x, radii.y)  # scale unit circle into the final ellipse shape\n            .rotate(self.rotation)  # rotate the ellipse the specified angle\n            .translate(center.x, center.y)  # translate to the final coordinates\n        )\n\n        curves: list[BezierCurve] = []\n\n        for ctrl1, ctrl2, end in self.subdivide_sweep(deltatheta):\n            curves.append(\n                BezierCurve(ctrl1 @ final_tf, ctrl2 @ final_tf, end @ final_tf)\n            )\n\n        return curves\n\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        \"\"\"\n        Compute the bounding box of this arc by approximating it with a series of\n        Bezier curves and aggregating their bounding boxes.\n        \"\"\"\n        bbox = BoundingBox.empty()\n        prev: Renderable = Move(start)\n\n        for curve in self._approximate_arc(prev):\n            segment_bbox, _ = curve.bounding_box(prev.end_point)\n            bbox = bbox.merge(segment_bbox)\n            prev = curve\n\n        return bbox, self.end\n\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        \"\"\"\n        Render this path element to its PDF representation.\n\n        Args:\n            resource_registry (ResourceCatalog): the owner's graphics state\n                dictionary registry.\n            style (GraphicsStyle): the current resolved graphics style\n            last_item: the previous path element.\n            initial_point: last position set by a \"M\" or \"m\" command\n\n        Returns:\n            a tuple of `(str, new_last_item)`, where `new_last_item` is a resolved\n            `BezierCurve`.\n        \"\"\"\n        curves = self._approximate_arc(last_item)\n\n        if not curves:\n            return \"\", last_item, initial_point\n\n        return (\n            \" \".join(\n                curve.render(resource_registry, style, prev, initial_point)[0]\n                for prev, curve in zip([last_item, *curves[:-1]], curves)\n            ),\n            curves[-1],\n            initial_point,\n        )",
      "language": "python"
    },
    {
      "code": "class Arc(NamedTuple):\n    \"\"\"\n    An elliptical arc path element.\n\n    The arc is drawn from the end of the current path element to its specified end point\n    using a number of parameters to determine how it is constructed.\n\n    See: `PaintedPath.arc_to`\n    \"\"\"\n\n    radii: Point\n    \"\"\"\n    The x- and y-radii of the arc. If `radii.x == radii.y` the arc will be circular.\n    \"\"\"\n    rotation: Number\n    \"\"\"The rotation of the arc's major/minor axes relative to the coordinate frame.\"\"\"\n    large: bool\n    \"\"\"If True, sweep the arc over an angle greater than or equal to 180 degrees.\"\"\"\n    sweep: bool\n    \"\"\"If True, the arc is swept in the positive angular direction.\"\"\"\n    end: Point\n    \"\"\"The end point of the arc.\"\"\"\n\n    @property\n    def end_point(self) -> Point:\n        \"\"\"The end point of this path element.\"\"\"\n        return self.end\n\n    @staticmethod\n    @force_nodocument\n    def subdivide_sweep(\n        sweep_angle: float,\n    ) -> Generator[tuple[Point, Point, Point], None, None]:\n        \"\"\"\n        A generator that subdivides a swept angle into segments no larger than a quarter\n        turn.\n\n        Any sweep that is larger than a quarter turn is subdivided into as many equally\n        sized segments as necessary to prevent any individual segment from being larger\n        than a quarter turn.\n\n        This is used for approximating a circular curve segment using cubic Bézier\n        curves. This computes the parameters used for the Bézier approximation up\n        front, as well as the transform necessary to place the segment in the correct\n        position.\n\n        Args:\n            sweep_angle (float): the angle to subdivide.\n\n        Yields:\n            A tuple of (ctrl1, ctrl2, end) representing the control and end points of\n            the cubic Bézier curve approximating the segment as a unit circle centered\n            at the origin.\n        \"\"\"\n        sweep_angle = abs(sweep_angle)\n        sweep_left = sweep_angle\n\n        quarterturn = math.pi / 2\n        chunks = math.ceil(sweep_angle / quarterturn)\n\n        sweep_segment = sweep_angle / chunks\n        cos_t = math.cos(sweep_segment)\n        sin_t = math.sin(sweep_segment)\n        kappa = 4 / 3 * math.tan(sweep_segment / 4)\n\n        ctrl1 = Point(1, kappa)\n        ctrl2 = Point(cos_t + kappa * sin_t, sin_t - kappa * cos_t)\n        end = Point(cos_t, sin_t)\n\n        for _ in range(chunks):\n            offset = sweep_angle - sweep_left\n\n            transform = Transform.rotation(offset)\n            yield ctrl1 @ transform, ctrl2 @ transform, end @ transform\n\n            sweep_left -= sweep_segment\n\n    def _approximate_arc(self, last_item: Renderable) -> list[BezierCurve]:\n        \"\"\"\n        Approximate this arc with a sequence of `BezierCurve`.\n\n        Args:\n            last_item: the previous path element (used for its end point)\n\n        Returns:\n            a list of `BezierCurve`.\n        \"\"\"\n        radii = self.radii\n\n        reverse = Transform.rotation(-self.rotation)\n        forward = Transform.rotation(self.rotation)\n\n        prime = ((last_item.end_point - self.end) * 0.5) @ reverse\n\n        lam_da = (prime.x / radii.x) ** 2 + (prime.y / radii.y) ** 2\n\n        if lam_da > 1:\n            radii = Point(x=(lam_da**0.5) * radii.x, y=(lam_da**0.5) * radii.y)\n\n        sign = (self.large != self.sweep) - (self.large == self.sweep)\n        rxry2 = (radii.x * radii.y) ** 2\n        rxpy2 = (radii.x * prime.y) ** 2\n        rypx2 = (radii.y * prime.x) ** 2\n\n        centerprime = (\n            sign\n            * math.sqrt(round(rxry2 - rxpy2 - rypx2, 8) / (rxpy2 + rypx2))\n            * Point(\n                x=radii.x * prime.y / radii.y,\n                y=-radii.y * prime.x / radii.x,\n            )\n        )\n\n        center = (centerprime @ forward) + ((last_item.end_point + self.end) * 0.5)\n\n        arcstart = Point(\n            x=(prime.x - centerprime.x) / radii.x,\n            y=(prime.y - centerprime.y) / radii.y,\n        )\n        arcend = Point(\n            x=(-prime.x - centerprime.x) / radii.x,\n            y=(-prime.y - centerprime.y) / radii.y,\n        )\n\n        theta = Point(1, 0).angle(arcstart)\n        deltatheta = arcstart.angle(arcend)\n\n        if (self.sweep is False) and (deltatheta > 0):\n            deltatheta -= math.tau\n        elif (self.sweep is True) and (deltatheta < 0):\n            deltatheta += math.tau\n\n        sweep_sign = (deltatheta >= 0) - (deltatheta < 0)\n        final_tf = (\n            Transform.scaling(x=1, y=sweep_sign)  # flip negative sweeps\n            .rotate(theta)  # rotate start of arc to correct position\n            .scale(radii.x, radii.y)  # scale unit circle into the final ellipse shape\n            .rotate(self.rotation)  # rotate the ellipse the specified angle\n            .translate(center.x, center.y)  # translate to the final coordinates\n        )\n\n        curves: list[BezierCurve] = []\n\n        for ctrl1, ctrl2, end in self.subdivide_sweep(deltatheta):\n            curves.append(\n                BezierCurve(ctrl1 @ final_tf, ctrl2 @ final_tf, end @ final_tf)\n            )\n\n        return curves\n\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        \"\"\"\n        Compute the bounding box of this arc by approximating it with a series of\n        Bezier curves and aggregating their bounding boxes.\n        \"\"\"\n        bbox = BoundingBox.empty()\n        prev: Renderable = Move(start)\n\n        for curve in self._approximate_arc(prev):\n            segment_bbox, _ = curve.bounding_box(prev.end_point)\n            bbox = bbox.merge(segment_bbox)\n            prev = curve\n\n        return bbox, self.end\n\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        \"\"\"\n        Render this path element to its PDF representation.\n\n        Args:\n            resource_registry (ResourceCatalog): the owner's graphics state\n                dictionary registry.\n            style (GraphicsStyle): the current resolved graphics style\n            last_item: the previous path element.\n            initial_point: last position set by a \"M\" or \"m\" command\n\n        Returns:\n            a tuple of `(str, new_last_item)`, where `new_last_item` is a resolved\n            `BezierCurve`.\n        \"\"\"\n        curves = self._approximate_arc(last_item)\n\n        if not curves:\n            return \"\", last_item, initial_point\n\n        return (\n            \" \".join(\n                curve.render(resource_registry, style, prev, initial_point)[0]\n                for prev, curve in zip([last_item, *curves[:-1]], curves)\n            ),\n            curves[-1],\n            initial_point,\n        )",
      "language": "python"
    },
    {
      "code": "class Arc(NamedTuple):\n    \"\"\"\n    An elliptical arc path element.\n\n    The arc is drawn from the end of the current path element to its specified end point\n    using a number of parameters to determine how it is constructed.\n\n    See: `PaintedPath.arc_to`\n    \"\"\"\n\n    radii: Point\n    \"\"\"\n    The x- and y-radii of the arc. If `radii.x == radii.y` the arc will be circular.\n    \"\"\"\n    rotation: Number\n    \"\"\"The rotation of the arc's major/minor axes relative to the coordinate frame.\"\"\"\n    large: bool\n    \"\"\"If True, sweep the arc over an angle greater than or equal to 180 degrees.\"\"\"\n    sweep: bool\n    \"\"\"If True, the arc is swept in the positive angular direction.\"\"\"\n    end: Point\n    \"\"\"The end point of the arc.\"\"\"\n\n    @property\n    def end_point(self) -> Point:\n        \"\"\"The end point of this path element.\"\"\"\n        return self.end\n\n    @staticmethod\n    @force_nodocument\n    def subdivide_sweep(\n        sweep_angle: float,\n    ) -> Generator[tuple[Point, Point, Point], None, None]:\n        \"\"\"\n        A generator that subdivides a swept angle into segments no larger than a quarter\n        turn.\n\n        Any sweep that is larger than a quarter turn is subdivided into as many equally\n        sized segments as necessary to prevent any individual segment from being larger\n        than a quarter turn.\n\n        This is used for approximating a circular curve segment using cubic Bézier\n        curves. This computes the parameters used for the Bézier approximation up\n        front, as well as the transform necessary to place the segment in the correct\n        position.\n\n        Args:\n            sweep_angle (float): the angle to subdivide.\n\n        Yields:\n            A tuple of (ctrl1, ctrl2, end) representing the control and end points of\n            the cubic Bézier curve approximating the segment as a unit circle centered\n            at the origin.\n        \"\"\"\n        sweep_angle = abs(sweep_angle)\n        sweep_left = sweep_angle\n\n        quarterturn = math.pi / 2\n        chunks = math.ceil(sweep_angle / quarterturn)\n\n        sweep_segment = sweep_angle / chunks\n        cos_t = math.cos(sweep_segment)\n        sin_t = math.sin(sweep_segment)\n        kappa = 4 / 3 * math.tan(sweep_segment / 4)\n\n        ctrl1 = Point(1, kappa)\n        ctrl2 = Point(cos_t + kappa * sin_t, sin_t - kappa * cos_t)\n        end = Point(cos_t, sin_t)\n\n        for _ in range(chunks):\n            offset = sweep_angle - sweep_left\n\n            transform = Transform.rotation(offset)\n            yield ctrl1 @ transform, ctrl2 @ transform, end @ transform\n\n            sweep_left -= sweep_segment\n\n    def _approximate_arc(self, last_item: Renderable) -> list[BezierCurve]:\n        \"\"\"\n        Approximate this arc with a sequence of `BezierCurve`.\n\n        Args:\n            last_item: the previous path element (used for its end point)\n\n        Returns:\n            a list of `BezierCurve`.\n        \"\"\"\n        radii = self.radii\n\n        reverse = Transform.rotation(-self.rotation)\n        forward = Transform.rotation(self.rotation)\n\n        prime = ((last_item.end_point - self.end) * 0.5) @ reverse\n\n        lam_da = (prime.x / radii.x) ** 2 + (prime.y / radii.y) ** 2\n\n        if lam_da > 1:\n            radii = Point(x=(lam_da**0.5) * radii.x, y=(lam_da**0.5) * radii.y)\n\n        sign = (self.large != self.sweep) - (self.large == self.sweep)\n        rxry2 = (radii.x * radii.y) ** 2\n        rxpy2 = (radii.x * prime.y) ** 2\n        rypx2 = (radii.y * prime.x) ** 2\n\n        centerprime = (\n            sign\n            * math.sqrt(round(rxry2 - rxpy2 - rypx2, 8) / (rxpy2 + rypx2))\n            * Point(\n                x=radii.x * prime.y / radii.y,\n                y=-radii.y * prime.x / radii.x,\n            )\n        )\n\n        center = (centerprime @ forward) + ((last_item.end_point + self.end) * 0.5)\n\n        arcstart = Point(\n            x=(prime.x - centerprime.x) / radii.x,\n            y=(prime.y - centerprime.y) / radii.y,\n        )\n        arcend = Point(\n            x=(-prime.x - centerprime.x) / radii.x,\n            y=(-prime.y - centerprime.y) / radii.y,\n        )\n\n        theta = Point(1, 0).angle(arcstart)\n        deltatheta = arcstart.angle(arcend)\n\n        if (self.sweep is False) and (deltatheta > 0):\n            deltatheta -= math.tau\n        elif (self.sweep is True) and (deltatheta < 0):\n            deltatheta += math.tau\n\n        sweep_sign = (deltatheta >= 0) - (deltatheta < 0)\n        final_tf = (\n            Transform.scaling(x=1, y=sweep_sign)  # flip negative sweeps\n            .rotate(theta)  # rotate start of arc to correct position\n            .scale(radii.x, radii.y)  # scale unit circle into the final ellipse shape\n            .rotate(self.rotation)  # rotate the ellipse the specified angle\n            .translate(center.x, center.y)  # translate to the final coordinates\n        )\n\n        curves: list[BezierCurve] = []\n\n        for ctrl1, ctrl2, end in self.subdivide_sweep(deltatheta):\n            curves.append(\n                BezierCurve(ctrl1 @ final_tf, ctrl2 @ final_tf, end @ final_tf)\n            )\n\n        return curves\n\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        \"\"\"\n        Compute the bounding box of this arc by approximating it with a series of\n        Bezier curves and aggregating their bounding boxes.\n        \"\"\"\n        bbox = BoundingBox.empty()\n        prev: Renderable = Move(start)\n\n        for curve in self._approximate_arc(prev):\n            segment_bbox, _ = curve.bounding_box(prev.end_point)\n            bbox = bbox.merge(segment_bbox)\n            prev = curve\n\n        return bbox, self.end\n\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        \"\"\"\n        Render this path element to its PDF representation.\n\n        Args:\n            resource_registry (ResourceCatalog): the owner's graphics state\n                dictionary registry.\n            style (GraphicsStyle): the current resolved graphics style\n            last_item: the previous path element.\n            initial_point: last position set by a \"M\" or \"m\" command\n\n        Returns:\n            a tuple of `(str, new_last_item)`, where `new_last_item` is a resolved\n            `BezierCurve`.\n        \"\"\"\n        curves = self._approximate_arc(last_item)\n\n        if not curves:\n            return \"\", last_item, initial_point\n\n        return (\n            \" \".join(\n                curve.render(resource_registry, style, prev, initial_point)[0]\n                for prev, curve in zip([last_item, *curves[:-1]], curves)\n            ),\n            curves[-1],\n            initial_point,\n        )",
      "language": "python"
    },
    {
      "code": "def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n    \"\"\"\n    Compute the bounding box of this arc by approximating it with a series of\n    Bezier curves and aggregating their bounding boxes.\n    \"\"\"\n    bbox = BoundingBox.empty()\n    prev: Renderable = Move(start)\n\n    for curve in self._approximate_arc(prev):\n        segment_bbox, _ = curve.bounding_box(prev.end_point)\n        bbox = bbox.merge(segment_bbox)\n        prev = curve\n\n    return bbox, self.end",
      "language": "python"
    },
    {
      "code": "@force_nodocument\ndef render(\n    self,\n    resource_registry: \"ResourceCatalog\",\n    style: GraphicsStyle,\n    last_item: Renderable,\n    initial_point: Point,\n) -> tuple[str, Renderable, Point]:\n    \"\"\"\n    Render this path element to its PDF representation.\n\n    Args:\n        resource_registry (ResourceCatalog): the owner's graphics state\n            dictionary registry.\n        style (GraphicsStyle): the current resolved graphics style\n        last_item: the previous path element.\n        initial_point: last position set by a \"M\" or \"m\" command\n\n    Returns:\n        a tuple of `(str, new_last_item)`, where `new_last_item` is a resolved\n        `BezierCurve`.\n    \"\"\"\n    curves = self._approximate_arc(last_item)\n\n    if not curves:\n        return \"\", last_item, initial_point\n\n    return (\n        \" \".join(\n            curve.render(resource_registry, style, prev, initial_point)[0]\n            for prev, curve in zip([last_item, *curves[:-1]], curves)\n        ),\n        curves[-1],\n        initial_point,\n    )",
      "language": "python"
    },
    {
      "code": "class BezierCurve(NamedTuple):\n    \"\"\"\n    A cubic Bézier curve path element.\n\n    This draws a Bézier curve parameterized by the end point of the previous path\n    element, two off-curve control points, and an end point.\n\n    See: `PaintedPath.curve_to`\n    \"\"\"\n\n    c1: Point\n    \"\"\"The curve's first control point.\"\"\"\n    c2: Point\n    \"\"\"The curve's second control point.\"\"\"\n    end: Point\n    \"\"\"The curve's end point.\"\"\"\n\n    @property\n    def end_point(self) -> Point:\n        \"\"\"The end point of this path element.\"\"\"\n        return self.end\n\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        \"\"\"Compute the bounding box of this cubic Bézier curve.\"\"\"\n\n        # Evaluate all candidate t values (endpoints + extrema) for both axes\n        px = [start.x, self.c1.x, self.c2.x, self.end.x]\n        py = [start.y, self.c1.y, self.c2.y, self.end.y]\n\n        tx = [0, 1] + _cubic_bezier_critical_ts_1d(*px)\n        ty = [0, 1] + _cubic_bezier_critical_ts_1d(*py)\n\n        xs = [_eval_cubic_bezier_1d(t, *px) for t in tx]\n        ys = [_eval_cubic_bezier_1d(t, *py) for t in ty]\n\n        bbox = BoundingBox(min(xs), min(ys), max(xs), max(ys))\n        return bbox, self.end\n\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        \"\"\"\n        Render this path element to its PDF representation.\n\n        Args:\n            resource_registry (ResourceCatalog): the owner's graphics state\n                dictionary registry.\n            style (GraphicsStyle): the current resolved graphics style\n            last_item: the previous path element.\n            initial_point: last position set by a \"M\" or \"m\" command\n\n        Returns:\n            a tuple of `(str, new_last_item)`, where `new_last_item` is `self`\n        \"\"\"\n        # pylint: disable=unused-argument\n        return _render_curve(self.c1, self.c2, self.end), self, initial_point",
      "language": "python"
    },
    {
      "code": "class BezierCurve(NamedTuple):\n    \"\"\"\n    A cubic Bézier curve path element.\n\n    This draws a Bézier curve parameterized by the end point of the previous path\n    element, two off-curve control points, and an end point.\n\n    See: `PaintedPath.curve_to`\n    \"\"\"\n\n    c1: Point\n    \"\"\"The curve's first control point.\"\"\"\n    c2: Point\n    \"\"\"The curve's second control point.\"\"\"\n    end: Point\n    \"\"\"The curve's end point.\"\"\"\n\n    @property\n    def end_point(self) -> Point:\n        \"\"\"The end point of this path element.\"\"\"\n        return self.end\n\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        \"\"\"Compute the bounding box of this cubic Bézier curve.\"\"\"\n\n        # Evaluate all candidate t values (endpoints + extrema) for both axes\n        px = [start.x, self.c1.x, self.c2.x, self.end.x]\n        py = [start.y, self.c1.y, self.c2.y, self.end.y]\n\n        tx = [0, 1] + _cubic_bezier_critical_ts_1d(*px)\n        ty = [0, 1] + _cubic_bezier_critical_ts_1d(*py)\n\n        xs = [_eval_cubic_bezier_1d(t, *px) for t in tx]\n        ys = [_eval_cubic_bezier_1d(t, *py) for t in ty]\n\n        bbox = BoundingBox(min(xs), min(ys), max(xs), max(ys))\n        return bbox, self.end\n\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        \"\"\"\n        Render this path element to its PDF representation.\n\n        Args:\n            resource_registry (ResourceCatalog): the owner's graphics state\n                dictionary registry.\n            style (GraphicsStyle): the current resolved graphics style\n            last_item: the previous path element.\n            initial_point: last position set by a \"M\" or \"m\" command\n\n        Returns:\n            a tuple of `(str, new_last_item)`, where `new_last_item` is `self`\n        \"\"\"\n        # pylint: disable=unused-argument\n        return _render_curve(self.c1, self.c2, self.end), self, initial_point",
      "language": "python"
    },
    {
      "code": "class BezierCurve(NamedTuple):\n    \"\"\"\n    A cubic Bézier curve path element.\n\n    This draws a Bézier curve parameterized by the end point of the previous path\n    element, two off-curve control points, and an end point.\n\n    See: `PaintedPath.curve_to`\n    \"\"\"\n\n    c1: Point\n    \"\"\"The curve's first control point.\"\"\"\n    c2: Point\n    \"\"\"The curve's second control point.\"\"\"\n    end: Point\n    \"\"\"The curve's end point.\"\"\"\n\n    @property\n    def end_point(self) -> Point:\n        \"\"\"The end point of this path element.\"\"\"\n        return self.end\n\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        \"\"\"Compute the bounding box of this cubic Bézier curve.\"\"\"\n\n        # Evaluate all candidate t values (endpoints + extrema) for both axes\n        px = [start.x, self.c1.x, self.c2.x, self.end.x]\n        py = [start.y, self.c1.y, self.c2.y, self.end.y]\n\n        tx = [0, 1] + _cubic_bezier_critical_ts_1d(*px)\n        ty = [0, 1] + _cubic_bezier_critical_ts_1d(*py)\n\n        xs = [_eval_cubic_bezier_1d(t, *px) for t in tx]\n        ys = [_eval_cubic_bezier_1d(t, *py) for t in ty]\n\n        bbox = BoundingBox(min(xs), min(ys), max(xs), max(ys))\n        return bbox, self.end\n\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        \"\"\"\n        Render this path element to its PDF representation.\n\n        Args:\n            resource_registry (ResourceCatalog): the owner's graphics state\n                dictionary registry.\n            style (GraphicsStyle): the current resolved graphics style\n            last_item: the previous path element.\n            initial_point: last position set by a \"M\" or \"m\" command\n\n        Returns:\n            a tuple of `(str, new_last_item)`, where `new_last_item` is `self`\n        \"\"\"\n        # pylint: disable=unused-argument\n        return _render_curve(self.c1, self.c2, self.end), self, initial_point",
      "language": "python"
    },
    {
      "code": "class BezierCurve(NamedTuple):\n    \"\"\"\n    A cubic Bézier curve path element.\n\n    This draws a Bézier curve parameterized by the end point of the previous path\n    element, two off-curve control points, and an end point.\n\n    See: `PaintedPath.curve_to`\n    \"\"\"\n\n    c1: Point\n    \"\"\"The curve's first control point.\"\"\"\n    c2: Point\n    \"\"\"The curve's second control point.\"\"\"\n    end: Point\n    \"\"\"The curve's end point.\"\"\"\n\n    @property\n    def end_point(self) -> Point:\n        \"\"\"The end point of this path element.\"\"\"\n        return self.end\n\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        \"\"\"Compute the bounding box of this cubic Bézier curve.\"\"\"\n\n        # Evaluate all candidate t values (endpoints + extrema) for both axes\n        px = [start.x, self.c1.x, self.c2.x, self.end.x]\n        py = [start.y, self.c1.y, self.c2.y, self.end.y]\n\n        tx = [0, 1] + _cubic_bezier_critical_ts_1d(*px)\n        ty = [0, 1] + _cubic_bezier_critical_ts_1d(*py)\n\n        xs = [_eval_cubic_bezier_1d(t, *px) for t in tx]\n        ys = [_eval_cubic_bezier_1d(t, *py) for t in ty]\n\n        bbox = BoundingBox(min(xs), min(ys), max(xs), max(ys))\n        return bbox, self.end\n\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        \"\"\"\n        Render this path element to its PDF representation.\n\n        Args:\n            resource_registry (ResourceCatalog): the owner's graphics state\n                dictionary registry.\n            style (GraphicsStyle): the current resolved graphics style\n            last_item: the previous path element.\n            initial_point: last position set by a \"M\" or \"m\" command\n\n        Returns:\n            a tuple of `(str, new_last_item)`, where `new_last_item` is `self`\n        \"\"\"\n        # pylint: disable=unused-argument\n        return _render_curve(self.c1, self.c2, self.end), self, initial_point",
      "language": "python"
    },
    {
      "code": "@property\ndef end_point(self) -> Point:\n    \"\"\"The end point of this path element.\"\"\"\n    return self.end",
      "language": "python"
    },
    {
      "code": "def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n    \"\"\"Compute the bounding box of this cubic Bézier curve.\"\"\"\n\n    # Evaluate all candidate t values (endpoints + extrema) for both axes\n    px = [start.x, self.c1.x, self.c2.x, self.end.x]\n    py = [start.y, self.c1.y, self.c2.y, self.end.y]\n\n    tx = [0, 1] + _cubic_bezier_critical_ts_1d(*px)\n    ty = [0, 1] + _cubic_bezier_critical_ts_1d(*py)\n\n    xs = [_eval_cubic_bezier_1d(t, *px) for t in tx]\n    ys = [_eval_cubic_bezier_1d(t, *py) for t in ty]\n\n    bbox = BoundingBox(min(xs), min(ys), max(xs), max(ys))\n    return bbox, self.end",
      "language": "python"
    },
    {
      "code": "@force_nodocument\ndef render(\n    self,\n    resource_registry: \"ResourceCatalog\",\n    style: GraphicsStyle,\n    last_item: Renderable,\n    initial_point: Point,\n) -> tuple[str, Renderable, Point]:\n    \"\"\"\n    Render this path element to its PDF representation.\n\n    Args:\n        resource_registry (ResourceCatalog): the owner's graphics state\n            dictionary registry.\n        style (GraphicsStyle): the current resolved graphics style\n        last_item: the previous path element.\n        initial_point: last position set by a \"M\" or \"m\" command\n\n    Returns:\n        a tuple of `(str, new_last_item)`, where `new_last_item` is `self`\n    \"\"\"\n    # pylint: disable=unused-argument\n    return _render_curve(self.c1, self.c2, self.end), self, initial_point",
      "language": "python"
    },
    {
      "code": "class BlendGroup:\n    __slots__ = (\"context\", \"base_style\", \"resources\")\n\n    def __init__(self, context: GraphicsContext, base_style: GraphicsStyle) -> None:\n        self.context = context\n        self.base_style = deepcopy(base_style)\n        self.resources: set[tuple[PDFResourceType, str]] = set()\n\n    def render(self, resource_registry: \"ResourceCatalog\") -> str:\n        stream, _, _ = self.context.render(\n            resource_registry,\n            style=self.base_style,\n            last_item=Move(Point(0, 0)),\n            initial_point=Point(0, 0),\n        )\n        self.resources = resource_registry.scan_stream(stream)\n        return stream\n\n    def get_bounding_box(self) -> tuple[float, float, float, float]:\n        bbox, _ = self.context.bounding_box(\n            Point(0, 0), style=self.base_style, expand_for_stroke=True\n        )\n        if not bbox.is_valid():\n            return (0.0, 0.0, 0.0, 0.0)\n        return bbox.to_tuple()\n\n    def get_resource_dictionary(\n        self,\n        gfxstate_objs_per_name: dict[str, PDFObject],\n        pattern_objs_per_name: dict[str, PDFObject],\n        shading_objs_per_name: dict[str, PDFObject],\n        font_objs_per_index: dict[int, Union[\"PDFFont\", \"PDFType3Font\"]],\n        img_objs_per_index: dict[int, PDFObject],\n    ) -> \"str\":\n        resources_registered: dict[PDFResourceType, set[str]] = {}\n        for rtype, resource_id in self.resources:\n            resources_registered.setdefault(rtype, set()).add(str(resource_id))\n\n        parts: list[str] = []\n\n        ext_g_states = resources_registered.get(PDFResourceType.EXT_G_STATE)\n        if ext_g_states:\n            serialized = \"\".join(\n                f\"{Name(name).serialize()} {gfxstate_objs_per_name[name].id} 0 R\"\n                for name in sorted(ext_g_states)\n                if name in gfxstate_objs_per_name\n            )\n            if serialized:\n                parts.append(f\"{Name('ExtGState').serialize()}<<{serialized}>>\")\n\n        patterns = resources_registered.get(PDFResourceType.PATTERN)\n        if patterns:\n            serialized = \"\".join(\n                f\"{Name(name).serialize()} {pattern_objs_per_name[name].id} 0 R\"\n                for name in sorted(patterns)\n                if name in pattern_objs_per_name\n            )\n            if serialized:\n                parts.append(f\"{Name('Pattern').serialize()}<<{serialized}>>\")\n\n        shadings = resources_registered.get(PDFResourceType.SHADING)\n        if shadings:\n            serialized = \"\".join(\n                f\"{Name(name).serialize()} {shading_objs_per_name[name].id} 0 R\"\n                for name in sorted(shadings)\n                if name in shading_objs_per_name\n            )\n            if serialized:\n                parts.append(f\"{Name('Shading').serialize()}<<{serialized}>>\")\n\n        fonts = resources_registered.get(PDFResourceType.FONT)\n        if fonts:\n            serialized = \"\".join(\n                f\"{Name(f'F{idx}').serialize()} {font_objs_per_index[int(idx)].id} 0 R\"\n                for idx in sorted(fonts)\n                if int(idx) in font_objs_per_index\n            )\n            if serialized:\n                parts.append(f\"{Name('Font').serialize()}<<{serialized}>>\")\n\n        xobjects = resources_registered.get(PDFResourceType.X_OBJECT)\n        if xobjects:\n            serialized = \"\".join(\n                f\"{Name(f'I{idx}').serialize()} {img_objs_per_index[int(idx)].id} 0 R\"\n                for idx in sorted(xobjects)\n                if int(idx) in img_objs_per_index\n            )\n            if serialized:\n                parts.append(f\"{Name('XObject').serialize()}<<{serialized}>>\")\n\n        return \"<<\" + \"\".join(parts) + \">>\" if parts else \"<<>>\"",
      "language": "python"
    },
    {
      "code": "class BlendGroup:\n    __slots__ = (\"context\", \"base_style\", \"resources\")\n\n    def __init__(self, context: GraphicsContext, base_style: GraphicsStyle) -> None:\n        self.context = context\n        self.base_style = deepcopy(base_style)\n        self.resources: set[tuple[PDFResourceType, str]] = set()\n\n    def render(self, resource_registry: \"ResourceCatalog\") -> str:\n        stream, _, _ = self.context.render(\n            resource_registry,\n            style=self.base_style,\n            last_item=Move(Point(0, 0)),\n            initial_point=Point(0, 0),\n        )\n        self.resources = resource_registry.scan_stream(stream)\n        return stream\n\n    def get_bounding_box(self) -> tuple[float, float, float, float]:\n        bbox, _ = self.context.bounding_box(\n            Point(0, 0), style=self.base_style, expand_for_stroke=True\n        )\n        if not bbox.is_valid():\n            return (0.0, 0.0, 0.0, 0.0)\n        return bbox.to_tuple()\n\n    def get_resource_dictionary(\n        self,\n        gfxstate_objs_per_name: dict[str, PDFObject],\n        pattern_objs_per_name: dict[str, PDFObject],\n        shading_objs_per_name: dict[str, PDFObject],\n        font_objs_per_index: dict[int, Union[\"PDFFont\", \"PDFType3Font\"]],\n        img_objs_per_index: dict[int, PDFObject],\n    ) -> \"str\":\n        resources_registered: dict[PDFResourceType, set[str]] = {}\n        for rtype, resource_id in self.resources:\n            resources_registered.setdefault(rtype, set()).add(str(resource_id))\n\n        parts: list[str] = []\n\n        ext_g_states = resources_registered.get(PDFResourceType.EXT_G_STATE)\n        if ext_g_states:\n            serialized = \"\".join(\n                f\"{Name(name).serialize()} {gfxstate_objs_per_name[name].id} 0 R\"\n                for name in sorted(ext_g_states)\n                if name in gfxstate_objs_per_name\n            )\n            if serialized:\n                parts.append(f\"{Name('ExtGState').serialize()}<<{serialized}>>\")\n\n        patterns = resources_registered.get(PDFResourceType.PATTERN)\n        if patterns:\n            serialized = \"\".join(\n                f\"{Name(name).serialize()} {pattern_objs_per_name[name].id} 0 R\"\n                for name in sorted(patterns)\n                if name in pattern_objs_per_name\n            )\n            if serialized:\n                parts.append(f\"{Name('Pattern').serialize()}<<{serialized}>>\")\n\n        shadings = resources_registered.get(PDFResourceType.SHADING)\n        if shadings:\n            serialized = \"\".join(\n                f\"{Name(name).serialize()} {shading_objs_per_name[name].id} 0 R\"\n                for name in sorted(shadings)\n                if name in shading_objs_per_name\n            )\n            if serialized:\n                parts.append(f\"{Name('Shading').serialize()}<<{serialized}>>\")\n\n        fonts = resources_registered.get(PDFResourceType.FONT)\n        if fonts:\n            serialized = \"\".join(\n                f\"{Name(f'F{idx}').serialize()} {font_objs_per_index[int(idx)].id} 0 R\"\n                for idx in sorted(fonts)\n                if int(idx) in font_objs_per_index\n            )\n            if serialized:\n                parts.append(f\"{Name('Font').serialize()}<<{serialized}>>\")\n\n        xobjects = resources_registered.get(PDFResourceType.X_OBJECT)\n        if xobjects:\n            serialized = \"\".join(\n                f\"{Name(f'I{idx}').serialize()} {img_objs_per_index[int(idx)].id} 0 R\"\n                for idx in sorted(xobjects)\n                if int(idx) in img_objs_per_index\n            )\n            if serialized:\n                parts.append(f\"{Name('XObject').serialize()}<<{serialized}>>\")\n\n        return \"<<\" + \"\".join(parts) + \">>\" if parts else \"<<>>\"",
      "language": "python"
    },
    {
      "code": "class BlendGroup:\n    __slots__ = (\"context\", \"base_style\", \"resources\")\n\n    def __init__(self, context: GraphicsContext, base_style: GraphicsStyle) -> None:\n        self.context = context\n        self.base_style = deepcopy(base_style)\n        self.resources: set[tuple[PDFResourceType, str]] = set()\n\n    def render(self, resource_registry: \"ResourceCatalog\") -> str:\n        stream, _, _ = self.context.render(\n            resource_registry,\n            style=self.base_style,\n            last_item=Move(Point(0, 0)),\n            initial_point=Point(0, 0),\n        )\n        self.resources = resource_registry.scan_stream(stream)\n        return stream\n\n    def get_bounding_box(self) -> tuple[float, float, float, float]:\n        bbox, _ = self.context.bounding_box(\n            Point(0, 0), style=self.base_style, expand_for_stroke=True\n        )\n        if not bbox.is_valid():\n            return (0.0, 0.0, 0.0, 0.0)\n        return bbox.to_tuple()\n\n    def get_resource_dictionary(\n        self,\n        gfxstate_objs_per_name: dict[str, PDFObject],\n        pattern_objs_per_name: dict[str, PDFObject],\n        shading_objs_per_name: dict[str, PDFObject],\n        font_objs_per_index: dict[int, Union[\"PDFFont\", \"PDFType3Font\"]],\n        img_objs_per_index: dict[int, PDFObject],\n    ) -> \"str\":\n        resources_registered: dict[PDFResourceType, set[str]] = {}\n        for rtype, resource_id in self.resources:\n            resources_registered.setdefault(rtype, set()).add(str(resource_id))\n\n        parts: list[str] = []\n\n        ext_g_states = resources_registered.get(PDFResourceType.EXT_G_STATE)\n        if ext_g_states:\n            serialized = \"\".join(\n                f\"{Name(name).serialize()} {gfxstate_objs_per_name[name].id} 0 R\"\n                for name in sorted(ext_g_states)\n                if name in gfxstate_objs_per_name\n            )\n            if serialized:\n                parts.append(f\"{Name('ExtGState').serialize()}<<{serialized}>>\")\n\n        patterns = resources_registered.get(PDFResourceType.PATTERN)\n        if patterns:\n            serialized = \"\".join(\n                f\"{Name(name).serialize()} {pattern_objs_per_name[name].id} 0 R\"\n                for name in sorted(patterns)\n                if name in pattern_objs_per_name\n            )\n            if serialized:\n                parts.append(f\"{Name('Pattern').serialize()}<<{serialized}>>\")\n\n        shadings = resources_registered.get(PDFResourceType.SHADING)\n        if shadings:\n            serialized = \"\".join(\n                f\"{Name(name).serialize()} {shading_objs_per_name[name].id} 0 R\"\n                for name in sorted(shadings)\n                if name in shading_objs_per_name\n            )\n            if serialized:\n                parts.append(f\"{Name('Shading').serialize()}<<{serialized}>>\")\n\n        fonts = resources_registered.get(PDFResourceType.FONT)\n        if fonts:\n            serialized = \"\".join(\n                f\"{Name(f'F{idx}').serialize()} {font_objs_per_index[int(idx)].id} 0 R\"\n                for idx in sorted(fonts)\n                if int(idx) in font_objs_per_index\n            )\n            if serialized:\n                parts.append(f\"{Name('Font').serialize()}<<{serialized}>>\")\n\n        xobjects = resources_registered.get(PDFResourceType.X_OBJECT)\n        if xobjects:\n            serialized = \"\".join(\n                f\"{Name(f'I{idx}').serialize()} {img_objs_per_index[int(idx)].id} 0 R\"\n                for idx in sorted(xobjects)\n                if int(idx) in img_objs_per_index\n            )\n            if serialized:\n                parts.append(f\"{Name('XObject').serialize()}<<{serialized}>>\")\n\n        return \"<<\" + \"\".join(parts) + \">>\" if parts else \"<<>>\"",
      "language": "python"
    },
    {
      "code": "class BlendGroup:\n    __slots__ = (\"context\", \"base_style\", \"resources\")\n\n    def __init__(self, context: GraphicsContext, base_style: GraphicsStyle) -> None:\n        self.context = context\n        self.base_style = deepcopy(base_style)\n        self.resources: set[tuple[PDFResourceType, str]] = set()\n\n    def render(self, resource_registry: \"ResourceCatalog\") -> str:\n        stream, _, _ = self.context.render(\n            resource_registry,\n            style=self.base_style,\n            last_item=Move(Point(0, 0)),\n            initial_point=Point(0, 0),\n        )\n        self.resources = resource_registry.scan_stream(stream)\n        return stream\n\n    def get_bounding_box(self) -> tuple[float, float, float, float]:\n        bbox, _ = self.context.bounding_box(\n            Point(0, 0), style=self.base_style, expand_for_stroke=True\n        )\n        if not bbox.is_valid():\n            return (0.0, 0.0, 0.0, 0.0)\n        return bbox.to_tuple()\n\n    def get_resource_dictionary(\n        self,\n        gfxstate_objs_per_name: dict[str, PDFObject],\n        pattern_objs_per_name: dict[str, PDFObject],\n        shading_objs_per_name: dict[str, PDFObject],\n        font_objs_per_index: dict[int, Union[\"PDFFont\", \"PDFType3Font\"]],\n        img_objs_per_index: dict[int, PDFObject],\n    ) -> \"str\":\n        resources_registered: dict[PDFResourceType, set[str]] = {}\n        for rtype, resource_id in self.resources:\n            resources_registered.setdefault(rtype, set()).add(str(resource_id))\n\n        parts: list[str] = []\n\n        ext_g_states = resources_registered.get(PDFResourceType.EXT_G_STATE)\n        if ext_g_states:\n            serialized = \"\".join(\n                f\"{Name(name).serialize()} {gfxstate_objs_per_name[name].id} 0 R\"\n                for name in sorted(ext_g_states)\n                if name in gfxstate_objs_per_name\n            )\n            if serialized:\n                parts.append(f\"{Name('ExtGState').serialize()}<<{serialized}>>\")\n\n        patterns = resources_registered.get(PDFResourceType.PATTERN)\n        if patterns:\n            serialized = \"\".join(\n                f\"{Name(name).serialize()} {pattern_objs_per_name[name].id} 0 R\"\n                for name in sorted(patterns)\n                if name in pattern_objs_per_name\n            )\n            if serialized:\n                parts.append(f\"{Name('Pattern').serialize()}<<{serialized}>>\")\n\n        shadings = resources_registered.get(PDFResourceType.SHADING)\n        if shadings:\n            serialized = \"\".join(\n                f\"{Name(name).serialize()} {shading_objs_per_name[name].id} 0 R\"\n                for name in sorted(shadings)\n                if name in shading_objs_per_name\n            )\n            if serialized:\n                parts.append(f\"{Name('Shading').serialize()}<<{serialized}>>\")\n\n        fonts = resources_registered.get(PDFResourceType.FONT)\n        if fonts:\n            serialized = \"\".join(\n                f\"{Name(f'F{idx}').serialize()} {font_objs_per_index[int(idx)].id} 0 R\"\n                for idx in sorted(fonts)\n                if int(idx) in font_objs_per_index\n            )\n            if serialized:\n                parts.append(f\"{Name('Font').serialize()}<<{serialized}>>\")\n\n        xobjects = resources_registered.get(PDFResourceType.X_OBJECT)\n        if xobjects:\n            serialized = \"\".join(\n                f\"{Name(f'I{idx}').serialize()} {img_objs_per_index[int(idx)].id} 0 R\"\n                for idx in sorted(xobjects)\n                if int(idx) in img_objs_per_index\n            )\n            if serialized:\n                parts.append(f\"{Name('XObject').serialize()}<<{serialized}>>\")\n\n        return \"<<\" + \"\".join(parts) + \">>\" if parts else \"<<>>\"",
      "language": "python"
    },
    {
      "code": "def get_bounding_box(self) -> tuple[float, float, float, float]:\n    bbox, _ = self.context.bounding_box(\n        Point(0, 0), style=self.base_style, expand_for_stroke=True\n    )\n    if not bbox.is_valid():\n        return (0.0, 0.0, 0.0, 0.0)\n    return bbox.to_tuple()",
      "language": "python"
    },
    {
      "code": "def get_resource_dictionary(\n    self,\n    gfxstate_objs_per_name: dict[str, PDFObject],\n    pattern_objs_per_name: dict[str, PDFObject],\n    shading_objs_per_name: dict[str, PDFObject],\n    font_objs_per_index: dict[int, Union[\"PDFFont\", \"PDFType3Font\"]],\n    img_objs_per_index: dict[int, PDFObject],\n) -> \"str\":\n    resources_registered: dict[PDFResourceType, set[str]] = {}\n    for rtype, resource_id in self.resources:\n        resources_registered.setdefault(rtype, set()).add(str(resource_id))\n\n    parts: list[str] = []\n\n    ext_g_states = resources_registered.get(PDFResourceType.EXT_G_STATE)\n    if ext_g_states:\n        serialized = \"\".join(\n            f\"{Name(name).serialize()} {gfxstate_objs_per_name[name].id} 0 R\"\n            for name in sorted(ext_g_states)\n            if name in gfxstate_objs_per_name\n        )\n        if serialized:\n            parts.append(f\"{Name('ExtGState').serialize()}<<{serialized}>>\")\n\n    patterns = resources_registered.get(PDFResourceType.PATTERN)\n    if patterns:\n        serialized = \"\".join(\n            f\"{Name(name).serialize()} {pattern_objs_per_name[name].id} 0 R\"\n            for name in sorted(patterns)\n            if name in pattern_objs_per_name\n        )\n        if serialized:\n            parts.append(f\"{Name('Pattern').serialize()}<<{serialized}>>\")\n\n    shadings = resources_registered.get(PDFResourceType.SHADING)\n    if shadings:\n        serialized = \"\".join(\n            f\"{Name(name).serialize()} {shading_objs_per_name[name].id} 0 R\"\n            for name in sorted(shadings)\n            if name in shading_objs_per_name\n        )\n        if serialized:\n            parts.append(f\"{Name('Shading').serialize()}<<{serialized}>>\")\n\n    fonts = resources_registered.get(PDFResourceType.FONT)\n    if fonts:\n        serialized = \"\".join(\n            f\"{Name(f'F{idx}').serialize()} {font_objs_per_index[int(idx)].id} 0 R\"\n            for idx in sorted(fonts)\n            if int(idx) in font_objs_per_index\n        )\n        if serialized:\n            parts.append(f\"{Name('Font').serialize()}<<{serialized}>>\")\n\n    xobjects = resources_registered.get(PDFResourceType.X_OBJECT)\n    if xobjects:\n        serialized = \"\".join(\n            f\"{Name(f'I{idx}').serialize()} {img_objs_per_index[int(idx)].id} 0 R\"\n            for idx in sorted(xobjects)\n            if int(idx) in img_objs_per_index\n        )\n        if serialized:\n            parts.append(f\"{Name('XObject').serialize()}<<{serialized}>>\")\n\n    return \"<<\" + \"\".join(parts) + \">>\" if parts else \"<<>>\"",
      "language": "python"
    },
    {
      "code": "def render(self, resource_registry: \"ResourceCatalog\") -> str:\n    stream, _, _ = self.context.render(\n        resource_registry,\n        style=self.base_style,\n        last_item=Move(Point(0, 0)),\n        initial_point=Point(0, 0),\n    )\n    self.resources = resource_registry.scan_stream(stream)\n    return stream",
      "language": "python"
    },
    {
      "code": "class BoundingBox(NamedTuple):\n    \"\"\"Represents a bounding box, with utility methods for creating and manipulating them.\"\"\"\n\n    x0: float\n    y0: float\n    x1: float\n    y1: float\n\n    @classmethod\n    def empty(cls) -> \"BoundingBox\":\n        \"\"\"\n        Return an 'empty' bounding box with extreme values that collapse on merge.\n        \"\"\"\n        return cls(float(\"inf\"), float(\"inf\"), float(\"-inf\"), float(\"-inf\"))\n\n    def is_valid(self) -> bool:\n        \"\"\"Return True if the bounding box is not empty.\"\"\"\n        return self.x0 <= self.x1 and self.y0 <= self.y1\n\n    @classmethod\n    def from_points(cls, points: list[Point]) -> \"BoundingBox\":\n        \"\"\"Given a list of points, create a bounding box that encloses them all.\"\"\"\n        xs = [float(p.x) for p in points]\n        ys = [float(p.y) for p in points]\n        return cls(min(xs), min(ys), max(xs), max(ys))\n\n    def merge(self, other: \"BoundingBox\") -> \"BoundingBox\":\n        \"\"\"Expand this bounding box to include another one.\"\"\"\n        if not self.is_valid():\n            return other\n        if not other.is_valid():\n            return self\n        return BoundingBox(\n            min(self.x0, other.x0),\n            min(self.y0, other.y0),\n            max(self.x1, other.x1),\n            max(self.y1, other.y1),\n        )\n\n    def transformed(self, tf: Transform) -> \"BoundingBox\":\n        \"\"\"\n        Return a new bounding box resulting from applying a transform to this one.\n        \"\"\"\n        corners = [\n            Point(self.x0, self.y0),\n            Point(self.x1, self.y0),\n            Point(self.x0, self.y1),\n            Point(self.x1, self.y1),\n        ]\n        transformed_points = [pt @ tf for pt in corners]\n        return BoundingBox.from_points(transformed_points)\n\n    def expanded(self, dx: float, dy: Optional[float] = None) -> \"BoundingBox\":\n        \"\"\"Return a new bounding box expanded by the given amounts in each direction.\"\"\"\n        if dy is None:\n            dy = dx\n        return BoundingBox(self.x0 - dx, self.y0 - dy, self.x1 + dx, self.y1 + dy)\n\n    def expanded_to_stroke(\n        self, style: \"GraphicsStyle\", row_norms: tuple[float, float] = (1.0, 1.0)\n    ) -> \"BoundingBox\":\n        \"\"\"Expand this bbox to include stroke coverage, given a graphics style.\"\"\"\n\n        # 1) Is there any stroke to consider?\n        if not style.resolve_paint_rule() in (\n            PathPaintRule.STROKE,\n            PathPaintRule.STROKE_FILL_NONZERO,\n            PathPaintRule.STROKE_FILL_EVENODD,\n        ):\n            return self\n\n        # If stroke opacity resolves to 0, no visible stroke => no expansion\n        if isinstance(style.stroke_opacity, NumberClass):\n            if float(style.stroke_opacity) <= 0.0:\n                return self\n\n        # 2) Effective stroke width (PDF default is 1 if unset/inherit)\n        w = (\n            1.00\n            if style.stroke_width is None or isinstance(style.stroke_width, InheritType)\n            else style.stroke_width\n        )\n        if w == 0.0:\n            return self\n        r = 0.5 * w\n\n        # 3) Row norms from CTM to scale the half-stroke in X/Y\n        nx, ny = row_norms\n        return self.expanded(r * nx, r * ny)\n\n    def to_tuple(self) -> tuple[float, float, float, float]:\n        \"\"\"Convert bounding box to a 4-tuple.\"\"\"\n        return (self.x0, self.y0, self.x1, self.y1)\n\n    def to_pdf_array(self) -> str:\n        \"\"\"Convert bounding box to a PDF array string.\"\"\"\n        return f\"[{number_to_str(self.x0)} {number_to_str(self.y0)} {number_to_str(self.x1)} {number_to_str(self.y1)}]\"\n\n    def corners(\n        self,\n    ) -> tuple[\n        tuple[float, float],\n        tuple[float, float],\n        tuple[float, float],\n        tuple[float, float],\n    ]:\n        \"\"\"Clockwise corners (x,y): (x0,y0),(x1,y0),(x1,y1),(x0,y1).\"\"\"\n        return (\n            (self.x0, self.y0),\n            (self.x1, self.y0),\n            (self.x1, self.y1),\n            (self.x0, self.y1),\n        )\n\n    def project_interval_on_axis(\n        self, x1: float, y1: float, x2: float, y2: float\n    ) -> tuple[float, float, float]:\n        \"\"\"\n        Project bbox corners onto the axis from (x1,y1) to (x2,y2).\n        Returns (tmin, tmax, L) where:\n          - L is the axis length\n          - t are distances along the axis with t=0 at (x1,y1)\n        \"\"\"\n        vx, vy = (x2 - x1), (y2 - y1)\n        L = math.hypot(vx, vy)\n        if L == 0.0:\n            return 0.0, 0.0, 0.0\n        ux, uy = vx / L, vy / L\n        ts: list[float] = []\n        for X, Y in self.corners():\n            dx, dy = (X - x1), (Y - y1)\n            ts.append(dx * ux + dy * uy)  # dot with unit axis\n        return min(ts), max(ts), L\n\n    def max_distance_to_point(self, cx: float, cy: float) -> float:\n        \"\"\"Max Euclidean distance from (cx,cy) to any bbox corner.\"\"\"\n        return max(math.hypot(X - cx, Y - cy) for (X, Y) in self.corners())\n\n    @property\n    def width(self) -> float:\n        \"\"\"Return the width of the bounding box.\"\"\"\n        return self.x1 - self.x0\n\n    @property\n    def height(self) -> float:\n        \"\"\"Return the height of the bounding box.\"\"\"\n        return self.y1 - self.y0\n\n    def __str__(self) -> str:\n        return f\"BoundingBox({self.x0}, {self.y0}, {self.x1}, {self.y1})\"\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, BoundingBox):\n            return False\n        tolerance = 1e-6\n        return (\n            abs(self.x0 - other.x0) < tolerance\n            and abs(self.y0 - other.y0) < tolerance\n            and abs(self.x1 - other.x1) < tolerance\n            and abs(self.y1 - other.y1) < tolerance\n        )\n\n    def __hash__(self) -> int:\n        # Round to match the tolerance used in __eq__\n        return hash(\n            (\n                round(self.x0, 6),\n                round(self.y0, 6),\n                round(self.x1, 6),\n                round(self.y1, 6),\n            )\n        )",
      "language": "python"
    },
    {
      "code": "@property\ndef height(self) -> float:\n    \"\"\"Return the height of the bounding box.\"\"\"\n    return self.y1 - self.y0",
      "language": "python"
    },
    {
      "code": "@property\ndef width(self) -> float:\n    \"\"\"Return the width of the bounding box.\"\"\"\n    return self.x1 - self.x0",
      "language": "python"
    },
    {
      "code": "class BoundingBox(NamedTuple):\n    \"\"\"Represents a bounding box, with utility methods for creating and manipulating them.\"\"\"\n\n    x0: float\n    y0: float\n    x1: float\n    y1: float\n\n    @classmethod\n    def empty(cls) -> \"BoundingBox\":\n        \"\"\"\n        Return an 'empty' bounding box with extreme values that collapse on merge.\n        \"\"\"\n        return cls(float(\"inf\"), float(\"inf\"), float(\"-inf\"), float(\"-inf\"))\n\n    def is_valid(self) -> bool:\n        \"\"\"Return True if the bounding box is not empty.\"\"\"\n        return self.x0 <= self.x1 and self.y0 <= self.y1\n\n    @classmethod\n    def from_points(cls, points: list[Point]) -> \"BoundingBox\":\n        \"\"\"Given a list of points, create a bounding box that encloses them all.\"\"\"\n        xs = [float(p.x) for p in points]\n        ys = [float(p.y) for p in points]\n        return cls(min(xs), min(ys), max(xs), max(ys))\n\n    def merge(self, other: \"BoundingBox\") -> \"BoundingBox\":\n        \"\"\"Expand this bounding box to include another one.\"\"\"\n        if not self.is_valid():\n            return other\n        if not other.is_valid():\n            return self\n        return BoundingBox(\n            min(self.x0, other.x0),\n            min(self.y0, other.y0),\n            max(self.x1, other.x1),\n            max(self.y1, other.y1),\n        )\n\n    def transformed(self, tf: Transform) -> \"BoundingBox\":\n        \"\"\"\n        Return a new bounding box resulting from applying a transform to this one.\n        \"\"\"\n        corners = [\n            Point(self.x0, self.y0),\n            Point(self.x1, self.y0),\n            Point(self.x0, self.y1),\n            Point(self.x1, self.y1),\n        ]\n        transformed_points = [pt @ tf for pt in corners]\n        return BoundingBox.from_points(transformed_points)\n\n    def expanded(self, dx: float, dy: Optional[float] = None) -> \"BoundingBox\":\n        \"\"\"Return a new bounding box expanded by the given amounts in each direction.\"\"\"\n        if dy is None:\n            dy = dx\n        return BoundingBox(self.x0 - dx, self.y0 - dy, self.x1 + dx, self.y1 + dy)\n\n    def expanded_to_stroke(\n        self, style: \"GraphicsStyle\", row_norms: tuple[float, float] = (1.0, 1.0)\n    ) -> \"BoundingBox\":\n        \"\"\"Expand this bbox to include stroke coverage, given a graphics style.\"\"\"\n\n        # 1) Is there any stroke to consider?\n        if not style.resolve_paint_rule() in (\n            PathPaintRule.STROKE,\n            PathPaintRule.STROKE_FILL_NONZERO,\n            PathPaintRule.STROKE_FILL_EVENODD,\n        ):\n            return self\n\n        # If stroke opacity resolves to 0, no visible stroke => no expansion\n        if isinstance(style.stroke_opacity, NumberClass):\n            if float(style.stroke_opacity) <= 0.0:\n                return self\n\n        # 2) Effective stroke width (PDF default is 1 if unset/inherit)\n        w = (\n            1.00\n            if style.stroke_width is None or isinstance(style.stroke_width, InheritType)\n            else style.stroke_width\n        )\n        if w == 0.0:\n            return self\n        r = 0.5 * w\n\n        # 3) Row norms from CTM to scale the half-stroke in X/Y\n        nx, ny = row_norms\n        return self.expanded(r * nx, r * ny)\n\n    def to_tuple(self) -> tuple[float, float, float, float]:\n        \"\"\"Convert bounding box to a 4-tuple.\"\"\"\n        return (self.x0, self.y0, self.x1, self.y1)\n\n    def to_pdf_array(self) -> str:\n        \"\"\"Convert bounding box to a PDF array string.\"\"\"\n        return f\"[{number_to_str(self.x0)} {number_to_str(self.y0)} {number_to_str(self.x1)} {number_to_str(self.y1)}]\"\n\n    def corners(\n        self,\n    ) -> tuple[\n        tuple[float, float],\n        tuple[float, float],\n        tuple[float, float],\n        tuple[float, float],\n    ]:\n        \"\"\"Clockwise corners (x,y): (x0,y0),(x1,y0),(x1,y1),(x0,y1).\"\"\"\n        return (\n            (self.x0, self.y0),\n            (self.x1, self.y0),\n            (self.x1, self.y1),\n            (self.x0, self.y1),\n        )\n\n    def project_interval_on_axis(\n        self, x1: float, y1: float, x2: float, y2: float\n    ) -> tuple[float, float, float]:\n        \"\"\"\n        Project bbox corners onto the axis from (x1,y1) to (x2,y2).\n        Returns (tmin, tmax, L) where:\n          - L is the axis length\n          - t are distances along the axis with t=0 at (x1,y1)\n        \"\"\"\n        vx, vy = (x2 - x1), (y2 - y1)\n        L = math.hypot(vx, vy)\n        if L == 0.0:\n            return 0.0, 0.0, 0.0\n        ux, uy = vx / L, vy / L\n        ts: list[float] = []\n        for X, Y in self.corners():\n            dx, dy = (X - x1), (Y - y1)\n            ts.append(dx * ux + dy * uy)  # dot with unit axis\n        return min(ts), max(ts), L\n\n    def max_distance_to_point(self, cx: float, cy: float) -> float:\n        \"\"\"Max Euclidean distance from (cx,cy) to any bbox corner.\"\"\"\n        return max(math.hypot(X - cx, Y - cy) for (X, Y) in self.corners())\n\n    @property\n    def width(self) -> float:\n        \"\"\"Return the width of the bounding box.\"\"\"\n        return self.x1 - self.x0\n\n    @property\n    def height(self) -> float:\n        \"\"\"Return the height of the bounding box.\"\"\"\n        return self.y1 - self.y0\n\n    def __str__(self) -> str:\n        return f\"BoundingBox({self.x0}, {self.y0}, {self.x1}, {self.y1})\"\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, BoundingBox):\n            return False\n        tolerance = 1e-6\n        return (\n            abs(self.x0 - other.x0) < tolerance\n            and abs(self.y0 - other.y0) < tolerance\n            and abs(self.x1 - other.x1) < tolerance\n            and abs(self.y1 - other.y1) < tolerance\n        )\n\n    def __hash__(self) -> int:\n        # Round to match the tolerance used in __eq__\n        return hash(\n            (\n                round(self.x0, 6),\n                round(self.y0, 6),\n                round(self.x1, 6),\n                round(self.y1, 6),\n            )\n        )",
      "language": "python"
    },
    {
      "code": "class BoundingBox(NamedTuple):\n    \"\"\"Represents a bounding box, with utility methods for creating and manipulating them.\"\"\"\n\n    x0: float\n    y0: float\n    x1: float\n    y1: float\n\n    @classmethod\n    def empty(cls) -> \"BoundingBox\":\n        \"\"\"\n        Return an 'empty' bounding box with extreme values that collapse on merge.\n        \"\"\"\n        return cls(float(\"inf\"), float(\"inf\"), float(\"-inf\"), float(\"-inf\"))\n\n    def is_valid(self) -> bool:\n        \"\"\"Return True if the bounding box is not empty.\"\"\"\n        return self.x0 <= self.x1 and self.y0 <= self.y1\n\n    @classmethod\n    def from_points(cls, points: list[Point]) -> \"BoundingBox\":\n        \"\"\"Given a list of points, create a bounding box that encloses them all.\"\"\"\n        xs = [float(p.x) for p in points]\n        ys = [float(p.y) for p in points]\n        return cls(min(xs), min(ys), max(xs), max(ys))\n\n    def merge(self, other: \"BoundingBox\") -> \"BoundingBox\":\n        \"\"\"Expand this bounding box to include another one.\"\"\"\n        if not self.is_valid():\n            return other\n        if not other.is_valid():\n            return self\n        return BoundingBox(\n            min(self.x0, other.x0),\n            min(self.y0, other.y0),\n            max(self.x1, other.x1),\n            max(self.y1, other.y1),\n        )\n\n    def transformed(self, tf: Transform) -> \"BoundingBox\":\n        \"\"\"\n        Return a new bounding box resulting from applying a transform to this one.\n        \"\"\"\n        corners = [\n            Point(self.x0, self.y0),\n            Point(self.x1, self.y0),\n            Point(self.x0, self.y1),\n            Point(self.x1, self.y1),\n        ]\n        transformed_points = [pt @ tf for pt in corners]\n        return BoundingBox.from_points(transformed_points)\n\n    def expanded(self, dx: float, dy: Optional[float] = None) -> \"BoundingBox\":\n        \"\"\"Return a new bounding box expanded by the given amounts in each direction.\"\"\"\n        if dy is None:\n            dy = dx\n        return BoundingBox(self.x0 - dx, self.y0 - dy, self.x1 + dx, self.y1 + dy)\n\n    def expanded_to_stroke(\n        self, style: \"GraphicsStyle\", row_norms: tuple[float, float] = (1.0, 1.0)\n    ) -> \"BoundingBox\":\n        \"\"\"Expand this bbox to include stroke coverage, given a graphics style.\"\"\"\n\n        # 1) Is there any stroke to consider?\n        if not style.resolve_paint_rule() in (\n            PathPaintRule.STROKE,\n            PathPaintRule.STROKE_FILL_NONZERO,\n            PathPaintRule.STROKE_FILL_EVENODD,\n        ):\n            return self\n\n        # If stroke opacity resolves to 0, no visible stroke => no expansion\n        if isinstance(style.stroke_opacity, NumberClass):\n            if float(style.stroke_opacity) <= 0.0:\n                return self\n\n        # 2) Effective stroke width (PDF default is 1 if unset/inherit)\n        w = (\n            1.00\n            if style.stroke_width is None or isinstance(style.stroke_width, InheritType)\n            else style.stroke_width\n        )\n        if w == 0.0:\n            return self\n        r = 0.5 * w\n\n        # 3) Row norms from CTM to scale the half-stroke in X/Y\n        nx, ny = row_norms\n        return self.expanded(r * nx, r * ny)\n\n    def to_tuple(self) -> tuple[float, float, float, float]:\n        \"\"\"Convert bounding box to a 4-tuple.\"\"\"\n        return (self.x0, self.y0, self.x1, self.y1)\n\n    def to_pdf_array(self) -> str:\n        \"\"\"Convert bounding box to a PDF array string.\"\"\"\n        return f\"[{number_to_str(self.x0)} {number_to_str(self.y0)} {number_to_str(self.x1)} {number_to_str(self.y1)}]\"\n\n    def corners(\n        self,\n    ) -> tuple[\n        tuple[float, float],\n        tuple[float, float],\n        tuple[float, float],\n        tuple[float, float],\n    ]:\n        \"\"\"Clockwise corners (x,y): (x0,y0),(x1,y0),(x1,y1),(x0,y1).\"\"\"\n        return (\n            (self.x0, self.y0),\n            (self.x1, self.y0),\n            (self.x1, self.y1),\n            (self.x0, self.y1),\n        )\n\n    def project_interval_on_axis(\n        self, x1: float, y1: float, x2: float, y2: float\n    ) -> tuple[float, float, float]:\n        \"\"\"\n        Project bbox corners onto the axis from (x1,y1) to (x2,y2).\n        Returns (tmin, tmax, L) where:\n          - L is the axis length\n          - t are distances along the axis with t=0 at (x1,y1)\n        \"\"\"\n        vx, vy = (x2 - x1), (y2 - y1)\n        L = math.hypot(vx, vy)\n        if L == 0.0:\n            return 0.0, 0.0, 0.0\n        ux, uy = vx / L, vy / L\n        ts: list[float] = []\n        for X, Y in self.corners():\n            dx, dy = (X - x1), (Y - y1)\n            ts.append(dx * ux + dy * uy)  # dot with unit axis\n        return min(ts), max(ts), L\n\n    def max_distance_to_point(self, cx: float, cy: float) -> float:\n        \"\"\"Max Euclidean distance from (cx,cy) to any bbox corner.\"\"\"\n        return max(math.hypot(X - cx, Y - cy) for (X, Y) in self.corners())\n\n    @property\n    def width(self) -> float:\n        \"\"\"Return the width of the bounding box.\"\"\"\n        return self.x1 - self.x0\n\n    @property\n    def height(self) -> float:\n        \"\"\"Return the height of the bounding box.\"\"\"\n        return self.y1 - self.y0\n\n    def __str__(self) -> str:\n        return f\"BoundingBox({self.x0}, {self.y0}, {self.x1}, {self.y1})\"\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, BoundingBox):\n            return False\n        tolerance = 1e-6\n        return (\n            abs(self.x0 - other.x0) < tolerance\n            and abs(self.y0 - other.y0) < tolerance\n            and abs(self.x1 - other.x1) < tolerance\n            and abs(self.y1 - other.y1) < tolerance\n        )\n\n    def __hash__(self) -> int:\n        # Round to match the tolerance used in __eq__\n        return hash(\n            (\n                round(self.x0, 6),\n                round(self.y0, 6),\n                round(self.x1, 6),\n                round(self.y1, 6),\n            )\n        )",
      "language": "python"
    },
    {
      "code": "class BoundingBox(NamedTuple):\n    \"\"\"Represents a bounding box, with utility methods for creating and manipulating them.\"\"\"\n\n    x0: float\n    y0: float\n    x1: float\n    y1: float\n\n    @classmethod\n    def empty(cls) -> \"BoundingBox\":\n        \"\"\"\n        Return an 'empty' bounding box with extreme values that collapse on merge.\n        \"\"\"\n        return cls(float(\"inf\"), float(\"inf\"), float(\"-inf\"), float(\"-inf\"))\n\n    def is_valid(self) -> bool:\n        \"\"\"Return True if the bounding box is not empty.\"\"\"\n        return self.x0 <= self.x1 and self.y0 <= self.y1\n\n    @classmethod\n    def from_points(cls, points: list[Point]) -> \"BoundingBox\":\n        \"\"\"Given a list of points, create a bounding box that encloses them all.\"\"\"\n        xs = [float(p.x) for p in points]\n        ys = [float(p.y) for p in points]\n        return cls(min(xs), min(ys), max(xs), max(ys))\n\n    def merge(self, other: \"BoundingBox\") -> \"BoundingBox\":\n        \"\"\"Expand this bounding box to include another one.\"\"\"\n        if not self.is_valid():\n            return other\n        if not other.is_valid():\n            return self\n        return BoundingBox(\n            min(self.x0, other.x0),\n            min(self.y0, other.y0),\n            max(self.x1, other.x1),\n            max(self.y1, other.y1),\n        )\n\n    def transformed(self, tf: Transform) -> \"BoundingBox\":\n        \"\"\"\n        Return a new bounding box resulting from applying a transform to this one.\n        \"\"\"\n        corners = [\n            Point(self.x0, self.y0),\n            Point(self.x1, self.y0),\n            Point(self.x0, self.y1),\n            Point(self.x1, self.y1),\n        ]\n        transformed_points = [pt @ tf for pt in corners]\n        return BoundingBox.from_points(transformed_points)\n\n    def expanded(self, dx: float, dy: Optional[float] = None) -> \"BoundingBox\":\n        \"\"\"Return a new bounding box expanded by the given amounts in each direction.\"\"\"\n        if dy is None:\n            dy = dx\n        return BoundingBox(self.x0 - dx, self.y0 - dy, self.x1 + dx, self.y1 + dy)\n\n    def expanded_to_stroke(\n        self, style: \"GraphicsStyle\", row_norms: tuple[float, float] = (1.0, 1.0)\n    ) -> \"BoundingBox\":\n        \"\"\"Expand this bbox to include stroke coverage, given a graphics style.\"\"\"\n\n        # 1) Is there any stroke to consider?\n        if not style.resolve_paint_rule() in (\n            PathPaintRule.STROKE,\n            PathPaintRule.STROKE_FILL_NONZERO,\n            PathPaintRule.STROKE_FILL_EVENODD,\n        ):\n            return self\n\n        # If stroke opacity resolves to 0, no visible stroke => no expansion\n        if isinstance(style.stroke_opacity, NumberClass):\n            if float(style.stroke_opacity) <= 0.0:\n                return self\n\n        # 2) Effective stroke width (PDF default is 1 if unset/inherit)\n        w = (\n            1.00\n            if style.stroke_width is None or isinstance(style.stroke_width, InheritType)\n            else style.stroke_width\n        )\n        if w == 0.0:\n            return self\n        r = 0.5 * w\n\n        # 3) Row norms from CTM to scale the half-stroke in X/Y\n        nx, ny = row_norms\n        return self.expanded(r * nx, r * ny)\n\n    def to_tuple(self) -> tuple[float, float, float, float]:\n        \"\"\"Convert bounding box to a 4-tuple.\"\"\"\n        return (self.x0, self.y0, self.x1, self.y1)\n\n    def to_pdf_array(self) -> str:\n        \"\"\"Convert bounding box to a PDF array string.\"\"\"\n        return f\"[{number_to_str(self.x0)} {number_to_str(self.y0)} {number_to_str(self.x1)} {number_to_str(self.y1)}]\"\n\n    def corners(\n        self,\n    ) -> tuple[\n        tuple[float, float],\n        tuple[float, float],\n        tuple[float, float],\n        tuple[float, float],\n    ]:\n        \"\"\"Clockwise corners (x,y): (x0,y0),(x1,y0),(x1,y1),(x0,y1).\"\"\"\n        return (\n            (self.x0, self.y0),\n            (self.x1, self.y0),\n            (self.x1, self.y1),\n            (self.x0, self.y1),\n        )\n\n    def project_interval_on_axis(\n        self, x1: float, y1: float, x2: float, y2: float\n    ) -> tuple[float, float, float]:\n        \"\"\"\n        Project bbox corners onto the axis from (x1,y1) to (x2,y2).\n        Returns (tmin, tmax, L) where:\n          - L is the axis length\n          - t are distances along the axis with t=0 at (x1,y1)\n        \"\"\"\n        vx, vy = (x2 - x1), (y2 - y1)\n        L = math.hypot(vx, vy)\n        if L == 0.0:\n            return 0.0, 0.0, 0.0\n        ux, uy = vx / L, vy / L\n        ts: list[float] = []\n        for X, Y in self.corners():\n            dx, dy = (X - x1), (Y - y1)\n            ts.append(dx * ux + dy * uy)  # dot with unit axis\n        return min(ts), max(ts), L\n\n    def max_distance_to_point(self, cx: float, cy: float) -> float:\n        \"\"\"Max Euclidean distance from (cx,cy) to any bbox corner.\"\"\"\n        return max(math.hypot(X - cx, Y - cy) for (X, Y) in self.corners())\n\n    @property\n    def width(self) -> float:\n        \"\"\"Return the width of the bounding box.\"\"\"\n        return self.x1 - self.x0\n\n    @property\n    def height(self) -> float:\n        \"\"\"Return the height of the bounding box.\"\"\"\n        return self.y1 - self.y0\n\n    def __str__(self) -> str:\n        return f\"BoundingBox({self.x0}, {self.y0}, {self.x1}, {self.y1})\"\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, BoundingBox):\n            return False\n        tolerance = 1e-6\n        return (\n            abs(self.x0 - other.x0) < tolerance\n            and abs(self.y0 - other.y0) < tolerance\n            and abs(self.x1 - other.x1) < tolerance\n            and abs(self.y1 - other.y1) < tolerance\n        )\n\n    def __hash__(self) -> int:\n        # Round to match the tolerance used in __eq__\n        return hash(\n            (\n                round(self.x0, 6),\n                round(self.y0, 6),\n                round(self.x1, 6),\n                round(self.y1, 6),\n            )\n        )",
      "language": "python"
    },
    {
      "code": "class BoundingBox(NamedTuple):\n    \"\"\"Represents a bounding box, with utility methods for creating and manipulating them.\"\"\"\n\n    x0: float\n    y0: float\n    x1: float\n    y1: float\n\n    @classmethod\n    def empty(cls) -> \"BoundingBox\":\n        \"\"\"\n        Return an 'empty' bounding box with extreme values that collapse on merge.\n        \"\"\"\n        return cls(float(\"inf\"), float(\"inf\"), float(\"-inf\"), float(\"-inf\"))\n\n    def is_valid(self) -> bool:\n        \"\"\"Return True if the bounding box is not empty.\"\"\"\n        return self.x0 <= self.x1 and self.y0 <= self.y1\n\n    @classmethod\n    def from_points(cls, points: list[Point]) -> \"BoundingBox\":\n        \"\"\"Given a list of points, create a bounding box that encloses them all.\"\"\"\n        xs = [float(p.x) for p in points]\n        ys = [float(p.y) for p in points]\n        return cls(min(xs), min(ys), max(xs), max(ys))\n\n    def merge(self, other: \"BoundingBox\") -> \"BoundingBox\":\n        \"\"\"Expand this bounding box to include another one.\"\"\"\n        if not self.is_valid():\n            return other\n        if not other.is_valid():\n            return self\n        return BoundingBox(\n            min(self.x0, other.x0),\n            min(self.y0, other.y0),\n            max(self.x1, other.x1),\n            max(self.y1, other.y1),\n        )\n\n    def transformed(self, tf: Transform) -> \"BoundingBox\":\n        \"\"\"\n        Return a new bounding box resulting from applying a transform to this one.\n        \"\"\"\n        corners = [\n            Point(self.x0, self.y0),\n            Point(self.x1, self.y0),\n            Point(self.x0, self.y1),\n            Point(self.x1, self.y1),\n        ]\n        transformed_points = [pt @ tf for pt in corners]\n        return BoundingBox.from_points(transformed_points)\n\n    def expanded(self, dx: float, dy: Optional[float] = None) -> \"BoundingBox\":\n        \"\"\"Return a new bounding box expanded by the given amounts in each direction.\"\"\"\n        if dy is None:\n            dy = dx\n        return BoundingBox(self.x0 - dx, self.y0 - dy, self.x1 + dx, self.y1 + dy)\n\n    def expanded_to_stroke(\n        self, style: \"GraphicsStyle\", row_norms: tuple[float, float] = (1.0, 1.0)\n    ) -> \"BoundingBox\":\n        \"\"\"Expand this bbox to include stroke coverage, given a graphics style.\"\"\"\n\n        # 1) Is there any stroke to consider?\n        if not style.resolve_paint_rule() in (\n            PathPaintRule.STROKE,\n            PathPaintRule.STROKE_FILL_NONZERO,\n            PathPaintRule.STROKE_FILL_EVENODD,\n        ):\n            return self\n\n        # If stroke opacity resolves to 0, no visible stroke => no expansion\n        if isinstance(style.stroke_opacity, NumberClass):\n            if float(style.stroke_opacity) <= 0.0:\n                return self\n\n        # 2) Effective stroke width (PDF default is 1 if unset/inherit)\n        w = (\n            1.00\n            if style.stroke_width is None or isinstance(style.stroke_width, InheritType)\n            else style.stroke_width\n        )\n        if w == 0.0:\n            return self\n        r = 0.5 * w\n\n        # 3) Row norms from CTM to scale the half-stroke in X/Y\n        nx, ny = row_norms\n        return self.expanded(r * nx, r * ny)\n\n    def to_tuple(self) -> tuple[float, float, float, float]:\n        \"\"\"Convert bounding box to a 4-tuple.\"\"\"\n        return (self.x0, self.y0, self.x1, self.y1)\n\n    def to_pdf_array(self) -> str:\n        \"\"\"Convert bounding box to a PDF array string.\"\"\"\n        return f\"[{number_to_str(self.x0)} {number_to_str(self.y0)} {number_to_str(self.x1)} {number_to_str(self.y1)}]\"\n\n    def corners(\n        self,\n    ) -> tuple[\n        tuple[float, float],\n        tuple[float, float],\n        tuple[float, float],\n        tuple[float, float],\n    ]:\n        \"\"\"Clockwise corners (x,y): (x0,y0),(x1,y0),(x1,y1),(x0,y1).\"\"\"\n        return (\n            (self.x0, self.y0),\n            (self.x1, self.y0),\n            (self.x1, self.y1),\n            (self.x0, self.y1),\n        )\n\n    def project_interval_on_axis(\n        self, x1: float, y1: float, x2: float, y2: float\n    ) -> tuple[float, float, float]:\n        \"\"\"\n        Project bbox corners onto the axis from (x1,y1) to (x2,y2).\n        Returns (tmin, tmax, L) where:\n          - L is the axis length\n          - t are distances along the axis with t=0 at (x1,y1)\n        \"\"\"\n        vx, vy = (x2 - x1), (y2 - y1)\n        L = math.hypot(vx, vy)\n        if L == 0.0:\n            return 0.0, 0.0, 0.0\n        ux, uy = vx / L, vy / L\n        ts: list[float] = []\n        for X, Y in self.corners():\n            dx, dy = (X - x1), (Y - y1)\n            ts.append(dx * ux + dy * uy)  # dot with unit axis\n        return min(ts), max(ts), L\n\n    def max_distance_to_point(self, cx: float, cy: float) -> float:\n        \"\"\"Max Euclidean distance from (cx,cy) to any bbox corner.\"\"\"\n        return max(math.hypot(X - cx, Y - cy) for (X, Y) in self.corners())\n\n    @property\n    def width(self) -> float:\n        \"\"\"Return the width of the bounding box.\"\"\"\n        return self.x1 - self.x0\n\n    @property\n    def height(self) -> float:\n        \"\"\"Return the height of the bounding box.\"\"\"\n        return self.y1 - self.y0\n\n    def __str__(self) -> str:\n        return f\"BoundingBox({self.x0}, {self.y0}, {self.x1}, {self.y1})\"\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, BoundingBox):\n            return False\n        tolerance = 1e-6\n        return (\n            abs(self.x0 - other.x0) < tolerance\n            and abs(self.y0 - other.y0) < tolerance\n            and abs(self.x1 - other.x1) < tolerance\n            and abs(self.y1 - other.y1) < tolerance\n        )\n\n    def __hash__(self) -> int:\n        # Round to match the tolerance used in __eq__\n        return hash(\n            (\n                round(self.x0, 6),\n                round(self.y0, 6),\n                round(self.x1, 6),\n                round(self.y1, 6),\n            )\n        )",
      "language": "python"
    },
    {
      "code": "def corners(\n    self,\n) -> tuple[\n    tuple[float, float],\n    tuple[float, float],\n    tuple[float, float],\n    tuple[float, float],\n]:\n    \"\"\"Clockwise corners (x,y): (x0,y0),(x1,y0),(x1,y1),(x0,y1).\"\"\"\n    return (\n        (self.x0, self.y0),\n        (self.x1, self.y0),\n        (self.x1, self.y1),\n        (self.x0, self.y1),\n    )",
      "language": "python"
    },
    {
      "code": "def expanded(self, dx: float, dy: Optional[float] = None) -> \"BoundingBox\":\n    \"\"\"Return a new bounding box expanded by the given amounts in each direction.\"\"\"\n    if dy is None:\n        dy = dx\n    return BoundingBox(self.x0 - dx, self.y0 - dy, self.x1 + dx, self.y1 + dy)",
      "language": "python"
    },
    {
      "code": "def expanded_to_stroke(\n    self, style: \"GraphicsStyle\", row_norms: tuple[float, float] = (1.0, 1.0)\n) -> \"BoundingBox\":\n    \"\"\"Expand this bbox to include stroke coverage, given a graphics style.\"\"\"\n\n    # 1) Is there any stroke to consider?\n    if not style.resolve_paint_rule() in (\n        PathPaintRule.STROKE,\n        PathPaintRule.STROKE_FILL_NONZERO,\n        PathPaintRule.STROKE_FILL_EVENODD,\n    ):\n        return self\n\n    # If stroke opacity resolves to 0, no visible stroke => no expansion\n    if isinstance(style.stroke_opacity, NumberClass):\n        if float(style.stroke_opacity) <= 0.0:\n            return self\n\n    # 2) Effective stroke width (PDF default is 1 if unset/inherit)\n    w = (\n        1.00\n        if style.stroke_width is None or isinstance(style.stroke_width, InheritType)\n        else style.stroke_width\n    )\n    if w == 0.0:\n        return self\n    r = 0.5 * w\n\n    # 3) Row norms from CTM to scale the half-stroke in X/Y\n    nx, ny = row_norms\n    return self.expanded(r * nx, r * ny)",
      "language": "python"
    },
    {
      "code": "def is_valid(self) -> bool:\n    \"\"\"Return True if the bounding box is not empty.\"\"\"\n    return self.x0 <= self.x1 and self.y0 <= self.y1",
      "language": "python"
    },
    {
      "code": "def max_distance_to_point(self, cx: float, cy: float) -> float:\n    \"\"\"Max Euclidean distance from (cx,cy) to any bbox corner.\"\"\"\n    return max(math.hypot(X - cx, Y - cy) for (X, Y) in self.corners())",
      "language": "python"
    },
    {
      "code": "def merge(self, other: \"BoundingBox\") -> \"BoundingBox\":\n    \"\"\"Expand this bounding box to include another one.\"\"\"\n    if not self.is_valid():\n        return other\n    if not other.is_valid():\n        return self\n    return BoundingBox(\n        min(self.x0, other.x0),\n        min(self.y0, other.y0),\n        max(self.x1, other.x1),\n        max(self.y1, other.y1),\n    )",
      "language": "python"
    },
    {
      "code": "def project_interval_on_axis(\n    self, x1: float, y1: float, x2: float, y2: float\n) -> tuple[float, float, float]:\n    \"\"\"\n    Project bbox corners onto the axis from (x1,y1) to (x2,y2).\n    Returns (tmin, tmax, L) where:\n      - L is the axis length\n      - t are distances along the axis with t=0 at (x1,y1)\n    \"\"\"\n    vx, vy = (x2 - x1), (y2 - y1)\n    L = math.hypot(vx, vy)\n    if L == 0.0:\n        return 0.0, 0.0, 0.0\n    ux, uy = vx / L, vy / L\n    ts: list[float] = []\n    for X, Y in self.corners():\n        dx, dy = (X - x1), (Y - y1)\n        ts.append(dx * ux + dy * uy)  # dot with unit axis\n    return min(ts), max(ts), L",
      "language": "python"
    },
    {
      "code": "def to_pdf_array(self) -> str:\n    \"\"\"Convert bounding box to a PDF array string.\"\"\"\n    return f\"[{number_to_str(self.x0)} {number_to_str(self.y0)} {number_to_str(self.x1)} {number_to_str(self.y1)}]\"",
      "language": "python"
    },
    {
      "code": "def to_tuple(self) -> tuple[float, float, float, float]:\n    \"\"\"Convert bounding box to a 4-tuple.\"\"\"\n    return (self.x0, self.y0, self.x1, self.y1)",
      "language": "python"
    },
    {
      "code": "def transformed(self, tf: Transform) -> \"BoundingBox\":\n    \"\"\"\n    Return a new bounding box resulting from applying a transform to this one.\n    \"\"\"\n    corners = [\n        Point(self.x0, self.y0),\n        Point(self.x1, self.y0),\n        Point(self.x0, self.y1),\n        Point(self.x1, self.y1),\n    ]\n    transformed_points = [pt @ tf for pt in corners]\n    return BoundingBox.from_points(transformed_points)",
      "language": "python"
    },
    {
      "code": "class ClippingPath(PaintedPath):\n    \"\"\"\n    The PaintedPath API but to be used to create clipping paths.\n\n    .. warning::\n        Unless you really know what you're doing, changing attributes of the clipping\n        path style is likely to produce unexpected results. This is because the\n        clipping path styles override implicit style inheritance of the `PaintedPath`\n        it applies to.\n\n        For example, `clippath.style.stroke_width = 2` can unexpectedly override\n        `paintpath.style.stroke_width = GraphicsStyle.INHERIT` and cause the painted\n        path to be rendered with a stroke of 2 instead of what it would have normally\n        inherited. Because a `ClippingPath` can be painted like a normal `PaintedPath`,\n        it would be overly restrictive to remove the ability to style it, so instead\n        this warning is here.\n    \"\"\"\n\n    __slots__ = ()  # no new attributes; preserve slotted layout from PaintedPath\n\n    # because clipping paths can be painted, we inherit from PaintedPath. However, when\n    # setting the styling on the clipping path, those values will also be applied to\n    # the PaintedPath the ClippingPath is applied to unless they are explicitly set for\n    # that painted path. This is not ideal, but there's no way to really fix it from\n    # the PDF rendering model, and trying to track the appropriate state/defaults seems\n    # similarly error prone.\n\n    # In general, the expectation is that painted clipping paths are likely to be very\n    # uncommon, so it's an edge case that isn't worth worrying too much about.\n\n    def __init__(self, x: Number = 0, y: Number = 0) -> None:\n        super().__init__(x=float(x), y=float(y))\n        self.paint_rule = PathPaintRule.DONT_PAINT\n\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        # painting the clipping path outside of its root graphics context allows it to\n        # be transformed without affecting the transform of the graphics context of the\n        # path it is being used to clip. This is because, unlike all of the other style\n        # settings, transformations immediately affect the points following them,\n        # rather than only affecting them at painting time. stroke settings and color\n        # settings are applied only at paint time.\n\n        (\n            render_list,\n            last_item,\n            initial_point,\n        ) = self._root_graphics_context.build_render_list(\n            resource_registry,\n            style,\n            last_item,\n            initial_point,\n            _push_stack=False,\n        )\n\n        merged_style = GraphicsStyle.merge(style, self.style)\n        # we should never get a collision error here\n        intersection_rule: ClippingPathIntersectionRule = (\n            ClippingPathIntersectionRule.NONZERO\n        )\n        if not isinstance(merged_style.intersection_rule, InheritType):\n            intersection_rule = ClippingPathIntersectionRule[\n                merged_style.intersection_rule.name\n            ]\n\n        paint_rule = merged_style.resolve_paint_rule()\n\n        render_list.append(intersection_rule.value)\n        render_list.append(paint_rule.value)\n\n        return \" \".join(render_list), last_item, initial_point",
      "language": "python"
    },
    {
      "code": "def render(\n    self,\n    resource_registry: \"ResourceCatalog\",\n    style: GraphicsStyle,\n    last_item: Renderable,\n    initial_point: Point,\n) -> tuple[str, Renderable, Point]:\n    # painting the clipping path outside of its root graphics context allows it to\n    # be transformed without affecting the transform of the graphics context of the\n    # path it is being used to clip. This is because, unlike all of the other style\n    # settings, transformations immediately affect the points following them,\n    # rather than only affecting them at painting time. stroke settings and color\n    # settings are applied only at paint time.\n\n    (\n        render_list,\n        last_item,\n        initial_point,\n    ) = self._root_graphics_context.build_render_list(\n        resource_registry,\n        style,\n        last_item,\n        initial_point,\n        _push_stack=False,\n    )\n\n    merged_style = GraphicsStyle.merge(style, self.style)\n    # we should never get a collision error here\n    intersection_rule: ClippingPathIntersectionRule = (\n        ClippingPathIntersectionRule.NONZERO\n    )\n    if not isinstance(merged_style.intersection_rule, InheritType):\n        intersection_rule = ClippingPathIntersectionRule[\n            merged_style.intersection_rule.name\n        ]\n\n    paint_rule = merged_style.resolve_paint_rule()\n\n    render_list.append(intersection_rule.value)\n    render_list.append(paint_rule.value)\n\n    return \" \".join(render_list), last_item, initial_point",
      "language": "python"
    },
    {
      "code": "class Close(NamedTuple):\n    \"\"\"\n    A path close element.\n\n    Instructs the renderer to draw a straight line from the end of the last path element\n    to the start of the current path.\n\n    See: `PaintedPath.close`\n    \"\"\"\n\n    @property\n    def end_point(self) -> Point:\n        \"\"\"The end point of a Close is undefined; return (0, 0).\"\"\"\n        return Point(0, 0)\n\n    # pylint: disable=no-self-use\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        \"\"\"Return an empty bounding box; Close does not affect the geometry.\"\"\"\n        return BoundingBox.empty(), start\n\n    # pylint: disable=no-self-use\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        \"\"\"\n        Render this path element to its PDF representation.\n\n        Args:\n            resource_registry (ResourceCatalog): the owner's graphics state\n                dictionary registry.\n            style (GraphicsStyle): the current resolved graphics style\n            last_item: the previous path element.\n            initial_point: last position set by a \"M\" or \"m\" command\n\n        Returns:\n            a tuple of `(str, new_last_item)`, where `new_last_item` is whatever the old\n            last_item was.\n        \"\"\"\n        # pylint: disable=unused-argument\n        return \"h\", Move(initial_point), initial_point",
      "language": "python"
    },
    {
      "code": "@property\ndef end_point(self) -> Point:\n    \"\"\"The end point of a Close is undefined; return (0, 0).\"\"\"\n    return Point(0, 0)",
      "language": "python"
    },
    {
      "code": "def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n    \"\"\"Return an empty bounding box; Close does not affect the geometry.\"\"\"\n    return BoundingBox.empty(), start",
      "language": "python"
    },
    {
      "code": "@force_nodocument\ndef render(\n    self,\n    resource_registry: \"ResourceCatalog\",\n    style: GraphicsStyle,\n    last_item: Renderable,\n    initial_point: Point,\n) -> tuple[str, Renderable, Point]:\n    \"\"\"\n    Render this path element to its PDF representation.\n\n    Args:\n        resource_registry (ResourceCatalog): the owner's graphics state\n            dictionary registry.\n        style (GraphicsStyle): the current resolved graphics style\n        last_item: the previous path element.\n        initial_point: last position set by a \"M\" or \"m\" command\n\n    Returns:\n        a tuple of `(str, new_last_item)`, where `new_last_item` is whatever the old\n        last_item was.\n    \"\"\"\n    # pylint: disable=unused-argument\n    return \"h\", Move(initial_point), initial_point",
      "language": "python"
    },
    {
      "code": "class DrawingContext:\n    \"\"\"\n    Base context for a drawing in a PDF\n\n    This context is not stylable and is mainly responsible for transforming path\n    drawing coordinates into user coordinates (i.e. it ensures that the output drawing\n    is correctly scaled).\n    \"\"\"\n\n    __slots__ = (\"_subitems\",)\n\n    def __init__(self) -> None:\n        self._subitems: list[Union[GraphicsContext, PaintedPath, PaintComposite]] = []\n\n    def add_item(\n        self,\n        item: Union[\"GraphicsContext\", \"PaintedPath\", \"PaintComposite\"],\n        clone: bool = True,\n    ) -> None:\n        \"\"\"\n        Append an item to this drawing context\n\n        Args:\n            item (GraphicsContext, PaintedPath): the item to be appended.\n            clone (bool): if true (the default), the item will be copied before being\n                appended. This prevents modifications to a referenced object from\n                \"retroactively\" altering its style/shape and should be disabled with\n                caution.\n        \"\"\"\n\n        if not isinstance(item, (GraphicsContext, PaintedPath, PaintComposite)):\n            raise TypeError(f\"{item} doesn't belong in a DrawingContext\")\n\n        if clone:\n            item = deepcopy(item)\n\n        self._subitems.append(item)\n\n    @staticmethod\n    def _setup_render_prereqs(\n        style: GraphicsStyle, first_point: Point, scale: float, height: float\n    ) -> tuple[list[str], GraphicsStyle, Renderable]:\n        style.auto_close = True\n        style.paint_rule = PathPaintRule.AUTO\n        style.intersection_rule = IntersectionRule.NONZERO\n\n        last_item: Renderable = Move(first_point)\n        scale_rendered, last_item = (\n            Transform.scaling(x=1, y=-1)\n            .about(x=0, y=height / 2)\n            .scale(scale)\n            .render(last_item)\n        )\n\n        render_list = [\"q\", scale_rendered]\n\n        return render_list, style, last_item\n\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        first_point: Point,\n        scale: float,\n        height: float,\n        starting_style: GraphicsStyle,\n    ) -> str:\n        \"\"\"\n        Render the drawing context to PDF format.\n\n        Args:\n            resource_registry (ResourceCatalog): the parent document's graphics\n                state registry.\n            first_point (Point): the starting point to use if the first path element is\n                a relative element.\n            scale (Number): the scale factor to convert from PDF pt units into the\n                document's semantic units (e.g. mm or in).\n            height (Number): the page height. This is used to remap the coordinates to\n                be from the top-left corner of the page (matching fpdf's behavior)\n                instead of the PDF native behavior of bottom-left.\n            starting_style (GraphicsStyle): the base style for this drawing context,\n                derived from the document's current style defaults.\n\n        Returns:\n            A string composed of the PDF representation of all the paths and groups in\n            this context (an empty string is returned if there are no paths or groups)\n        \"\"\"\n        if not self._subitems:\n            return \"\"\n\n        render_list, style, last_item = self._setup_render_prereqs(\n            starting_style, first_point, scale, height\n        )\n\n        for item in self._subitems:\n            rendered, last_item, first_point = item.render(\n                resource_registry, style, last_item, first_point\n            )\n            if rendered:\n                render_list.append(rendered)\n\n        # there was nothing to render: the only items are the start group and scale\n        # transform.\n        if len(render_list) == 2:\n            return \"\"\n\n        if (\n            not isinstance(style.soft_mask, InheritType)\n            and style.soft_mask.object_id == 0\n        ):\n            style.soft_mask.object_id = resource_registry.register_soft_mask(\n                style.soft_mask\n            )\n        style_dict_name = resource_registry.register_graphics_style(style)\n        if style_dict_name is not None:\n            assert not isinstance(style.stroke_dash_pattern, InheritType)\n            assert not isinstance(style.stroke_dash_phase, InheritType)\n            render_list.insert(2, f\"{render_pdf_primitive(style_dict_name)} gs\")\n            render_list.insert(\n                3,\n                render_pdf_primitive(style.stroke_dash_pattern)\n                + f\" {number_to_str(style.stroke_dash_phase)} d\",\n            )\n\n        render_list.append(\"Q\")\n\n        return \" \".join(render_list)",
      "language": "python"
    },
    {
      "code": "def add_item(\n    self,\n    item: Union[\"GraphicsContext\", \"PaintedPath\", \"PaintComposite\"],\n    clone: bool = True,\n) -> None:\n    \"\"\"\n    Append an item to this drawing context\n\n    Args:\n        item (GraphicsContext, PaintedPath): the item to be appended.\n        clone (bool): if true (the default), the item will be copied before being\n            appended. This prevents modifications to a referenced object from\n            \"retroactively\" altering its style/shape and should be disabled with\n            caution.\n    \"\"\"\n\n    if not isinstance(item, (GraphicsContext, PaintedPath, PaintComposite)):\n        raise TypeError(f\"{item} doesn't belong in a DrawingContext\")\n\n    if clone:\n        item = deepcopy(item)\n\n    self._subitems.append(item)",
      "language": "python"
    },
    {
      "code": "def render(\n    self,\n    resource_registry: \"ResourceCatalog\",\n    first_point: Point,\n    scale: float,\n    height: float,\n    starting_style: GraphicsStyle,\n) -> str:\n    \"\"\"\n    Render the drawing context to PDF format.\n\n    Args:\n        resource_registry (ResourceCatalog): the parent document's graphics\n            state registry.\n        first_point (Point): the starting point to use if the first path element is\n            a relative element.\n        scale (Number): the scale factor to convert from PDF pt units into the\n            document's semantic units (e.g. mm or in).\n        height (Number): the page height. This is used to remap the coordinates to\n            be from the top-left corner of the page (matching fpdf's behavior)\n            instead of the PDF native behavior of bottom-left.\n        starting_style (GraphicsStyle): the base style for this drawing context,\n            derived from the document's current style defaults.\n\n    Returns:\n        A string composed of the PDF representation of all the paths and groups in\n        this context (an empty string is returned if there are no paths or groups)\n    \"\"\"\n    if not self._subitems:\n        return \"\"\n\n    render_list, style, last_item = self._setup_render_prereqs(\n        starting_style, first_point, scale, height\n    )\n\n    for item in self._subitems:\n        rendered, last_item, first_point = item.render(\n            resource_registry, style, last_item, first_point\n        )\n        if rendered:\n            render_list.append(rendered)\n\n    # there was nothing to render: the only items are the start group and scale\n    # transform.\n    if len(render_list) == 2:\n        return \"\"\n\n    if (\n        not isinstance(style.soft_mask, InheritType)\n        and style.soft_mask.object_id == 0\n    ):\n        style.soft_mask.object_id = resource_registry.register_soft_mask(\n            style.soft_mask\n        )\n    style_dict_name = resource_registry.register_graphics_style(style)\n    if style_dict_name is not None:\n        assert not isinstance(style.stroke_dash_pattern, InheritType)\n        assert not isinstance(style.stroke_dash_phase, InheritType)\n        render_list.insert(2, f\"{render_pdf_primitive(style_dict_name)} gs\")\n        render_list.insert(\n            3,\n            render_pdf_primitive(style.stroke_dash_pattern)\n            + f\" {number_to_str(style.stroke_dash_phase)} d\",\n        )\n\n    render_list.append(\"Q\")\n\n    return \" \".join(render_list)",
      "language": "python"
    },
    {
      "code": "class Ellipse(NamedTuple):\n    \"\"\"\n    An ellipse.\n\n    See: `PaintedPath.ellipse`\n    \"\"\"\n\n    radii: Point\n    \"\"\"The x- and y-radii of the ellipse\"\"\"\n    center: Point\n    \"\"\"The abscissa and ordinate of the center of the ellipse\"\"\"\n\n    @property\n    def end_point(self) -> Point:\n        raise NotImplementedError\n\n    def _decompose(self) -> list[Renderable]:\n        items: list[Renderable] = []\n\n        rx = abs(self.radii.x)\n        ry = abs(self.radii.y)\n        cx, cy = self.center\n\n        arc_rad = Point(rx, ry)\n\n        # this isn't the most efficient way to do this, computationally, but it's\n        # internally consistent.\n        if (rx != 0) and (ry != 0):\n            items.append(Move(Point(cx + rx, cy)))\n            items.append(Arc(arc_rad, 0, False, True, Point(cx, cy + ry)))\n            items.append(Arc(arc_rad, 0, False, True, Point(cx - rx, cy)))\n            items.append(Arc(arc_rad, 0, False, True, Point(cx, cy - ry)))\n            items.append(Arc(arc_rad, 0, False, True, Point(cx + rx, cy)))\n            items.append(Close())\n\n        return items\n\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        \"\"\"\n        Compute the bounding box of this ellipse by decomposing it and merging the bounding boxes\n        of its components.\n        \"\"\"\n        bbox = BoundingBox.empty()\n        current_point = start\n\n        for item in self._decompose():\n            b, current_point = item.bounding_box(current_point)\n            bbox = bbox.merge(b)\n\n        return bbox, self.center\n\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        \"\"\"\n        Render this path element to its PDF representation.\n\n        Args:\n            resource_registry (ResourceCatalog): the owner's graphics state\n                dictionary registry.\n            style (GraphicsStyle): the current resolved graphics style\n            last_item: the previous path element.\n            initial_point: last position set by a \"M\" or \"m\" command\n\n        Returns:\n            a tuple of `(str, new_last_item)`, where `new_last_item` is a resolved\n            `Move` to the center of the ellipse.\n        \"\"\"\n        components = self._decompose()\n\n        if not components:\n            return \"\", last_item, initial_point\n\n        render_list: list[str] = []\n        for item in components:\n            rendered, last_item, initial_point = item.render(\n                resource_registry, style, last_item, initial_point\n            )\n            render_list.append(rendered)\n\n        return \" \".join(render_list), Move(self.center), initial_point",
      "language": "python"
    },
    {
      "code": "class Ellipse(NamedTuple):\n    \"\"\"\n    An ellipse.\n\n    See: `PaintedPath.ellipse`\n    \"\"\"\n\n    radii: Point\n    \"\"\"The x- and y-radii of the ellipse\"\"\"\n    center: Point\n    \"\"\"The abscissa and ordinate of the center of the ellipse\"\"\"\n\n    @property\n    def end_point(self) -> Point:\n        raise NotImplementedError\n\n    def _decompose(self) -> list[Renderable]:\n        items: list[Renderable] = []\n\n        rx = abs(self.radii.x)\n        ry = abs(self.radii.y)\n        cx, cy = self.center\n\n        arc_rad = Point(rx, ry)\n\n        # this isn't the most efficient way to do this, computationally, but it's\n        # internally consistent.\n        if (rx != 0) and (ry != 0):\n            items.append(Move(Point(cx + rx, cy)))\n            items.append(Arc(arc_rad, 0, False, True, Point(cx, cy + ry)))\n            items.append(Arc(arc_rad, 0, False, True, Point(cx - rx, cy)))\n            items.append(Arc(arc_rad, 0, False, True, Point(cx, cy - ry)))\n            items.append(Arc(arc_rad, 0, False, True, Point(cx + rx, cy)))\n            items.append(Close())\n\n        return items\n\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        \"\"\"\n        Compute the bounding box of this ellipse by decomposing it and merging the bounding boxes\n        of its components.\n        \"\"\"\n        bbox = BoundingBox.empty()\n        current_point = start\n\n        for item in self._decompose():\n            b, current_point = item.bounding_box(current_point)\n            bbox = bbox.merge(b)\n\n        return bbox, self.center\n\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        \"\"\"\n        Render this path element to its PDF representation.\n\n        Args:\n            resource_registry (ResourceCatalog): the owner's graphics state\n                dictionary registry.\n            style (GraphicsStyle): the current resolved graphics style\n            last_item: the previous path element.\n            initial_point: last position set by a \"M\" or \"m\" command\n\n        Returns:\n            a tuple of `(str, new_last_item)`, where `new_last_item` is a resolved\n            `Move` to the center of the ellipse.\n        \"\"\"\n        components = self._decompose()\n\n        if not components:\n            return \"\", last_item, initial_point\n\n        render_list: list[str] = []\n        for item in components:\n            rendered, last_item, initial_point = item.render(\n                resource_registry, style, last_item, initial_point\n            )\n            render_list.append(rendered)\n\n        return \" \".join(render_list), Move(self.center), initial_point",
      "language": "python"
    },
    {
      "code": "@property\ndef end_point(self) -> Point:\n    raise NotImplementedError",
      "language": "python"
    },
    {
      "code": "class Ellipse(NamedTuple):\n    \"\"\"\n    An ellipse.\n\n    See: `PaintedPath.ellipse`\n    \"\"\"\n\n    radii: Point\n    \"\"\"The x- and y-radii of the ellipse\"\"\"\n    center: Point\n    \"\"\"The abscissa and ordinate of the center of the ellipse\"\"\"\n\n    @property\n    def end_point(self) -> Point:\n        raise NotImplementedError\n\n    def _decompose(self) -> list[Renderable]:\n        items: list[Renderable] = []\n\n        rx = abs(self.radii.x)\n        ry = abs(self.radii.y)\n        cx, cy = self.center\n\n        arc_rad = Point(rx, ry)\n\n        # this isn't the most efficient way to do this, computationally, but it's\n        # internally consistent.\n        if (rx != 0) and (ry != 0):\n            items.append(Move(Point(cx + rx, cy)))\n            items.append(Arc(arc_rad, 0, False, True, Point(cx, cy + ry)))\n            items.append(Arc(arc_rad, 0, False, True, Point(cx - rx, cy)))\n            items.append(Arc(arc_rad, 0, False, True, Point(cx, cy - ry)))\n            items.append(Arc(arc_rad, 0, False, True, Point(cx + rx, cy)))\n            items.append(Close())\n\n        return items\n\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        \"\"\"\n        Compute the bounding box of this ellipse by decomposing it and merging the bounding boxes\n        of its components.\n        \"\"\"\n        bbox = BoundingBox.empty()\n        current_point = start\n\n        for item in self._decompose():\n            b, current_point = item.bounding_box(current_point)\n            bbox = bbox.merge(b)\n\n        return bbox, self.center\n\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        \"\"\"\n        Render this path element to its PDF representation.\n\n        Args:\n            resource_registry (ResourceCatalog): the owner's graphics state\n                dictionary registry.\n            style (GraphicsStyle): the current resolved graphics style\n            last_item: the previous path element.\n            initial_point: last position set by a \"M\" or \"m\" command\n\n        Returns:\n            a tuple of `(str, new_last_item)`, where `new_last_item` is a resolved\n            `Move` to the center of the ellipse.\n        \"\"\"\n        components = self._decompose()\n\n        if not components:\n            return \"\", last_item, initial_point\n\n        render_list: list[str] = []\n        for item in components:\n            rendered, last_item, initial_point = item.render(\n                resource_registry, style, last_item, initial_point\n            )\n            render_list.append(rendered)\n\n        return \" \".join(render_list), Move(self.center), initial_point",
      "language": "python"
    },
    {
      "code": "def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n    \"\"\"\n    Compute the bounding box of this ellipse by decomposing it and merging the bounding boxes\n    of its components.\n    \"\"\"\n    bbox = BoundingBox.empty()\n    current_point = start\n\n    for item in self._decompose():\n        b, current_point = item.bounding_box(current_point)\n        bbox = bbox.merge(b)\n\n    return bbox, self.center",
      "language": "python"
    },
    {
      "code": "@force_nodocument\ndef render(\n    self,\n    resource_registry: \"ResourceCatalog\",\n    style: GraphicsStyle,\n    last_item: Renderable,\n    initial_point: Point,\n) -> tuple[str, Renderable, Point]:\n    \"\"\"\n    Render this path element to its PDF representation.\n\n    Args:\n        resource_registry (ResourceCatalog): the owner's graphics state\n            dictionary registry.\n        style (GraphicsStyle): the current resolved graphics style\n        last_item: the previous path element.\n        initial_point: last position set by a \"M\" or \"m\" command\n\n    Returns:\n        a tuple of `(str, new_last_item)`, where `new_last_item` is a resolved\n        `Move` to the center of the ellipse.\n    \"\"\"\n    components = self._decompose()\n\n    if not components:\n        return \"\", last_item, initial_point\n\n    render_list: list[str] = []\n    for item in components:\n        rendered, last_item, initial_point = item.render(\n            resource_registry, style, last_item, initial_point\n        )\n        render_list.append(rendered)\n\n    return \" \".join(render_list), Move(self.center), initial_point",
      "language": "python"
    },
    {
      "code": "class GlyphPathPen(PathPen):\n    \"\"\"A pen that can be used to draw glyphs into a `PaintedPath`.\"\"\"\n\n    def _closePath(self) -> None:\n        \"\"\"\n        The difference between GlyphPathPen and PathPen is that GlyphPathPen does not\n        remove the last path element before closing the path.\n        This last line back to start point is necessary for correctly rendering glyphs.\n        \"\"\"\n        self.pdf_path.close()",
      "language": "python"
    },
    {
      "code": "class GradientPaint:\n    \"\"\"Fill/stroke paint using a gradient\"\"\"\n\n    __slots__ = (\n        \"gradient\",\n        \"units\",\n        \"gradient_transform\",\n        \"apply_page_ctm\",\n        \"skip_alpha\",\n        \"spread_method\",\n    )\n\n    def __init__(\n        self,\n        gradient: Union[\"Gradient\", \"SweepGradient\"],\n        units: Union[GradientUnits, str] = GradientUnits.USER_SPACE_ON_USE,\n        gradient_transform: Optional[\"Transform\"] = None,\n        apply_page_ctm: bool = True,\n        spread_method: Optional[Union[str, GradientSpreadMethod]] = None,\n    ):\n        self.gradient = gradient\n        self.units = GradientUnits.coerce(units)\n        self.gradient_transform = gradient_transform or Transform.identity()\n        self.apply_page_ctm = apply_page_ctm\n        self.skip_alpha = False\n        self.spread_method = (\n            GradientSpreadMethod.coerce(spread_method)\n            if spread_method is not None\n            else GradientSpreadMethod.PAD\n        )\n\n    def _matrix_for(self, bbox: Optional[\"BoundingBox\"]) -> \"Transform\":\n        \"\"\"Return the final /Matrix for this gradient, given an optional bbox.\"\"\"\n        if self.units == GradientUnits.OBJECT_BOUNDING_BOX:\n            if bbox is None:\n                raise RuntimeError(\n                    \"GradientPaint requires bbox for objectBoundingBox units\"\n                )\n            # Map [0,1]x[0,1] object space, then apply gradient_transform\n            matrix_bbox = Transform(\n                a=bbox.width, b=0, c=0, d=bbox.height, e=bbox.x0, f=bbox.y0\n            )\n            return self.gradient_transform @ matrix_bbox\n        # userSpaceOnUse: only the provided gradient_transform\n        return self.gradient_transform\n\n    def _register_pattern(\n        self,\n        resource_catalog: \"ResourceCatalog\",\n        gradient: Gradient | MeshShading,\n        matrix: \"Transform\",\n    ) -> str:\n        \"\"\"Create a Pattern with the given matrix, register shading+pattern, return pattern name.\"\"\"\n        resource_catalog.add(PDFResourceType.SHADING, gradient, None)\n        pattern = Pattern(gradient).set_matrix(matrix)\n        pattern.set_apply_page_ctm(self.apply_page_ctm)\n        resource_id = resource_catalog.add(PDFResourceType.PATTERN, pattern, None)\n        assert resource_id is not None\n        return resource_id\n\n    def emit_fill(\n        self, resource_catalog: \"ResourceCatalog\", bbox: Optional[\"BoundingBox\"]\n    ) -> str:\n        domain_bbox = (\n            BoundingBox(0.0, 0.0, 1.0, 1.0)\n            if self.units == GradientUnits.OBJECT_BOUNDING_BOX\n            else bbox\n        )\n        gradient = self._get_gradient_with_spread_method(domain_bbox)\n        matrix = self._matrix_for(bbox)\n        pattern_name = self._register_pattern(resource_catalog, gradient, matrix)\n        return f\"/Pattern cs /{pattern_name} scn\"\n\n    def emit_stroke(\n        self, resource_catalog: \"ResourceCatalog\", bbox: Optional[\"BoundingBox\"]\n    ) -> str:\n        domain_bbox = (\n            BoundingBox(0.0, 0.0, 1.0, 1.0)\n            if self.units == GradientUnits.OBJECT_BOUNDING_BOX\n            else bbox\n        )\n        gradient = self._get_gradient_with_spread_method(domain_bbox)\n        matrix = self._matrix_for(bbox)\n        pattern_name = self._register_pattern(resource_catalog, gradient, matrix)\n        return f\"/Pattern CS /{pattern_name} SCN\"\n\n    def has_alpha(self) -> bool:\n        return self.gradient.has_alpha() and not self.skip_alpha\n\n    def _register_alpha_pattern(\n        self,\n        resource_catalog: \"ResourceCatalog\",\n        matrix: \"Transform\",\n        bbox: \"BoundingBox\",\n    ) -> str:\n        alpha_shading = self.gradient.get_alpha_shading_object(bbox)\n        if alpha_shading is None:\n            raise RuntimeError(\"Alpha gradient requested but no alpha ramp found\")\n        # Register the shading and wrap it into a Pattern using the same matrix\n        resource_catalog.add(PDFResourceType.SHADING, alpha_shading, None)\n        alpha_pattern = Pattern(alpha_shading).set_matrix(matrix)\n        alpha_pattern.set_apply_page_ctm(False)\n        pattern_id = resource_catalog.add(PDFResourceType.PATTERN, alpha_pattern, None)\n        assert isinstance(pattern_id, str)\n        return pattern_id\n\n    def _get_gradient_with_spread_method(\n        self, bbox: Optional[\"BoundingBox\"]\n    ) -> Gradient | MeshShading:\n        \"\"\"\n        Now that the bbox is known, we can construct a new gradient stop line to apply\n        the spread method reflect or repeat.\n        \"\"\"\n\n        if isinstance(self.gradient, SweepGradient):\n            self.gradient.spread_method = self.spread_method\n            assert bbox is not None\n            return self.gradient.get_shading_object(bbox)\n\n        if self.spread_method == GradientSpreadMethod.PAD:\n            return self.gradient  # nothing to do\n\n        if isinstance(self.gradient, LinearGradient):\n            x1, y1, x2, y2 = self.gradient.coords\n            raw_stops = getattr(self.gradient, \"raw_stops\", None)\n            if raw_stops is None:\n                colors = self.gradient.colors\n                bounds = self.gradient.bounds\n                stops = (\n                    [(0.0, colors[0])]\n                    + list(zip(bounds, colors[1:-1]))\n                    + [(1.0, colors[-1])]\n                )\n            else:\n                stops = raw_stops\n\n            spread_bbox = bbox\n            if bbox is not None and self.units == GradientUnits.USER_SPACE_ON_USE:\n                try:\n                    spread_bbox = bbox.transformed(self.gradient_transform.inverse())\n                except ValueError:\n                    spread_bbox = bbox\n\n            return shape_linear_gradient(\n                x1,\n                y1,\n                x2,\n                y2,\n                stops,\n                spread_method=self.spread_method,\n                bbox=spread_bbox,\n            )\n\n        if isinstance(self.gradient, RadialGradient):\n            fx, fy, fr, cx, cy, r = self.gradient.coords\n            raw_stops = getattr(self.gradient, \"raw_stops\", None)\n            if raw_stops is None:\n                colors = self.gradient.colors\n                bounds = self.gradient.bounds\n                stops = (\n                    [(0.0, colors[0])]\n                    + list(zip(bounds, colors[1:-1]))\n                    + [(1.0, colors[-1])]\n                )\n            else:\n                stops = raw_stops\n            spread_bbox = bbox\n            if bbox is not None and self.units == GradientUnits.USER_SPACE_ON_USE:\n                try:\n                    spread_bbox = bbox.transformed(self.gradient_transform.inverse())\n                except ValueError:\n                    spread_bbox = bbox\n\n            return shape_radial_gradient(\n                cx,\n                cy,\n                r,\n                stops,\n                fx=fx,\n                fy=fy,\n                fr=fr,\n                spread_method=self.spread_method,\n                bbox=spread_bbox,\n            )\n\n        return self.gradient  # unknown gradient type, return as is",
      "language": "python"
    },
    {
      "code": "class GradientPaint:\n    \"\"\"Fill/stroke paint using a gradient\"\"\"\n\n    __slots__ = (\n        \"gradient\",\n        \"units\",\n        \"gradient_transform\",\n        \"apply_page_ctm\",\n        \"skip_alpha\",\n        \"spread_method\",\n    )\n\n    def __init__(\n        self,\n        gradient: Union[\"Gradient\", \"SweepGradient\"],\n        units: Union[GradientUnits, str] = GradientUnits.USER_SPACE_ON_USE,\n        gradient_transform: Optional[\"Transform\"] = None,\n        apply_page_ctm: bool = True,\n        spread_method: Optional[Union[str, GradientSpreadMethod]] = None,\n    ):\n        self.gradient = gradient\n        self.units = GradientUnits.coerce(units)\n        self.gradient_transform = gradient_transform or Transform.identity()\n        self.apply_page_ctm = apply_page_ctm\n        self.skip_alpha = False\n        self.spread_method = (\n            GradientSpreadMethod.coerce(spread_method)\n            if spread_method is not None\n            else GradientSpreadMethod.PAD\n        )\n\n    def _matrix_for(self, bbox: Optional[\"BoundingBox\"]) -> \"Transform\":\n        \"\"\"Return the final /Matrix for this gradient, given an optional bbox.\"\"\"\n        if self.units == GradientUnits.OBJECT_BOUNDING_BOX:\n            if bbox is None:\n                raise RuntimeError(\n                    \"GradientPaint requires bbox for objectBoundingBox units\"\n                )\n            # Map [0,1]x[0,1] object space, then apply gradient_transform\n            matrix_bbox = Transform(\n                a=bbox.width, b=0, c=0, d=bbox.height, e=bbox.x0, f=bbox.y0\n            )\n            return self.gradient_transform @ matrix_bbox\n        # userSpaceOnUse: only the provided gradient_transform\n        return self.gradient_transform\n\n    def _register_pattern(\n        self,\n        resource_catalog: \"ResourceCatalog\",\n        gradient: Gradient | MeshShading,\n        matrix: \"Transform\",\n    ) -> str:\n        \"\"\"Create a Pattern with the given matrix, register shading+pattern, return pattern name.\"\"\"\n        resource_catalog.add(PDFResourceType.SHADING, gradient, None)\n        pattern = Pattern(gradient).set_matrix(matrix)\n        pattern.set_apply_page_ctm(self.apply_page_ctm)\n        resource_id = resource_catalog.add(PDFResourceType.PATTERN, pattern, None)\n        assert resource_id is not None\n        return resource_id\n\n    def emit_fill(\n        self, resource_catalog: \"ResourceCatalog\", bbox: Optional[\"BoundingBox\"]\n    ) -> str:\n        domain_bbox = (\n            BoundingBox(0.0, 0.0, 1.0, 1.0)\n            if self.units == GradientUnits.OBJECT_BOUNDING_BOX\n            else bbox\n        )\n        gradient = self._get_gradient_with_spread_method(domain_bbox)\n        matrix = self._matrix_for(bbox)\n        pattern_name = self._register_pattern(resource_catalog, gradient, matrix)\n        return f\"/Pattern cs /{pattern_name} scn\"\n\n    def emit_stroke(\n        self, resource_catalog: \"ResourceCatalog\", bbox: Optional[\"BoundingBox\"]\n    ) -> str:\n        domain_bbox = (\n            BoundingBox(0.0, 0.0, 1.0, 1.0)\n            if self.units == GradientUnits.OBJECT_BOUNDING_BOX\n            else bbox\n        )\n        gradient = self._get_gradient_with_spread_method(domain_bbox)\n        matrix = self._matrix_for(bbox)\n        pattern_name = self._register_pattern(resource_catalog, gradient, matrix)\n        return f\"/Pattern CS /{pattern_name} SCN\"\n\n    def has_alpha(self) -> bool:\n        return self.gradient.has_alpha() and not self.skip_alpha\n\n    def _register_alpha_pattern(\n        self,\n        resource_catalog: \"ResourceCatalog\",\n        matrix: \"Transform\",\n        bbox: \"BoundingBox\",\n    ) -> str:\n        alpha_shading = self.gradient.get_alpha_shading_object(bbox)\n        if alpha_shading is None:\n            raise RuntimeError(\"Alpha gradient requested but no alpha ramp found\")\n        # Register the shading and wrap it into a Pattern using the same matrix\n        resource_catalog.add(PDFResourceType.SHADING, alpha_shading, None)\n        alpha_pattern = Pattern(alpha_shading).set_matrix(matrix)\n        alpha_pattern.set_apply_page_ctm(False)\n        pattern_id = resource_catalog.add(PDFResourceType.PATTERN, alpha_pattern, None)\n        assert isinstance(pattern_id, str)\n        return pattern_id\n\n    def _get_gradient_with_spread_method(\n        self, bbox: Optional[\"BoundingBox\"]\n    ) -> Gradient | MeshShading:\n        \"\"\"\n        Now that the bbox is known, we can construct a new gradient stop line to apply\n        the spread method reflect or repeat.\n        \"\"\"\n\n        if isinstance(self.gradient, SweepGradient):\n            self.gradient.spread_method = self.spread_method\n            assert bbox is not None\n            return self.gradient.get_shading_object(bbox)\n\n        if self.spread_method == GradientSpreadMethod.PAD:\n            return self.gradient  # nothing to do\n\n        if isinstance(self.gradient, LinearGradient):\n            x1, y1, x2, y2 = self.gradient.coords\n            raw_stops = getattr(self.gradient, \"raw_stops\", None)\n            if raw_stops is None:\n                colors = self.gradient.colors\n                bounds = self.gradient.bounds\n                stops = (\n                    [(0.0, colors[0])]\n                    + list(zip(bounds, colors[1:-1]))\n                    + [(1.0, colors[-1])]\n                )\n            else:\n                stops = raw_stops\n\n            spread_bbox = bbox\n            if bbox is not None and self.units == GradientUnits.USER_SPACE_ON_USE:\n                try:\n                    spread_bbox = bbox.transformed(self.gradient_transform.inverse())\n                except ValueError:\n                    spread_bbox = bbox\n\n            return shape_linear_gradient(\n                x1,\n                y1,\n                x2,\n                y2,\n                stops,\n                spread_method=self.spread_method,\n                bbox=spread_bbox,\n            )\n\n        if isinstance(self.gradient, RadialGradient):\n            fx, fy, fr, cx, cy, r = self.gradient.coords\n            raw_stops = getattr(self.gradient, \"raw_stops\", None)\n            if raw_stops is None:\n                colors = self.gradient.colors\n                bounds = self.gradient.bounds\n                stops = (\n                    [(0.0, colors[0])]\n                    + list(zip(bounds, colors[1:-1]))\n                    + [(1.0, colors[-1])]\n                )\n            else:\n                stops = raw_stops\n            spread_bbox = bbox\n            if bbox is not None and self.units == GradientUnits.USER_SPACE_ON_USE:\n                try:\n                    spread_bbox = bbox.transformed(self.gradient_transform.inverse())\n                except ValueError:\n                    spread_bbox = bbox\n\n            return shape_radial_gradient(\n                cx,\n                cy,\n                r,\n                stops,\n                fx=fx,\n                fy=fy,\n                fr=fr,\n                spread_method=self.spread_method,\n                bbox=spread_bbox,\n            )\n\n        return self.gradient  # unknown gradient type, return as is",
      "language": "python"
    },
    {
      "code": "class GradientPaint:\n    \"\"\"Fill/stroke paint using a gradient\"\"\"\n\n    __slots__ = (\n        \"gradient\",\n        \"units\",\n        \"gradient_transform\",\n        \"apply_page_ctm\",\n        \"skip_alpha\",\n        \"spread_method\",\n    )\n\n    def __init__(\n        self,\n        gradient: Union[\"Gradient\", \"SweepGradient\"],\n        units: Union[GradientUnits, str] = GradientUnits.USER_SPACE_ON_USE,\n        gradient_transform: Optional[\"Transform\"] = None,\n        apply_page_ctm: bool = True,\n        spread_method: Optional[Union[str, GradientSpreadMethod]] = None,\n    ):\n        self.gradient = gradient\n        self.units = GradientUnits.coerce(units)\n        self.gradient_transform = gradient_transform or Transform.identity()\n        self.apply_page_ctm = apply_page_ctm\n        self.skip_alpha = False\n        self.spread_method = (\n            GradientSpreadMethod.coerce(spread_method)\n            if spread_method is not None\n            else GradientSpreadMethod.PAD\n        )\n\n    def _matrix_for(self, bbox: Optional[\"BoundingBox\"]) -> \"Transform\":\n        \"\"\"Return the final /Matrix for this gradient, given an optional bbox.\"\"\"\n        if self.units == GradientUnits.OBJECT_BOUNDING_BOX:\n            if bbox is None:\n                raise RuntimeError(\n                    \"GradientPaint requires bbox for objectBoundingBox units\"\n                )\n            # Map [0,1]x[0,1] object space, then apply gradient_transform\n            matrix_bbox = Transform(\n                a=bbox.width, b=0, c=0, d=bbox.height, e=bbox.x0, f=bbox.y0\n            )\n            return self.gradient_transform @ matrix_bbox\n        # userSpaceOnUse: only the provided gradient_transform\n        return self.gradient_transform\n\n    def _register_pattern(\n        self,\n        resource_catalog: \"ResourceCatalog\",\n        gradient: Gradient | MeshShading,\n        matrix: \"Transform\",\n    ) -> str:\n        \"\"\"Create a Pattern with the given matrix, register shading+pattern, return pattern name.\"\"\"\n        resource_catalog.add(PDFResourceType.SHADING, gradient, None)\n        pattern = Pattern(gradient).set_matrix(matrix)\n        pattern.set_apply_page_ctm(self.apply_page_ctm)\n        resource_id = resource_catalog.add(PDFResourceType.PATTERN, pattern, None)\n        assert resource_id is not None\n        return resource_id\n\n    def emit_fill(\n        self, resource_catalog: \"ResourceCatalog\", bbox: Optional[\"BoundingBox\"]\n    ) -> str:\n        domain_bbox = (\n            BoundingBox(0.0, 0.0, 1.0, 1.0)\n            if self.units == GradientUnits.OBJECT_BOUNDING_BOX\n            else bbox\n        )\n        gradient = self._get_gradient_with_spread_method(domain_bbox)\n        matrix = self._matrix_for(bbox)\n        pattern_name = self._register_pattern(resource_catalog, gradient, matrix)\n        return f\"/Pattern cs /{pattern_name} scn\"\n\n    def emit_stroke(\n        self, resource_catalog: \"ResourceCatalog\", bbox: Optional[\"BoundingBox\"]\n    ) -> str:\n        domain_bbox = (\n            BoundingBox(0.0, 0.0, 1.0, 1.0)\n            if self.units == GradientUnits.OBJECT_BOUNDING_BOX\n            else bbox\n        )\n        gradient = self._get_gradient_with_spread_method(domain_bbox)\n        matrix = self._matrix_for(bbox)\n        pattern_name = self._register_pattern(resource_catalog, gradient, matrix)\n        return f\"/Pattern CS /{pattern_name} SCN\"\n\n    def has_alpha(self) -> bool:\n        return self.gradient.has_alpha() and not self.skip_alpha\n\n    def _register_alpha_pattern(\n        self,\n        resource_catalog: \"ResourceCatalog\",\n        matrix: \"Transform\",\n        bbox: \"BoundingBox\",\n    ) -> str:\n        alpha_shading = self.gradient.get_alpha_shading_object(bbox)\n        if alpha_shading is None:\n            raise RuntimeError(\"Alpha gradient requested but no alpha ramp found\")\n        # Register the shading and wrap it into a Pattern using the same matrix\n        resource_catalog.add(PDFResourceType.SHADING, alpha_shading, None)\n        alpha_pattern = Pattern(alpha_shading).set_matrix(matrix)\n        alpha_pattern.set_apply_page_ctm(False)\n        pattern_id = resource_catalog.add(PDFResourceType.PATTERN, alpha_pattern, None)\n        assert isinstance(pattern_id, str)\n        return pattern_id\n\n    def _get_gradient_with_spread_method(\n        self, bbox: Optional[\"BoundingBox\"]\n    ) -> Gradient | MeshShading:\n        \"\"\"\n        Now that the bbox is known, we can construct a new gradient stop line to apply\n        the spread method reflect or repeat.\n        \"\"\"\n\n        if isinstance(self.gradient, SweepGradient):\n            self.gradient.spread_method = self.spread_method\n            assert bbox is not None\n            return self.gradient.get_shading_object(bbox)\n\n        if self.spread_method == GradientSpreadMethod.PAD:\n            return self.gradient  # nothing to do\n\n        if isinstance(self.gradient, LinearGradient):\n            x1, y1, x2, y2 = self.gradient.coords\n            raw_stops = getattr(self.gradient, \"raw_stops\", None)\n            if raw_stops is None:\n                colors = self.gradient.colors\n                bounds = self.gradient.bounds\n                stops = (\n                    [(0.0, colors[0])]\n                    + list(zip(bounds, colors[1:-1]))\n                    + [(1.0, colors[-1])]\n                )\n            else:\n                stops = raw_stops\n\n            spread_bbox = bbox\n            if bbox is not None and self.units == GradientUnits.USER_SPACE_ON_USE:\n                try:\n                    spread_bbox = bbox.transformed(self.gradient_transform.inverse())\n                except ValueError:\n                    spread_bbox = bbox\n\n            return shape_linear_gradient(\n                x1,\n                y1,\n                x2,\n                y2,\n                stops,\n                spread_method=self.spread_method,\n                bbox=spread_bbox,\n            )\n\n        if isinstance(self.gradient, RadialGradient):\n            fx, fy, fr, cx, cy, r = self.gradient.coords\n            raw_stops = getattr(self.gradient, \"raw_stops\", None)\n            if raw_stops is None:\n                colors = self.gradient.colors\n                bounds = self.gradient.bounds\n                stops = (\n                    [(0.0, colors[0])]\n                    + list(zip(bounds, colors[1:-1]))\n                    + [(1.0, colors[-1])]\n                )\n            else:\n                stops = raw_stops\n            spread_bbox = bbox\n            if bbox is not None and self.units == GradientUnits.USER_SPACE_ON_USE:\n                try:\n                    spread_bbox = bbox.transformed(self.gradient_transform.inverse())\n                except ValueError:\n                    spread_bbox = bbox\n\n            return shape_radial_gradient(\n                cx,\n                cy,\n                r,\n                stops,\n                fx=fx,\n                fy=fy,\n                fr=fr,\n                spread_method=self.spread_method,\n                bbox=spread_bbox,\n            )\n\n        return self.gradient  # unknown gradient type, return as is",
      "language": "python"
    },
    {
      "code": "class GradientPaint:\n    \"\"\"Fill/stroke paint using a gradient\"\"\"\n\n    __slots__ = (\n        \"gradient\",\n        \"units\",\n        \"gradient_transform\",\n        \"apply_page_ctm\",\n        \"skip_alpha\",\n        \"spread_method\",\n    )\n\n    def __init__(\n        self,\n        gradient: Union[\"Gradient\", \"SweepGradient\"],\n        units: Union[GradientUnits, str] = GradientUnits.USER_SPACE_ON_USE,\n        gradient_transform: Optional[\"Transform\"] = None,\n        apply_page_ctm: bool = True,\n        spread_method: Optional[Union[str, GradientSpreadMethod]] = None,\n    ):\n        self.gradient = gradient\n        self.units = GradientUnits.coerce(units)\n        self.gradient_transform = gradient_transform or Transform.identity()\n        self.apply_page_ctm = apply_page_ctm\n        self.skip_alpha = False\n        self.spread_method = (\n            GradientSpreadMethod.coerce(spread_method)\n            if spread_method is not None\n            else GradientSpreadMethod.PAD\n        )\n\n    def _matrix_for(self, bbox: Optional[\"BoundingBox\"]) -> \"Transform\":\n        \"\"\"Return the final /Matrix for this gradient, given an optional bbox.\"\"\"\n        if self.units == GradientUnits.OBJECT_BOUNDING_BOX:\n            if bbox is None:\n                raise RuntimeError(\n                    \"GradientPaint requires bbox for objectBoundingBox units\"\n                )\n            # Map [0,1]x[0,1] object space, then apply gradient_transform\n            matrix_bbox = Transform(\n                a=bbox.width, b=0, c=0, d=bbox.height, e=bbox.x0, f=bbox.y0\n            )\n            return self.gradient_transform @ matrix_bbox\n        # userSpaceOnUse: only the provided gradient_transform\n        return self.gradient_transform\n\n    def _register_pattern(\n        self,\n        resource_catalog: \"ResourceCatalog\",\n        gradient: Gradient | MeshShading,\n        matrix: \"Transform\",\n    ) -> str:\n        \"\"\"Create a Pattern with the given matrix, register shading+pattern, return pattern name.\"\"\"\n        resource_catalog.add(PDFResourceType.SHADING, gradient, None)\n        pattern = Pattern(gradient).set_matrix(matrix)\n        pattern.set_apply_page_ctm(self.apply_page_ctm)\n        resource_id = resource_catalog.add(PDFResourceType.PATTERN, pattern, None)\n        assert resource_id is not None\n        return resource_id\n\n    def emit_fill(\n        self, resource_catalog: \"ResourceCatalog\", bbox: Optional[\"BoundingBox\"]\n    ) -> str:\n        domain_bbox = (\n            BoundingBox(0.0, 0.0, 1.0, 1.0)\n            if self.units == GradientUnits.OBJECT_BOUNDING_BOX\n            else bbox\n        )\n        gradient = self._get_gradient_with_spread_method(domain_bbox)\n        matrix = self._matrix_for(bbox)\n        pattern_name = self._register_pattern(resource_catalog, gradient, matrix)\n        return f\"/Pattern cs /{pattern_name} scn\"\n\n    def emit_stroke(\n        self, resource_catalog: \"ResourceCatalog\", bbox: Optional[\"BoundingBox\"]\n    ) -> str:\n        domain_bbox = (\n            BoundingBox(0.0, 0.0, 1.0, 1.0)\n            if self.units == GradientUnits.OBJECT_BOUNDING_BOX\n            else bbox\n        )\n        gradient = self._get_gradient_with_spread_method(domain_bbox)\n        matrix = self._matrix_for(bbox)\n        pattern_name = self._register_pattern(resource_catalog, gradient, matrix)\n        return f\"/Pattern CS /{pattern_name} SCN\"\n\n    def has_alpha(self) -> bool:\n        return self.gradient.has_alpha() and not self.skip_alpha\n\n    def _register_alpha_pattern(\n        self,\n        resource_catalog: \"ResourceCatalog\",\n        matrix: \"Transform\",\n        bbox: \"BoundingBox\",\n    ) -> str:\n        alpha_shading = self.gradient.get_alpha_shading_object(bbox)\n        if alpha_shading is None:\n            raise RuntimeError(\"Alpha gradient requested but no alpha ramp found\")\n        # Register the shading and wrap it into a Pattern using the same matrix\n        resource_catalog.add(PDFResourceType.SHADING, alpha_shading, None)\n        alpha_pattern = Pattern(alpha_shading).set_matrix(matrix)\n        alpha_pattern.set_apply_page_ctm(False)\n        pattern_id = resource_catalog.add(PDFResourceType.PATTERN, alpha_pattern, None)\n        assert isinstance(pattern_id, str)\n        return pattern_id\n\n    def _get_gradient_with_spread_method(\n        self, bbox: Optional[\"BoundingBox\"]\n    ) -> Gradient | MeshShading:\n        \"\"\"\n        Now that the bbox is known, we can construct a new gradient stop line to apply\n        the spread method reflect or repeat.\n        \"\"\"\n\n        if isinstance(self.gradient, SweepGradient):\n            self.gradient.spread_method = self.spread_method\n            assert bbox is not None\n            return self.gradient.get_shading_object(bbox)\n\n        if self.spread_method == GradientSpreadMethod.PAD:\n            return self.gradient  # nothing to do\n\n        if isinstance(self.gradient, LinearGradient):\n            x1, y1, x2, y2 = self.gradient.coords\n            raw_stops = getattr(self.gradient, \"raw_stops\", None)\n            if raw_stops is None:\n                colors = self.gradient.colors\n                bounds = self.gradient.bounds\n                stops = (\n                    [(0.0, colors[0])]\n                    + list(zip(bounds, colors[1:-1]))\n                    + [(1.0, colors[-1])]\n                )\n            else:\n                stops = raw_stops\n\n            spread_bbox = bbox\n            if bbox is not None and self.units == GradientUnits.USER_SPACE_ON_USE:\n                try:\n                    spread_bbox = bbox.transformed(self.gradient_transform.inverse())\n                except ValueError:\n                    spread_bbox = bbox\n\n            return shape_linear_gradient(\n                x1,\n                y1,\n                x2,\n                y2,\n                stops,\n                spread_method=self.spread_method,\n                bbox=spread_bbox,\n            )\n\n        if isinstance(self.gradient, RadialGradient):\n            fx, fy, fr, cx, cy, r = self.gradient.coords\n            raw_stops = getattr(self.gradient, \"raw_stops\", None)\n            if raw_stops is None:\n                colors = self.gradient.colors\n                bounds = self.gradient.bounds\n                stops = (\n                    [(0.0, colors[0])]\n                    + list(zip(bounds, colors[1:-1]))\n                    + [(1.0, colors[-1])]\n                )\n            else:\n                stops = raw_stops\n            spread_bbox = bbox\n            if bbox is not None and self.units == GradientUnits.USER_SPACE_ON_USE:\n                try:\n                    spread_bbox = bbox.transformed(self.gradient_transform.inverse())\n                except ValueError:\n                    spread_bbox = bbox\n\n            return shape_radial_gradient(\n                cx,\n                cy,\n                r,\n                stops,\n                fx=fx,\n                fy=fy,\n                fr=fr,\n                spread_method=self.spread_method,\n                bbox=spread_bbox,\n            )\n\n        return self.gradient  # unknown gradient type, return as is",
      "language": "python"
    },
    {
      "code": "class GradientPaint:\n    \"\"\"Fill/stroke paint using a gradient\"\"\"\n\n    __slots__ = (\n        \"gradient\",\n        \"units\",\n        \"gradient_transform\",\n        \"apply_page_ctm\",\n        \"skip_alpha\",\n        \"spread_method\",\n    )\n\n    def __init__(\n        self,\n        gradient: Union[\"Gradient\", \"SweepGradient\"],\n        units: Union[GradientUnits, str] = GradientUnits.USER_SPACE_ON_USE,\n        gradient_transform: Optional[\"Transform\"] = None,\n        apply_page_ctm: bool = True,\n        spread_method: Optional[Union[str, GradientSpreadMethod]] = None,\n    ):\n        self.gradient = gradient\n        self.units = GradientUnits.coerce(units)\n        self.gradient_transform = gradient_transform or Transform.identity()\n        self.apply_page_ctm = apply_page_ctm\n        self.skip_alpha = False\n        self.spread_method = (\n            GradientSpreadMethod.coerce(spread_method)\n            if spread_method is not None\n            else GradientSpreadMethod.PAD\n        )\n\n    def _matrix_for(self, bbox: Optional[\"BoundingBox\"]) -> \"Transform\":\n        \"\"\"Return the final /Matrix for this gradient, given an optional bbox.\"\"\"\n        if self.units == GradientUnits.OBJECT_BOUNDING_BOX:\n            if bbox is None:\n                raise RuntimeError(\n                    \"GradientPaint requires bbox for objectBoundingBox units\"\n                )\n            # Map [0,1]x[0,1] object space, then apply gradient_transform\n            matrix_bbox = Transform(\n                a=bbox.width, b=0, c=0, d=bbox.height, e=bbox.x0, f=bbox.y0\n            )\n            return self.gradient_transform @ matrix_bbox\n        # userSpaceOnUse: only the provided gradient_transform\n        return self.gradient_transform\n\n    def _register_pattern(\n        self,\n        resource_catalog: \"ResourceCatalog\",\n        gradient: Gradient | MeshShading,\n        matrix: \"Transform\",\n    ) -> str:\n        \"\"\"Create a Pattern with the given matrix, register shading+pattern, return pattern name.\"\"\"\n        resource_catalog.add(PDFResourceType.SHADING, gradient, None)\n        pattern = Pattern(gradient).set_matrix(matrix)\n        pattern.set_apply_page_ctm(self.apply_page_ctm)\n        resource_id = resource_catalog.add(PDFResourceType.PATTERN, pattern, None)\n        assert resource_id is not None\n        return resource_id\n\n    def emit_fill(\n        self, resource_catalog: \"ResourceCatalog\", bbox: Optional[\"BoundingBox\"]\n    ) -> str:\n        domain_bbox = (\n            BoundingBox(0.0, 0.0, 1.0, 1.0)\n            if self.units == GradientUnits.OBJECT_BOUNDING_BOX\n            else bbox\n        )\n        gradient = self._get_gradient_with_spread_method(domain_bbox)\n        matrix = self._matrix_for(bbox)\n        pattern_name = self._register_pattern(resource_catalog, gradient, matrix)\n        return f\"/Pattern cs /{pattern_name} scn\"\n\n    def emit_stroke(\n        self, resource_catalog: \"ResourceCatalog\", bbox: Optional[\"BoundingBox\"]\n    ) -> str:\n        domain_bbox = (\n            BoundingBox(0.0, 0.0, 1.0, 1.0)\n            if self.units == GradientUnits.OBJECT_BOUNDING_BOX\n            else bbox\n        )\n        gradient = self._get_gradient_with_spread_method(domain_bbox)\n        matrix = self._matrix_for(bbox)\n        pattern_name = self._register_pattern(resource_catalog, gradient, matrix)\n        return f\"/Pattern CS /{pattern_name} SCN\"\n\n    def has_alpha(self) -> bool:\n        return self.gradient.has_alpha() and not self.skip_alpha\n\n    def _register_alpha_pattern(\n        self,\n        resource_catalog: \"ResourceCatalog\",\n        matrix: \"Transform\",\n        bbox: \"BoundingBox\",\n    ) -> str:\n        alpha_shading = self.gradient.get_alpha_shading_object(bbox)\n        if alpha_shading is None:\n            raise RuntimeError(\"Alpha gradient requested but no alpha ramp found\")\n        # Register the shading and wrap it into a Pattern using the same matrix\n        resource_catalog.add(PDFResourceType.SHADING, alpha_shading, None)\n        alpha_pattern = Pattern(alpha_shading).set_matrix(matrix)\n        alpha_pattern.set_apply_page_ctm(False)\n        pattern_id = resource_catalog.add(PDFResourceType.PATTERN, alpha_pattern, None)\n        assert isinstance(pattern_id, str)\n        return pattern_id\n\n    def _get_gradient_with_spread_method(\n        self, bbox: Optional[\"BoundingBox\"]\n    ) -> Gradient | MeshShading:\n        \"\"\"\n        Now that the bbox is known, we can construct a new gradient stop line to apply\n        the spread method reflect or repeat.\n        \"\"\"\n\n        if isinstance(self.gradient, SweepGradient):\n            self.gradient.spread_method = self.spread_method\n            assert bbox is not None\n            return self.gradient.get_shading_object(bbox)\n\n        if self.spread_method == GradientSpreadMethod.PAD:\n            return self.gradient  # nothing to do\n\n        if isinstance(self.gradient, LinearGradient):\n            x1, y1, x2, y2 = self.gradient.coords\n            raw_stops = getattr(self.gradient, \"raw_stops\", None)\n            if raw_stops is None:\n                colors = self.gradient.colors\n                bounds = self.gradient.bounds\n                stops = (\n                    [(0.0, colors[0])]\n                    + list(zip(bounds, colors[1:-1]))\n                    + [(1.0, colors[-1])]\n                )\n            else:\n                stops = raw_stops\n\n            spread_bbox = bbox\n            if bbox is not None and self.units == GradientUnits.USER_SPACE_ON_USE:\n                try:\n                    spread_bbox = bbox.transformed(self.gradient_transform.inverse())\n                except ValueError:\n                    spread_bbox = bbox\n\n            return shape_linear_gradient(\n                x1,\n                y1,\n                x2,\n                y2,\n                stops,\n                spread_method=self.spread_method,\n                bbox=spread_bbox,\n            )\n\n        if isinstance(self.gradient, RadialGradient):\n            fx, fy, fr, cx, cy, r = self.gradient.coords\n            raw_stops = getattr(self.gradient, \"raw_stops\", None)\n            if raw_stops is None:\n                colors = self.gradient.colors\n                bounds = self.gradient.bounds\n                stops = (\n                    [(0.0, colors[0])]\n                    + list(zip(bounds, colors[1:-1]))\n                    + [(1.0, colors[-1])]\n                )\n            else:\n                stops = raw_stops\n            spread_bbox = bbox\n            if bbox is not None and self.units == GradientUnits.USER_SPACE_ON_USE:\n                try:\n                    spread_bbox = bbox.transformed(self.gradient_transform.inverse())\n                except ValueError:\n                    spread_bbox = bbox\n\n            return shape_radial_gradient(\n                cx,\n                cy,\n                r,\n                stops,\n                fx=fx,\n                fy=fy,\n                fr=fr,\n                spread_method=self.spread_method,\n                bbox=spread_bbox,\n            )\n\n        return self.gradient  # unknown gradient type, return as is",
      "language": "python"
    },
    {
      "code": "class GradientPaint:\n    \"\"\"Fill/stroke paint using a gradient\"\"\"\n\n    __slots__ = (\n        \"gradient\",\n        \"units\",\n        \"gradient_transform\",\n        \"apply_page_ctm\",\n        \"skip_alpha\",\n        \"spread_method\",\n    )\n\n    def __init__(\n        self,\n        gradient: Union[\"Gradient\", \"SweepGradient\"],\n        units: Union[GradientUnits, str] = GradientUnits.USER_SPACE_ON_USE,\n        gradient_transform: Optional[\"Transform\"] = None,\n        apply_page_ctm: bool = True,\n        spread_method: Optional[Union[str, GradientSpreadMethod]] = None,\n    ):\n        self.gradient = gradient\n        self.units = GradientUnits.coerce(units)\n        self.gradient_transform = gradient_transform or Transform.identity()\n        self.apply_page_ctm = apply_page_ctm\n        self.skip_alpha = False\n        self.spread_method = (\n            GradientSpreadMethod.coerce(spread_method)\n            if spread_method is not None\n            else GradientSpreadMethod.PAD\n        )\n\n    def _matrix_for(self, bbox: Optional[\"BoundingBox\"]) -> \"Transform\":\n        \"\"\"Return the final /Matrix for this gradient, given an optional bbox.\"\"\"\n        if self.units == GradientUnits.OBJECT_BOUNDING_BOX:\n            if bbox is None:\n                raise RuntimeError(\n                    \"GradientPaint requires bbox for objectBoundingBox units\"\n                )\n            # Map [0,1]x[0,1] object space, then apply gradient_transform\n            matrix_bbox = Transform(\n                a=bbox.width, b=0, c=0, d=bbox.height, e=bbox.x0, f=bbox.y0\n            )\n            return self.gradient_transform @ matrix_bbox\n        # userSpaceOnUse: only the provided gradient_transform\n        return self.gradient_transform\n\n    def _register_pattern(\n        self,\n        resource_catalog: \"ResourceCatalog\",\n        gradient: Gradient | MeshShading,\n        matrix: \"Transform\",\n    ) -> str:\n        \"\"\"Create a Pattern with the given matrix, register shading+pattern, return pattern name.\"\"\"\n        resource_catalog.add(PDFResourceType.SHADING, gradient, None)\n        pattern = Pattern(gradient).set_matrix(matrix)\n        pattern.set_apply_page_ctm(self.apply_page_ctm)\n        resource_id = resource_catalog.add(PDFResourceType.PATTERN, pattern, None)\n        assert resource_id is not None\n        return resource_id\n\n    def emit_fill(\n        self, resource_catalog: \"ResourceCatalog\", bbox: Optional[\"BoundingBox\"]\n    ) -> str:\n        domain_bbox = (\n            BoundingBox(0.0, 0.0, 1.0, 1.0)\n            if self.units == GradientUnits.OBJECT_BOUNDING_BOX\n            else bbox\n        )\n        gradient = self._get_gradient_with_spread_method(domain_bbox)\n        matrix = self._matrix_for(bbox)\n        pattern_name = self._register_pattern(resource_catalog, gradient, matrix)\n        return f\"/Pattern cs /{pattern_name} scn\"\n\n    def emit_stroke(\n        self, resource_catalog: \"ResourceCatalog\", bbox: Optional[\"BoundingBox\"]\n    ) -> str:\n        domain_bbox = (\n            BoundingBox(0.0, 0.0, 1.0, 1.0)\n            if self.units == GradientUnits.OBJECT_BOUNDING_BOX\n            else bbox\n        )\n        gradient = self._get_gradient_with_spread_method(domain_bbox)\n        matrix = self._matrix_for(bbox)\n        pattern_name = self._register_pattern(resource_catalog, gradient, matrix)\n        return f\"/Pattern CS /{pattern_name} SCN\"\n\n    def has_alpha(self) -> bool:\n        return self.gradient.has_alpha() and not self.skip_alpha\n\n    def _register_alpha_pattern(\n        self,\n        resource_catalog: \"ResourceCatalog\",\n        matrix: \"Transform\",\n        bbox: \"BoundingBox\",\n    ) -> str:\n        alpha_shading = self.gradient.get_alpha_shading_object(bbox)\n        if alpha_shading is None:\n            raise RuntimeError(\"Alpha gradient requested but no alpha ramp found\")\n        # Register the shading and wrap it into a Pattern using the same matrix\n        resource_catalog.add(PDFResourceType.SHADING, alpha_shading, None)\n        alpha_pattern = Pattern(alpha_shading).set_matrix(matrix)\n        alpha_pattern.set_apply_page_ctm(False)\n        pattern_id = resource_catalog.add(PDFResourceType.PATTERN, alpha_pattern, None)\n        assert isinstance(pattern_id, str)\n        return pattern_id\n\n    def _get_gradient_with_spread_method(\n        self, bbox: Optional[\"BoundingBox\"]\n    ) -> Gradient | MeshShading:\n        \"\"\"\n        Now that the bbox is known, we can construct a new gradient stop line to apply\n        the spread method reflect or repeat.\n        \"\"\"\n\n        if isinstance(self.gradient, SweepGradient):\n            self.gradient.spread_method = self.spread_method\n            assert bbox is not None\n            return self.gradient.get_shading_object(bbox)\n\n        if self.spread_method == GradientSpreadMethod.PAD:\n            return self.gradient  # nothing to do\n\n        if isinstance(self.gradient, LinearGradient):\n            x1, y1, x2, y2 = self.gradient.coords\n            raw_stops = getattr(self.gradient, \"raw_stops\", None)\n            if raw_stops is None:\n                colors = self.gradient.colors\n                bounds = self.gradient.bounds\n                stops = (\n                    [(0.0, colors[0])]\n                    + list(zip(bounds, colors[1:-1]))\n                    + [(1.0, colors[-1])]\n                )\n            else:\n                stops = raw_stops\n\n            spread_bbox = bbox\n            if bbox is not None and self.units == GradientUnits.USER_SPACE_ON_USE:\n                try:\n                    spread_bbox = bbox.transformed(self.gradient_transform.inverse())\n                except ValueError:\n                    spread_bbox = bbox\n\n            return shape_linear_gradient(\n                x1,\n                y1,\n                x2,\n                y2,\n                stops,\n                spread_method=self.spread_method,\n                bbox=spread_bbox,\n            )\n\n        if isinstance(self.gradient, RadialGradient):\n            fx, fy, fr, cx, cy, r = self.gradient.coords\n            raw_stops = getattr(self.gradient, \"raw_stops\", None)\n            if raw_stops is None:\n                colors = self.gradient.colors\n                bounds = self.gradient.bounds\n                stops = (\n                    [(0.0, colors[0])]\n                    + list(zip(bounds, colors[1:-1]))\n                    + [(1.0, colors[-1])]\n                )\n            else:\n                stops = raw_stops\n            spread_bbox = bbox\n            if bbox is not None and self.units == GradientUnits.USER_SPACE_ON_USE:\n                try:\n                    spread_bbox = bbox.transformed(self.gradient_transform.inverse())\n                except ValueError:\n                    spread_bbox = bbox\n\n            return shape_radial_gradient(\n                cx,\n                cy,\n                r,\n                stops,\n                fx=fx,\n                fy=fy,\n                fr=fr,\n                spread_method=self.spread_method,\n                bbox=spread_bbox,\n            )\n\n        return self.gradient  # unknown gradient type, return as is",
      "language": "python"
    },
    {
      "code": "class GradientPaint:\n    \"\"\"Fill/stroke paint using a gradient\"\"\"\n\n    __slots__ = (\n        \"gradient\",\n        \"units\",\n        \"gradient_transform\",\n        \"apply_page_ctm\",\n        \"skip_alpha\",\n        \"spread_method\",\n    )\n\n    def __init__(\n        self,\n        gradient: Union[\"Gradient\", \"SweepGradient\"],\n        units: Union[GradientUnits, str] = GradientUnits.USER_SPACE_ON_USE,\n        gradient_transform: Optional[\"Transform\"] = None,\n        apply_page_ctm: bool = True,\n        spread_method: Optional[Union[str, GradientSpreadMethod]] = None,\n    ):\n        self.gradient = gradient\n        self.units = GradientUnits.coerce(units)\n        self.gradient_transform = gradient_transform or Transform.identity()\n        self.apply_page_ctm = apply_page_ctm\n        self.skip_alpha = False\n        self.spread_method = (\n            GradientSpreadMethod.coerce(spread_method)\n            if spread_method is not None\n            else GradientSpreadMethod.PAD\n        )\n\n    def _matrix_for(self, bbox: Optional[\"BoundingBox\"]) -> \"Transform\":\n        \"\"\"Return the final /Matrix for this gradient, given an optional bbox.\"\"\"\n        if self.units == GradientUnits.OBJECT_BOUNDING_BOX:\n            if bbox is None:\n                raise RuntimeError(\n                    \"GradientPaint requires bbox for objectBoundingBox units\"\n                )\n            # Map [0,1]x[0,1] object space, then apply gradient_transform\n            matrix_bbox = Transform(\n                a=bbox.width, b=0, c=0, d=bbox.height, e=bbox.x0, f=bbox.y0\n            )\n            return self.gradient_transform @ matrix_bbox\n        # userSpaceOnUse: only the provided gradient_transform\n        return self.gradient_transform\n\n    def _register_pattern(\n        self,\n        resource_catalog: \"ResourceCatalog\",\n        gradient: Gradient | MeshShading,\n        matrix: \"Transform\",\n    ) -> str:\n        \"\"\"Create a Pattern with the given matrix, register shading+pattern, return pattern name.\"\"\"\n        resource_catalog.add(PDFResourceType.SHADING, gradient, None)\n        pattern = Pattern(gradient).set_matrix(matrix)\n        pattern.set_apply_page_ctm(self.apply_page_ctm)\n        resource_id = resource_catalog.add(PDFResourceType.PATTERN, pattern, None)\n        assert resource_id is not None\n        return resource_id\n\n    def emit_fill(\n        self, resource_catalog: \"ResourceCatalog\", bbox: Optional[\"BoundingBox\"]\n    ) -> str:\n        domain_bbox = (\n            BoundingBox(0.0, 0.0, 1.0, 1.0)\n            if self.units == GradientUnits.OBJECT_BOUNDING_BOX\n            else bbox\n        )\n        gradient = self._get_gradient_with_spread_method(domain_bbox)\n        matrix = self._matrix_for(bbox)\n        pattern_name = self._register_pattern(resource_catalog, gradient, matrix)\n        return f\"/Pattern cs /{pattern_name} scn\"\n\n    def emit_stroke(\n        self, resource_catalog: \"ResourceCatalog\", bbox: Optional[\"BoundingBox\"]\n    ) -> str:\n        domain_bbox = (\n            BoundingBox(0.0, 0.0, 1.0, 1.0)\n            if self.units == GradientUnits.OBJECT_BOUNDING_BOX\n            else bbox\n        )\n        gradient = self._get_gradient_with_spread_method(domain_bbox)\n        matrix = self._matrix_for(bbox)\n        pattern_name = self._register_pattern(resource_catalog, gradient, matrix)\n        return f\"/Pattern CS /{pattern_name} SCN\"\n\n    def has_alpha(self) -> bool:\n        return self.gradient.has_alpha() and not self.skip_alpha\n\n    def _register_alpha_pattern(\n        self,\n        resource_catalog: \"ResourceCatalog\",\n        matrix: \"Transform\",\n        bbox: \"BoundingBox\",\n    ) -> str:\n        alpha_shading = self.gradient.get_alpha_shading_object(bbox)\n        if alpha_shading is None:\n            raise RuntimeError(\"Alpha gradient requested but no alpha ramp found\")\n        # Register the shading and wrap it into a Pattern using the same matrix\n        resource_catalog.add(PDFResourceType.SHADING, alpha_shading, None)\n        alpha_pattern = Pattern(alpha_shading).set_matrix(matrix)\n        alpha_pattern.set_apply_page_ctm(False)\n        pattern_id = resource_catalog.add(PDFResourceType.PATTERN, alpha_pattern, None)\n        assert isinstance(pattern_id, str)\n        return pattern_id\n\n    def _get_gradient_with_spread_method(\n        self, bbox: Optional[\"BoundingBox\"]\n    ) -> Gradient | MeshShading:\n        \"\"\"\n        Now that the bbox is known, we can construct a new gradient stop line to apply\n        the spread method reflect or repeat.\n        \"\"\"\n\n        if isinstance(self.gradient, SweepGradient):\n            self.gradient.spread_method = self.spread_method\n            assert bbox is not None\n            return self.gradient.get_shading_object(bbox)\n\n        if self.spread_method == GradientSpreadMethod.PAD:\n            return self.gradient  # nothing to do\n\n        if isinstance(self.gradient, LinearGradient):\n            x1, y1, x2, y2 = self.gradient.coords\n            raw_stops = getattr(self.gradient, \"raw_stops\", None)\n            if raw_stops is None:\n                colors = self.gradient.colors\n                bounds = self.gradient.bounds\n                stops = (\n                    [(0.0, colors[0])]\n                    + list(zip(bounds, colors[1:-1]))\n                    + [(1.0, colors[-1])]\n                )\n            else:\n                stops = raw_stops\n\n            spread_bbox = bbox\n            if bbox is not None and self.units == GradientUnits.USER_SPACE_ON_USE:\n                try:\n                    spread_bbox = bbox.transformed(self.gradient_transform.inverse())\n                except ValueError:\n                    spread_bbox = bbox\n\n            return shape_linear_gradient(\n                x1,\n                y1,\n                x2,\n                y2,\n                stops,\n                spread_method=self.spread_method,\n                bbox=spread_bbox,\n            )\n\n        if isinstance(self.gradient, RadialGradient):\n            fx, fy, fr, cx, cy, r = self.gradient.coords\n            raw_stops = getattr(self.gradient, \"raw_stops\", None)\n            if raw_stops is None:\n                colors = self.gradient.colors\n                bounds = self.gradient.bounds\n                stops = (\n                    [(0.0, colors[0])]\n                    + list(zip(bounds, colors[1:-1]))\n                    + [(1.0, colors[-1])]\n                )\n            else:\n                stops = raw_stops\n            spread_bbox = bbox\n            if bbox is not None and self.units == GradientUnits.USER_SPACE_ON_USE:\n                try:\n                    spread_bbox = bbox.transformed(self.gradient_transform.inverse())\n                except ValueError:\n                    spread_bbox = bbox\n\n            return shape_radial_gradient(\n                cx,\n                cy,\n                r,\n                stops,\n                fx=fx,\n                fy=fy,\n                fr=fr,\n                spread_method=self.spread_method,\n                bbox=spread_bbox,\n            )\n\n        return self.gradient  # unknown gradient type, return as is",
      "language": "python"
    },
    {
      "code": "def emit_fill(\n    self, resource_catalog: \"ResourceCatalog\", bbox: Optional[\"BoundingBox\"]\n) -> str:\n    domain_bbox = (\n        BoundingBox(0.0, 0.0, 1.0, 1.0)\n        if self.units == GradientUnits.OBJECT_BOUNDING_BOX\n        else bbox\n    )\n    gradient = self._get_gradient_with_spread_method(domain_bbox)\n    matrix = self._matrix_for(bbox)\n    pattern_name = self._register_pattern(resource_catalog, gradient, matrix)\n    return f\"/Pattern cs /{pattern_name} scn\"",
      "language": "python"
    },
    {
      "code": "def emit_stroke(\n    self, resource_catalog: \"ResourceCatalog\", bbox: Optional[\"BoundingBox\"]\n) -> str:\n    domain_bbox = (\n        BoundingBox(0.0, 0.0, 1.0, 1.0)\n        if self.units == GradientUnits.OBJECT_BOUNDING_BOX\n        else bbox\n    )\n    gradient = self._get_gradient_with_spread_method(domain_bbox)\n    matrix = self._matrix_for(bbox)\n    pattern_name = self._register_pattern(resource_catalog, gradient, matrix)\n    return f\"/Pattern CS /{pattern_name} SCN\"",
      "language": "python"
    },
    {
      "code": "def has_alpha(self) -> bool:\n    return self.gradient.has_alpha() and not self.skip_alpha",
      "language": "python"
    },
    {
      "code": "class GraphicsContext:\n    \"\"\"\n    Page-level container that collects drawable items and renders them into a PDF\n    content stream.\n\n    Converts model coordinates to PDF user space by applying the provided\n    `scale` and a vertical flip so (0, 0) is the top-left of the page.\n\n    Wraps output in a saved graphics state (`q … Q`) and registers any\n    required resources (graphics state dictionaries, soft masks, dash pattern).\n\n    Child items are typically `GraphicsContext`, `PaintedPath`, or `PaintComposite`\n    objects added via `add_item()`. By default, items are deep-copied on insert to\n    avoid later mutations affecting the emitted stream.\n    \"\"\"\n\n    __slots__ = (\"style\", \"path_items\", \"_transform\", \"_clipping_path\")\n\n    def __init__(self) -> None:\n        self.style: GraphicsStyle = GraphicsStyle()\n        self.path_items: list[\n            Renderable\n            | GraphicsContext\n            | PaintedPath\n            | PaintComposite\n            | PaintBlendComposite\n        ] = []\n\n        self._transform: Optional[Transform] = None\n        self._clipping_path: Optional[ClippingPath] = None\n\n    def __deepcopy__(self: GC, memo: dict[int, Any]) -> GC:\n        copied = self.__class__()\n        copied.style = deepcopy(self.style, memo)\n        copied.path_items = deepcopy(self.path_items, memo)\n        copied._transform = deepcopy(self.transform, memo)\n        copied._clipping_path = deepcopy(self.clipping_path, memo)\n        return copied\n\n    @property\n    def transform(self) -> Optional[Transform]:\n        return self._transform\n\n    @transform.setter\n    def transform(self, tf: Optional[Transform]) -> None:\n        self._transform = tf\n\n    @property\n    def clipping_path(self) -> Optional[ClippingPath]:\n        \"\"\"The `ClippingPath` for this graphics context.\"\"\"\n        return self._clipping_path\n\n    @clipping_path.setter\n    def clipping_path(self, new_clipath: Optional[ClippingPath]) -> None:\n        self._clipping_path = new_clipath\n\n    def add_item(\n        self,\n        item: Union[\n            Renderable,\n            \"GraphicsContext\",\n            PaintedPath,\n            \"PaintComposite\",\n            \"PaintBlendComposite\",\n        ],\n        clone: bool = True,\n    ) -> None:\n        \"\"\"\n        Add a path element to this graphics context.\n\n        Args:\n            item: the path element to add. May be a primitive element or another\n                `GraphicsContext` or a `PaintedPath`.\n            clone (bool): if true (the default), the item will be copied before being\n                appended. This prevents modifications to a referenced object from\n                \"retroactively\" altering its style/shape and should be disabled with\n                caution.\n        \"\"\"\n        if clone:\n            item = deepcopy(item)\n\n        self.path_items.append(item)\n\n    def remove_last_item(self) -> None:\n        del self.path_items[-1]\n\n    def merge(self, other_context: \"GraphicsContext\") -> None:\n        \"\"\"Copy another `GraphicsContext`'s path items into this one.\"\"\"\n        self.path_items.extend(other_context.path_items)\n\n    @force_nodocument\n    def build_render_list(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n        _push_stack: bool = True,\n    ) -> tuple[list[str], Renderable, Point]:\n        \"\"\"\n        Build a list composed of all all the individual elements rendered.\n\n        This is used by `PaintedPath` and `ClippingPath` to reuse the `GraphicsContext`\n        rendering process while still being able to inject some path specific items\n        (e.g. the painting directive) before the render is collapsed into a single\n        string.\n\n        Args:\n            resource_registry (ResourceCatalog): the owner's graphics state\n                dictionary registry.\n            style (GraphicsStyle): the current resolved graphics style\n            last_item: the previous path element.\n            initial_point: last position set by a \"M\" or \"m\" command\n            _push_stack (bool): if True, wrap the resulting render list in a push/pop\n                graphics stack directive pair.\n\n        Returns:\n            `tuple[list[str], last_item]` where `last_item` is the past path element in\n            this `GraphicsContext`\n        \"\"\"\n        render_list: list[str] = []\n\n        if self.path_items:\n            merged_style = style.__class__.merge(style, self.style)\n\n            NO_EMIT_SET = (None, merged_style.INHERIT)\n\n            emit_style = self.style\n            if merged_style.allow_transparency != self.style.allow_transparency:\n                emit_style = deepcopy(self.style)\n                emit_style.allow_transparency = merged_style.allow_transparency\n\n            # in order to decouple the dash pattern and the dash phase at the API layer,\n            # we have to perform additional logic here to recombine them. We can rely\n            # on these being serializable because we always get a sane style on the\n            # drawing context.\n            dash_pattern = merged_style.stroke_dash_pattern\n            dash_phase = merged_style.stroke_dash_phase\n            emit_dash = None\n            if (\n                dash_pattern != style.stroke_dash_pattern\n                or dash_phase != style.stroke_dash_phase\n            ):\n                if emit_style is self.style:\n                    emit_style = deepcopy(emit_style)\n                emit_style.stroke_dash_pattern = dash_pattern\n                emit_style.stroke_dash_phase = dash_phase\n                emit_dash = (dash_pattern, dash_phase)\n\n            if (\n                not isinstance(emit_style.soft_mask, InheritType)\n                and emit_style.soft_mask.object_id == 0\n            ):\n                emit_style.soft_mask.object_id = resource_registry.register_soft_mask(\n                    emit_style.soft_mask\n                )\n\n            # ---- If fill/stroke use a GradientPaint with alpha, synthesize a soft mask now\n            def _attach_alpha_mask_if_needed(\n                paint_obj: GradientPaint | Color | InheritType | str | None,\n            ) -> None:\n                if not isinstance(paint_obj, GradientPaint):\n                    return\n                if not paint_obj.has_alpha():\n                    return\n                # bbox in content space (shared by color & mask)\n                bbox_for_units = self.bounding_box(\n                    initial_point,\n                    style=self.style,\n                    expand_for_stroke=False,\n                    transformed=False,\n                )[0]\n                # rectangular mask covering the painted area\n                mask_rect = PaintedPath()\n                mask_rect.rectangle(\n                    bbox_for_units.x0,\n                    bbox_for_units.y0,\n                    bbox_for_units.width,\n                    bbox_for_units.height,\n                )\n                # paint that rectangle with the grayscale alpha gradient\n                alpha_paint = _AlphaGradientPaint(\n                    paint_obj.gradient,\n                    paint_obj.units,\n                    gradient_transform=paint_obj.gradient_transform,\n                )\n                alpha_paint.apply_page_ctm = paint_obj.apply_page_ctm\n                mask_rect.style.fill_color = alpha_paint\n                mask_rect.style.stroke_color = None\n                mask_rect.style.stroke_width = 0\n                mask_rect.style.paint_rule = PathPaintRule.FILL_NONZERO\n\n                mask_gc = GraphicsContext()\n                mask_gc.add_item(mask_rect, clone=False)\n\n                # use luminosity so gray intensity drives coverage\n                sm = PaintSoftMask(\n                    mask_gc,\n                    invert=False,\n                    use_luminosity=True,\n                    matrix=paint_obj.gradient_transform,\n                )\n\n                nonlocal emit_style\n                if emit_style.allow_transparency is False:\n                    return\n                if emit_style is self.style:\n                    emit_style = deepcopy(self.style)\n                emit_style.soft_mask = sm\n                emit_style.soft_mask.object_id = resource_registry.register_soft_mask(\n                    emit_style.soft_mask\n                )\n\n            # Decide whether to attach a soft mask from fill or stroke gradient alpha.\n            # Priority: fill first (most common), otherwise stroke.\n            if isinstance(emit_style.fill_color, GradientPaint) and (\n                emit_style.soft_mask in (None, GraphicsStyle.INHERIT)\n            ):\n                _attach_alpha_mask_if_needed(self.style.fill_color)\n            elif isinstance(emit_style.stroke_color, GradientPaint) and (\n                emit_style.soft_mask in (None, GraphicsStyle.INHERIT)\n            ):\n                _attach_alpha_mask_if_needed(self.style.stroke_color)\n\n            style_dict_name = resource_registry.register_graphics_style(emit_style)\n\n            if style_dict_name is not None:\n                render_list.append(f\"{render_pdf_primitive(style_dict_name)} gs\")\n\n            # we can't set color in the graphics state context dictionary, so we have to\n            # manually inherit it and emit it here.\n            fill_color = self.style.fill_color\n            stroke_color = self.style.stroke_color\n\n            bbox_for_units = None\n            if isinstance(fill_color, GradientPaint) or isinstance(\n                stroke_color, GradientPaint\n            ):\n                # Compute bbox once so mask and color share the same mapping\n                bbox_for_units = self.bounding_box(\n                    initial_point, style=self.style, expand_for_stroke=False\n                )[0]\n\n            if fill_color not in NO_EMIT_SET:\n                if isinstance(fill_color, GradientPaint):\n                    render_list.append(\n                        fill_color.emit_fill(resource_registry, bbox_for_units)\n                    )\n                else:\n                    assert isinstance(fill_color, (DeviceCMYK | DeviceGray | DeviceRGB))\n                    render_list.append(fill_color.serialize().lower())\n\n            if stroke_color not in NO_EMIT_SET:\n                if isinstance(stroke_color, GradientPaint):\n                    render_list.append(\n                        stroke_color.emit_stroke(resource_registry, bbox_for_units)\n                    )\n                else:\n                    assert isinstance(stroke_color, (DeviceCMYK, DeviceGray, DeviceRGB))\n                    render_list.append(stroke_color.serialize().upper())\n\n            if emit_dash is not None:\n                assert isinstance(emit_dash[1], NumberClass)\n                render_list.append(\n                    render_pdf_primitive(emit_dash[0])\n                    + f\" {number_to_str(emit_dash[1])} d\"\n                )\n\n            if self.clipping_path is not None:\n                rendered_cpath, _, __ = self.clipping_path.render(\n                    resource_registry, merged_style, last_item, initial_point\n                )\n                if rendered_cpath:\n                    render_list.append(rendered_cpath)\n\n            for item in self.path_items:\n                rendered, last_item, initial_point = item.render(\n                    resource_registry, merged_style, last_item, initial_point\n                )\n\n                if rendered:\n                    render_list.append(rendered)\n\n            # insert transform before points\n            if self.transform is not None:\n                render_list.insert(0, self.transform.render(last_item)[0])\n\n            if _push_stack:\n                render_list.insert(0, \"q\")\n                render_list.append(\"Q\")\n\n        return render_list, last_item, initial_point\n\n    def bounding_box(\n        self,\n        start: Point,\n        style: Optional[GraphicsStyle] = None,\n        expand_for_stroke: bool = True,\n        transformed: bool = True,\n    ) -> tuple[BoundingBox, Point]:\n        \"\"\"\n        Compute bbox of all path items. We:\n        1) recurse with accumulated CTM,\n        2) merge child bboxes already transformed to this level,\n        3) at the end, expand once for stroke using the worst-case CTM row norms.\n        \"\"\"\n        identity = Transform.identity()\n\n        def walk(\n            ctx: \"GraphicsContext\",\n            current_point: Point,\n            ambient_style: Optional[GraphicsStyle],\n            accum_tf: Transform,\n        ) -> tuple[BoundingBox, Point, float, float]:\n            bbox = BoundingBox.empty()\n            tf = accum_tf @ (ctx.transform or identity)\n            if not transformed:\n                tf = identity\n\n            merged_style = (\n                ambient_style.__class__.merge(ambient_style, ctx.style)\n                if ambient_style\n                else ctx.style\n            )\n\n            max_nx, max_ny = tf.row_norms()\n\n            for item in ctx.path_items:\n                if isinstance(item, (PaintComposite, PaintBlendComposite)):\n                    continue\n                if isinstance(item, GraphicsContext):\n                    child_bbox, end_point, cnx, cny = walk(\n                        item, current_point, merged_style, tf\n                    )\n                    bbox = bbox.merge(child_bbox)  # child bbox already in this space\n                    current_point = end_point\n                    max_nx = max(max_nx, cnx)\n                    max_ny = max(max_ny, cny)\n                elif hasattr(item, \"bounding_box\"):\n                    item_bbox, end_point = item.bounding_box(current_point)\n                    bbox = bbox.merge(item_bbox.transformed(tf))\n                    current_point = end_point\n\n            return bbox, current_point, max_nx, max_ny\n\n        # 1) geometric + collect CTM scales\n        geom_bbox, end_pt, nx, ny = walk(self, start, style, identity)\n\n        final_bbox = geom_bbox\n\n        if expand_for_stroke:\n            # 2) expand once for stroke with the effective style at *this* level\n            effective_style = (\n                style.__class__.merge(style, self.style) if style else self.style\n            )\n            final_bbox = geom_bbox.expanded_to_stroke(\n                effective_style, row_norms=(nx, ny)\n            )\n        return final_bbox, end_pt\n\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n        _push_stack: bool = True,\n    ) -> tuple[str, Renderable, Point]:\n        render_list, last_item, initial_point = self.build_render_list(\n            resource_registry,\n            style,\n            last_item,\n            initial_point,\n            _push_stack=_push_stack,\n        )\n\n        return \" \".join(render_list), last_item, initial_point",
      "language": "python"
    },
    {
      "code": "@property\ndef clipping_path(self) -> Optional[ClippingPath]:\n    \"\"\"The `ClippingPath` for this graphics context.\"\"\"\n    return self._clipping_path",
      "language": "python"
    },
    {
      "code": "class GraphicsContext:\n    \"\"\"\n    Page-level container that collects drawable items and renders them into a PDF\n    content stream.\n\n    Converts model coordinates to PDF user space by applying the provided\n    `scale` and a vertical flip so (0, 0) is the top-left of the page.\n\n    Wraps output in a saved graphics state (`q … Q`) and registers any\n    required resources (graphics state dictionaries, soft masks, dash pattern).\n\n    Child items are typically `GraphicsContext`, `PaintedPath`, or `PaintComposite`\n    objects added via `add_item()`. By default, items are deep-copied on insert to\n    avoid later mutations affecting the emitted stream.\n    \"\"\"\n\n    __slots__ = (\"style\", \"path_items\", \"_transform\", \"_clipping_path\")\n\n    def __init__(self) -> None:\n        self.style: GraphicsStyle = GraphicsStyle()\n        self.path_items: list[\n            Renderable\n            | GraphicsContext\n            | PaintedPath\n            | PaintComposite\n            | PaintBlendComposite\n        ] = []\n\n        self._transform: Optional[Transform] = None\n        self._clipping_path: Optional[ClippingPath] = None\n\n    def __deepcopy__(self: GC, memo: dict[int, Any]) -> GC:\n        copied = self.__class__()\n        copied.style = deepcopy(self.style, memo)\n        copied.path_items = deepcopy(self.path_items, memo)\n        copied._transform = deepcopy(self.transform, memo)\n        copied._clipping_path = deepcopy(self.clipping_path, memo)\n        return copied\n\n    @property\n    def transform(self) -> Optional[Transform]:\n        return self._transform\n\n    @transform.setter\n    def transform(self, tf: Optional[Transform]) -> None:\n        self._transform = tf\n\n    @property\n    def clipping_path(self) -> Optional[ClippingPath]:\n        \"\"\"The `ClippingPath` for this graphics context.\"\"\"\n        return self._clipping_path\n\n    @clipping_path.setter\n    def clipping_path(self, new_clipath: Optional[ClippingPath]) -> None:\n        self._clipping_path = new_clipath\n\n    def add_item(\n        self,\n        item: Union[\n            Renderable,\n            \"GraphicsContext\",\n            PaintedPath,\n            \"PaintComposite\",\n            \"PaintBlendComposite\",\n        ],\n        clone: bool = True,\n    ) -> None:\n        \"\"\"\n        Add a path element to this graphics context.\n\n        Args:\n            item: the path element to add. May be a primitive element or another\n                `GraphicsContext` or a `PaintedPath`.\n            clone (bool): if true (the default), the item will be copied before being\n                appended. This prevents modifications to a referenced object from\n                \"retroactively\" altering its style/shape and should be disabled with\n                caution.\n        \"\"\"\n        if clone:\n            item = deepcopy(item)\n\n        self.path_items.append(item)\n\n    def remove_last_item(self) -> None:\n        del self.path_items[-1]\n\n    def merge(self, other_context: \"GraphicsContext\") -> None:\n        \"\"\"Copy another `GraphicsContext`'s path items into this one.\"\"\"\n        self.path_items.extend(other_context.path_items)\n\n    @force_nodocument\n    def build_render_list(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n        _push_stack: bool = True,\n    ) -> tuple[list[str], Renderable, Point]:\n        \"\"\"\n        Build a list composed of all all the individual elements rendered.\n\n        This is used by `PaintedPath` and `ClippingPath` to reuse the `GraphicsContext`\n        rendering process while still being able to inject some path specific items\n        (e.g. the painting directive) before the render is collapsed into a single\n        string.\n\n        Args:\n            resource_registry (ResourceCatalog): the owner's graphics state\n                dictionary registry.\n            style (GraphicsStyle): the current resolved graphics style\n            last_item: the previous path element.\n            initial_point: last position set by a \"M\" or \"m\" command\n            _push_stack (bool): if True, wrap the resulting render list in a push/pop\n                graphics stack directive pair.\n\n        Returns:\n            `tuple[list[str], last_item]` where `last_item` is the past path element in\n            this `GraphicsContext`\n        \"\"\"\n        render_list: list[str] = []\n\n        if self.path_items:\n            merged_style = style.__class__.merge(style, self.style)\n\n            NO_EMIT_SET = (None, merged_style.INHERIT)\n\n            emit_style = self.style\n            if merged_style.allow_transparency != self.style.allow_transparency:\n                emit_style = deepcopy(self.style)\n                emit_style.allow_transparency = merged_style.allow_transparency\n\n            # in order to decouple the dash pattern and the dash phase at the API layer,\n            # we have to perform additional logic here to recombine them. We can rely\n            # on these being serializable because we always get a sane style on the\n            # drawing context.\n            dash_pattern = merged_style.stroke_dash_pattern\n            dash_phase = merged_style.stroke_dash_phase\n            emit_dash = None\n            if (\n                dash_pattern != style.stroke_dash_pattern\n                or dash_phase != style.stroke_dash_phase\n            ):\n                if emit_style is self.style:\n                    emit_style = deepcopy(emit_style)\n                emit_style.stroke_dash_pattern = dash_pattern\n                emit_style.stroke_dash_phase = dash_phase\n                emit_dash = (dash_pattern, dash_phase)\n\n            if (\n                not isinstance(emit_style.soft_mask, InheritType)\n                and emit_style.soft_mask.object_id == 0\n            ):\n                emit_style.soft_mask.object_id = resource_registry.register_soft_mask(\n                    emit_style.soft_mask\n                )\n\n            # ---- If fill/stroke use a GradientPaint with alpha, synthesize a soft mask now\n            def _attach_alpha_mask_if_needed(\n                paint_obj: GradientPaint | Color | InheritType | str | None,\n            ) -> None:\n                if not isinstance(paint_obj, GradientPaint):\n                    return\n                if not paint_obj.has_alpha():\n                    return\n                # bbox in content space (shared by color & mask)\n                bbox_for_units = self.bounding_box(\n                    initial_point,\n                    style=self.style,\n                    expand_for_stroke=False,\n                    transformed=False,\n                )[0]\n                # rectangular mask covering the painted area\n                mask_rect = PaintedPath()\n                mask_rect.rectangle(\n                    bbox_for_units.x0,\n                    bbox_for_units.y0,\n                    bbox_for_units.width,\n                    bbox_for_units.height,\n                )\n                # paint that rectangle with the grayscale alpha gradient\n                alpha_paint = _AlphaGradientPaint(\n                    paint_obj.gradient,\n                    paint_obj.units,\n                    gradient_transform=paint_obj.gradient_transform,\n                )\n                alpha_paint.apply_page_ctm = paint_obj.apply_page_ctm\n                mask_rect.style.fill_color = alpha_paint\n                mask_rect.style.stroke_color = None\n                mask_rect.style.stroke_width = 0\n                mask_rect.style.paint_rule = PathPaintRule.FILL_NONZERO\n\n                mask_gc = GraphicsContext()\n                mask_gc.add_item(mask_rect, clone=False)\n\n                # use luminosity so gray intensity drives coverage\n                sm = PaintSoftMask(\n                    mask_gc,\n                    invert=False,\n                    use_luminosity=True,\n                    matrix=paint_obj.gradient_transform,\n                )\n\n                nonlocal emit_style\n                if emit_style.allow_transparency is False:\n                    return\n                if emit_style is self.style:\n                    emit_style = deepcopy(self.style)\n                emit_style.soft_mask = sm\n                emit_style.soft_mask.object_id = resource_registry.register_soft_mask(\n                    emit_style.soft_mask\n                )\n\n            # Decide whether to attach a soft mask from fill or stroke gradient alpha.\n            # Priority: fill first (most common), otherwise stroke.\n            if isinstance(emit_style.fill_color, GradientPaint) and (\n                emit_style.soft_mask in (None, GraphicsStyle.INHERIT)\n            ):\n                _attach_alpha_mask_if_needed(self.style.fill_color)\n            elif isinstance(emit_style.stroke_color, GradientPaint) and (\n                emit_style.soft_mask in (None, GraphicsStyle.INHERIT)\n            ):\n                _attach_alpha_mask_if_needed(self.style.stroke_color)\n\n            style_dict_name = resource_registry.register_graphics_style(emit_style)\n\n            if style_dict_name is not None:\n                render_list.append(f\"{render_pdf_primitive(style_dict_name)} gs\")\n\n            # we can't set color in the graphics state context dictionary, so we have to\n            # manually inherit it and emit it here.\n            fill_color = self.style.fill_color\n            stroke_color = self.style.stroke_color\n\n            bbox_for_units = None\n            if isinstance(fill_color, GradientPaint) or isinstance(\n                stroke_color, GradientPaint\n            ):\n                # Compute bbox once so mask and color share the same mapping\n                bbox_for_units = self.bounding_box(\n                    initial_point, style=self.style, expand_for_stroke=False\n                )[0]\n\n            if fill_color not in NO_EMIT_SET:\n                if isinstance(fill_color, GradientPaint):\n                    render_list.append(\n                        fill_color.emit_fill(resource_registry, bbox_for_units)\n                    )\n                else:\n                    assert isinstance(fill_color, (DeviceCMYK | DeviceGray | DeviceRGB))\n                    render_list.append(fill_color.serialize().lower())\n\n            if stroke_color not in NO_EMIT_SET:\n                if isinstance(stroke_color, GradientPaint):\n                    render_list.append(\n                        stroke_color.emit_stroke(resource_registry, bbox_for_units)\n                    )\n                else:\n                    assert isinstance(stroke_color, (DeviceCMYK, DeviceGray, DeviceRGB))\n                    render_list.append(stroke_color.serialize().upper())\n\n            if emit_dash is not None:\n                assert isinstance(emit_dash[1], NumberClass)\n                render_list.append(\n                    render_pdf_primitive(emit_dash[0])\n                    + f\" {number_to_str(emit_dash[1])} d\"\n                )\n\n            if self.clipping_path is not None:\n                rendered_cpath, _, __ = self.clipping_path.render(\n                    resource_registry, merged_style, last_item, initial_point\n                )\n                if rendered_cpath:\n                    render_list.append(rendered_cpath)\n\n            for item in self.path_items:\n                rendered, last_item, initial_point = item.render(\n                    resource_registry, merged_style, last_item, initial_point\n                )\n\n                if rendered:\n                    render_list.append(rendered)\n\n            # insert transform before points\n            if self.transform is not None:\n                render_list.insert(0, self.transform.render(last_item)[0])\n\n            if _push_stack:\n                render_list.insert(0, \"q\")\n                render_list.append(\"Q\")\n\n        return render_list, last_item, initial_point\n\n    def bounding_box(\n        self,\n        start: Point,\n        style: Optional[GraphicsStyle] = None,\n        expand_for_stroke: bool = True,\n        transformed: bool = True,\n    ) -> tuple[BoundingBox, Point]:\n        \"\"\"\n        Compute bbox of all path items. We:\n        1) recurse with accumulated CTM,\n        2) merge child bboxes already transformed to this level,\n        3) at the end, expand once for stroke using the worst-case CTM row norms.\n        \"\"\"\n        identity = Transform.identity()\n\n        def walk(\n            ctx: \"GraphicsContext\",\n            current_point: Point,\n            ambient_style: Optional[GraphicsStyle],\n            accum_tf: Transform,\n        ) -> tuple[BoundingBox, Point, float, float]:\n            bbox = BoundingBox.empty()\n            tf = accum_tf @ (ctx.transform or identity)\n            if not transformed:\n                tf = identity\n\n            merged_style = (\n                ambient_style.__class__.merge(ambient_style, ctx.style)\n                if ambient_style\n                else ctx.style\n            )\n\n            max_nx, max_ny = tf.row_norms()\n\n            for item in ctx.path_items:\n                if isinstance(item, (PaintComposite, PaintBlendComposite)):\n                    continue\n                if isinstance(item, GraphicsContext):\n                    child_bbox, end_point, cnx, cny = walk(\n                        item, current_point, merged_style, tf\n                    )\n                    bbox = bbox.merge(child_bbox)  # child bbox already in this space\n                    current_point = end_point\n                    max_nx = max(max_nx, cnx)\n                    max_ny = max(max_ny, cny)\n                elif hasattr(item, \"bounding_box\"):\n                    item_bbox, end_point = item.bounding_box(current_point)\n                    bbox = bbox.merge(item_bbox.transformed(tf))\n                    current_point = end_point\n\n            return bbox, current_point, max_nx, max_ny\n\n        # 1) geometric + collect CTM scales\n        geom_bbox, end_pt, nx, ny = walk(self, start, style, identity)\n\n        final_bbox = geom_bbox\n\n        if expand_for_stroke:\n            # 2) expand once for stroke with the effective style at *this* level\n            effective_style = (\n                style.__class__.merge(style, self.style) if style else self.style\n            )\n            final_bbox = geom_bbox.expanded_to_stroke(\n                effective_style, row_norms=(nx, ny)\n            )\n        return final_bbox, end_pt\n\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n        _push_stack: bool = True,\n    ) -> tuple[str, Renderable, Point]:\n        render_list, last_item, initial_point = self.build_render_list(\n            resource_registry,\n            style,\n            last_item,\n            initial_point,\n            _push_stack=_push_stack,\n        )\n\n        return \" \".join(render_list), last_item, initial_point",
      "language": "python"
    },
    {
      "code": "class GraphicsContext:\n    \"\"\"\n    Page-level container that collects drawable items and renders them into a PDF\n    content stream.\n\n    Converts model coordinates to PDF user space by applying the provided\n    `scale` and a vertical flip so (0, 0) is the top-left of the page.\n\n    Wraps output in a saved graphics state (`q … Q`) and registers any\n    required resources (graphics state dictionaries, soft masks, dash pattern).\n\n    Child items are typically `GraphicsContext`, `PaintedPath`, or `PaintComposite`\n    objects added via `add_item()`. By default, items are deep-copied on insert to\n    avoid later mutations affecting the emitted stream.\n    \"\"\"\n\n    __slots__ = (\"style\", \"path_items\", \"_transform\", \"_clipping_path\")\n\n    def __init__(self) -> None:\n        self.style: GraphicsStyle = GraphicsStyle()\n        self.path_items: list[\n            Renderable\n            | GraphicsContext\n            | PaintedPath\n            | PaintComposite\n            | PaintBlendComposite\n        ] = []\n\n        self._transform: Optional[Transform] = None\n        self._clipping_path: Optional[ClippingPath] = None\n\n    def __deepcopy__(self: GC, memo: dict[int, Any]) -> GC:\n        copied = self.__class__()\n        copied.style = deepcopy(self.style, memo)\n        copied.path_items = deepcopy(self.path_items, memo)\n        copied._transform = deepcopy(self.transform, memo)\n        copied._clipping_path = deepcopy(self.clipping_path, memo)\n        return copied\n\n    @property\n    def transform(self) -> Optional[Transform]:\n        return self._transform\n\n    @transform.setter\n    def transform(self, tf: Optional[Transform]) -> None:\n        self._transform = tf\n\n    @property\n    def clipping_path(self) -> Optional[ClippingPath]:\n        \"\"\"The `ClippingPath` for this graphics context.\"\"\"\n        return self._clipping_path\n\n    @clipping_path.setter\n    def clipping_path(self, new_clipath: Optional[ClippingPath]) -> None:\n        self._clipping_path = new_clipath\n\n    def add_item(\n        self,\n        item: Union[\n            Renderable,\n            \"GraphicsContext\",\n            PaintedPath,\n            \"PaintComposite\",\n            \"PaintBlendComposite\",\n        ],\n        clone: bool = True,\n    ) -> None:\n        \"\"\"\n        Add a path element to this graphics context.\n\n        Args:\n            item: the path element to add. May be a primitive element or another\n                `GraphicsContext` or a `PaintedPath`.\n            clone (bool): if true (the default), the item will be copied before being\n                appended. This prevents modifications to a referenced object from\n                \"retroactively\" altering its style/shape and should be disabled with\n                caution.\n        \"\"\"\n        if clone:\n            item = deepcopy(item)\n\n        self.path_items.append(item)\n\n    def remove_last_item(self) -> None:\n        del self.path_items[-1]\n\n    def merge(self, other_context: \"GraphicsContext\") -> None:\n        \"\"\"Copy another `GraphicsContext`'s path items into this one.\"\"\"\n        self.path_items.extend(other_context.path_items)\n\n    @force_nodocument\n    def build_render_list(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n        _push_stack: bool = True,\n    ) -> tuple[list[str], Renderable, Point]:\n        \"\"\"\n        Build a list composed of all all the individual elements rendered.\n\n        This is used by `PaintedPath` and `ClippingPath` to reuse the `GraphicsContext`\n        rendering process while still being able to inject some path specific items\n        (e.g. the painting directive) before the render is collapsed into a single\n        string.\n\n        Args:\n            resource_registry (ResourceCatalog): the owner's graphics state\n                dictionary registry.\n            style (GraphicsStyle): the current resolved graphics style\n            last_item: the previous path element.\n            initial_point: last position set by a \"M\" or \"m\" command\n            _push_stack (bool): if True, wrap the resulting render list in a push/pop\n                graphics stack directive pair.\n\n        Returns:\n            `tuple[list[str], last_item]` where `last_item` is the past path element in\n            this `GraphicsContext`\n        \"\"\"\n        render_list: list[str] = []\n\n        if self.path_items:\n            merged_style = style.__class__.merge(style, self.style)\n\n            NO_EMIT_SET = (None, merged_style.INHERIT)\n\n            emit_style = self.style\n            if merged_style.allow_transparency != self.style.allow_transparency:\n                emit_style = deepcopy(self.style)\n                emit_style.allow_transparency = merged_style.allow_transparency\n\n            # in order to decouple the dash pattern and the dash phase at the API layer,\n            # we have to perform additional logic here to recombine them. We can rely\n            # on these being serializable because we always get a sane style on the\n            # drawing context.\n            dash_pattern = merged_style.stroke_dash_pattern\n            dash_phase = merged_style.stroke_dash_phase\n            emit_dash = None\n            if (\n                dash_pattern != style.stroke_dash_pattern\n                or dash_phase != style.stroke_dash_phase\n            ):\n                if emit_style is self.style:\n                    emit_style = deepcopy(emit_style)\n                emit_style.stroke_dash_pattern = dash_pattern\n                emit_style.stroke_dash_phase = dash_phase\n                emit_dash = (dash_pattern, dash_phase)\n\n            if (\n                not isinstance(emit_style.soft_mask, InheritType)\n                and emit_style.soft_mask.object_id == 0\n            ):\n                emit_style.soft_mask.object_id = resource_registry.register_soft_mask(\n                    emit_style.soft_mask\n                )\n\n            # ---- If fill/stroke use a GradientPaint with alpha, synthesize a soft mask now\n            def _attach_alpha_mask_if_needed(\n                paint_obj: GradientPaint | Color | InheritType | str | None,\n            ) -> None:\n                if not isinstance(paint_obj, GradientPaint):\n                    return\n                if not paint_obj.has_alpha():\n                    return\n                # bbox in content space (shared by color & mask)\n                bbox_for_units = self.bounding_box(\n                    initial_point,\n                    style=self.style,\n                    expand_for_stroke=False,\n                    transformed=False,\n                )[0]\n                # rectangular mask covering the painted area\n                mask_rect = PaintedPath()\n                mask_rect.rectangle(\n                    bbox_for_units.x0,\n                    bbox_for_units.y0,\n                    bbox_for_units.width,\n                    bbox_for_units.height,\n                )\n                # paint that rectangle with the grayscale alpha gradient\n                alpha_paint = _AlphaGradientPaint(\n                    paint_obj.gradient,\n                    paint_obj.units,\n                    gradient_transform=paint_obj.gradient_transform,\n                )\n                alpha_paint.apply_page_ctm = paint_obj.apply_page_ctm\n                mask_rect.style.fill_color = alpha_paint\n                mask_rect.style.stroke_color = None\n                mask_rect.style.stroke_width = 0\n                mask_rect.style.paint_rule = PathPaintRule.FILL_NONZERO\n\n                mask_gc = GraphicsContext()\n                mask_gc.add_item(mask_rect, clone=False)\n\n                # use luminosity so gray intensity drives coverage\n                sm = PaintSoftMask(\n                    mask_gc,\n                    invert=False,\n                    use_luminosity=True,\n                    matrix=paint_obj.gradient_transform,\n                )\n\n                nonlocal emit_style\n                if emit_style.allow_transparency is False:\n                    return\n                if emit_style is self.style:\n                    emit_style = deepcopy(self.style)\n                emit_style.soft_mask = sm\n                emit_style.soft_mask.object_id = resource_registry.register_soft_mask(\n                    emit_style.soft_mask\n                )\n\n            # Decide whether to attach a soft mask from fill or stroke gradient alpha.\n            # Priority: fill first (most common), otherwise stroke.\n            if isinstance(emit_style.fill_color, GradientPaint) and (\n                emit_style.soft_mask in (None, GraphicsStyle.INHERIT)\n            ):\n                _attach_alpha_mask_if_needed(self.style.fill_color)\n            elif isinstance(emit_style.stroke_color, GradientPaint) and (\n                emit_style.soft_mask in (None, GraphicsStyle.INHERIT)\n            ):\n                _attach_alpha_mask_if_needed(self.style.stroke_color)\n\n            style_dict_name = resource_registry.register_graphics_style(emit_style)\n\n            if style_dict_name is not None:\n                render_list.append(f\"{render_pdf_primitive(style_dict_name)} gs\")\n\n            # we can't set color in the graphics state context dictionary, so we have to\n            # manually inherit it and emit it here.\n            fill_color = self.style.fill_color\n            stroke_color = self.style.stroke_color\n\n            bbox_for_units = None\n            if isinstance(fill_color, GradientPaint) or isinstance(\n                stroke_color, GradientPaint\n            ):\n                # Compute bbox once so mask and color share the same mapping\n                bbox_for_units = self.bounding_box(\n                    initial_point, style=self.style, expand_for_stroke=False\n                )[0]\n\n            if fill_color not in NO_EMIT_SET:\n                if isinstance(fill_color, GradientPaint):\n                    render_list.append(\n                        fill_color.emit_fill(resource_registry, bbox_for_units)\n                    )\n                else:\n                    assert isinstance(fill_color, (DeviceCMYK | DeviceGray | DeviceRGB))\n                    render_list.append(fill_color.serialize().lower())\n\n            if stroke_color not in NO_EMIT_SET:\n                if isinstance(stroke_color, GradientPaint):\n                    render_list.append(\n                        stroke_color.emit_stroke(resource_registry, bbox_for_units)\n                    )\n                else:\n                    assert isinstance(stroke_color, (DeviceCMYK, DeviceGray, DeviceRGB))\n                    render_list.append(stroke_color.serialize().upper())\n\n            if emit_dash is not None:\n                assert isinstance(emit_dash[1], NumberClass)\n                render_list.append(\n                    render_pdf_primitive(emit_dash[0])\n                    + f\" {number_to_str(emit_dash[1])} d\"\n                )\n\n            if self.clipping_path is not None:\n                rendered_cpath, _, __ = self.clipping_path.render(\n                    resource_registry, merged_style, last_item, initial_point\n                )\n                if rendered_cpath:\n                    render_list.append(rendered_cpath)\n\n            for item in self.path_items:\n                rendered, last_item, initial_point = item.render(\n                    resource_registry, merged_style, last_item, initial_point\n                )\n\n                if rendered:\n                    render_list.append(rendered)\n\n            # insert transform before points\n            if self.transform is not None:\n                render_list.insert(0, self.transform.render(last_item)[0])\n\n            if _push_stack:\n                render_list.insert(0, \"q\")\n                render_list.append(\"Q\")\n\n        return render_list, last_item, initial_point\n\n    def bounding_box(\n        self,\n        start: Point,\n        style: Optional[GraphicsStyle] = None,\n        expand_for_stroke: bool = True,\n        transformed: bool = True,\n    ) -> tuple[BoundingBox, Point]:\n        \"\"\"\n        Compute bbox of all path items. We:\n        1) recurse with accumulated CTM,\n        2) merge child bboxes already transformed to this level,\n        3) at the end, expand once for stroke using the worst-case CTM row norms.\n        \"\"\"\n        identity = Transform.identity()\n\n        def walk(\n            ctx: \"GraphicsContext\",\n            current_point: Point,\n            ambient_style: Optional[GraphicsStyle],\n            accum_tf: Transform,\n        ) -> tuple[BoundingBox, Point, float, float]:\n            bbox = BoundingBox.empty()\n            tf = accum_tf @ (ctx.transform or identity)\n            if not transformed:\n                tf = identity\n\n            merged_style = (\n                ambient_style.__class__.merge(ambient_style, ctx.style)\n                if ambient_style\n                else ctx.style\n            )\n\n            max_nx, max_ny = tf.row_norms()\n\n            for item in ctx.path_items:\n                if isinstance(item, (PaintComposite, PaintBlendComposite)):\n                    continue\n                if isinstance(item, GraphicsContext):\n                    child_bbox, end_point, cnx, cny = walk(\n                        item, current_point, merged_style, tf\n                    )\n                    bbox = bbox.merge(child_bbox)  # child bbox already in this space\n                    current_point = end_point\n                    max_nx = max(max_nx, cnx)\n                    max_ny = max(max_ny, cny)\n                elif hasattr(item, \"bounding_box\"):\n                    item_bbox, end_point = item.bounding_box(current_point)\n                    bbox = bbox.merge(item_bbox.transformed(tf))\n                    current_point = end_point\n\n            return bbox, current_point, max_nx, max_ny\n\n        # 1) geometric + collect CTM scales\n        geom_bbox, end_pt, nx, ny = walk(self, start, style, identity)\n\n        final_bbox = geom_bbox\n\n        if expand_for_stroke:\n            # 2) expand once for stroke with the effective style at *this* level\n            effective_style = (\n                style.__class__.merge(style, self.style) if style else self.style\n            )\n            final_bbox = geom_bbox.expanded_to_stroke(\n                effective_style, row_norms=(nx, ny)\n            )\n        return final_bbox, end_pt\n\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n        _push_stack: bool = True,\n    ) -> tuple[str, Renderable, Point]:\n        render_list, last_item, initial_point = self.build_render_list(\n            resource_registry,\n            style,\n            last_item,\n            initial_point,\n            _push_stack=_push_stack,\n        )\n\n        return \" \".join(render_list), last_item, initial_point",
      "language": "python"
    },
    {
      "code": "@property\ndef transform(self) -> Optional[Transform]:\n    return self._transform",
      "language": "python"
    },
    {
      "code": "def add_item(\n    self,\n    item: Union[\n        Renderable,\n        \"GraphicsContext\",\n        PaintedPath,\n        \"PaintComposite\",\n        \"PaintBlendComposite\",\n    ],\n    clone: bool = True,\n) -> None:\n    \"\"\"\n    Add a path element to this graphics context.\n\n    Args:\n        item: the path element to add. May be a primitive element or another\n            `GraphicsContext` or a `PaintedPath`.\n        clone (bool): if true (the default), the item will be copied before being\n            appended. This prevents modifications to a referenced object from\n            \"retroactively\" altering its style/shape and should be disabled with\n            caution.\n    \"\"\"\n    if clone:\n        item = deepcopy(item)\n\n    self.path_items.append(item)",
      "language": "python"
    },
    {
      "code": "def bounding_box(\n    self,\n    start: Point,\n    style: Optional[GraphicsStyle] = None,\n    expand_for_stroke: bool = True,\n    transformed: bool = True,\n) -> tuple[BoundingBox, Point]:\n    \"\"\"\n    Compute bbox of all path items. We:\n    1) recurse with accumulated CTM,\n    2) merge child bboxes already transformed to this level,\n    3) at the end, expand once for stroke using the worst-case CTM row norms.\n    \"\"\"\n    identity = Transform.identity()\n\n    def walk(\n        ctx: \"GraphicsContext\",\n        current_point: Point,\n        ambient_style: Optional[GraphicsStyle],\n        accum_tf: Transform,\n    ) -> tuple[BoundingBox, Point, float, float]:\n        bbox = BoundingBox.empty()\n        tf = accum_tf @ (ctx.transform or identity)\n        if not transformed:\n            tf = identity\n\n        merged_style = (\n            ambient_style.__class__.merge(ambient_style, ctx.style)\n            if ambient_style\n            else ctx.style\n        )\n\n        max_nx, max_ny = tf.row_norms()\n\n        for item in ctx.path_items:\n            if isinstance(item, (PaintComposite, PaintBlendComposite)):\n                continue\n            if isinstance(item, GraphicsContext):\n                child_bbox, end_point, cnx, cny = walk(\n                    item, current_point, merged_style, tf\n                )\n                bbox = bbox.merge(child_bbox)  # child bbox already in this space\n                current_point = end_point\n                max_nx = max(max_nx, cnx)\n                max_ny = max(max_ny, cny)\n            elif hasattr(item, \"bounding_box\"):\n                item_bbox, end_point = item.bounding_box(current_point)\n                bbox = bbox.merge(item_bbox.transformed(tf))\n                current_point = end_point\n\n        return bbox, current_point, max_nx, max_ny\n\n    # 1) geometric + collect CTM scales\n    geom_bbox, end_pt, nx, ny = walk(self, start, style, identity)\n\n    final_bbox = geom_bbox\n\n    if expand_for_stroke:\n        # 2) expand once for stroke with the effective style at *this* level\n        effective_style = (\n            style.__class__.merge(style, self.style) if style else self.style\n        )\n        final_bbox = geom_bbox.expanded_to_stroke(\n            effective_style, row_norms=(nx, ny)\n        )\n    return final_bbox, end_pt",
      "language": "python"
    },
    {
      "code": "@force_nodocument\ndef build_render_list(\n    self,\n    resource_registry: \"ResourceCatalog\",\n    style: GraphicsStyle,\n    last_item: Renderable,\n    initial_point: Point,\n    _push_stack: bool = True,\n) -> tuple[list[str], Renderable, Point]:\n    \"\"\"\n    Build a list composed of all all the individual elements rendered.\n\n    This is used by `PaintedPath` and `ClippingPath` to reuse the `GraphicsContext`\n    rendering process while still being able to inject some path specific items\n    (e.g. the painting directive) before the render is collapsed into a single\n    string.\n\n    Args:\n        resource_registry (ResourceCatalog): the owner's graphics state\n            dictionary registry.\n        style (GraphicsStyle): the current resolved graphics style\n        last_item: the previous path element.\n        initial_point: last position set by a \"M\" or \"m\" command\n        _push_stack (bool): if True, wrap the resulting render list in a push/pop\n            graphics stack directive pair.\n\n    Returns:\n        `tuple[list[str], last_item]` where `last_item` is the past path element in\n        this `GraphicsContext`\n    \"\"\"\n    render_list: list[str] = []\n\n    if self.path_items:\n        merged_style = style.__class__.merge(style, self.style)\n\n        NO_EMIT_SET = (None, merged_style.INHERIT)\n\n        emit_style = self.style\n        if merged_style.allow_transparency != self.style.allow_transparency:\n            emit_style = deepcopy(self.style)\n            emit_style.allow_transparency = merged_style.allow_transparency\n\n        # in order to decouple the dash pattern and the dash phase at the API layer,\n        # we have to perform additional logic here to recombine them. We can rely\n        # on these being serializable because we always get a sane style on the\n        # drawing context.\n        dash_pattern = merged_style.stroke_dash_pattern\n        dash_phase = merged_style.stroke_dash_phase\n        emit_dash = None\n        if (\n            dash_pattern != style.stroke_dash_pattern\n            or dash_phase != style.stroke_dash_phase\n        ):\n            if emit_style is self.style:\n                emit_style = deepcopy(emit_style)\n            emit_style.stroke_dash_pattern = dash_pattern\n            emit_style.stroke_dash_phase = dash_phase\n            emit_dash = (dash_pattern, dash_phase)\n\n        if (\n            not isinstance(emit_style.soft_mask, InheritType)\n            and emit_style.soft_mask.object_id == 0\n        ):\n            emit_style.soft_mask.object_id = resource_registry.register_soft_mask(\n                emit_style.soft_mask\n            )\n\n        # ---- If fill/stroke use a GradientPaint with alpha, synthesize a soft mask now\n        def _attach_alpha_mask_if_needed(\n            paint_obj: GradientPaint | Color | InheritType | str | None,\n        ) -> None:\n            if not isinstance(paint_obj, GradientPaint):\n                return\n            if not paint_obj.has_alpha():\n                return\n            # bbox in content space (shared by color & mask)\n            bbox_for_units = self.bounding_box(\n                initial_point,\n                style=self.style,\n                expand_for_stroke=False,\n                transformed=False,\n            )[0]\n            # rectangular mask covering the painted area\n            mask_rect = PaintedPath()\n            mask_rect.rectangle(\n                bbox_for_units.x0,\n                bbox_for_units.y0,\n                bbox_for_units.width,\n                bbox_for_units.height,\n            )\n            # paint that rectangle with the grayscale alpha gradient\n            alpha_paint = _AlphaGradientPaint(\n                paint_obj.gradient,\n                paint_obj.units,\n                gradient_transform=paint_obj.gradient_transform,\n            )\n            alpha_paint.apply_page_ctm = paint_obj.apply_page_ctm\n            mask_rect.style.fill_color = alpha_paint\n            mask_rect.style.stroke_color = None\n            mask_rect.style.stroke_width = 0\n            mask_rect.style.paint_rule = PathPaintRule.FILL_NONZERO\n\n            mask_gc = GraphicsContext()\n            mask_gc.add_item(mask_rect, clone=False)\n\n            # use luminosity so gray intensity drives coverage\n            sm = PaintSoftMask(\n                mask_gc,\n                invert=False,\n                use_luminosity=True,\n                matrix=paint_obj.gradient_transform,\n            )\n\n            nonlocal emit_style\n            if emit_style.allow_transparency is False:\n                return\n            if emit_style is self.style:\n                emit_style = deepcopy(self.style)\n            emit_style.soft_mask = sm\n            emit_style.soft_mask.object_id = resource_registry.register_soft_mask(\n                emit_style.soft_mask\n            )\n\n        # Decide whether to attach a soft mask from fill or stroke gradient alpha.\n        # Priority: fill first (most common), otherwise stroke.\n        if isinstance(emit_style.fill_color, GradientPaint) and (\n            emit_style.soft_mask in (None, GraphicsStyle.INHERIT)\n        ):\n            _attach_alpha_mask_if_needed(self.style.fill_color)\n        elif isinstance(emit_style.stroke_color, GradientPaint) and (\n            emit_style.soft_mask in (None, GraphicsStyle.INHERIT)\n        ):\n            _attach_alpha_mask_if_needed(self.style.stroke_color)\n\n        style_dict_name = resource_registry.register_graphics_style(emit_style)\n\n        if style_dict_name is not None:\n            render_list.append(f\"{render_pdf_primitive(style_dict_name)} gs\")\n\n        # we can't set color in the graphics state context dictionary, so we have to\n        # manually inherit it and emit it here.\n        fill_color = self.style.fill_color\n        stroke_color = self.style.stroke_color\n\n        bbox_for_units = None\n        if isinstance(fill_color, GradientPaint) or isinstance(\n            stroke_color, GradientPaint\n        ):\n            # Compute bbox once so mask and color share the same mapping\n            bbox_for_units = self.bounding_box(\n                initial_point, style=self.style, expand_for_stroke=False\n            )[0]\n\n        if fill_color not in NO_EMIT_SET:\n            if isinstance(fill_color, GradientPaint):\n                render_list.append(\n                    fill_color.emit_fill(resource_registry, bbox_for_units)\n                )\n            else:\n                assert isinstance(fill_color, (DeviceCMYK | DeviceGray | DeviceRGB))\n                render_list.append(fill_color.serialize().lower())\n\n        if stroke_color not in NO_EMIT_SET:\n            if isinstance(stroke_color, GradientPaint):\n                render_list.append(\n                    stroke_color.emit_stroke(resource_registry, bbox_for_units)\n                )\n            else:\n                assert isinstance(stroke_color, (DeviceCMYK, DeviceGray, DeviceRGB))\n                render_list.append(stroke_color.serialize().upper())\n\n        if emit_dash is not None:\n            assert isinstance(emit_dash[1], NumberClass)\n            render_list.append(\n                render_pdf_primitive(emit_dash[0])\n                + f\" {number_to_str(emit_dash[1])} d\"\n            )\n\n        if self.clipping_path is not None:\n            rendered_cpath, _, __ = self.clipping_path.render(\n                resource_registry, merged_style, last_item, initial_point\n            )\n            if rendered_cpath:\n                render_list.append(rendered_cpath)\n\n        for item in self.path_items:\n            rendered, last_item, initial_point = item.render(\n                resource_registry, merged_style, last_item, initial_point\n            )\n\n            if rendered:\n                render_list.append(rendered)\n\n        # insert transform before points\n        if self.transform is not None:\n            render_list.insert(0, self.transform.render(last_item)[0])\n\n        if _push_stack:\n            render_list.insert(0, \"q\")\n            render_list.append(\"Q\")\n\n    return render_list, last_item, initial_point",
      "language": "python"
    },
    {
      "code": "def merge(self, other_context: \"GraphicsContext\") -> None:\n    \"\"\"Copy another `GraphicsContext`'s path items into this one.\"\"\"\n    self.path_items.extend(other_context.path_items)",
      "language": "python"
    },
    {
      "code": "def remove_last_item(self) -> None:\n    del self.path_items[-1]",
      "language": "python"
    },
    {
      "code": "def render(\n    self,\n    resource_registry: \"ResourceCatalog\",\n    style: GraphicsStyle,\n    last_item: Renderable,\n    initial_point: Point,\n    _push_stack: bool = True,\n) -> tuple[str, Renderable, Point]:\n    render_list, last_item, initial_point = self.build_render_list(\n        resource_registry,\n        style,\n        last_item,\n        initial_point,\n        _push_stack=_push_stack,\n    )\n\n    return \" \".join(render_list), last_item, initial_point",
      "language": "python"
    },
    {
      "code": "class GraphicsStyle:\n    \"\"\"\n    A class representing various style attributes that determine drawing appearance.\n\n    This class uses the convention that the global Python singleton ellipsis (`...`) is\n    exclusively used to represent values that are inherited from the parent style. This\n    is to disambiguate the value None which is used for several values to signal an\n    explicitly disabled style. An example of this is the fill/stroke color styles,\n    which use None as hints to the auto paint style detection code.\n    \"\"\"\n\n    _PRIVATE_SLOTS = (\n        \"_allow_transparency\",\n        \"_auto_close\",\n        \"_fill_color\",\n        \"_intersection_rule\",\n        \"_paint_rule\",\n        \"_stroke_color\",\n        \"_stroke_dash_pattern\",\n        \"_stroke_dash_phase\",\n    )\n\n    __slots__ = _PRIVATE_SLOTS + tuple(\n        k.value\n        for k in PDFStyleKeys\n        # we do not store STROKE_DASH_PATTERN under its PDF key; it's in _stroke_dash_pattern\n        if k is not PDFStyleKeys.STROKE_DASH_PATTERN\n    )\n\n    INHERIT = ...\n    \"\"\"Singleton specifying a style parameter should be inherited from the parent context.\"\"\"\n\n    # order is be important here because some of these properties are entangled, e.g.\n    # fill_color and fill_opacity\n    MERGE_PROPERTIES = (\n        \"paint_rule\",\n        \"allow_transparency\",\n        \"auto_close\",\n        \"intersection_rule\",\n        \"fill_color\",\n        \"fill_opacity\",\n        \"stroke_color\",\n        \"stroke_opacity\",\n        \"blend_mode\",\n        \"stroke_width\",\n        \"stroke_cap_style\",\n        \"stroke_join_style\",\n        \"stroke_miter_limit\",\n        \"stroke_dash_pattern\",\n        \"stroke_dash_phase\",\n        \"soft_mask\",\n    )\n    \"\"\"An ordered collection of properties to use when merging two GraphicsStyles.\"\"\"\n\n    TRANSPARENCY_KEYS = (\n        PDFStyleKeys.FILL_ALPHA.value,\n        PDFStyleKeys.STROKE_ALPHA.value,\n        PDFStyleKeys.BLEND_MODE.value,\n        PDFStyleKeys.SOFT_MASK.value,\n    )\n    \"\"\"An ordered collection of attributes not to emit in no transparency mode.\"\"\"\n\n    PDF_STYLE_KEYS = (\n        *(k.value for k in PDFStyleKeys if k is not PDFStyleKeys.STROKE_DASH_PATTERN),\n    )\n    \"\"\"An ordered collection of keys to directly emit when serializing the style.\"\"\"\n\n    _PAINT_RULE_LOOKUP: dict[frozenset[str | IntersectionRule], PathPaintRule] = {\n        frozenset({}): PathPaintRule.DONT_PAINT,\n        frozenset({\"stroke\"}): PathPaintRule.STROKE,\n        frozenset({\"fill\", IntersectionRule.NONZERO}): PathPaintRule.FILL_NONZERO,\n        frozenset({\"fill\", IntersectionRule.EVENODD}): PathPaintRule.FILL_EVENODD,\n        frozenset(\n            {\"stroke\", \"fill\", IntersectionRule.NONZERO}\n        ): PathPaintRule.STROKE_FILL_NONZERO,\n        frozenset(\n            {\"stroke\", \"fill\", IntersectionRule.EVENODD}\n        ): PathPaintRule.STROKE_FILL_EVENODD,\n    }\n    \"\"\"A dictionary for resolving `PathPaintRule.AUTO`\"\"\"\n\n    @classmethod\n    def merge(cls, parent: \"GraphicsStyle\", child: \"GraphicsStyle\") -> \"GraphicsStyle\":\n        \"\"\"\n        Merge parent and child into a single GraphicsStyle.\n\n        The result contains the properties of the parent as overridden by any properties\n        explicitly set on the child. If both the parent and the child specify to\n        inherit a given property, that property will preserve the inherit value.\n        \"\"\"\n        new = deepcopy(child)\n        for prop in cls.__slots__:\n            cval = getattr(new, prop)\n            if cval is cls.INHERIT:\n                setattr(new, prop, getattr(parent, prop))\n\n        return new\n\n    def __init__(self) -> None:\n        for key in self.__slots__:\n            setattr(self, key, self.INHERIT)\n\n    def __deepcopy__(self: GS, memo: dict[int, Any]) -> GS:\n        cls = self.__class__\n        new = cls.__new__(cls)  # bypass __init__\n        # copy private slots directly\n        for s in cls._PRIVATE_SLOTS:\n            object.__setattr__(new, s, getattr(self, s, cls.INHERIT))\n        # copy PDF-exposed slots (BM, ca, CA, etc.)\n        for key in cls.PDF_STYLE_KEYS:\n            object.__setattr__(new, key, getattr(self, key, cls.INHERIT))\n        return new\n\n    def __setattr__(self, name: str, value: Any) -> None:\n        try:\n            super().__setattr__(name, value)\n        except AttributeError as e:\n            raise AttributeError(\n                f'{self.__class__} does not have style \"{name}\" (a typo?)'\n            ) from e\n\n    # at some point it probably makes sense to turn this into a general compliance\n    # property, but for now this is the simple approach.\n    @property\n    def allow_transparency(self) -> bool | InheritType:\n        allow_transparency = getattr(self, \"_allow_transparency\", self.INHERIT)\n        if allow_transparency is self.INHERIT:\n            return self.INHERIT\n        return cast(bool, allow_transparency)\n\n    @allow_transparency.setter\n    def allow_transparency(self, new: bool | InheritType) -> None:\n        return super().__setattr__(\"_allow_transparency\", new)\n\n    # If these are used in a nested graphics context inside of a painting path\n    # operation, they are no-ops. However, they can be used for outer GraphicsContexts\n    # that painting paths inherit from.\n    @property\n    def paint_rule(self) -> PathPaintRule | InheritType | None:\n        \"\"\"The paint rule to use for this path/group.\"\"\"\n        paint_rule = getattr(self, \"_paint_rule\", self.INHERIT)\n        if paint_rule is self.INHERIT or paint_rule is None:\n            return paint_rule\n        return cast(PathPaintRule, paint_rule)\n\n    @paint_rule.setter\n    def paint_rule(self, new: PathPaintRule | InheritType | str | None) -> None:\n        if new is None:\n            super().__setattr__(\"_paint_rule\", PathPaintRule.DONT_PAINT)\n        elif isinstance(new, InheritType):\n            super().__setattr__(\"_paint_rule\", new)\n        else:\n            super().__setattr__(\"_paint_rule\", PathPaintRule.coerce(new))\n\n    @property\n    def auto_close(self) -> bool | InheritType:\n        \"\"\"If True, unclosed paths will be automatically closed before stroking.\"\"\"\n        auto_close = getattr(self, \"_auto_close\", self.INHERIT)\n        if auto_close is self.INHERIT:\n            return auto_close\n        return cast(bool, auto_close)\n\n    @auto_close.setter\n    def auto_close(self, new: bool | InheritType) -> None:\n        if new not in {True, False, self.INHERIT}:\n            raise TypeError(f\"auto_close must be a bool or self.INHERIT, not {new}\")\n        super().__setattr__(\"_auto_close\", new)\n\n    @property\n    def intersection_rule(self) -> IntersectionRule | InheritType:\n        \"\"\"The desired intersection rule for this path/group.\"\"\"\n        intersection_rule = getattr(self, \"_intersection_rule\", self.INHERIT)\n        if intersection_rule is self.INHERIT:\n            return intersection_rule\n        return cast(IntersectionRule, intersection_rule)\n\n    @intersection_rule.setter\n    def intersection_rule(self, new: IntersectionRule | InheritType | str) -> None:\n        # don't allow None for this one.\n        if isinstance(new, InheritType):\n            super().__setattr__(\"_intersection_rule\", new)\n        else:\n            super().__setattr__(\"_intersection_rule\", IntersectionRule.coerce(new))\n\n    @property\n    def fill_color(self) -> Color | GradientPaint | InheritType | str | None:\n        \"\"\"\n        The desired fill color for this path/group.\n\n        When setting this property, if the color specifies an opacity value, that will\n        be used to set the fill_opacity property as well.\n        \"\"\"\n        fill_color = getattr(self, \"_fill_color\", self.INHERIT)\n        if fill_color is self.INHERIT or fill_color is None:\n            return fill_color\n        assert isinstance(\n            fill_color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)\n        )\n        return fill_color\n\n    @fill_color.setter\n    def fill_color(\n        self, color: Color | GradientPaint | str | InheritType | None\n    ) -> None:\n        if isinstance(color, str):\n            color = color_from_hex_string(color)\n\n        if isinstance(color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)):\n            super().__setattr__(\"_fill_color\", color)\n            if getattr(color, \"a\", None) is not None and not isinstance(\n                color, GradientPaint\n            ):\n                self.fill_opacity = color.a\n\n        elif (color is None) or (color is self.INHERIT):\n            super().__setattr__(\"_fill_color\", color)\n\n        else:\n            raise TypeError(f\"{color} doesn't look like a drawing color\")\n\n    @property\n    def fill_opacity(self) -> float | InheritType | None:\n        \"\"\"The desired fill opacity for this path/group.\"\"\"\n        fill_opacity = getattr(self, PDFStyleKeys.FILL_ALPHA.value, self.INHERIT)\n        if fill_opacity is self.INHERIT or fill_opacity is None:\n            return fill_opacity\n        return cast(float, fill_opacity)\n\n    @fill_opacity.setter\n    def fill_opacity(self, new: float | InheritType | None) -> None:\n        if new not in {None, self.INHERIT}:\n            assert isinstance(new, NumberClass)\n            check_range(new)\n        super().__setattr__(PDFStyleKeys.FILL_ALPHA.value, new)\n\n    @property\n    def stroke_color(self) -> Color | GradientPaint | InheritType | None:\n        \"\"\"\n        The desired stroke color for this path/group.\n\n        When setting this property, if the color specifies an opacity value, that will\n        be used to set the fill_opacity property as well.\n        \"\"\"\n        stroke_color = getattr(self, \"_stroke_color\", self.INHERIT)\n        if stroke_color is self.INHERIT or stroke_color is None:\n            return stroke_color\n        assert isinstance(\n            stroke_color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)\n        )\n        return stroke_color\n\n    @stroke_color.setter\n    def stroke_color(\n        self, color: Color | GradientPaint | str | InheritType | None\n    ) -> None:\n        if isinstance(color, str):\n            color = color_from_hex_string(color)\n\n        if isinstance(color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)):\n            super().__setattr__(\"_stroke_color\", color)\n            if getattr(color, \"a\", None) is not None and not isinstance(\n                color, GradientPaint\n            ):\n                self.stroke_opacity = color.a\n            if self.stroke_width is self.INHERIT:\n                self.stroke_width = 1\n\n        elif (color is None) or (color is self.INHERIT):\n            super().__setattr__(\"_stroke_color\", color)\n\n        else:\n            raise TypeError(f\"{color} doesn't look like a drawing color\")\n\n    @property\n    def stroke_opacity(self) -> float | InheritType | None:\n        \"\"\"The desired stroke opacity for this path/group.\"\"\"\n        stroke_opacity = getattr(self, PDFStyleKeys.STROKE_ALPHA.value, self.INHERIT)\n        if stroke_opacity is self.INHERIT or stroke_opacity is None:\n            return stroke_opacity\n        assert isinstance(stroke_opacity, NumberClass)\n        return float(stroke_opacity)\n\n    @stroke_opacity.setter\n    def stroke_opacity(self, new: float | InheritType | None) -> None:\n        if new not in (None, self.INHERIT):\n            assert isinstance(new, NumberClass)\n            check_range(new)\n        super().__setattr__(PDFStyleKeys.STROKE_ALPHA.value, new)\n\n    @property\n    def blend_mode(self) -> BlendMode | InheritType:\n        \"\"\"The desired blend mode for this path/group.\"\"\"\n        blend_mode = getattr(self, PDFStyleKeys.BLEND_MODE.value, self.INHERIT)\n        if blend_mode is self.INHERIT:\n            return blend_mode\n        return cast(BlendMode, blend_mode)\n\n    @blend_mode.setter\n    def blend_mode(self, value: BlendMode | str | InheritType) -> None:\n        if isinstance(value, InheritType):\n            super().__setattr__(PDFStyleKeys.BLEND_MODE.value, value)\n        else:\n            super().__setattr__(\n                PDFStyleKeys.BLEND_MODE.value, BlendMode.coerce(value).value\n            )\n\n    @property\n    def stroke_width(self) -> float | InheritType | None:\n        \"\"\"The desired stroke width for this path/group.\"\"\"\n        stroke_width = getattr(self, PDFStyleKeys.STROKE_WIDTH.value, self.INHERIT)\n        if stroke_width is self.INHERIT or stroke_width is None:\n            return stroke_width\n        assert isinstance(stroke_width, NumberClass)\n        return float(stroke_width)\n\n    @stroke_width.setter\n    def stroke_width(self, width: float | InheritType | None) -> None:\n        if width not in (None, self.INHERIT) and not isinstance(width, NumberClass):\n            raise TypeError(f\"stroke_width must be a number, not {type(width)}\")\n        super().__setattr__(PDFStyleKeys.STROKE_WIDTH.value, width)\n\n    @property\n    def stroke_cap_style(self) -> StrokeCapStyle | InheritType:\n        \"\"\"The desired stroke cap style for this path/group.\"\"\"\n        stroke_cap_style = getattr(\n            self, PDFStyleKeys.STROKE_CAP_STYLE.value, self.INHERIT\n        )\n        if stroke_cap_style is self.INHERIT:\n            return stroke_cap_style\n        return cast(StrokeCapStyle, stroke_cap_style)\n\n    @stroke_cap_style.setter\n    def stroke_cap_style(self, value: StrokeCapStyle | str | InheritType) -> None:\n        if isinstance(value, InheritType):\n            super().__setattr__(PDFStyleKeys.STROKE_CAP_STYLE.value, value)\n        else:\n            super().__setattr__(\n                PDFStyleKeys.STROKE_CAP_STYLE.value, StrokeCapStyle.coerce(value)\n            )\n\n    @property\n    def stroke_join_style(self) -> StrokeJoinStyle | InheritType:\n        \"\"\"The desired stroke join style for this path/group.\"\"\"\n        stroke_join_style = getattr(\n            self, PDFStyleKeys.STROKE_JOIN_STYLE.value, self.INHERIT\n        )\n        if stroke_join_style is self.INHERIT:\n            return stroke_join_style\n        return cast(StrokeJoinStyle, stroke_join_style)\n\n    @stroke_join_style.setter\n    def stroke_join_style(self, value: StrokeJoinStyle | str | InheritType) -> None:\n        if isinstance(value, InheritType):\n            super().__setattr__(PDFStyleKeys.STROKE_JOIN_STYLE.value, value)\n        else:\n            super().__setattr__(\n                PDFStyleKeys.STROKE_JOIN_STYLE.value, StrokeJoinStyle.coerce(value)\n            )\n\n    @property\n    def stroke_miter_limit(self) -> float | InheritType:\n        \"\"\"The desired stroke miter limit for this path/group.\"\"\"\n        stroke_miter_limit = getattr(\n            self, PDFStyleKeys.STROKE_MITER_LIMIT.value, self.INHERIT\n        )\n        if stroke_miter_limit is self.INHERIT:\n            return stroke_miter_limit\n        assert isinstance(stroke_miter_limit, NumberClass)\n        return float(stroke_miter_limit)\n\n    @stroke_miter_limit.setter\n    def stroke_miter_limit(self, value: Number | InheritType) -> None:\n        if (value is self.INHERIT) or isinstance(value, NumberClass):\n            super().__setattr__(PDFStyleKeys.STROKE_MITER_LIMIT.value, value)\n        else:\n            raise TypeError(f\"{value} is not a number\")\n\n    @property\n    def stroke_dash_pattern(self) -> Optional[InheritType | tuple[float, ...]]:\n        \"\"\"The desired stroke dash pattern for this path/group.\"\"\"\n        stroke_dash_pattern = getattr(self, \"_stroke_dash_pattern\", self.INHERIT)\n        if stroke_dash_pattern is self.INHERIT:\n            return stroke_dash_pattern\n        return cast(tuple[float, ...], stroke_dash_pattern)\n\n    @stroke_dash_pattern.setter\n    def stroke_dash_pattern(\n        self, value: None | InheritType | Number | Sequence[Number]\n    ) -> None:\n        result: None | InheritType | Number | Sequence[Number]\n        if value is None:\n            result = ()\n        elif isinstance(value, InheritType):\n            result = self.INHERIT\n        elif isinstance(value, NumberClass):\n            result = (float(value),)\n        elif isinstance(value, (str, bytes, bytearray)):\n            raise TypeError(\n                f\"stroke_dash_pattern {value!r} must be a number or sequence of numbers\"\n            )\n        else:\n            try:\n                accum: list[float] = []\n                for item in value:\n                    if isinstance(item, (str, bytes, bytearray)):\n                        raise TypeError\n                    accum.append(float(item))\n            except (TypeError, ValueError):\n                raise TypeError(\n                    f\"stroke_dash_pattern {value!r} must be a number or sequence of numbers\"\n                ) from None\n            result = (*accum,)\n        super().__setattr__(\"_stroke_dash_pattern\", result)\n\n    @property\n    def stroke_dash_phase(self) -> InheritType | float:\n        \"\"\"The desired stroke dash pattern phase offset for this path/group.\"\"\"\n        stroke_dash_phase = getattr(self, \"_stroke_dash_phase\", self.INHERIT)\n        if stroke_dash_phase is self.INHERIT:\n            return stroke_dash_phase\n        assert isinstance(stroke_dash_phase, NumberClass)\n        return float(stroke_dash_phase)\n\n    @stroke_dash_phase.setter\n    def stroke_dash_phase(self, value: InheritType | Number) -> None:\n        if value is self.INHERIT or isinstance(value, NumberClass):\n            return super().__setattr__(\"_stroke_dash_phase\", value)\n\n        raise TypeError(f\"{value} isn't a number or GraphicsStyle.INHERIT\")\n\n    @property\n    def soft_mask(self) -> Union[InheritType, \"PaintSoftMask\"]:\n        paint_soft_mask = getattr(self, PDFStyleKeys.SOFT_MASK.value, self.INHERIT)\n        if paint_soft_mask is self.INHERIT:\n            return paint_soft_mask\n        return cast(PaintSoftMask, paint_soft_mask)\n\n    @soft_mask.setter\n    def soft_mask(self, value: Union[InheritType, \"PaintSoftMask\"]) -> None:\n        if value is self.INHERIT or isinstance(value, PaintSoftMask):\n            return super().__setattr__(PDFStyleKeys.SOFT_MASK.value, value)\n        raise TypeError(f\"{value} isn't a PaintSoftMask or GraphicsStyle.INHERIT\")\n\n    def serialize(self) -> Optional[Raw]:\n        \"\"\"\n        Convert this style object to a PDF dictionary with appropriate style keys.\n\n        Only explicitly specified values are emitted.\n        \"\"\"\n        result: dict[Name, Any] = OrderedDict()\n\n        for key in self.PDF_STYLE_KEYS:\n            value = getattr(self, key, self.INHERIT)\n\n            if (value is not self.INHERIT) and (value is not None):\n                # None is used for out-of-band signaling on these, e.g. a stroke_width\n                # of None doesn't need to land here because it signals the\n                # PathPaintRule auto resolution only.\n                result[key] = value\n\n        # There is additional logic in GraphicsContext to ensure that this will work\n        if self.stroke_dash_pattern and self.stroke_dash_pattern is not self.INHERIT:\n            result[PDFStyleKeys.STROKE_DASH_PATTERN.value] = [\n                self.stroke_dash_pattern,\n                self.stroke_dash_phase,\n            ]\n\n        if self.allow_transparency is False:\n            for key in self.TRANSPARENCY_KEYS:\n                if key in result:\n                    del result[key]\n\n        if result:\n            # Only insert this key if there is at least one other item in the result so\n            # that we don't junk up the output PDF with empty ExtGState dictionaries.\n            type_name = Name(\"Type\")\n            result[type_name] = Name(\"ExtGState\")\n            result.move_to_end(type_name, last=False)  # type: ignore[attr-defined]\n\n            return render_pdf_primitive(result)\n\n        # this signals to the graphics state registry that there is nothing to\n        # register. This is a success case.\n        return None\n\n    @force_nodocument\n    def resolve_paint_rule(self) -> PathPaintRule:\n        \"\"\"\n        Resolve `PathPaintRule.AUTO` to a real paint rule based on this style.\n\n        Returns:\n            the resolved `PathPaintRule`.\n        \"\"\"\n        if self.paint_rule is PathPaintRule.AUTO:\n            want: set[str | IntersectionRule] = set()\n            stroke_color = self.stroke_color\n            if self.stroke_width is not None and stroke_color is not None:\n                want.add(\"stroke\")\n            fill_color = self.fill_color\n            if fill_color is not None:\n                intersection_rule = (\n                    self.intersection_rule\n                    if isinstance(self.intersection_rule, IntersectionRule)\n                    else IntersectionRule.NONZERO\n                )\n                want.add(\"fill\")\n                # we need to guarantee that this will not be None. The default will\n                # be \"nonzero\".\n                want.add(intersection_rule)\n\n            try:\n                paint_rule: PathPaintRule = self._PAINT_RULE_LOOKUP[frozenset(want)]\n            except KeyError:\n                # don't default to DONT_PAINT because that's almost certainly not a very\n                # good default.\n                paint_rule = PathPaintRule.STROKE_FILL_NONZERO\n            return paint_rule\n\n        if isinstance(self.paint_rule, InheritType) or self.paint_rule is None:\n            # this shouldn't happen under normal usage, but certain API (ab)use can end\n            # up in this state. We can't resolve anything meaningful, so fall back to a\n            # sane(?) default.\n            return PathPaintRule.STROKE_FILL_NONZERO\n\n        return self.paint_rule",
      "language": "python"
    },
    {
      "code": "class GraphicsStyle:\n    \"\"\"\n    A class representing various style attributes that determine drawing appearance.\n\n    This class uses the convention that the global Python singleton ellipsis (`...`) is\n    exclusively used to represent values that are inherited from the parent style. This\n    is to disambiguate the value None which is used for several values to signal an\n    explicitly disabled style. An example of this is the fill/stroke color styles,\n    which use None as hints to the auto paint style detection code.\n    \"\"\"\n\n    _PRIVATE_SLOTS = (\n        \"_allow_transparency\",\n        \"_auto_close\",\n        \"_fill_color\",\n        \"_intersection_rule\",\n        \"_paint_rule\",\n        \"_stroke_color\",\n        \"_stroke_dash_pattern\",\n        \"_stroke_dash_phase\",\n    )\n\n    __slots__ = _PRIVATE_SLOTS + tuple(\n        k.value\n        for k in PDFStyleKeys\n        # we do not store STROKE_DASH_PATTERN under its PDF key; it's in _stroke_dash_pattern\n        if k is not PDFStyleKeys.STROKE_DASH_PATTERN\n    )\n\n    INHERIT = ...\n    \"\"\"Singleton specifying a style parameter should be inherited from the parent context.\"\"\"\n\n    # order is be important here because some of these properties are entangled, e.g.\n    # fill_color and fill_opacity\n    MERGE_PROPERTIES = (\n        \"paint_rule\",\n        \"allow_transparency\",\n        \"auto_close\",\n        \"intersection_rule\",\n        \"fill_color\",\n        \"fill_opacity\",\n        \"stroke_color\",\n        \"stroke_opacity\",\n        \"blend_mode\",\n        \"stroke_width\",\n        \"stroke_cap_style\",\n        \"stroke_join_style\",\n        \"stroke_miter_limit\",\n        \"stroke_dash_pattern\",\n        \"stroke_dash_phase\",\n        \"soft_mask\",\n    )\n    \"\"\"An ordered collection of properties to use when merging two GraphicsStyles.\"\"\"\n\n    TRANSPARENCY_KEYS = (\n        PDFStyleKeys.FILL_ALPHA.value,\n        PDFStyleKeys.STROKE_ALPHA.value,\n        PDFStyleKeys.BLEND_MODE.value,\n        PDFStyleKeys.SOFT_MASK.value,\n    )\n    \"\"\"An ordered collection of attributes not to emit in no transparency mode.\"\"\"\n\n    PDF_STYLE_KEYS = (\n        *(k.value for k in PDFStyleKeys if k is not PDFStyleKeys.STROKE_DASH_PATTERN),\n    )\n    \"\"\"An ordered collection of keys to directly emit when serializing the style.\"\"\"\n\n    _PAINT_RULE_LOOKUP: dict[frozenset[str | IntersectionRule], PathPaintRule] = {\n        frozenset({}): PathPaintRule.DONT_PAINT,\n        frozenset({\"stroke\"}): PathPaintRule.STROKE,\n        frozenset({\"fill\", IntersectionRule.NONZERO}): PathPaintRule.FILL_NONZERO,\n        frozenset({\"fill\", IntersectionRule.EVENODD}): PathPaintRule.FILL_EVENODD,\n        frozenset(\n            {\"stroke\", \"fill\", IntersectionRule.NONZERO}\n        ): PathPaintRule.STROKE_FILL_NONZERO,\n        frozenset(\n            {\"stroke\", \"fill\", IntersectionRule.EVENODD}\n        ): PathPaintRule.STROKE_FILL_EVENODD,\n    }\n    \"\"\"A dictionary for resolving `PathPaintRule.AUTO`\"\"\"\n\n    @classmethod\n    def merge(cls, parent: \"GraphicsStyle\", child: \"GraphicsStyle\") -> \"GraphicsStyle\":\n        \"\"\"\n        Merge parent and child into a single GraphicsStyle.\n\n        The result contains the properties of the parent as overridden by any properties\n        explicitly set on the child. If both the parent and the child specify to\n        inherit a given property, that property will preserve the inherit value.\n        \"\"\"\n        new = deepcopy(child)\n        for prop in cls.__slots__:\n            cval = getattr(new, prop)\n            if cval is cls.INHERIT:\n                setattr(new, prop, getattr(parent, prop))\n\n        return new\n\n    def __init__(self) -> None:\n        for key in self.__slots__:\n            setattr(self, key, self.INHERIT)\n\n    def __deepcopy__(self: GS, memo: dict[int, Any]) -> GS:\n        cls = self.__class__\n        new = cls.__new__(cls)  # bypass __init__\n        # copy private slots directly\n        for s in cls._PRIVATE_SLOTS:\n            object.__setattr__(new, s, getattr(self, s, cls.INHERIT))\n        # copy PDF-exposed slots (BM, ca, CA, etc.)\n        for key in cls.PDF_STYLE_KEYS:\n            object.__setattr__(new, key, getattr(self, key, cls.INHERIT))\n        return new\n\n    def __setattr__(self, name: str, value: Any) -> None:\n        try:\n            super().__setattr__(name, value)\n        except AttributeError as e:\n            raise AttributeError(\n                f'{self.__class__} does not have style \"{name}\" (a typo?)'\n            ) from e\n\n    # at some point it probably makes sense to turn this into a general compliance\n    # property, but for now this is the simple approach.\n    @property\n    def allow_transparency(self) -> bool | InheritType:\n        allow_transparency = getattr(self, \"_allow_transparency\", self.INHERIT)\n        if allow_transparency is self.INHERIT:\n            return self.INHERIT\n        return cast(bool, allow_transparency)\n\n    @allow_transparency.setter\n    def allow_transparency(self, new: bool | InheritType) -> None:\n        return super().__setattr__(\"_allow_transparency\", new)\n\n    # If these are used in a nested graphics context inside of a painting path\n    # operation, they are no-ops. However, they can be used for outer GraphicsContexts\n    # that painting paths inherit from.\n    @property\n    def paint_rule(self) -> PathPaintRule | InheritType | None:\n        \"\"\"The paint rule to use for this path/group.\"\"\"\n        paint_rule = getattr(self, \"_paint_rule\", self.INHERIT)\n        if paint_rule is self.INHERIT or paint_rule is None:\n            return paint_rule\n        return cast(PathPaintRule, paint_rule)\n\n    @paint_rule.setter\n    def paint_rule(self, new: PathPaintRule | InheritType | str | None) -> None:\n        if new is None:\n            super().__setattr__(\"_paint_rule\", PathPaintRule.DONT_PAINT)\n        elif isinstance(new, InheritType):\n            super().__setattr__(\"_paint_rule\", new)\n        else:\n            super().__setattr__(\"_paint_rule\", PathPaintRule.coerce(new))\n\n    @property\n    def auto_close(self) -> bool | InheritType:\n        \"\"\"If True, unclosed paths will be automatically closed before stroking.\"\"\"\n        auto_close = getattr(self, \"_auto_close\", self.INHERIT)\n        if auto_close is self.INHERIT:\n            return auto_close\n        return cast(bool, auto_close)\n\n    @auto_close.setter\n    def auto_close(self, new: bool | InheritType) -> None:\n        if new not in {True, False, self.INHERIT}:\n            raise TypeError(f\"auto_close must be a bool or self.INHERIT, not {new}\")\n        super().__setattr__(\"_auto_close\", new)\n\n    @property\n    def intersection_rule(self) -> IntersectionRule | InheritType:\n        \"\"\"The desired intersection rule for this path/group.\"\"\"\n        intersection_rule = getattr(self, \"_intersection_rule\", self.INHERIT)\n        if intersection_rule is self.INHERIT:\n            return intersection_rule\n        return cast(IntersectionRule, intersection_rule)\n\n    @intersection_rule.setter\n    def intersection_rule(self, new: IntersectionRule | InheritType | str) -> None:\n        # don't allow None for this one.\n        if isinstance(new, InheritType):\n            super().__setattr__(\"_intersection_rule\", new)\n        else:\n            super().__setattr__(\"_intersection_rule\", IntersectionRule.coerce(new))\n\n    @property\n    def fill_color(self) -> Color | GradientPaint | InheritType | str | None:\n        \"\"\"\n        The desired fill color for this path/group.\n\n        When setting this property, if the color specifies an opacity value, that will\n        be used to set the fill_opacity property as well.\n        \"\"\"\n        fill_color = getattr(self, \"_fill_color\", self.INHERIT)\n        if fill_color is self.INHERIT or fill_color is None:\n            return fill_color\n        assert isinstance(\n            fill_color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)\n        )\n        return fill_color\n\n    @fill_color.setter\n    def fill_color(\n        self, color: Color | GradientPaint | str | InheritType | None\n    ) -> None:\n        if isinstance(color, str):\n            color = color_from_hex_string(color)\n\n        if isinstance(color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)):\n            super().__setattr__(\"_fill_color\", color)\n            if getattr(color, \"a\", None) is not None and not isinstance(\n                color, GradientPaint\n            ):\n                self.fill_opacity = color.a\n\n        elif (color is None) or (color is self.INHERIT):\n            super().__setattr__(\"_fill_color\", color)\n\n        else:\n            raise TypeError(f\"{color} doesn't look like a drawing color\")\n\n    @property\n    def fill_opacity(self) -> float | InheritType | None:\n        \"\"\"The desired fill opacity for this path/group.\"\"\"\n        fill_opacity = getattr(self, PDFStyleKeys.FILL_ALPHA.value, self.INHERIT)\n        if fill_opacity is self.INHERIT or fill_opacity is None:\n            return fill_opacity\n        return cast(float, fill_opacity)\n\n    @fill_opacity.setter\n    def fill_opacity(self, new: float | InheritType | None) -> None:\n        if new not in {None, self.INHERIT}:\n            assert isinstance(new, NumberClass)\n            check_range(new)\n        super().__setattr__(PDFStyleKeys.FILL_ALPHA.value, new)\n\n    @property\n    def stroke_color(self) -> Color | GradientPaint | InheritType | None:\n        \"\"\"\n        The desired stroke color for this path/group.\n\n        When setting this property, if the color specifies an opacity value, that will\n        be used to set the fill_opacity property as well.\n        \"\"\"\n        stroke_color = getattr(self, \"_stroke_color\", self.INHERIT)\n        if stroke_color is self.INHERIT or stroke_color is None:\n            return stroke_color\n        assert isinstance(\n            stroke_color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)\n        )\n        return stroke_color\n\n    @stroke_color.setter\n    def stroke_color(\n        self, color: Color | GradientPaint | str | InheritType | None\n    ) -> None:\n        if isinstance(color, str):\n            color = color_from_hex_string(color)\n\n        if isinstance(color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)):\n            super().__setattr__(\"_stroke_color\", color)\n            if getattr(color, \"a\", None) is not None and not isinstance(\n                color, GradientPaint\n            ):\n                self.stroke_opacity = color.a\n            if self.stroke_width is self.INHERIT:\n                self.stroke_width = 1\n\n        elif (color is None) or (color is self.INHERIT):\n            super().__setattr__(\"_stroke_color\", color)\n\n        else:\n            raise TypeError(f\"{color} doesn't look like a drawing color\")\n\n    @property\n    def stroke_opacity(self) -> float | InheritType | None:\n        \"\"\"The desired stroke opacity for this path/group.\"\"\"\n        stroke_opacity = getattr(self, PDFStyleKeys.STROKE_ALPHA.value, self.INHERIT)\n        if stroke_opacity is self.INHERIT or stroke_opacity is None:\n            return stroke_opacity\n        assert isinstance(stroke_opacity, NumberClass)\n        return float(stroke_opacity)\n\n    @stroke_opacity.setter\n    def stroke_opacity(self, new: float | InheritType | None) -> None:\n        if new not in (None, self.INHERIT):\n            assert isinstance(new, NumberClass)\n            check_range(new)\n        super().__setattr__(PDFStyleKeys.STROKE_ALPHA.value, new)\n\n    @property\n    def blend_mode(self) -> BlendMode | InheritType:\n        \"\"\"The desired blend mode for this path/group.\"\"\"\n        blend_mode = getattr(self, PDFStyleKeys.BLEND_MODE.value, self.INHERIT)\n        if blend_mode is self.INHERIT:\n            return blend_mode\n        return cast(BlendMode, blend_mode)\n\n    @blend_mode.setter\n    def blend_mode(self, value: BlendMode | str | InheritType) -> None:\n        if isinstance(value, InheritType):\n            super().__setattr__(PDFStyleKeys.BLEND_MODE.value, value)\n        else:\n            super().__setattr__(\n                PDFStyleKeys.BLEND_MODE.value, BlendMode.coerce(value).value\n            )\n\n    @property\n    def stroke_width(self) -> float | InheritType | None:\n        \"\"\"The desired stroke width for this path/group.\"\"\"\n        stroke_width = getattr(self, PDFStyleKeys.STROKE_WIDTH.value, self.INHERIT)\n        if stroke_width is self.INHERIT or stroke_width is None:\n            return stroke_width\n        assert isinstance(stroke_width, NumberClass)\n        return float(stroke_width)\n\n    @stroke_width.setter\n    def stroke_width(self, width: float | InheritType | None) -> None:\n        if width not in (None, self.INHERIT) and not isinstance(width, NumberClass):\n            raise TypeError(f\"stroke_width must be a number, not {type(width)}\")\n        super().__setattr__(PDFStyleKeys.STROKE_WIDTH.value, width)\n\n    @property\n    def stroke_cap_style(self) -> StrokeCapStyle | InheritType:\n        \"\"\"The desired stroke cap style for this path/group.\"\"\"\n        stroke_cap_style = getattr(\n            self, PDFStyleKeys.STROKE_CAP_STYLE.value, self.INHERIT\n        )\n        if stroke_cap_style is self.INHERIT:\n            return stroke_cap_style\n        return cast(StrokeCapStyle, stroke_cap_style)\n\n    @stroke_cap_style.setter\n    def stroke_cap_style(self, value: StrokeCapStyle | str | InheritType) -> None:\n        if isinstance(value, InheritType):\n            super().__setattr__(PDFStyleKeys.STROKE_CAP_STYLE.value, value)\n        else:\n            super().__setattr__(\n                PDFStyleKeys.STROKE_CAP_STYLE.value, StrokeCapStyle.coerce(value)\n            )\n\n    @property\n    def stroke_join_style(self) -> StrokeJoinStyle | InheritType:\n        \"\"\"The desired stroke join style for this path/group.\"\"\"\n        stroke_join_style = getattr(\n            self, PDFStyleKeys.STROKE_JOIN_STYLE.value, self.INHERIT\n        )\n        if stroke_join_style is self.INHERIT:\n            return stroke_join_style\n        return cast(StrokeJoinStyle, stroke_join_style)\n\n    @stroke_join_style.setter\n    def stroke_join_style(self, value: StrokeJoinStyle | str | InheritType) -> None:\n        if isinstance(value, InheritType):\n            super().__setattr__(PDFStyleKeys.STROKE_JOIN_STYLE.value, value)\n        else:\n            super().__setattr__(\n                PDFStyleKeys.STROKE_JOIN_STYLE.value, StrokeJoinStyle.coerce(value)\n            )\n\n    @property\n    def stroke_miter_limit(self) -> float | InheritType:\n        \"\"\"The desired stroke miter limit for this path/group.\"\"\"\n        stroke_miter_limit = getattr(\n            self, PDFStyleKeys.STROKE_MITER_LIMIT.value, self.INHERIT\n        )\n        if stroke_miter_limit is self.INHERIT:\n            return stroke_miter_limit\n        assert isinstance(stroke_miter_limit, NumberClass)\n        return float(stroke_miter_limit)\n\n    @stroke_miter_limit.setter\n    def stroke_miter_limit(self, value: Number | InheritType) -> None:\n        if (value is self.INHERIT) or isinstance(value, NumberClass):\n            super().__setattr__(PDFStyleKeys.STROKE_MITER_LIMIT.value, value)\n        else:\n            raise TypeError(f\"{value} is not a number\")\n\n    @property\n    def stroke_dash_pattern(self) -> Optional[InheritType | tuple[float, ...]]:\n        \"\"\"The desired stroke dash pattern for this path/group.\"\"\"\n        stroke_dash_pattern = getattr(self, \"_stroke_dash_pattern\", self.INHERIT)\n        if stroke_dash_pattern is self.INHERIT:\n            return stroke_dash_pattern\n        return cast(tuple[float, ...], stroke_dash_pattern)\n\n    @stroke_dash_pattern.setter\n    def stroke_dash_pattern(\n        self, value: None | InheritType | Number | Sequence[Number]\n    ) -> None:\n        result: None | InheritType | Number | Sequence[Number]\n        if value is None:\n            result = ()\n        elif isinstance(value, InheritType):\n            result = self.INHERIT\n        elif isinstance(value, NumberClass):\n            result = (float(value),)\n        elif isinstance(value, (str, bytes, bytearray)):\n            raise TypeError(\n                f\"stroke_dash_pattern {value!r} must be a number or sequence of numbers\"\n            )\n        else:\n            try:\n                accum: list[float] = []\n                for item in value:\n                    if isinstance(item, (str, bytes, bytearray)):\n                        raise TypeError\n                    accum.append(float(item))\n            except (TypeError, ValueError):\n                raise TypeError(\n                    f\"stroke_dash_pattern {value!r} must be a number or sequence of numbers\"\n                ) from None\n            result = (*accum,)\n        super().__setattr__(\"_stroke_dash_pattern\", result)\n\n    @property\n    def stroke_dash_phase(self) -> InheritType | float:\n        \"\"\"The desired stroke dash pattern phase offset for this path/group.\"\"\"\n        stroke_dash_phase = getattr(self, \"_stroke_dash_phase\", self.INHERIT)\n        if stroke_dash_phase is self.INHERIT:\n            return stroke_dash_phase\n        assert isinstance(stroke_dash_phase, NumberClass)\n        return float(stroke_dash_phase)\n\n    @stroke_dash_phase.setter\n    def stroke_dash_phase(self, value: InheritType | Number) -> None:\n        if value is self.INHERIT or isinstance(value, NumberClass):\n            return super().__setattr__(\"_stroke_dash_phase\", value)\n\n        raise TypeError(f\"{value} isn't a number or GraphicsStyle.INHERIT\")\n\n    @property\n    def soft_mask(self) -> Union[InheritType, \"PaintSoftMask\"]:\n        paint_soft_mask = getattr(self, PDFStyleKeys.SOFT_MASK.value, self.INHERIT)\n        if paint_soft_mask is self.INHERIT:\n            return paint_soft_mask\n        return cast(PaintSoftMask, paint_soft_mask)\n\n    @soft_mask.setter\n    def soft_mask(self, value: Union[InheritType, \"PaintSoftMask\"]) -> None:\n        if value is self.INHERIT or isinstance(value, PaintSoftMask):\n            return super().__setattr__(PDFStyleKeys.SOFT_MASK.value, value)\n        raise TypeError(f\"{value} isn't a PaintSoftMask or GraphicsStyle.INHERIT\")\n\n    def serialize(self) -> Optional[Raw]:\n        \"\"\"\n        Convert this style object to a PDF dictionary with appropriate style keys.\n\n        Only explicitly specified values are emitted.\n        \"\"\"\n        result: dict[Name, Any] = OrderedDict()\n\n        for key in self.PDF_STYLE_KEYS:\n            value = getattr(self, key, self.INHERIT)\n\n            if (value is not self.INHERIT) and (value is not None):\n                # None is used for out-of-band signaling on these, e.g. a stroke_width\n                # of None doesn't need to land here because it signals the\n                # PathPaintRule auto resolution only.\n                result[key] = value\n\n        # There is additional logic in GraphicsContext to ensure that this will work\n        if self.stroke_dash_pattern and self.stroke_dash_pattern is not self.INHERIT:\n            result[PDFStyleKeys.STROKE_DASH_PATTERN.value] = [\n                self.stroke_dash_pattern,\n                self.stroke_dash_phase,\n            ]\n\n        if self.allow_transparency is False:\n            for key in self.TRANSPARENCY_KEYS:\n                if key in result:\n                    del result[key]\n\n        if result:\n            # Only insert this key if there is at least one other item in the result so\n            # that we don't junk up the output PDF with empty ExtGState dictionaries.\n            type_name = Name(\"Type\")\n            result[type_name] = Name(\"ExtGState\")\n            result.move_to_end(type_name, last=False)  # type: ignore[attr-defined]\n\n            return render_pdf_primitive(result)\n\n        # this signals to the graphics state registry that there is nothing to\n        # register. This is a success case.\n        return None\n\n    @force_nodocument\n    def resolve_paint_rule(self) -> PathPaintRule:\n        \"\"\"\n        Resolve `PathPaintRule.AUTO` to a real paint rule based on this style.\n\n        Returns:\n            the resolved `PathPaintRule`.\n        \"\"\"\n        if self.paint_rule is PathPaintRule.AUTO:\n            want: set[str | IntersectionRule] = set()\n            stroke_color = self.stroke_color\n            if self.stroke_width is not None and stroke_color is not None:\n                want.add(\"stroke\")\n            fill_color = self.fill_color\n            if fill_color is not None:\n                intersection_rule = (\n                    self.intersection_rule\n                    if isinstance(self.intersection_rule, IntersectionRule)\n                    else IntersectionRule.NONZERO\n                )\n                want.add(\"fill\")\n                # we need to guarantee that this will not be None. The default will\n                # be \"nonzero\".\n                want.add(intersection_rule)\n\n            try:\n                paint_rule: PathPaintRule = self._PAINT_RULE_LOOKUP[frozenset(want)]\n            except KeyError:\n                # don't default to DONT_PAINT because that's almost certainly not a very\n                # good default.\n                paint_rule = PathPaintRule.STROKE_FILL_NONZERO\n            return paint_rule\n\n        if isinstance(self.paint_rule, InheritType) or self.paint_rule is None:\n            # this shouldn't happen under normal usage, but certain API (ab)use can end\n            # up in this state. We can't resolve anything meaningful, so fall back to a\n            # sane(?) default.\n            return PathPaintRule.STROKE_FILL_NONZERO\n\n        return self.paint_rule",
      "language": "python"
    },
    {
      "code": "class GraphicsStyle:\n    \"\"\"\n    A class representing various style attributes that determine drawing appearance.\n\n    This class uses the convention that the global Python singleton ellipsis (`...`) is\n    exclusively used to represent values that are inherited from the parent style. This\n    is to disambiguate the value None which is used for several values to signal an\n    explicitly disabled style. An example of this is the fill/stroke color styles,\n    which use None as hints to the auto paint style detection code.\n    \"\"\"\n\n    _PRIVATE_SLOTS = (\n        \"_allow_transparency\",\n        \"_auto_close\",\n        \"_fill_color\",\n        \"_intersection_rule\",\n        \"_paint_rule\",\n        \"_stroke_color\",\n        \"_stroke_dash_pattern\",\n        \"_stroke_dash_phase\",\n    )\n\n    __slots__ = _PRIVATE_SLOTS + tuple(\n        k.value\n        for k in PDFStyleKeys\n        # we do not store STROKE_DASH_PATTERN under its PDF key; it's in _stroke_dash_pattern\n        if k is not PDFStyleKeys.STROKE_DASH_PATTERN\n    )\n\n    INHERIT = ...\n    \"\"\"Singleton specifying a style parameter should be inherited from the parent context.\"\"\"\n\n    # order is be important here because some of these properties are entangled, e.g.\n    # fill_color and fill_opacity\n    MERGE_PROPERTIES = (\n        \"paint_rule\",\n        \"allow_transparency\",\n        \"auto_close\",\n        \"intersection_rule\",\n        \"fill_color\",\n        \"fill_opacity\",\n        \"stroke_color\",\n        \"stroke_opacity\",\n        \"blend_mode\",\n        \"stroke_width\",\n        \"stroke_cap_style\",\n        \"stroke_join_style\",\n        \"stroke_miter_limit\",\n        \"stroke_dash_pattern\",\n        \"stroke_dash_phase\",\n        \"soft_mask\",\n    )\n    \"\"\"An ordered collection of properties to use when merging two GraphicsStyles.\"\"\"\n\n    TRANSPARENCY_KEYS = (\n        PDFStyleKeys.FILL_ALPHA.value,\n        PDFStyleKeys.STROKE_ALPHA.value,\n        PDFStyleKeys.BLEND_MODE.value,\n        PDFStyleKeys.SOFT_MASK.value,\n    )\n    \"\"\"An ordered collection of attributes not to emit in no transparency mode.\"\"\"\n\n    PDF_STYLE_KEYS = (\n        *(k.value for k in PDFStyleKeys if k is not PDFStyleKeys.STROKE_DASH_PATTERN),\n    )\n    \"\"\"An ordered collection of keys to directly emit when serializing the style.\"\"\"\n\n    _PAINT_RULE_LOOKUP: dict[frozenset[str | IntersectionRule], PathPaintRule] = {\n        frozenset({}): PathPaintRule.DONT_PAINT,\n        frozenset({\"stroke\"}): PathPaintRule.STROKE,\n        frozenset({\"fill\", IntersectionRule.NONZERO}): PathPaintRule.FILL_NONZERO,\n        frozenset({\"fill\", IntersectionRule.EVENODD}): PathPaintRule.FILL_EVENODD,\n        frozenset(\n            {\"stroke\", \"fill\", IntersectionRule.NONZERO}\n        ): PathPaintRule.STROKE_FILL_NONZERO,\n        frozenset(\n            {\"stroke\", \"fill\", IntersectionRule.EVENODD}\n        ): PathPaintRule.STROKE_FILL_EVENODD,\n    }\n    \"\"\"A dictionary for resolving `PathPaintRule.AUTO`\"\"\"\n\n    @classmethod\n    def merge(cls, parent: \"GraphicsStyle\", child: \"GraphicsStyle\") -> \"GraphicsStyle\":\n        \"\"\"\n        Merge parent and child into a single GraphicsStyle.\n\n        The result contains the properties of the parent as overridden by any properties\n        explicitly set on the child. If both the parent and the child specify to\n        inherit a given property, that property will preserve the inherit value.\n        \"\"\"\n        new = deepcopy(child)\n        for prop in cls.__slots__:\n            cval = getattr(new, prop)\n            if cval is cls.INHERIT:\n                setattr(new, prop, getattr(parent, prop))\n\n        return new\n\n    def __init__(self) -> None:\n        for key in self.__slots__:\n            setattr(self, key, self.INHERIT)\n\n    def __deepcopy__(self: GS, memo: dict[int, Any]) -> GS:\n        cls = self.__class__\n        new = cls.__new__(cls)  # bypass __init__\n        # copy private slots directly\n        for s in cls._PRIVATE_SLOTS:\n            object.__setattr__(new, s, getattr(self, s, cls.INHERIT))\n        # copy PDF-exposed slots (BM, ca, CA, etc.)\n        for key in cls.PDF_STYLE_KEYS:\n            object.__setattr__(new, key, getattr(self, key, cls.INHERIT))\n        return new\n\n    def __setattr__(self, name: str, value: Any) -> None:\n        try:\n            super().__setattr__(name, value)\n        except AttributeError as e:\n            raise AttributeError(\n                f'{self.__class__} does not have style \"{name}\" (a typo?)'\n            ) from e\n\n    # at some point it probably makes sense to turn this into a general compliance\n    # property, but for now this is the simple approach.\n    @property\n    def allow_transparency(self) -> bool | InheritType:\n        allow_transparency = getattr(self, \"_allow_transparency\", self.INHERIT)\n        if allow_transparency is self.INHERIT:\n            return self.INHERIT\n        return cast(bool, allow_transparency)\n\n    @allow_transparency.setter\n    def allow_transparency(self, new: bool | InheritType) -> None:\n        return super().__setattr__(\"_allow_transparency\", new)\n\n    # If these are used in a nested graphics context inside of a painting path\n    # operation, they are no-ops. However, they can be used for outer GraphicsContexts\n    # that painting paths inherit from.\n    @property\n    def paint_rule(self) -> PathPaintRule | InheritType | None:\n        \"\"\"The paint rule to use for this path/group.\"\"\"\n        paint_rule = getattr(self, \"_paint_rule\", self.INHERIT)\n        if paint_rule is self.INHERIT or paint_rule is None:\n            return paint_rule\n        return cast(PathPaintRule, paint_rule)\n\n    @paint_rule.setter\n    def paint_rule(self, new: PathPaintRule | InheritType | str | None) -> None:\n        if new is None:\n            super().__setattr__(\"_paint_rule\", PathPaintRule.DONT_PAINT)\n        elif isinstance(new, InheritType):\n            super().__setattr__(\"_paint_rule\", new)\n        else:\n            super().__setattr__(\"_paint_rule\", PathPaintRule.coerce(new))\n\n    @property\n    def auto_close(self) -> bool | InheritType:\n        \"\"\"If True, unclosed paths will be automatically closed before stroking.\"\"\"\n        auto_close = getattr(self, \"_auto_close\", self.INHERIT)\n        if auto_close is self.INHERIT:\n            return auto_close\n        return cast(bool, auto_close)\n\n    @auto_close.setter\n    def auto_close(self, new: bool | InheritType) -> None:\n        if new not in {True, False, self.INHERIT}:\n            raise TypeError(f\"auto_close must be a bool or self.INHERIT, not {new}\")\n        super().__setattr__(\"_auto_close\", new)\n\n    @property\n    def intersection_rule(self) -> IntersectionRule | InheritType:\n        \"\"\"The desired intersection rule for this path/group.\"\"\"\n        intersection_rule = getattr(self, \"_intersection_rule\", self.INHERIT)\n        if intersection_rule is self.INHERIT:\n            return intersection_rule\n        return cast(IntersectionRule, intersection_rule)\n\n    @intersection_rule.setter\n    def intersection_rule(self, new: IntersectionRule | InheritType | str) -> None:\n        # don't allow None for this one.\n        if isinstance(new, InheritType):\n            super().__setattr__(\"_intersection_rule\", new)\n        else:\n            super().__setattr__(\"_intersection_rule\", IntersectionRule.coerce(new))\n\n    @property\n    def fill_color(self) -> Color | GradientPaint | InheritType | str | None:\n        \"\"\"\n        The desired fill color for this path/group.\n\n        When setting this property, if the color specifies an opacity value, that will\n        be used to set the fill_opacity property as well.\n        \"\"\"\n        fill_color = getattr(self, \"_fill_color\", self.INHERIT)\n        if fill_color is self.INHERIT or fill_color is None:\n            return fill_color\n        assert isinstance(\n            fill_color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)\n        )\n        return fill_color\n\n    @fill_color.setter\n    def fill_color(\n        self, color: Color | GradientPaint | str | InheritType | None\n    ) -> None:\n        if isinstance(color, str):\n            color = color_from_hex_string(color)\n\n        if isinstance(color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)):\n            super().__setattr__(\"_fill_color\", color)\n            if getattr(color, \"a\", None) is not None and not isinstance(\n                color, GradientPaint\n            ):\n                self.fill_opacity = color.a\n\n        elif (color is None) or (color is self.INHERIT):\n            super().__setattr__(\"_fill_color\", color)\n\n        else:\n            raise TypeError(f\"{color} doesn't look like a drawing color\")\n\n    @property\n    def fill_opacity(self) -> float | InheritType | None:\n        \"\"\"The desired fill opacity for this path/group.\"\"\"\n        fill_opacity = getattr(self, PDFStyleKeys.FILL_ALPHA.value, self.INHERIT)\n        if fill_opacity is self.INHERIT or fill_opacity is None:\n            return fill_opacity\n        return cast(float, fill_opacity)\n\n    @fill_opacity.setter\n    def fill_opacity(self, new: float | InheritType | None) -> None:\n        if new not in {None, self.INHERIT}:\n            assert isinstance(new, NumberClass)\n            check_range(new)\n        super().__setattr__(PDFStyleKeys.FILL_ALPHA.value, new)\n\n    @property\n    def stroke_color(self) -> Color | GradientPaint | InheritType | None:\n        \"\"\"\n        The desired stroke color for this path/group.\n\n        When setting this property, if the color specifies an opacity value, that will\n        be used to set the fill_opacity property as well.\n        \"\"\"\n        stroke_color = getattr(self, \"_stroke_color\", self.INHERIT)\n        if stroke_color is self.INHERIT or stroke_color is None:\n            return stroke_color\n        assert isinstance(\n            stroke_color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)\n        )\n        return stroke_color\n\n    @stroke_color.setter\n    def stroke_color(\n        self, color: Color | GradientPaint | str | InheritType | None\n    ) -> None:\n        if isinstance(color, str):\n            color = color_from_hex_string(color)\n\n        if isinstance(color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)):\n            super().__setattr__(\"_stroke_color\", color)\n            if getattr(color, \"a\", None) is not None and not isinstance(\n                color, GradientPaint\n            ):\n                self.stroke_opacity = color.a\n            if self.stroke_width is self.INHERIT:\n                self.stroke_width = 1\n\n        elif (color is None) or (color is self.INHERIT):\n            super().__setattr__(\"_stroke_color\", color)\n\n        else:\n            raise TypeError(f\"{color} doesn't look like a drawing color\")\n\n    @property\n    def stroke_opacity(self) -> float | InheritType | None:\n        \"\"\"The desired stroke opacity for this path/group.\"\"\"\n        stroke_opacity = getattr(self, PDFStyleKeys.STROKE_ALPHA.value, self.INHERIT)\n        if stroke_opacity is self.INHERIT or stroke_opacity is None:\n            return stroke_opacity\n        assert isinstance(stroke_opacity, NumberClass)\n        return float(stroke_opacity)\n\n    @stroke_opacity.setter\n    def stroke_opacity(self, new: float | InheritType | None) -> None:\n        if new not in (None, self.INHERIT):\n            assert isinstance(new, NumberClass)\n            check_range(new)\n        super().__setattr__(PDFStyleKeys.STROKE_ALPHA.value, new)\n\n    @property\n    def blend_mode(self) -> BlendMode | InheritType:\n        \"\"\"The desired blend mode for this path/group.\"\"\"\n        blend_mode = getattr(self, PDFStyleKeys.BLEND_MODE.value, self.INHERIT)\n        if blend_mode is self.INHERIT:\n            return blend_mode\n        return cast(BlendMode, blend_mode)\n\n    @blend_mode.setter\n    def blend_mode(self, value: BlendMode | str | InheritType) -> None:\n        if isinstance(value, InheritType):\n            super().__setattr__(PDFStyleKeys.BLEND_MODE.value, value)\n        else:\n            super().__setattr__(\n                PDFStyleKeys.BLEND_MODE.value, BlendMode.coerce(value).value\n            )\n\n    @property\n    def stroke_width(self) -> float | InheritType | None:\n        \"\"\"The desired stroke width for this path/group.\"\"\"\n        stroke_width = getattr(self, PDFStyleKeys.STROKE_WIDTH.value, self.INHERIT)\n        if stroke_width is self.INHERIT or stroke_width is None:\n            return stroke_width\n        assert isinstance(stroke_width, NumberClass)\n        return float(stroke_width)\n\n    @stroke_width.setter\n    def stroke_width(self, width: float | InheritType | None) -> None:\n        if width not in (None, self.INHERIT) and not isinstance(width, NumberClass):\n            raise TypeError(f\"stroke_width must be a number, not {type(width)}\")\n        super().__setattr__(PDFStyleKeys.STROKE_WIDTH.value, width)\n\n    @property\n    def stroke_cap_style(self) -> StrokeCapStyle | InheritType:\n        \"\"\"The desired stroke cap style for this path/group.\"\"\"\n        stroke_cap_style = getattr(\n            self, PDFStyleKeys.STROKE_CAP_STYLE.value, self.INHERIT\n        )\n        if stroke_cap_style is self.INHERIT:\n            return stroke_cap_style\n        return cast(StrokeCapStyle, stroke_cap_style)\n\n    @stroke_cap_style.setter\n    def stroke_cap_style(self, value: StrokeCapStyle | str | InheritType) -> None:\n        if isinstance(value, InheritType):\n            super().__setattr__(PDFStyleKeys.STROKE_CAP_STYLE.value, value)\n        else:\n            super().__setattr__(\n                PDFStyleKeys.STROKE_CAP_STYLE.value, StrokeCapStyle.coerce(value)\n            )\n\n    @property\n    def stroke_join_style(self) -> StrokeJoinStyle | InheritType:\n        \"\"\"The desired stroke join style for this path/group.\"\"\"\n        stroke_join_style = getattr(\n            self, PDFStyleKeys.STROKE_JOIN_STYLE.value, self.INHERIT\n        )\n        if stroke_join_style is self.INHERIT:\n            return stroke_join_style\n        return cast(StrokeJoinStyle, stroke_join_style)\n\n    @stroke_join_style.setter\n    def stroke_join_style(self, value: StrokeJoinStyle | str | InheritType) -> None:\n        if isinstance(value, InheritType):\n            super().__setattr__(PDFStyleKeys.STROKE_JOIN_STYLE.value, value)\n        else:\n            super().__setattr__(\n                PDFStyleKeys.STROKE_JOIN_STYLE.value, StrokeJoinStyle.coerce(value)\n            )\n\n    @property\n    def stroke_miter_limit(self) -> float | InheritType:\n        \"\"\"The desired stroke miter limit for this path/group.\"\"\"\n        stroke_miter_limit = getattr(\n            self, PDFStyleKeys.STROKE_MITER_LIMIT.value, self.INHERIT\n        )\n        if stroke_miter_limit is self.INHERIT:\n            return stroke_miter_limit\n        assert isinstance(stroke_miter_limit, NumberClass)\n        return float(stroke_miter_limit)\n\n    @stroke_miter_limit.setter\n    def stroke_miter_limit(self, value: Number | InheritType) -> None:\n        if (value is self.INHERIT) or isinstance(value, NumberClass):\n            super().__setattr__(PDFStyleKeys.STROKE_MITER_LIMIT.value, value)\n        else:\n            raise TypeError(f\"{value} is not a number\")\n\n    @property\n    def stroke_dash_pattern(self) -> Optional[InheritType | tuple[float, ...]]:\n        \"\"\"The desired stroke dash pattern for this path/group.\"\"\"\n        stroke_dash_pattern = getattr(self, \"_stroke_dash_pattern\", self.INHERIT)\n        if stroke_dash_pattern is self.INHERIT:\n            return stroke_dash_pattern\n        return cast(tuple[float, ...], stroke_dash_pattern)\n\n    @stroke_dash_pattern.setter\n    def stroke_dash_pattern(\n        self, value: None | InheritType | Number | Sequence[Number]\n    ) -> None:\n        result: None | InheritType | Number | Sequence[Number]\n        if value is None:\n            result = ()\n        elif isinstance(value, InheritType):\n            result = self.INHERIT\n        elif isinstance(value, NumberClass):\n            result = (float(value),)\n        elif isinstance(value, (str, bytes, bytearray)):\n            raise TypeError(\n                f\"stroke_dash_pattern {value!r} must be a number or sequence of numbers\"\n            )\n        else:\n            try:\n                accum: list[float] = []\n                for item in value:\n                    if isinstance(item, (str, bytes, bytearray)):\n                        raise TypeError\n                    accum.append(float(item))\n            except (TypeError, ValueError):\n                raise TypeError(\n                    f\"stroke_dash_pattern {value!r} must be a number or sequence of numbers\"\n                ) from None\n            result = (*accum,)\n        super().__setattr__(\"_stroke_dash_pattern\", result)\n\n    @property\n    def stroke_dash_phase(self) -> InheritType | float:\n        \"\"\"The desired stroke dash pattern phase offset for this path/group.\"\"\"\n        stroke_dash_phase = getattr(self, \"_stroke_dash_phase\", self.INHERIT)\n        if stroke_dash_phase is self.INHERIT:\n            return stroke_dash_phase\n        assert isinstance(stroke_dash_phase, NumberClass)\n        return float(stroke_dash_phase)\n\n    @stroke_dash_phase.setter\n    def stroke_dash_phase(self, value: InheritType | Number) -> None:\n        if value is self.INHERIT or isinstance(value, NumberClass):\n            return super().__setattr__(\"_stroke_dash_phase\", value)\n\n        raise TypeError(f\"{value} isn't a number or GraphicsStyle.INHERIT\")\n\n    @property\n    def soft_mask(self) -> Union[InheritType, \"PaintSoftMask\"]:\n        paint_soft_mask = getattr(self, PDFStyleKeys.SOFT_MASK.value, self.INHERIT)\n        if paint_soft_mask is self.INHERIT:\n            return paint_soft_mask\n        return cast(PaintSoftMask, paint_soft_mask)\n\n    @soft_mask.setter\n    def soft_mask(self, value: Union[InheritType, \"PaintSoftMask\"]) -> None:\n        if value is self.INHERIT or isinstance(value, PaintSoftMask):\n            return super().__setattr__(PDFStyleKeys.SOFT_MASK.value, value)\n        raise TypeError(f\"{value} isn't a PaintSoftMask or GraphicsStyle.INHERIT\")\n\n    def serialize(self) -> Optional[Raw]:\n        \"\"\"\n        Convert this style object to a PDF dictionary with appropriate style keys.\n\n        Only explicitly specified values are emitted.\n        \"\"\"\n        result: dict[Name, Any] = OrderedDict()\n\n        for key in self.PDF_STYLE_KEYS:\n            value = getattr(self, key, self.INHERIT)\n\n            if (value is not self.INHERIT) and (value is not None):\n                # None is used for out-of-band signaling on these, e.g. a stroke_width\n                # of None doesn't need to land here because it signals the\n                # PathPaintRule auto resolution only.\n                result[key] = value\n\n        # There is additional logic in GraphicsContext to ensure that this will work\n        if self.stroke_dash_pattern and self.stroke_dash_pattern is not self.INHERIT:\n            result[PDFStyleKeys.STROKE_DASH_PATTERN.value] = [\n                self.stroke_dash_pattern,\n                self.stroke_dash_phase,\n            ]\n\n        if self.allow_transparency is False:\n            for key in self.TRANSPARENCY_KEYS:\n                if key in result:\n                    del result[key]\n\n        if result:\n            # Only insert this key if there is at least one other item in the result so\n            # that we don't junk up the output PDF with empty ExtGState dictionaries.\n            type_name = Name(\"Type\")\n            result[type_name] = Name(\"ExtGState\")\n            result.move_to_end(type_name, last=False)  # type: ignore[attr-defined]\n\n            return render_pdf_primitive(result)\n\n        # this signals to the graphics state registry that there is nothing to\n        # register. This is a success case.\n        return None\n\n    @force_nodocument\n    def resolve_paint_rule(self) -> PathPaintRule:\n        \"\"\"\n        Resolve `PathPaintRule.AUTO` to a real paint rule based on this style.\n\n        Returns:\n            the resolved `PathPaintRule`.\n        \"\"\"\n        if self.paint_rule is PathPaintRule.AUTO:\n            want: set[str | IntersectionRule] = set()\n            stroke_color = self.stroke_color\n            if self.stroke_width is not None and stroke_color is not None:\n                want.add(\"stroke\")\n            fill_color = self.fill_color\n            if fill_color is not None:\n                intersection_rule = (\n                    self.intersection_rule\n                    if isinstance(self.intersection_rule, IntersectionRule)\n                    else IntersectionRule.NONZERO\n                )\n                want.add(\"fill\")\n                # we need to guarantee that this will not be None. The default will\n                # be \"nonzero\".\n                want.add(intersection_rule)\n\n            try:\n                paint_rule: PathPaintRule = self._PAINT_RULE_LOOKUP[frozenset(want)]\n            except KeyError:\n                # don't default to DONT_PAINT because that's almost certainly not a very\n                # good default.\n                paint_rule = PathPaintRule.STROKE_FILL_NONZERO\n            return paint_rule\n\n        if isinstance(self.paint_rule, InheritType) or self.paint_rule is None:\n            # this shouldn't happen under normal usage, but certain API (ab)use can end\n            # up in this state. We can't resolve anything meaningful, so fall back to a\n            # sane(?) default.\n            return PathPaintRule.STROKE_FILL_NONZERO\n\n        return self.paint_rule",
      "language": "python"
    },
    {
      "code": "class GraphicsStyle:\n    \"\"\"\n    A class representing various style attributes that determine drawing appearance.\n\n    This class uses the convention that the global Python singleton ellipsis (`...`) is\n    exclusively used to represent values that are inherited from the parent style. This\n    is to disambiguate the value None which is used for several values to signal an\n    explicitly disabled style. An example of this is the fill/stroke color styles,\n    which use None as hints to the auto paint style detection code.\n    \"\"\"\n\n    _PRIVATE_SLOTS = (\n        \"_allow_transparency\",\n        \"_auto_close\",\n        \"_fill_color\",\n        \"_intersection_rule\",\n        \"_paint_rule\",\n        \"_stroke_color\",\n        \"_stroke_dash_pattern\",\n        \"_stroke_dash_phase\",\n    )\n\n    __slots__ = _PRIVATE_SLOTS + tuple(\n        k.value\n        for k in PDFStyleKeys\n        # we do not store STROKE_DASH_PATTERN under its PDF key; it's in _stroke_dash_pattern\n        if k is not PDFStyleKeys.STROKE_DASH_PATTERN\n    )\n\n    INHERIT = ...\n    \"\"\"Singleton specifying a style parameter should be inherited from the parent context.\"\"\"\n\n    # order is be important here because some of these properties are entangled, e.g.\n    # fill_color and fill_opacity\n    MERGE_PROPERTIES = (\n        \"paint_rule\",\n        \"allow_transparency\",\n        \"auto_close\",\n        \"intersection_rule\",\n        \"fill_color\",\n        \"fill_opacity\",\n        \"stroke_color\",\n        \"stroke_opacity\",\n        \"blend_mode\",\n        \"stroke_width\",\n        \"stroke_cap_style\",\n        \"stroke_join_style\",\n        \"stroke_miter_limit\",\n        \"stroke_dash_pattern\",\n        \"stroke_dash_phase\",\n        \"soft_mask\",\n    )\n    \"\"\"An ordered collection of properties to use when merging two GraphicsStyles.\"\"\"\n\n    TRANSPARENCY_KEYS = (\n        PDFStyleKeys.FILL_ALPHA.value,\n        PDFStyleKeys.STROKE_ALPHA.value,\n        PDFStyleKeys.BLEND_MODE.value,\n        PDFStyleKeys.SOFT_MASK.value,\n    )\n    \"\"\"An ordered collection of attributes not to emit in no transparency mode.\"\"\"\n\n    PDF_STYLE_KEYS = (\n        *(k.value for k in PDFStyleKeys if k is not PDFStyleKeys.STROKE_DASH_PATTERN),\n    )\n    \"\"\"An ordered collection of keys to directly emit when serializing the style.\"\"\"\n\n    _PAINT_RULE_LOOKUP: dict[frozenset[str | IntersectionRule], PathPaintRule] = {\n        frozenset({}): PathPaintRule.DONT_PAINT,\n        frozenset({\"stroke\"}): PathPaintRule.STROKE,\n        frozenset({\"fill\", IntersectionRule.NONZERO}): PathPaintRule.FILL_NONZERO,\n        frozenset({\"fill\", IntersectionRule.EVENODD}): PathPaintRule.FILL_EVENODD,\n        frozenset(\n            {\"stroke\", \"fill\", IntersectionRule.NONZERO}\n        ): PathPaintRule.STROKE_FILL_NONZERO,\n        frozenset(\n            {\"stroke\", \"fill\", IntersectionRule.EVENODD}\n        ): PathPaintRule.STROKE_FILL_EVENODD,\n    }\n    \"\"\"A dictionary for resolving `PathPaintRule.AUTO`\"\"\"\n\n    @classmethod\n    def merge(cls, parent: \"GraphicsStyle\", child: \"GraphicsStyle\") -> \"GraphicsStyle\":\n        \"\"\"\n        Merge parent and child into a single GraphicsStyle.\n\n        The result contains the properties of the parent as overridden by any properties\n        explicitly set on the child. If both the parent and the child specify to\n        inherit a given property, that property will preserve the inherit value.\n        \"\"\"\n        new = deepcopy(child)\n        for prop in cls.__slots__:\n            cval = getattr(new, prop)\n            if cval is cls.INHERIT:\n                setattr(new, prop, getattr(parent, prop))\n\n        return new\n\n    def __init__(self) -> None:\n        for key in self.__slots__:\n            setattr(self, key, self.INHERIT)\n\n    def __deepcopy__(self: GS, memo: dict[int, Any]) -> GS:\n        cls = self.__class__\n        new = cls.__new__(cls)  # bypass __init__\n        # copy private slots directly\n        for s in cls._PRIVATE_SLOTS:\n            object.__setattr__(new, s, getattr(self, s, cls.INHERIT))\n        # copy PDF-exposed slots (BM, ca, CA, etc.)\n        for key in cls.PDF_STYLE_KEYS:\n            object.__setattr__(new, key, getattr(self, key, cls.INHERIT))\n        return new\n\n    def __setattr__(self, name: str, value: Any) -> None:\n        try:\n            super().__setattr__(name, value)\n        except AttributeError as e:\n            raise AttributeError(\n                f'{self.__class__} does not have style \"{name}\" (a typo?)'\n            ) from e\n\n    # at some point it probably makes sense to turn this into a general compliance\n    # property, but for now this is the simple approach.\n    @property\n    def allow_transparency(self) -> bool | InheritType:\n        allow_transparency = getattr(self, \"_allow_transparency\", self.INHERIT)\n        if allow_transparency is self.INHERIT:\n            return self.INHERIT\n        return cast(bool, allow_transparency)\n\n    @allow_transparency.setter\n    def allow_transparency(self, new: bool | InheritType) -> None:\n        return super().__setattr__(\"_allow_transparency\", new)\n\n    # If these are used in a nested graphics context inside of a painting path\n    # operation, they are no-ops. However, they can be used for outer GraphicsContexts\n    # that painting paths inherit from.\n    @property\n    def paint_rule(self) -> PathPaintRule | InheritType | None:\n        \"\"\"The paint rule to use for this path/group.\"\"\"\n        paint_rule = getattr(self, \"_paint_rule\", self.INHERIT)\n        if paint_rule is self.INHERIT or paint_rule is None:\n            return paint_rule\n        return cast(PathPaintRule, paint_rule)\n\n    @paint_rule.setter\n    def paint_rule(self, new: PathPaintRule | InheritType | str | None) -> None:\n        if new is None:\n            super().__setattr__(\"_paint_rule\", PathPaintRule.DONT_PAINT)\n        elif isinstance(new, InheritType):\n            super().__setattr__(\"_paint_rule\", new)\n        else:\n            super().__setattr__(\"_paint_rule\", PathPaintRule.coerce(new))\n\n    @property\n    def auto_close(self) -> bool | InheritType:\n        \"\"\"If True, unclosed paths will be automatically closed before stroking.\"\"\"\n        auto_close = getattr(self, \"_auto_close\", self.INHERIT)\n        if auto_close is self.INHERIT:\n            return auto_close\n        return cast(bool, auto_close)\n\n    @auto_close.setter\n    def auto_close(self, new: bool | InheritType) -> None:\n        if new not in {True, False, self.INHERIT}:\n            raise TypeError(f\"auto_close must be a bool or self.INHERIT, not {new}\")\n        super().__setattr__(\"_auto_close\", new)\n\n    @property\n    def intersection_rule(self) -> IntersectionRule | InheritType:\n        \"\"\"The desired intersection rule for this path/group.\"\"\"\n        intersection_rule = getattr(self, \"_intersection_rule\", self.INHERIT)\n        if intersection_rule is self.INHERIT:\n            return intersection_rule\n        return cast(IntersectionRule, intersection_rule)\n\n    @intersection_rule.setter\n    def intersection_rule(self, new: IntersectionRule | InheritType | str) -> None:\n        # don't allow None for this one.\n        if isinstance(new, InheritType):\n            super().__setattr__(\"_intersection_rule\", new)\n        else:\n            super().__setattr__(\"_intersection_rule\", IntersectionRule.coerce(new))\n\n    @property\n    def fill_color(self) -> Color | GradientPaint | InheritType | str | None:\n        \"\"\"\n        The desired fill color for this path/group.\n\n        When setting this property, if the color specifies an opacity value, that will\n        be used to set the fill_opacity property as well.\n        \"\"\"\n        fill_color = getattr(self, \"_fill_color\", self.INHERIT)\n        if fill_color is self.INHERIT or fill_color is None:\n            return fill_color\n        assert isinstance(\n            fill_color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)\n        )\n        return fill_color\n\n    @fill_color.setter\n    def fill_color(\n        self, color: Color | GradientPaint | str | InheritType | None\n    ) -> None:\n        if isinstance(color, str):\n            color = color_from_hex_string(color)\n\n        if isinstance(color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)):\n            super().__setattr__(\"_fill_color\", color)\n            if getattr(color, \"a\", None) is not None and not isinstance(\n                color, GradientPaint\n            ):\n                self.fill_opacity = color.a\n\n        elif (color is None) or (color is self.INHERIT):\n            super().__setattr__(\"_fill_color\", color)\n\n        else:\n            raise TypeError(f\"{color} doesn't look like a drawing color\")\n\n    @property\n    def fill_opacity(self) -> float | InheritType | None:\n        \"\"\"The desired fill opacity for this path/group.\"\"\"\n        fill_opacity = getattr(self, PDFStyleKeys.FILL_ALPHA.value, self.INHERIT)\n        if fill_opacity is self.INHERIT or fill_opacity is None:\n            return fill_opacity\n        return cast(float, fill_opacity)\n\n    @fill_opacity.setter\n    def fill_opacity(self, new: float | InheritType | None) -> None:\n        if new not in {None, self.INHERIT}:\n            assert isinstance(new, NumberClass)\n            check_range(new)\n        super().__setattr__(PDFStyleKeys.FILL_ALPHA.value, new)\n\n    @property\n    def stroke_color(self) -> Color | GradientPaint | InheritType | None:\n        \"\"\"\n        The desired stroke color for this path/group.\n\n        When setting this property, if the color specifies an opacity value, that will\n        be used to set the fill_opacity property as well.\n        \"\"\"\n        stroke_color = getattr(self, \"_stroke_color\", self.INHERIT)\n        if stroke_color is self.INHERIT or stroke_color is None:\n            return stroke_color\n        assert isinstance(\n            stroke_color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)\n        )\n        return stroke_color\n\n    @stroke_color.setter\n    def stroke_color(\n        self, color: Color | GradientPaint | str | InheritType | None\n    ) -> None:\n        if isinstance(color, str):\n            color = color_from_hex_string(color)\n\n        if isinstance(color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)):\n            super().__setattr__(\"_stroke_color\", color)\n            if getattr(color, \"a\", None) is not None and not isinstance(\n                color, GradientPaint\n            ):\n                self.stroke_opacity = color.a\n            if self.stroke_width is self.INHERIT:\n                self.stroke_width = 1\n\n        elif (color is None) or (color is self.INHERIT):\n            super().__setattr__(\"_stroke_color\", color)\n\n        else:\n            raise TypeError(f\"{color} doesn't look like a drawing color\")\n\n    @property\n    def stroke_opacity(self) -> float | InheritType | None:\n        \"\"\"The desired stroke opacity for this path/group.\"\"\"\n        stroke_opacity = getattr(self, PDFStyleKeys.STROKE_ALPHA.value, self.INHERIT)\n        if stroke_opacity is self.INHERIT or stroke_opacity is None:\n            return stroke_opacity\n        assert isinstance(stroke_opacity, NumberClass)\n        return float(stroke_opacity)\n\n    @stroke_opacity.setter\n    def stroke_opacity(self, new: float | InheritType | None) -> None:\n        if new not in (None, self.INHERIT):\n            assert isinstance(new, NumberClass)\n            check_range(new)\n        super().__setattr__(PDFStyleKeys.STROKE_ALPHA.value, new)\n\n    @property\n    def blend_mode(self) -> BlendMode | InheritType:\n        \"\"\"The desired blend mode for this path/group.\"\"\"\n        blend_mode = getattr(self, PDFStyleKeys.BLEND_MODE.value, self.INHERIT)\n        if blend_mode is self.INHERIT:\n            return blend_mode\n        return cast(BlendMode, blend_mode)\n\n    @blend_mode.setter\n    def blend_mode(self, value: BlendMode | str | InheritType) -> None:\n        if isinstance(value, InheritType):\n            super().__setattr__(PDFStyleKeys.BLEND_MODE.value, value)\n        else:\n            super().__setattr__(\n                PDFStyleKeys.BLEND_MODE.value, BlendMode.coerce(value).value\n            )\n\n    @property\n    def stroke_width(self) -> float | InheritType | None:\n        \"\"\"The desired stroke width for this path/group.\"\"\"\n        stroke_width = getattr(self, PDFStyleKeys.STROKE_WIDTH.value, self.INHERIT)\n        if stroke_width is self.INHERIT or stroke_width is None:\n            return stroke_width\n        assert isinstance(stroke_width, NumberClass)\n        return float(stroke_width)\n\n    @stroke_width.setter\n    def stroke_width(self, width: float | InheritType | None) -> None:\n        if width not in (None, self.INHERIT) and not isinstance(width, NumberClass):\n            raise TypeError(f\"stroke_width must be a number, not {type(width)}\")\n        super().__setattr__(PDFStyleKeys.STROKE_WIDTH.value, width)\n\n    @property\n    def stroke_cap_style(self) -> StrokeCapStyle | InheritType:\n        \"\"\"The desired stroke cap style for this path/group.\"\"\"\n        stroke_cap_style = getattr(\n            self, PDFStyleKeys.STROKE_CAP_STYLE.value, self.INHERIT\n        )\n        if stroke_cap_style is self.INHERIT:\n            return stroke_cap_style\n        return cast(StrokeCapStyle, stroke_cap_style)\n\n    @stroke_cap_style.setter\n    def stroke_cap_style(self, value: StrokeCapStyle | str | InheritType) -> None:\n        if isinstance(value, InheritType):\n            super().__setattr__(PDFStyleKeys.STROKE_CAP_STYLE.value, value)\n        else:\n            super().__setattr__(\n                PDFStyleKeys.STROKE_CAP_STYLE.value, StrokeCapStyle.coerce(value)\n            )\n\n    @property\n    def stroke_join_style(self) -> StrokeJoinStyle | InheritType:\n        \"\"\"The desired stroke join style for this path/group.\"\"\"\n        stroke_join_style = getattr(\n            self, PDFStyleKeys.STROKE_JOIN_STYLE.value, self.INHERIT\n        )\n        if stroke_join_style is self.INHERIT:\n            return stroke_join_style\n        return cast(StrokeJoinStyle, stroke_join_style)\n\n    @stroke_join_style.setter\n    def stroke_join_style(self, value: StrokeJoinStyle | str | InheritType) -> None:\n        if isinstance(value, InheritType):\n            super().__setattr__(PDFStyleKeys.STROKE_JOIN_STYLE.value, value)\n        else:\n            super().__setattr__(\n                PDFStyleKeys.STROKE_JOIN_STYLE.value, StrokeJoinStyle.coerce(value)\n            )\n\n    @property\n    def stroke_miter_limit(self) -> float | InheritType:\n        \"\"\"The desired stroke miter limit for this path/group.\"\"\"\n        stroke_miter_limit = getattr(\n            self, PDFStyleKeys.STROKE_MITER_LIMIT.value, self.INHERIT\n        )\n        if stroke_miter_limit is self.INHERIT:\n            return stroke_miter_limit\n        assert isinstance(stroke_miter_limit, NumberClass)\n        return float(stroke_miter_limit)\n\n    @stroke_miter_limit.setter\n    def stroke_miter_limit(self, value: Number | InheritType) -> None:\n        if (value is self.INHERIT) or isinstance(value, NumberClass):\n            super().__setattr__(PDFStyleKeys.STROKE_MITER_LIMIT.value, value)\n        else:\n            raise TypeError(f\"{value} is not a number\")\n\n    @property\n    def stroke_dash_pattern(self) -> Optional[InheritType | tuple[float, ...]]:\n        \"\"\"The desired stroke dash pattern for this path/group.\"\"\"\n        stroke_dash_pattern = getattr(self, \"_stroke_dash_pattern\", self.INHERIT)\n        if stroke_dash_pattern is self.INHERIT:\n            return stroke_dash_pattern\n        return cast(tuple[float, ...], stroke_dash_pattern)\n\n    @stroke_dash_pattern.setter\n    def stroke_dash_pattern(\n        self, value: None | InheritType | Number | Sequence[Number]\n    ) -> None:\n        result: None | InheritType | Number | Sequence[Number]\n        if value is None:\n            result = ()\n        elif isinstance(value, InheritType):\n            result = self.INHERIT\n        elif isinstance(value, NumberClass):\n            result = (float(value),)\n        elif isinstance(value, (str, bytes, bytearray)):\n            raise TypeError(\n                f\"stroke_dash_pattern {value!r} must be a number or sequence of numbers\"\n            )\n        else:\n            try:\n                accum: list[float] = []\n                for item in value:\n                    if isinstance(item, (str, bytes, bytearray)):\n                        raise TypeError\n                    accum.append(float(item))\n            except (TypeError, ValueError):\n                raise TypeError(\n                    f\"stroke_dash_pattern {value!r} must be a number or sequence of numbers\"\n                ) from None\n            result = (*accum,)\n        super().__setattr__(\"_stroke_dash_pattern\", result)\n\n    @property\n    def stroke_dash_phase(self) -> InheritType | float:\n        \"\"\"The desired stroke dash pattern phase offset for this path/group.\"\"\"\n        stroke_dash_phase = getattr(self, \"_stroke_dash_phase\", self.INHERIT)\n        if stroke_dash_phase is self.INHERIT:\n            return stroke_dash_phase\n        assert isinstance(stroke_dash_phase, NumberClass)\n        return float(stroke_dash_phase)\n\n    @stroke_dash_phase.setter\n    def stroke_dash_phase(self, value: InheritType | Number) -> None:\n        if value is self.INHERIT or isinstance(value, NumberClass):\n            return super().__setattr__(\"_stroke_dash_phase\", value)\n\n        raise TypeError(f\"{value} isn't a number or GraphicsStyle.INHERIT\")\n\n    @property\n    def soft_mask(self) -> Union[InheritType, \"PaintSoftMask\"]:\n        paint_soft_mask = getattr(self, PDFStyleKeys.SOFT_MASK.value, self.INHERIT)\n        if paint_soft_mask is self.INHERIT:\n            return paint_soft_mask\n        return cast(PaintSoftMask, paint_soft_mask)\n\n    @soft_mask.setter\n    def soft_mask(self, value: Union[InheritType, \"PaintSoftMask\"]) -> None:\n        if value is self.INHERIT or isinstance(value, PaintSoftMask):\n            return super().__setattr__(PDFStyleKeys.SOFT_MASK.value, value)\n        raise TypeError(f\"{value} isn't a PaintSoftMask or GraphicsStyle.INHERIT\")\n\n    def serialize(self) -> Optional[Raw]:\n        \"\"\"\n        Convert this style object to a PDF dictionary with appropriate style keys.\n\n        Only explicitly specified values are emitted.\n        \"\"\"\n        result: dict[Name, Any] = OrderedDict()\n\n        for key in self.PDF_STYLE_KEYS:\n            value = getattr(self, key, self.INHERIT)\n\n            if (value is not self.INHERIT) and (value is not None):\n                # None is used for out-of-band signaling on these, e.g. a stroke_width\n                # of None doesn't need to land here because it signals the\n                # PathPaintRule auto resolution only.\n                result[key] = value\n\n        # There is additional logic in GraphicsContext to ensure that this will work\n        if self.stroke_dash_pattern and self.stroke_dash_pattern is not self.INHERIT:\n            result[PDFStyleKeys.STROKE_DASH_PATTERN.value] = [\n                self.stroke_dash_pattern,\n                self.stroke_dash_phase,\n            ]\n\n        if self.allow_transparency is False:\n            for key in self.TRANSPARENCY_KEYS:\n                if key in result:\n                    del result[key]\n\n        if result:\n            # Only insert this key if there is at least one other item in the result so\n            # that we don't junk up the output PDF with empty ExtGState dictionaries.\n            type_name = Name(\"Type\")\n            result[type_name] = Name(\"ExtGState\")\n            result.move_to_end(type_name, last=False)  # type: ignore[attr-defined]\n\n            return render_pdf_primitive(result)\n\n        # this signals to the graphics state registry that there is nothing to\n        # register. This is a success case.\n        return None\n\n    @force_nodocument\n    def resolve_paint_rule(self) -> PathPaintRule:\n        \"\"\"\n        Resolve `PathPaintRule.AUTO` to a real paint rule based on this style.\n\n        Returns:\n            the resolved `PathPaintRule`.\n        \"\"\"\n        if self.paint_rule is PathPaintRule.AUTO:\n            want: set[str | IntersectionRule] = set()\n            stroke_color = self.stroke_color\n            if self.stroke_width is not None and stroke_color is not None:\n                want.add(\"stroke\")\n            fill_color = self.fill_color\n            if fill_color is not None:\n                intersection_rule = (\n                    self.intersection_rule\n                    if isinstance(self.intersection_rule, IntersectionRule)\n                    else IntersectionRule.NONZERO\n                )\n                want.add(\"fill\")\n                # we need to guarantee that this will not be None. The default will\n                # be \"nonzero\".\n                want.add(intersection_rule)\n\n            try:\n                paint_rule: PathPaintRule = self._PAINT_RULE_LOOKUP[frozenset(want)]\n            except KeyError:\n                # don't default to DONT_PAINT because that's almost certainly not a very\n                # good default.\n                paint_rule = PathPaintRule.STROKE_FILL_NONZERO\n            return paint_rule\n\n        if isinstance(self.paint_rule, InheritType) or self.paint_rule is None:\n            # this shouldn't happen under normal usage, but certain API (ab)use can end\n            # up in this state. We can't resolve anything meaningful, so fall back to a\n            # sane(?) default.\n            return PathPaintRule.STROKE_FILL_NONZERO\n\n        return self.paint_rule",
      "language": "python"
    },
    {
      "code": "class GraphicsStyle:\n    \"\"\"\n    A class representing various style attributes that determine drawing appearance.\n\n    This class uses the convention that the global Python singleton ellipsis (`...`) is\n    exclusively used to represent values that are inherited from the parent style. This\n    is to disambiguate the value None which is used for several values to signal an\n    explicitly disabled style. An example of this is the fill/stroke color styles,\n    which use None as hints to the auto paint style detection code.\n    \"\"\"\n\n    _PRIVATE_SLOTS = (\n        \"_allow_transparency\",\n        \"_auto_close\",\n        \"_fill_color\",\n        \"_intersection_rule\",\n        \"_paint_rule\",\n        \"_stroke_color\",\n        \"_stroke_dash_pattern\",\n        \"_stroke_dash_phase\",\n    )\n\n    __slots__ = _PRIVATE_SLOTS + tuple(\n        k.value\n        for k in PDFStyleKeys\n        # we do not store STROKE_DASH_PATTERN under its PDF key; it's in _stroke_dash_pattern\n        if k is not PDFStyleKeys.STROKE_DASH_PATTERN\n    )\n\n    INHERIT = ...\n    \"\"\"Singleton specifying a style parameter should be inherited from the parent context.\"\"\"\n\n    # order is be important here because some of these properties are entangled, e.g.\n    # fill_color and fill_opacity\n    MERGE_PROPERTIES = (\n        \"paint_rule\",\n        \"allow_transparency\",\n        \"auto_close\",\n        \"intersection_rule\",\n        \"fill_color\",\n        \"fill_opacity\",\n        \"stroke_color\",\n        \"stroke_opacity\",\n        \"blend_mode\",\n        \"stroke_width\",\n        \"stroke_cap_style\",\n        \"stroke_join_style\",\n        \"stroke_miter_limit\",\n        \"stroke_dash_pattern\",\n        \"stroke_dash_phase\",\n        \"soft_mask\",\n    )\n    \"\"\"An ordered collection of properties to use when merging two GraphicsStyles.\"\"\"\n\n    TRANSPARENCY_KEYS = (\n        PDFStyleKeys.FILL_ALPHA.value,\n        PDFStyleKeys.STROKE_ALPHA.value,\n        PDFStyleKeys.BLEND_MODE.value,\n        PDFStyleKeys.SOFT_MASK.value,\n    )\n    \"\"\"An ordered collection of attributes not to emit in no transparency mode.\"\"\"\n\n    PDF_STYLE_KEYS = (\n        *(k.value for k in PDFStyleKeys if k is not PDFStyleKeys.STROKE_DASH_PATTERN),\n    )\n    \"\"\"An ordered collection of keys to directly emit when serializing the style.\"\"\"\n\n    _PAINT_RULE_LOOKUP: dict[frozenset[str | IntersectionRule], PathPaintRule] = {\n        frozenset({}): PathPaintRule.DONT_PAINT,\n        frozenset({\"stroke\"}): PathPaintRule.STROKE,\n        frozenset({\"fill\", IntersectionRule.NONZERO}): PathPaintRule.FILL_NONZERO,\n        frozenset({\"fill\", IntersectionRule.EVENODD}): PathPaintRule.FILL_EVENODD,\n        frozenset(\n            {\"stroke\", \"fill\", IntersectionRule.NONZERO}\n        ): PathPaintRule.STROKE_FILL_NONZERO,\n        frozenset(\n            {\"stroke\", \"fill\", IntersectionRule.EVENODD}\n        ): PathPaintRule.STROKE_FILL_EVENODD,\n    }\n    \"\"\"A dictionary for resolving `PathPaintRule.AUTO`\"\"\"\n\n    @classmethod\n    def merge(cls, parent: \"GraphicsStyle\", child: \"GraphicsStyle\") -> \"GraphicsStyle\":\n        \"\"\"\n        Merge parent and child into a single GraphicsStyle.\n\n        The result contains the properties of the parent as overridden by any properties\n        explicitly set on the child. If both the parent and the child specify to\n        inherit a given property, that property will preserve the inherit value.\n        \"\"\"\n        new = deepcopy(child)\n        for prop in cls.__slots__:\n            cval = getattr(new, prop)\n            if cval is cls.INHERIT:\n                setattr(new, prop, getattr(parent, prop))\n\n        return new\n\n    def __init__(self) -> None:\n        for key in self.__slots__:\n            setattr(self, key, self.INHERIT)\n\n    def __deepcopy__(self: GS, memo: dict[int, Any]) -> GS:\n        cls = self.__class__\n        new = cls.__new__(cls)  # bypass __init__\n        # copy private slots directly\n        for s in cls._PRIVATE_SLOTS:\n            object.__setattr__(new, s, getattr(self, s, cls.INHERIT))\n        # copy PDF-exposed slots (BM, ca, CA, etc.)\n        for key in cls.PDF_STYLE_KEYS:\n            object.__setattr__(new, key, getattr(self, key, cls.INHERIT))\n        return new\n\n    def __setattr__(self, name: str, value: Any) -> None:\n        try:\n            super().__setattr__(name, value)\n        except AttributeError as e:\n            raise AttributeError(\n                f'{self.__class__} does not have style \"{name}\" (a typo?)'\n            ) from e\n\n    # at some point it probably makes sense to turn this into a general compliance\n    # property, but for now this is the simple approach.\n    @property\n    def allow_transparency(self) -> bool | InheritType:\n        allow_transparency = getattr(self, \"_allow_transparency\", self.INHERIT)\n        if allow_transparency is self.INHERIT:\n            return self.INHERIT\n        return cast(bool, allow_transparency)\n\n    @allow_transparency.setter\n    def allow_transparency(self, new: bool | InheritType) -> None:\n        return super().__setattr__(\"_allow_transparency\", new)\n\n    # If these are used in a nested graphics context inside of a painting path\n    # operation, they are no-ops. However, they can be used for outer GraphicsContexts\n    # that painting paths inherit from.\n    @property\n    def paint_rule(self) -> PathPaintRule | InheritType | None:\n        \"\"\"The paint rule to use for this path/group.\"\"\"\n        paint_rule = getattr(self, \"_paint_rule\", self.INHERIT)\n        if paint_rule is self.INHERIT or paint_rule is None:\n            return paint_rule\n        return cast(PathPaintRule, paint_rule)\n\n    @paint_rule.setter\n    def paint_rule(self, new: PathPaintRule | InheritType | str | None) -> None:\n        if new is None:\n            super().__setattr__(\"_paint_rule\", PathPaintRule.DONT_PAINT)\n        elif isinstance(new, InheritType):\n            super().__setattr__(\"_paint_rule\", new)\n        else:\n            super().__setattr__(\"_paint_rule\", PathPaintRule.coerce(new))\n\n    @property\n    def auto_close(self) -> bool | InheritType:\n        \"\"\"If True, unclosed paths will be automatically closed before stroking.\"\"\"\n        auto_close = getattr(self, \"_auto_close\", self.INHERIT)\n        if auto_close is self.INHERIT:\n            return auto_close\n        return cast(bool, auto_close)\n\n    @auto_close.setter\n    def auto_close(self, new: bool | InheritType) -> None:\n        if new not in {True, False, self.INHERIT}:\n            raise TypeError(f\"auto_close must be a bool or self.INHERIT, not {new}\")\n        super().__setattr__(\"_auto_close\", new)\n\n    @property\n    def intersection_rule(self) -> IntersectionRule | InheritType:\n        \"\"\"The desired intersection rule for this path/group.\"\"\"\n        intersection_rule = getattr(self, \"_intersection_rule\", self.INHERIT)\n        if intersection_rule is self.INHERIT:\n            return intersection_rule\n        return cast(IntersectionRule, intersection_rule)\n\n    @intersection_rule.setter\n    def intersection_rule(self, new: IntersectionRule | InheritType | str) -> None:\n        # don't allow None for this one.\n        if isinstance(new, InheritType):\n            super().__setattr__(\"_intersection_rule\", new)\n        else:\n            super().__setattr__(\"_intersection_rule\", IntersectionRule.coerce(new))\n\n    @property\n    def fill_color(self) -> Color | GradientPaint | InheritType | str | None:\n        \"\"\"\n        The desired fill color for this path/group.\n\n        When setting this property, if the color specifies an opacity value, that will\n        be used to set the fill_opacity property as well.\n        \"\"\"\n        fill_color = getattr(self, \"_fill_color\", self.INHERIT)\n        if fill_color is self.INHERIT or fill_color is None:\n            return fill_color\n        assert isinstance(\n            fill_color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)\n        )\n        return fill_color\n\n    @fill_color.setter\n    def fill_color(\n        self, color: Color | GradientPaint | str | InheritType | None\n    ) -> None:\n        if isinstance(color, str):\n            color = color_from_hex_string(color)\n\n        if isinstance(color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)):\n            super().__setattr__(\"_fill_color\", color)\n            if getattr(color, \"a\", None) is not None and not isinstance(\n                color, GradientPaint\n            ):\n                self.fill_opacity = color.a\n\n        elif (color is None) or (color is self.INHERIT):\n            super().__setattr__(\"_fill_color\", color)\n\n        else:\n            raise TypeError(f\"{color} doesn't look like a drawing color\")\n\n    @property\n    def fill_opacity(self) -> float | InheritType | None:\n        \"\"\"The desired fill opacity for this path/group.\"\"\"\n        fill_opacity = getattr(self, PDFStyleKeys.FILL_ALPHA.value, self.INHERIT)\n        if fill_opacity is self.INHERIT or fill_opacity is None:\n            return fill_opacity\n        return cast(float, fill_opacity)\n\n    @fill_opacity.setter\n    def fill_opacity(self, new: float | InheritType | None) -> None:\n        if new not in {None, self.INHERIT}:\n            assert isinstance(new, NumberClass)\n            check_range(new)\n        super().__setattr__(PDFStyleKeys.FILL_ALPHA.value, new)\n\n    @property\n    def stroke_color(self) -> Color | GradientPaint | InheritType | None:\n        \"\"\"\n        The desired stroke color for this path/group.\n\n        When setting this property, if the color specifies an opacity value, that will\n        be used to set the fill_opacity property as well.\n        \"\"\"\n        stroke_color = getattr(self, \"_stroke_color\", self.INHERIT)\n        if stroke_color is self.INHERIT or stroke_color is None:\n            return stroke_color\n        assert isinstance(\n            stroke_color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)\n        )\n        return stroke_color\n\n    @stroke_color.setter\n    def stroke_color(\n        self, color: Color | GradientPaint | str | InheritType | None\n    ) -> None:\n        if isinstance(color, str):\n            color = color_from_hex_string(color)\n\n        if isinstance(color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)):\n            super().__setattr__(\"_stroke_color\", color)\n            if getattr(color, \"a\", None) is not None and not isinstance(\n                color, GradientPaint\n            ):\n                self.stroke_opacity = color.a\n            if self.stroke_width is self.INHERIT:\n                self.stroke_width = 1\n\n        elif (color is None) or (color is self.INHERIT):\n            super().__setattr__(\"_stroke_color\", color)\n\n        else:\n            raise TypeError(f\"{color} doesn't look like a drawing color\")\n\n    @property\n    def stroke_opacity(self) -> float | InheritType | None:\n        \"\"\"The desired stroke opacity for this path/group.\"\"\"\n        stroke_opacity = getattr(self, PDFStyleKeys.STROKE_ALPHA.value, self.INHERIT)\n        if stroke_opacity is self.INHERIT or stroke_opacity is None:\n            return stroke_opacity\n        assert isinstance(stroke_opacity, NumberClass)\n        return float(stroke_opacity)\n\n    @stroke_opacity.setter\n    def stroke_opacity(self, new: float | InheritType | None) -> None:\n        if new not in (None, self.INHERIT):\n            assert isinstance(new, NumberClass)\n            check_range(new)\n        super().__setattr__(PDFStyleKeys.STROKE_ALPHA.value, new)\n\n    @property\n    def blend_mode(self) -> BlendMode | InheritType:\n        \"\"\"The desired blend mode for this path/group.\"\"\"\n        blend_mode = getattr(self, PDFStyleKeys.BLEND_MODE.value, self.INHERIT)\n        if blend_mode is self.INHERIT:\n            return blend_mode\n        return cast(BlendMode, blend_mode)\n\n    @blend_mode.setter\n    def blend_mode(self, value: BlendMode | str | InheritType) -> None:\n        if isinstance(value, InheritType):\n            super().__setattr__(PDFStyleKeys.BLEND_MODE.value, value)\n        else:\n            super().__setattr__(\n                PDFStyleKeys.BLEND_MODE.value, BlendMode.coerce(value).value\n            )\n\n    @property\n    def stroke_width(self) -> float | InheritType | None:\n        \"\"\"The desired stroke width for this path/group.\"\"\"\n        stroke_width = getattr(self, PDFStyleKeys.STROKE_WIDTH.value, self.INHERIT)\n        if stroke_width is self.INHERIT or stroke_width is None:\n            return stroke_width\n        assert isinstance(stroke_width, NumberClass)\n        return float(stroke_width)\n\n    @stroke_width.setter\n    def stroke_width(self, width: float | InheritType | None) -> None:\n        if width not in (None, self.INHERIT) and not isinstance(width, NumberClass):\n            raise TypeError(f\"stroke_width must be a number, not {type(width)}\")\n        super().__setattr__(PDFStyleKeys.STROKE_WIDTH.value, width)\n\n    @property\n    def stroke_cap_style(self) -> StrokeCapStyle | InheritType:\n        \"\"\"The desired stroke cap style for this path/group.\"\"\"\n        stroke_cap_style = getattr(\n            self, PDFStyleKeys.STROKE_CAP_STYLE.value, self.INHERIT\n        )\n        if stroke_cap_style is self.INHERIT:\n            return stroke_cap_style\n        return cast(StrokeCapStyle, stroke_cap_style)\n\n    @stroke_cap_style.setter\n    def stroke_cap_style(self, value: StrokeCapStyle | str | InheritType) -> None:\n        if isinstance(value, InheritType):\n            super().__setattr__(PDFStyleKeys.STROKE_CAP_STYLE.value, value)\n        else:\n            super().__setattr__(\n                PDFStyleKeys.STROKE_CAP_STYLE.value, StrokeCapStyle.coerce(value)\n            )\n\n    @property\n    def stroke_join_style(self) -> StrokeJoinStyle | InheritType:\n        \"\"\"The desired stroke join style for this path/group.\"\"\"\n        stroke_join_style = getattr(\n            self, PDFStyleKeys.STROKE_JOIN_STYLE.value, self.INHERIT\n        )\n        if stroke_join_style is self.INHERIT:\n            return stroke_join_style\n        return cast(StrokeJoinStyle, stroke_join_style)\n\n    @stroke_join_style.setter\n    def stroke_join_style(self, value: StrokeJoinStyle | str | InheritType) -> None:\n        if isinstance(value, InheritType):\n            super().__setattr__(PDFStyleKeys.STROKE_JOIN_STYLE.value, value)\n        else:\n            super().__setattr__(\n                PDFStyleKeys.STROKE_JOIN_STYLE.value, StrokeJoinStyle.coerce(value)\n            )\n\n    @property\n    def stroke_miter_limit(self) -> float | InheritType:\n        \"\"\"The desired stroke miter limit for this path/group.\"\"\"\n        stroke_miter_limit = getattr(\n            self, PDFStyleKeys.STROKE_MITER_LIMIT.value, self.INHERIT\n        )\n        if stroke_miter_limit is self.INHERIT:\n            return stroke_miter_limit\n        assert isinstance(stroke_miter_limit, NumberClass)\n        return float(stroke_miter_limit)\n\n    @stroke_miter_limit.setter\n    def stroke_miter_limit(self, value: Number | InheritType) -> None:\n        if (value is self.INHERIT) or isinstance(value, NumberClass):\n            super().__setattr__(PDFStyleKeys.STROKE_MITER_LIMIT.value, value)\n        else:\n            raise TypeError(f\"{value} is not a number\")\n\n    @property\n    def stroke_dash_pattern(self) -> Optional[InheritType | tuple[float, ...]]:\n        \"\"\"The desired stroke dash pattern for this path/group.\"\"\"\n        stroke_dash_pattern = getattr(self, \"_stroke_dash_pattern\", self.INHERIT)\n        if stroke_dash_pattern is self.INHERIT:\n            return stroke_dash_pattern\n        return cast(tuple[float, ...], stroke_dash_pattern)\n\n    @stroke_dash_pattern.setter\n    def stroke_dash_pattern(\n        self, value: None | InheritType | Number | Sequence[Number]\n    ) -> None:\n        result: None | InheritType | Number | Sequence[Number]\n        if value is None:\n            result = ()\n        elif isinstance(value, InheritType):\n            result = self.INHERIT\n        elif isinstance(value, NumberClass):\n            result = (float(value),)\n        elif isinstance(value, (str, bytes, bytearray)):\n            raise TypeError(\n                f\"stroke_dash_pattern {value!r} must be a number or sequence of numbers\"\n            )\n        else:\n            try:\n                accum: list[float] = []\n                for item in value:\n                    if isinstance(item, (str, bytes, bytearray)):\n                        raise TypeError\n                    accum.append(float(item))\n            except (TypeError, ValueError):\n                raise TypeError(\n                    f\"stroke_dash_pattern {value!r} must be a number or sequence of numbers\"\n                ) from None\n            result = (*accum,)\n        super().__setattr__(\"_stroke_dash_pattern\", result)\n\n    @property\n    def stroke_dash_phase(self) -> InheritType | float:\n        \"\"\"The desired stroke dash pattern phase offset for this path/group.\"\"\"\n        stroke_dash_phase = getattr(self, \"_stroke_dash_phase\", self.INHERIT)\n        if stroke_dash_phase is self.INHERIT:\n            return stroke_dash_phase\n        assert isinstance(stroke_dash_phase, NumberClass)\n        return float(stroke_dash_phase)\n\n    @stroke_dash_phase.setter\n    def stroke_dash_phase(self, value: InheritType | Number) -> None:\n        if value is self.INHERIT or isinstance(value, NumberClass):\n            return super().__setattr__(\"_stroke_dash_phase\", value)\n\n        raise TypeError(f\"{value} isn't a number or GraphicsStyle.INHERIT\")\n\n    @property\n    def soft_mask(self) -> Union[InheritType, \"PaintSoftMask\"]:\n        paint_soft_mask = getattr(self, PDFStyleKeys.SOFT_MASK.value, self.INHERIT)\n        if paint_soft_mask is self.INHERIT:\n            return paint_soft_mask\n        return cast(PaintSoftMask, paint_soft_mask)\n\n    @soft_mask.setter\n    def soft_mask(self, value: Union[InheritType, \"PaintSoftMask\"]) -> None:\n        if value is self.INHERIT or isinstance(value, PaintSoftMask):\n            return super().__setattr__(PDFStyleKeys.SOFT_MASK.value, value)\n        raise TypeError(f\"{value} isn't a PaintSoftMask or GraphicsStyle.INHERIT\")\n\n    def serialize(self) -> Optional[Raw]:\n        \"\"\"\n        Convert this style object to a PDF dictionary with appropriate style keys.\n\n        Only explicitly specified values are emitted.\n        \"\"\"\n        result: dict[Name, Any] = OrderedDict()\n\n        for key in self.PDF_STYLE_KEYS:\n            value = getattr(self, key, self.INHERIT)\n\n            if (value is not self.INHERIT) and (value is not None):\n                # None is used for out-of-band signaling on these, e.g. a stroke_width\n                # of None doesn't need to land here because it signals the\n                # PathPaintRule auto resolution only.\n                result[key] = value\n\n        # There is additional logic in GraphicsContext to ensure that this will work\n        if self.stroke_dash_pattern and self.stroke_dash_pattern is not self.INHERIT:\n            result[PDFStyleKeys.STROKE_DASH_PATTERN.value] = [\n                self.stroke_dash_pattern,\n                self.stroke_dash_phase,\n            ]\n\n        if self.allow_transparency is False:\n            for key in self.TRANSPARENCY_KEYS:\n                if key in result:\n                    del result[key]\n\n        if result:\n            # Only insert this key if there is at least one other item in the result so\n            # that we don't junk up the output PDF with empty ExtGState dictionaries.\n            type_name = Name(\"Type\")\n            result[type_name] = Name(\"ExtGState\")\n            result.move_to_end(type_name, last=False)  # type: ignore[attr-defined]\n\n            return render_pdf_primitive(result)\n\n        # this signals to the graphics state registry that there is nothing to\n        # register. This is a success case.\n        return None\n\n    @force_nodocument\n    def resolve_paint_rule(self) -> PathPaintRule:\n        \"\"\"\n        Resolve `PathPaintRule.AUTO` to a real paint rule based on this style.\n\n        Returns:\n            the resolved `PathPaintRule`.\n        \"\"\"\n        if self.paint_rule is PathPaintRule.AUTO:\n            want: set[str | IntersectionRule] = set()\n            stroke_color = self.stroke_color\n            if self.stroke_width is not None and stroke_color is not None:\n                want.add(\"stroke\")\n            fill_color = self.fill_color\n            if fill_color is not None:\n                intersection_rule = (\n                    self.intersection_rule\n                    if isinstance(self.intersection_rule, IntersectionRule)\n                    else IntersectionRule.NONZERO\n                )\n                want.add(\"fill\")\n                # we need to guarantee that this will not be None. The default will\n                # be \"nonzero\".\n                want.add(intersection_rule)\n\n            try:\n                paint_rule: PathPaintRule = self._PAINT_RULE_LOOKUP[frozenset(want)]\n            except KeyError:\n                # don't default to DONT_PAINT because that's almost certainly not a very\n                # good default.\n                paint_rule = PathPaintRule.STROKE_FILL_NONZERO\n            return paint_rule\n\n        if isinstance(self.paint_rule, InheritType) or self.paint_rule is None:\n            # this shouldn't happen under normal usage, but certain API (ab)use can end\n            # up in this state. We can't resolve anything meaningful, so fall back to a\n            # sane(?) default.\n            return PathPaintRule.STROKE_FILL_NONZERO\n\n        return self.paint_rule",
      "language": "python"
    },
    {
      "code": "class GraphicsStyle:\n    \"\"\"\n    A class representing various style attributes that determine drawing appearance.\n\n    This class uses the convention that the global Python singleton ellipsis (`...`) is\n    exclusively used to represent values that are inherited from the parent style. This\n    is to disambiguate the value None which is used for several values to signal an\n    explicitly disabled style. An example of this is the fill/stroke color styles,\n    which use None as hints to the auto paint style detection code.\n    \"\"\"\n\n    _PRIVATE_SLOTS = (\n        \"_allow_transparency\",\n        \"_auto_close\",\n        \"_fill_color\",\n        \"_intersection_rule\",\n        \"_paint_rule\",\n        \"_stroke_color\",\n        \"_stroke_dash_pattern\",\n        \"_stroke_dash_phase\",\n    )\n\n    __slots__ = _PRIVATE_SLOTS + tuple(\n        k.value\n        for k in PDFStyleKeys\n        # we do not store STROKE_DASH_PATTERN under its PDF key; it's in _stroke_dash_pattern\n        if k is not PDFStyleKeys.STROKE_DASH_PATTERN\n    )\n\n    INHERIT = ...\n    \"\"\"Singleton specifying a style parameter should be inherited from the parent context.\"\"\"\n\n    # order is be important here because some of these properties are entangled, e.g.\n    # fill_color and fill_opacity\n    MERGE_PROPERTIES = (\n        \"paint_rule\",\n        \"allow_transparency\",\n        \"auto_close\",\n        \"intersection_rule\",\n        \"fill_color\",\n        \"fill_opacity\",\n        \"stroke_color\",\n        \"stroke_opacity\",\n        \"blend_mode\",\n        \"stroke_width\",\n        \"stroke_cap_style\",\n        \"stroke_join_style\",\n        \"stroke_miter_limit\",\n        \"stroke_dash_pattern\",\n        \"stroke_dash_phase\",\n        \"soft_mask\",\n    )\n    \"\"\"An ordered collection of properties to use when merging two GraphicsStyles.\"\"\"\n\n    TRANSPARENCY_KEYS = (\n        PDFStyleKeys.FILL_ALPHA.value,\n        PDFStyleKeys.STROKE_ALPHA.value,\n        PDFStyleKeys.BLEND_MODE.value,\n        PDFStyleKeys.SOFT_MASK.value,\n    )\n    \"\"\"An ordered collection of attributes not to emit in no transparency mode.\"\"\"\n\n    PDF_STYLE_KEYS = (\n        *(k.value for k in PDFStyleKeys if k is not PDFStyleKeys.STROKE_DASH_PATTERN),\n    )\n    \"\"\"An ordered collection of keys to directly emit when serializing the style.\"\"\"\n\n    _PAINT_RULE_LOOKUP: dict[frozenset[str | IntersectionRule], PathPaintRule] = {\n        frozenset({}): PathPaintRule.DONT_PAINT,\n        frozenset({\"stroke\"}): PathPaintRule.STROKE,\n        frozenset({\"fill\", IntersectionRule.NONZERO}): PathPaintRule.FILL_NONZERO,\n        frozenset({\"fill\", IntersectionRule.EVENODD}): PathPaintRule.FILL_EVENODD,\n        frozenset(\n            {\"stroke\", \"fill\", IntersectionRule.NONZERO}\n        ): PathPaintRule.STROKE_FILL_NONZERO,\n        frozenset(\n            {\"stroke\", \"fill\", IntersectionRule.EVENODD}\n        ): PathPaintRule.STROKE_FILL_EVENODD,\n    }\n    \"\"\"A dictionary for resolving `PathPaintRule.AUTO`\"\"\"\n\n    @classmethod\n    def merge(cls, parent: \"GraphicsStyle\", child: \"GraphicsStyle\") -> \"GraphicsStyle\":\n        \"\"\"\n        Merge parent and child into a single GraphicsStyle.\n\n        The result contains the properties of the parent as overridden by any properties\n        explicitly set on the child. If both the parent and the child specify to\n        inherit a given property, that property will preserve the inherit value.\n        \"\"\"\n        new = deepcopy(child)\n        for prop in cls.__slots__:\n            cval = getattr(new, prop)\n            if cval is cls.INHERIT:\n                setattr(new, prop, getattr(parent, prop))\n\n        return new\n\n    def __init__(self) -> None:\n        for key in self.__slots__:\n            setattr(self, key, self.INHERIT)\n\n    def __deepcopy__(self: GS, memo: dict[int, Any]) -> GS:\n        cls = self.__class__\n        new = cls.__new__(cls)  # bypass __init__\n        # copy private slots directly\n        for s in cls._PRIVATE_SLOTS:\n            object.__setattr__(new, s, getattr(self, s, cls.INHERIT))\n        # copy PDF-exposed slots (BM, ca, CA, etc.)\n        for key in cls.PDF_STYLE_KEYS:\n            object.__setattr__(new, key, getattr(self, key, cls.INHERIT))\n        return new\n\n    def __setattr__(self, name: str, value: Any) -> None:\n        try:\n            super().__setattr__(name, value)\n        except AttributeError as e:\n            raise AttributeError(\n                f'{self.__class__} does not have style \"{name}\" (a typo?)'\n            ) from e\n\n    # at some point it probably makes sense to turn this into a general compliance\n    # property, but for now this is the simple approach.\n    @property\n    def allow_transparency(self) -> bool | InheritType:\n        allow_transparency = getattr(self, \"_allow_transparency\", self.INHERIT)\n        if allow_transparency is self.INHERIT:\n            return self.INHERIT\n        return cast(bool, allow_transparency)\n\n    @allow_transparency.setter\n    def allow_transparency(self, new: bool | InheritType) -> None:\n        return super().__setattr__(\"_allow_transparency\", new)\n\n    # If these are used in a nested graphics context inside of a painting path\n    # operation, they are no-ops. However, they can be used for outer GraphicsContexts\n    # that painting paths inherit from.\n    @property\n    def paint_rule(self) -> PathPaintRule | InheritType | None:\n        \"\"\"The paint rule to use for this path/group.\"\"\"\n        paint_rule = getattr(self, \"_paint_rule\", self.INHERIT)\n        if paint_rule is self.INHERIT or paint_rule is None:\n            return paint_rule\n        return cast(PathPaintRule, paint_rule)\n\n    @paint_rule.setter\n    def paint_rule(self, new: PathPaintRule | InheritType | str | None) -> None:\n        if new is None:\n            super().__setattr__(\"_paint_rule\", PathPaintRule.DONT_PAINT)\n        elif isinstance(new, InheritType):\n            super().__setattr__(\"_paint_rule\", new)\n        else:\n            super().__setattr__(\"_paint_rule\", PathPaintRule.coerce(new))\n\n    @property\n    def auto_close(self) -> bool | InheritType:\n        \"\"\"If True, unclosed paths will be automatically closed before stroking.\"\"\"\n        auto_close = getattr(self, \"_auto_close\", self.INHERIT)\n        if auto_close is self.INHERIT:\n            return auto_close\n        return cast(bool, auto_close)\n\n    @auto_close.setter\n    def auto_close(self, new: bool | InheritType) -> None:\n        if new not in {True, False, self.INHERIT}:\n            raise TypeError(f\"auto_close must be a bool or self.INHERIT, not {new}\")\n        super().__setattr__(\"_auto_close\", new)\n\n    @property\n    def intersection_rule(self) -> IntersectionRule | InheritType:\n        \"\"\"The desired intersection rule for this path/group.\"\"\"\n        intersection_rule = getattr(self, \"_intersection_rule\", self.INHERIT)\n        if intersection_rule is self.INHERIT:\n            return intersection_rule\n        return cast(IntersectionRule, intersection_rule)\n\n    @intersection_rule.setter\n    def intersection_rule(self, new: IntersectionRule | InheritType | str) -> None:\n        # don't allow None for this one.\n        if isinstance(new, InheritType):\n            super().__setattr__(\"_intersection_rule\", new)\n        else:\n            super().__setattr__(\"_intersection_rule\", IntersectionRule.coerce(new))\n\n    @property\n    def fill_color(self) -> Color | GradientPaint | InheritType | str | None:\n        \"\"\"\n        The desired fill color for this path/group.\n\n        When setting this property, if the color specifies an opacity value, that will\n        be used to set the fill_opacity property as well.\n        \"\"\"\n        fill_color = getattr(self, \"_fill_color\", self.INHERIT)\n        if fill_color is self.INHERIT or fill_color is None:\n            return fill_color\n        assert isinstance(\n            fill_color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)\n        )\n        return fill_color\n\n    @fill_color.setter\n    def fill_color(\n        self, color: Color | GradientPaint | str | InheritType | None\n    ) -> None:\n        if isinstance(color, str):\n            color = color_from_hex_string(color)\n\n        if isinstance(color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)):\n            super().__setattr__(\"_fill_color\", color)\n            if getattr(color, \"a\", None) is not None and not isinstance(\n                color, GradientPaint\n            ):\n                self.fill_opacity = color.a\n\n        elif (color is None) or (color is self.INHERIT):\n            super().__setattr__(\"_fill_color\", color)\n\n        else:\n            raise TypeError(f\"{color} doesn't look like a drawing color\")\n\n    @property\n    def fill_opacity(self) -> float | InheritType | None:\n        \"\"\"The desired fill opacity for this path/group.\"\"\"\n        fill_opacity = getattr(self, PDFStyleKeys.FILL_ALPHA.value, self.INHERIT)\n        if fill_opacity is self.INHERIT or fill_opacity is None:\n            return fill_opacity\n        return cast(float, fill_opacity)\n\n    @fill_opacity.setter\n    def fill_opacity(self, new: float | InheritType | None) -> None:\n        if new not in {None, self.INHERIT}:\n            assert isinstance(new, NumberClass)\n            check_range(new)\n        super().__setattr__(PDFStyleKeys.FILL_ALPHA.value, new)\n\n    @property\n    def stroke_color(self) -> Color | GradientPaint | InheritType | None:\n        \"\"\"\n        The desired stroke color for this path/group.\n\n        When setting this property, if the color specifies an opacity value, that will\n        be used to set the fill_opacity property as well.\n        \"\"\"\n        stroke_color = getattr(self, \"_stroke_color\", self.INHERIT)\n        if stroke_color is self.INHERIT or stroke_color is None:\n            return stroke_color\n        assert isinstance(\n            stroke_color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)\n        )\n        return stroke_color\n\n    @stroke_color.setter\n    def stroke_color(\n        self, color: Color | GradientPaint | str | InheritType | None\n    ) -> None:\n        if isinstance(color, str):\n            color = color_from_hex_string(color)\n\n        if isinstance(color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)):\n            super().__setattr__(\"_stroke_color\", color)\n            if getattr(color, \"a\", None) is not None and not isinstance(\n                color, GradientPaint\n            ):\n                self.stroke_opacity = color.a\n            if self.stroke_width is self.INHERIT:\n                self.stroke_width = 1\n\n        elif (color is None) or (color is self.INHERIT):\n            super().__setattr__(\"_stroke_color\", color)\n\n        else:\n            raise TypeError(f\"{color} doesn't look like a drawing color\")\n\n    @property\n    def stroke_opacity(self) -> float | InheritType | None:\n        \"\"\"The desired stroke opacity for this path/group.\"\"\"\n        stroke_opacity = getattr(self, PDFStyleKeys.STROKE_ALPHA.value, self.INHERIT)\n        if stroke_opacity is self.INHERIT or stroke_opacity is None:\n            return stroke_opacity\n        assert isinstance(stroke_opacity, NumberClass)\n        return float(stroke_opacity)\n\n    @stroke_opacity.setter\n    def stroke_opacity(self, new: float | InheritType | None) -> None:\n        if new not in (None, self.INHERIT):\n            assert isinstance(new, NumberClass)\n            check_range(new)\n        super().__setattr__(PDFStyleKeys.STROKE_ALPHA.value, new)\n\n    @property\n    def blend_mode(self) -> BlendMode | InheritType:\n        \"\"\"The desired blend mode for this path/group.\"\"\"\n        blend_mode = getattr(self, PDFStyleKeys.BLEND_MODE.value, self.INHERIT)\n        if blend_mode is self.INHERIT:\n            return blend_mode\n        return cast(BlendMode, blend_mode)\n\n    @blend_mode.setter\n    def blend_mode(self, value: BlendMode | str | InheritType) -> None:\n        if isinstance(value, InheritType):\n            super().__setattr__(PDFStyleKeys.BLEND_MODE.value, value)\n        else:\n            super().__setattr__(\n                PDFStyleKeys.BLEND_MODE.value, BlendMode.coerce(value).value\n            )\n\n    @property\n    def stroke_width(self) -> float | InheritType | None:\n        \"\"\"The desired stroke width for this path/group.\"\"\"\n        stroke_width = getattr(self, PDFStyleKeys.STROKE_WIDTH.value, self.INHERIT)\n        if stroke_width is self.INHERIT or stroke_width is None:\n            return stroke_width\n        assert isinstance(stroke_width, NumberClass)\n        return float(stroke_width)\n\n    @stroke_width.setter\n    def stroke_width(self, width: float | InheritType | None) -> None:\n        if width not in (None, self.INHERIT) and not isinstance(width, NumberClass):\n            raise TypeError(f\"stroke_width must be a number, not {type(width)}\")\n        super().__setattr__(PDFStyleKeys.STROKE_WIDTH.value, width)\n\n    @property\n    def stroke_cap_style(self) -> StrokeCapStyle | InheritType:\n        \"\"\"The desired stroke cap style for this path/group.\"\"\"\n        stroke_cap_style = getattr(\n            self, PDFStyleKeys.STROKE_CAP_STYLE.value, self.INHERIT\n        )\n        if stroke_cap_style is self.INHERIT:\n            return stroke_cap_style\n        return cast(StrokeCapStyle, stroke_cap_style)\n\n    @stroke_cap_style.setter\n    def stroke_cap_style(self, value: StrokeCapStyle | str | InheritType) -> None:\n        if isinstance(value, InheritType):\n            super().__setattr__(PDFStyleKeys.STROKE_CAP_STYLE.value, value)\n        else:\n            super().__setattr__(\n                PDFStyleKeys.STROKE_CAP_STYLE.value, StrokeCapStyle.coerce(value)\n            )\n\n    @property\n    def stroke_join_style(self) -> StrokeJoinStyle | InheritType:\n        \"\"\"The desired stroke join style for this path/group.\"\"\"\n        stroke_join_style = getattr(\n            self, PDFStyleKeys.STROKE_JOIN_STYLE.value, self.INHERIT\n        )\n        if stroke_join_style is self.INHERIT:\n            return stroke_join_style\n        return cast(StrokeJoinStyle, stroke_join_style)\n\n    @stroke_join_style.setter\n    def stroke_join_style(self, value: StrokeJoinStyle | str | InheritType) -> None:\n        if isinstance(value, InheritType):\n            super().__setattr__(PDFStyleKeys.STROKE_JOIN_STYLE.value, value)\n        else:\n            super().__setattr__(\n                PDFStyleKeys.STROKE_JOIN_STYLE.value, StrokeJoinStyle.coerce(value)\n            )\n\n    @property\n    def stroke_miter_limit(self) -> float | InheritType:\n        \"\"\"The desired stroke miter limit for this path/group.\"\"\"\n        stroke_miter_limit = getattr(\n            self, PDFStyleKeys.STROKE_MITER_LIMIT.value, self.INHERIT\n        )\n        if stroke_miter_limit is self.INHERIT:\n            return stroke_miter_limit\n        assert isinstance(stroke_miter_limit, NumberClass)\n        return float(stroke_miter_limit)\n\n    @stroke_miter_limit.setter\n    def stroke_miter_limit(self, value: Number | InheritType) -> None:\n        if (value is self.INHERIT) or isinstance(value, NumberClass):\n            super().__setattr__(PDFStyleKeys.STROKE_MITER_LIMIT.value, value)\n        else:\n            raise TypeError(f\"{value} is not a number\")\n\n    @property\n    def stroke_dash_pattern(self) -> Optional[InheritType | tuple[float, ...]]:\n        \"\"\"The desired stroke dash pattern for this path/group.\"\"\"\n        stroke_dash_pattern = getattr(self, \"_stroke_dash_pattern\", self.INHERIT)\n        if stroke_dash_pattern is self.INHERIT:\n            return stroke_dash_pattern\n        return cast(tuple[float, ...], stroke_dash_pattern)\n\n    @stroke_dash_pattern.setter\n    def stroke_dash_pattern(\n        self, value: None | InheritType | Number | Sequence[Number]\n    ) -> None:\n        result: None | InheritType | Number | Sequence[Number]\n        if value is None:\n            result = ()\n        elif isinstance(value, InheritType):\n            result = self.INHERIT\n        elif isinstance(value, NumberClass):\n            result = (float(value),)\n        elif isinstance(value, (str, bytes, bytearray)):\n            raise TypeError(\n                f\"stroke_dash_pattern {value!r} must be a number or sequence of numbers\"\n            )\n        else:\n            try:\n                accum: list[float] = []\n                for item in value:\n                    if isinstance(item, (str, bytes, bytearray)):\n                        raise TypeError\n                    accum.append(float(item))\n            except (TypeError, ValueError):\n                raise TypeError(\n                    f\"stroke_dash_pattern {value!r} must be a number or sequence of numbers\"\n                ) from None\n            result = (*accum,)\n        super().__setattr__(\"_stroke_dash_pattern\", result)\n\n    @property\n    def stroke_dash_phase(self) -> InheritType | float:\n        \"\"\"The desired stroke dash pattern phase offset for this path/group.\"\"\"\n        stroke_dash_phase = getattr(self, \"_stroke_dash_phase\", self.INHERIT)\n        if stroke_dash_phase is self.INHERIT:\n            return stroke_dash_phase\n        assert isinstance(stroke_dash_phase, NumberClass)\n        return float(stroke_dash_phase)\n\n    @stroke_dash_phase.setter\n    def stroke_dash_phase(self, value: InheritType | Number) -> None:\n        if value is self.INHERIT or isinstance(value, NumberClass):\n            return super().__setattr__(\"_stroke_dash_phase\", value)\n\n        raise TypeError(f\"{value} isn't a number or GraphicsStyle.INHERIT\")\n\n    @property\n    def soft_mask(self) -> Union[InheritType, \"PaintSoftMask\"]:\n        paint_soft_mask = getattr(self, PDFStyleKeys.SOFT_MASK.value, self.INHERIT)\n        if paint_soft_mask is self.INHERIT:\n            return paint_soft_mask\n        return cast(PaintSoftMask, paint_soft_mask)\n\n    @soft_mask.setter\n    def soft_mask(self, value: Union[InheritType, \"PaintSoftMask\"]) -> None:\n        if value is self.INHERIT or isinstance(value, PaintSoftMask):\n            return super().__setattr__(PDFStyleKeys.SOFT_MASK.value, value)\n        raise TypeError(f\"{value} isn't a PaintSoftMask or GraphicsStyle.INHERIT\")\n\n    def serialize(self) -> Optional[Raw]:\n        \"\"\"\n        Convert this style object to a PDF dictionary with appropriate style keys.\n\n        Only explicitly specified values are emitted.\n        \"\"\"\n        result: dict[Name, Any] = OrderedDict()\n\n        for key in self.PDF_STYLE_KEYS:\n            value = getattr(self, key, self.INHERIT)\n\n            if (value is not self.INHERIT) and (value is not None):\n                # None is used for out-of-band signaling on these, e.g. a stroke_width\n                # of None doesn't need to land here because it signals the\n                # PathPaintRule auto resolution only.\n                result[key] = value\n\n        # There is additional logic in GraphicsContext to ensure that this will work\n        if self.stroke_dash_pattern and self.stroke_dash_pattern is not self.INHERIT:\n            result[PDFStyleKeys.STROKE_DASH_PATTERN.value] = [\n                self.stroke_dash_pattern,\n                self.stroke_dash_phase,\n            ]\n\n        if self.allow_transparency is False:\n            for key in self.TRANSPARENCY_KEYS:\n                if key in result:\n                    del result[key]\n\n        if result:\n            # Only insert this key if there is at least one other item in the result so\n            # that we don't junk up the output PDF with empty ExtGState dictionaries.\n            type_name = Name(\"Type\")\n            result[type_name] = Name(\"ExtGState\")\n            result.move_to_end(type_name, last=False)  # type: ignore[attr-defined]\n\n            return render_pdf_primitive(result)\n\n        # this signals to the graphics state registry that there is nothing to\n        # register. This is a success case.\n        return None\n\n    @force_nodocument\n    def resolve_paint_rule(self) -> PathPaintRule:\n        \"\"\"\n        Resolve `PathPaintRule.AUTO` to a real paint rule based on this style.\n\n        Returns:\n            the resolved `PathPaintRule`.\n        \"\"\"\n        if self.paint_rule is PathPaintRule.AUTO:\n            want: set[str | IntersectionRule] = set()\n            stroke_color = self.stroke_color\n            if self.stroke_width is not None and stroke_color is not None:\n                want.add(\"stroke\")\n            fill_color = self.fill_color\n            if fill_color is not None:\n                intersection_rule = (\n                    self.intersection_rule\n                    if isinstance(self.intersection_rule, IntersectionRule)\n                    else IntersectionRule.NONZERO\n                )\n                want.add(\"fill\")\n                # we need to guarantee that this will not be None. The default will\n                # be \"nonzero\".\n                want.add(intersection_rule)\n\n            try:\n                paint_rule: PathPaintRule = self._PAINT_RULE_LOOKUP[frozenset(want)]\n            except KeyError:\n                # don't default to DONT_PAINT because that's almost certainly not a very\n                # good default.\n                paint_rule = PathPaintRule.STROKE_FILL_NONZERO\n            return paint_rule\n\n        if isinstance(self.paint_rule, InheritType) or self.paint_rule is None:\n            # this shouldn't happen under normal usage, but certain API (ab)use can end\n            # up in this state. We can't resolve anything meaningful, so fall back to a\n            # sane(?) default.\n            return PathPaintRule.STROKE_FILL_NONZERO\n\n        return self.paint_rule",
      "language": "python"
    },
    {
      "code": "class GraphicsStyle:\n    \"\"\"\n    A class representing various style attributes that determine drawing appearance.\n\n    This class uses the convention that the global Python singleton ellipsis (`...`) is\n    exclusively used to represent values that are inherited from the parent style. This\n    is to disambiguate the value None which is used for several values to signal an\n    explicitly disabled style. An example of this is the fill/stroke color styles,\n    which use None as hints to the auto paint style detection code.\n    \"\"\"\n\n    _PRIVATE_SLOTS = (\n        \"_allow_transparency\",\n        \"_auto_close\",\n        \"_fill_color\",\n        \"_intersection_rule\",\n        \"_paint_rule\",\n        \"_stroke_color\",\n        \"_stroke_dash_pattern\",\n        \"_stroke_dash_phase\",\n    )\n\n    __slots__ = _PRIVATE_SLOTS + tuple(\n        k.value\n        for k in PDFStyleKeys\n        # we do not store STROKE_DASH_PATTERN under its PDF key; it's in _stroke_dash_pattern\n        if k is not PDFStyleKeys.STROKE_DASH_PATTERN\n    )\n\n    INHERIT = ...\n    \"\"\"Singleton specifying a style parameter should be inherited from the parent context.\"\"\"\n\n    # order is be important here because some of these properties are entangled, e.g.\n    # fill_color and fill_opacity\n    MERGE_PROPERTIES = (\n        \"paint_rule\",\n        \"allow_transparency\",\n        \"auto_close\",\n        \"intersection_rule\",\n        \"fill_color\",\n        \"fill_opacity\",\n        \"stroke_color\",\n        \"stroke_opacity\",\n        \"blend_mode\",\n        \"stroke_width\",\n        \"stroke_cap_style\",\n        \"stroke_join_style\",\n        \"stroke_miter_limit\",\n        \"stroke_dash_pattern\",\n        \"stroke_dash_phase\",\n        \"soft_mask\",\n    )\n    \"\"\"An ordered collection of properties to use when merging two GraphicsStyles.\"\"\"\n\n    TRANSPARENCY_KEYS = (\n        PDFStyleKeys.FILL_ALPHA.value,\n        PDFStyleKeys.STROKE_ALPHA.value,\n        PDFStyleKeys.BLEND_MODE.value,\n        PDFStyleKeys.SOFT_MASK.value,\n    )\n    \"\"\"An ordered collection of attributes not to emit in no transparency mode.\"\"\"\n\n    PDF_STYLE_KEYS = (\n        *(k.value for k in PDFStyleKeys if k is not PDFStyleKeys.STROKE_DASH_PATTERN),\n    )\n    \"\"\"An ordered collection of keys to directly emit when serializing the style.\"\"\"\n\n    _PAINT_RULE_LOOKUP: dict[frozenset[str | IntersectionRule], PathPaintRule] = {\n        frozenset({}): PathPaintRule.DONT_PAINT,\n        frozenset({\"stroke\"}): PathPaintRule.STROKE,\n        frozenset({\"fill\", IntersectionRule.NONZERO}): PathPaintRule.FILL_NONZERO,\n        frozenset({\"fill\", IntersectionRule.EVENODD}): PathPaintRule.FILL_EVENODD,\n        frozenset(\n            {\"stroke\", \"fill\", IntersectionRule.NONZERO}\n        ): PathPaintRule.STROKE_FILL_NONZERO,\n        frozenset(\n            {\"stroke\", \"fill\", IntersectionRule.EVENODD}\n        ): PathPaintRule.STROKE_FILL_EVENODD,\n    }\n    \"\"\"A dictionary for resolving `PathPaintRule.AUTO`\"\"\"\n\n    @classmethod\n    def merge(cls, parent: \"GraphicsStyle\", child: \"GraphicsStyle\") -> \"GraphicsStyle\":\n        \"\"\"\n        Merge parent and child into a single GraphicsStyle.\n\n        The result contains the properties of the parent as overridden by any properties\n        explicitly set on the child. If both the parent and the child specify to\n        inherit a given property, that property will preserve the inherit value.\n        \"\"\"\n        new = deepcopy(child)\n        for prop in cls.__slots__:\n            cval = getattr(new, prop)\n            if cval is cls.INHERIT:\n                setattr(new, prop, getattr(parent, prop))\n\n        return new\n\n    def __init__(self) -> None:\n        for key in self.__slots__:\n            setattr(self, key, self.INHERIT)\n\n    def __deepcopy__(self: GS, memo: dict[int, Any]) -> GS:\n        cls = self.__class__\n        new = cls.__new__(cls)  # bypass __init__\n        # copy private slots directly\n        for s in cls._PRIVATE_SLOTS:\n            object.__setattr__(new, s, getattr(self, s, cls.INHERIT))\n        # copy PDF-exposed slots (BM, ca, CA, etc.)\n        for key in cls.PDF_STYLE_KEYS:\n            object.__setattr__(new, key, getattr(self, key, cls.INHERIT))\n        return new\n\n    def __setattr__(self, name: str, value: Any) -> None:\n        try:\n            super().__setattr__(name, value)\n        except AttributeError as e:\n            raise AttributeError(\n                f'{self.__class__} does not have style \"{name}\" (a typo?)'\n            ) from e\n\n    # at some point it probably makes sense to turn this into a general compliance\n    # property, but for now this is the simple approach.\n    @property\n    def allow_transparency(self) -> bool | InheritType:\n        allow_transparency = getattr(self, \"_allow_transparency\", self.INHERIT)\n        if allow_transparency is self.INHERIT:\n            return self.INHERIT\n        return cast(bool, allow_transparency)\n\n    @allow_transparency.setter\n    def allow_transparency(self, new: bool | InheritType) -> None:\n        return super().__setattr__(\"_allow_transparency\", new)\n\n    # If these are used in a nested graphics context inside of a painting path\n    # operation, they are no-ops. However, they can be used for outer GraphicsContexts\n    # that painting paths inherit from.\n    @property\n    def paint_rule(self) -> PathPaintRule | InheritType | None:\n        \"\"\"The paint rule to use for this path/group.\"\"\"\n        paint_rule = getattr(self, \"_paint_rule\", self.INHERIT)\n        if paint_rule is self.INHERIT or paint_rule is None:\n            return paint_rule\n        return cast(PathPaintRule, paint_rule)\n\n    @paint_rule.setter\n    def paint_rule(self, new: PathPaintRule | InheritType | str | None) -> None:\n        if new is None:\n            super().__setattr__(\"_paint_rule\", PathPaintRule.DONT_PAINT)\n        elif isinstance(new, InheritType):\n            super().__setattr__(\"_paint_rule\", new)\n        else:\n            super().__setattr__(\"_paint_rule\", PathPaintRule.coerce(new))\n\n    @property\n    def auto_close(self) -> bool | InheritType:\n        \"\"\"If True, unclosed paths will be automatically closed before stroking.\"\"\"\n        auto_close = getattr(self, \"_auto_close\", self.INHERIT)\n        if auto_close is self.INHERIT:\n            return auto_close\n        return cast(bool, auto_close)\n\n    @auto_close.setter\n    def auto_close(self, new: bool | InheritType) -> None:\n        if new not in {True, False, self.INHERIT}:\n            raise TypeError(f\"auto_close must be a bool or self.INHERIT, not {new}\")\n        super().__setattr__(\"_auto_close\", new)\n\n    @property\n    def intersection_rule(self) -> IntersectionRule | InheritType:\n        \"\"\"The desired intersection rule for this path/group.\"\"\"\n        intersection_rule = getattr(self, \"_intersection_rule\", self.INHERIT)\n        if intersection_rule is self.INHERIT:\n            return intersection_rule\n        return cast(IntersectionRule, intersection_rule)\n\n    @intersection_rule.setter\n    def intersection_rule(self, new: IntersectionRule | InheritType | str) -> None:\n        # don't allow None for this one.\n        if isinstance(new, InheritType):\n            super().__setattr__(\"_intersection_rule\", new)\n        else:\n            super().__setattr__(\"_intersection_rule\", IntersectionRule.coerce(new))\n\n    @property\n    def fill_color(self) -> Color | GradientPaint | InheritType | str | None:\n        \"\"\"\n        The desired fill color for this path/group.\n\n        When setting this property, if the color specifies an opacity value, that will\n        be used to set the fill_opacity property as well.\n        \"\"\"\n        fill_color = getattr(self, \"_fill_color\", self.INHERIT)\n        if fill_color is self.INHERIT or fill_color is None:\n            return fill_color\n        assert isinstance(\n            fill_color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)\n        )\n        return fill_color\n\n    @fill_color.setter\n    def fill_color(\n        self, color: Color | GradientPaint | str | InheritType | None\n    ) -> None:\n        if isinstance(color, str):\n            color = color_from_hex_string(color)\n\n        if isinstance(color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)):\n            super().__setattr__(\"_fill_color\", color)\n            if getattr(color, \"a\", None) is not None and not isinstance(\n                color, GradientPaint\n            ):\n                self.fill_opacity = color.a\n\n        elif (color is None) or (color is self.INHERIT):\n            super().__setattr__(\"_fill_color\", color)\n\n        else:\n            raise TypeError(f\"{color} doesn't look like a drawing color\")\n\n    @property\n    def fill_opacity(self) -> float | InheritType | None:\n        \"\"\"The desired fill opacity for this path/group.\"\"\"\n        fill_opacity = getattr(self, PDFStyleKeys.FILL_ALPHA.value, self.INHERIT)\n        if fill_opacity is self.INHERIT or fill_opacity is None:\n            return fill_opacity\n        return cast(float, fill_opacity)\n\n    @fill_opacity.setter\n    def fill_opacity(self, new: float | InheritType | None) -> None:\n        if new not in {None, self.INHERIT}:\n            assert isinstance(new, NumberClass)\n            check_range(new)\n        super().__setattr__(PDFStyleKeys.FILL_ALPHA.value, new)\n\n    @property\n    def stroke_color(self) -> Color | GradientPaint | InheritType | None:\n        \"\"\"\n        The desired stroke color for this path/group.\n\n        When setting this property, if the color specifies an opacity value, that will\n        be used to set the fill_opacity property as well.\n        \"\"\"\n        stroke_color = getattr(self, \"_stroke_color\", self.INHERIT)\n        if stroke_color is self.INHERIT or stroke_color is None:\n            return stroke_color\n        assert isinstance(\n            stroke_color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)\n        )\n        return stroke_color\n\n    @stroke_color.setter\n    def stroke_color(\n        self, color: Color | GradientPaint | str | InheritType | None\n    ) -> None:\n        if isinstance(color, str):\n            color = color_from_hex_string(color)\n\n        if isinstance(color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)):\n            super().__setattr__(\"_stroke_color\", color)\n            if getattr(color, \"a\", None) is not None and not isinstance(\n                color, GradientPaint\n            ):\n                self.stroke_opacity = color.a\n            if self.stroke_width is self.INHERIT:\n                self.stroke_width = 1\n\n        elif (color is None) or (color is self.INHERIT):\n            super().__setattr__(\"_stroke_color\", color)\n\n        else:\n            raise TypeError(f\"{color} doesn't look like a drawing color\")\n\n    @property\n    def stroke_opacity(self) -> float | InheritType | None:\n        \"\"\"The desired stroke opacity for this path/group.\"\"\"\n        stroke_opacity = getattr(self, PDFStyleKeys.STROKE_ALPHA.value, self.INHERIT)\n        if stroke_opacity is self.INHERIT or stroke_opacity is None:\n            return stroke_opacity\n        assert isinstance(stroke_opacity, NumberClass)\n        return float(stroke_opacity)\n\n    @stroke_opacity.setter\n    def stroke_opacity(self, new: float | InheritType | None) -> None:\n        if new not in (None, self.INHERIT):\n            assert isinstance(new, NumberClass)\n            check_range(new)\n        super().__setattr__(PDFStyleKeys.STROKE_ALPHA.value, new)\n\n    @property\n    def blend_mode(self) -> BlendMode | InheritType:\n        \"\"\"The desired blend mode for this path/group.\"\"\"\n        blend_mode = getattr(self, PDFStyleKeys.BLEND_MODE.value, self.INHERIT)\n        if blend_mode is self.INHERIT:\n            return blend_mode\n        return cast(BlendMode, blend_mode)\n\n    @blend_mode.setter\n    def blend_mode(self, value: BlendMode | str | InheritType) -> None:\n        if isinstance(value, InheritType):\n            super().__setattr__(PDFStyleKeys.BLEND_MODE.value, value)\n        else:\n            super().__setattr__(\n                PDFStyleKeys.BLEND_MODE.value, BlendMode.coerce(value).value\n            )\n\n    @property\n    def stroke_width(self) -> float | InheritType | None:\n        \"\"\"The desired stroke width for this path/group.\"\"\"\n        stroke_width = getattr(self, PDFStyleKeys.STROKE_WIDTH.value, self.INHERIT)\n        if stroke_width is self.INHERIT or stroke_width is None:\n            return stroke_width\n        assert isinstance(stroke_width, NumberClass)\n        return float(stroke_width)\n\n    @stroke_width.setter\n    def stroke_width(self, width: float | InheritType | None) -> None:\n        if width not in (None, self.INHERIT) and not isinstance(width, NumberClass):\n            raise TypeError(f\"stroke_width must be a number, not {type(width)}\")\n        super().__setattr__(PDFStyleKeys.STROKE_WIDTH.value, width)\n\n    @property\n    def stroke_cap_style(self) -> StrokeCapStyle | InheritType:\n        \"\"\"The desired stroke cap style for this path/group.\"\"\"\n        stroke_cap_style = getattr(\n            self, PDFStyleKeys.STROKE_CAP_STYLE.value, self.INHERIT\n        )\n        if stroke_cap_style is self.INHERIT:\n            return stroke_cap_style\n        return cast(StrokeCapStyle, stroke_cap_style)\n\n    @stroke_cap_style.setter\n    def stroke_cap_style(self, value: StrokeCapStyle | str | InheritType) -> None:\n        if isinstance(value, InheritType):\n            super().__setattr__(PDFStyleKeys.STROKE_CAP_STYLE.value, value)\n        else:\n            super().__setattr__(\n                PDFStyleKeys.STROKE_CAP_STYLE.value, StrokeCapStyle.coerce(value)\n            )\n\n    @property\n    def stroke_join_style(self) -> StrokeJoinStyle | InheritType:\n        \"\"\"The desired stroke join style for this path/group.\"\"\"\n        stroke_join_style = getattr(\n            self, PDFStyleKeys.STROKE_JOIN_STYLE.value, self.INHERIT\n        )\n        if stroke_join_style is self.INHERIT:\n            return stroke_join_style\n        return cast(StrokeJoinStyle, stroke_join_style)\n\n    @stroke_join_style.setter\n    def stroke_join_style(self, value: StrokeJoinStyle | str | InheritType) -> None:\n        if isinstance(value, InheritType):\n            super().__setattr__(PDFStyleKeys.STROKE_JOIN_STYLE.value, value)\n        else:\n            super().__setattr__(\n                PDFStyleKeys.STROKE_JOIN_STYLE.value, StrokeJoinStyle.coerce(value)\n            )\n\n    @property\n    def stroke_miter_limit(self) -> float | InheritType:\n        \"\"\"The desired stroke miter limit for this path/group.\"\"\"\n        stroke_miter_limit = getattr(\n            self, PDFStyleKeys.STROKE_MITER_LIMIT.value, self.INHERIT\n        )\n        if stroke_miter_limit is self.INHERIT:\n            return stroke_miter_limit\n        assert isinstance(stroke_miter_limit, NumberClass)\n        return float(stroke_miter_limit)\n\n    @stroke_miter_limit.setter\n    def stroke_miter_limit(self, value: Number | InheritType) -> None:\n        if (value is self.INHERIT) or isinstance(value, NumberClass):\n            super().__setattr__(PDFStyleKeys.STROKE_MITER_LIMIT.value, value)\n        else:\n            raise TypeError(f\"{value} is not a number\")\n\n    @property\n    def stroke_dash_pattern(self) -> Optional[InheritType | tuple[float, ...]]:\n        \"\"\"The desired stroke dash pattern for this path/group.\"\"\"\n        stroke_dash_pattern = getattr(self, \"_stroke_dash_pattern\", self.INHERIT)\n        if stroke_dash_pattern is self.INHERIT:\n            return stroke_dash_pattern\n        return cast(tuple[float, ...], stroke_dash_pattern)\n\n    @stroke_dash_pattern.setter\n    def stroke_dash_pattern(\n        self, value: None | InheritType | Number | Sequence[Number]\n    ) -> None:\n        result: None | InheritType | Number | Sequence[Number]\n        if value is None:\n            result = ()\n        elif isinstance(value, InheritType):\n            result = self.INHERIT\n        elif isinstance(value, NumberClass):\n            result = (float(value),)\n        elif isinstance(value, (str, bytes, bytearray)):\n            raise TypeError(\n                f\"stroke_dash_pattern {value!r} must be a number or sequence of numbers\"\n            )\n        else:\n            try:\n                accum: list[float] = []\n                for item in value:\n                    if isinstance(item, (str, bytes, bytearray)):\n                        raise TypeError\n                    accum.append(float(item))\n            except (TypeError, ValueError):\n                raise TypeError(\n                    f\"stroke_dash_pattern {value!r} must be a number or sequence of numbers\"\n                ) from None\n            result = (*accum,)\n        super().__setattr__(\"_stroke_dash_pattern\", result)\n\n    @property\n    def stroke_dash_phase(self) -> InheritType | float:\n        \"\"\"The desired stroke dash pattern phase offset for this path/group.\"\"\"\n        stroke_dash_phase = getattr(self, \"_stroke_dash_phase\", self.INHERIT)\n        if stroke_dash_phase is self.INHERIT:\n            return stroke_dash_phase\n        assert isinstance(stroke_dash_phase, NumberClass)\n        return float(stroke_dash_phase)\n\n    @stroke_dash_phase.setter\n    def stroke_dash_phase(self, value: InheritType | Number) -> None:\n        if value is self.INHERIT or isinstance(value, NumberClass):\n            return super().__setattr__(\"_stroke_dash_phase\", value)\n\n        raise TypeError(f\"{value} isn't a number or GraphicsStyle.INHERIT\")\n\n    @property\n    def soft_mask(self) -> Union[InheritType, \"PaintSoftMask\"]:\n        paint_soft_mask = getattr(self, PDFStyleKeys.SOFT_MASK.value, self.INHERIT)\n        if paint_soft_mask is self.INHERIT:\n            return paint_soft_mask\n        return cast(PaintSoftMask, paint_soft_mask)\n\n    @soft_mask.setter\n    def soft_mask(self, value: Union[InheritType, \"PaintSoftMask\"]) -> None:\n        if value is self.INHERIT or isinstance(value, PaintSoftMask):\n            return super().__setattr__(PDFStyleKeys.SOFT_MASK.value, value)\n        raise TypeError(f\"{value} isn't a PaintSoftMask or GraphicsStyle.INHERIT\")\n\n    def serialize(self) -> Optional[Raw]:\n        \"\"\"\n        Convert this style object to a PDF dictionary with appropriate style keys.\n\n        Only explicitly specified values are emitted.\n        \"\"\"\n        result: dict[Name, Any] = OrderedDict()\n\n        for key in self.PDF_STYLE_KEYS:\n            value = getattr(self, key, self.INHERIT)\n\n            if (value is not self.INHERIT) and (value is not None):\n                # None is used for out-of-band signaling on these, e.g. a stroke_width\n                # of None doesn't need to land here because it signals the\n                # PathPaintRule auto resolution only.\n                result[key] = value\n\n        # There is additional logic in GraphicsContext to ensure that this will work\n        if self.stroke_dash_pattern and self.stroke_dash_pattern is not self.INHERIT:\n            result[PDFStyleKeys.STROKE_DASH_PATTERN.value] = [\n                self.stroke_dash_pattern,\n                self.stroke_dash_phase,\n            ]\n\n        if self.allow_transparency is False:\n            for key in self.TRANSPARENCY_KEYS:\n                if key in result:\n                    del result[key]\n\n        if result:\n            # Only insert this key if there is at least one other item in the result so\n            # that we don't junk up the output PDF with empty ExtGState dictionaries.\n            type_name = Name(\"Type\")\n            result[type_name] = Name(\"ExtGState\")\n            result.move_to_end(type_name, last=False)  # type: ignore[attr-defined]\n\n            return render_pdf_primitive(result)\n\n        # this signals to the graphics state registry that there is nothing to\n        # register. This is a success case.\n        return None\n\n    @force_nodocument\n    def resolve_paint_rule(self) -> PathPaintRule:\n        \"\"\"\n        Resolve `PathPaintRule.AUTO` to a real paint rule based on this style.\n\n        Returns:\n            the resolved `PathPaintRule`.\n        \"\"\"\n        if self.paint_rule is PathPaintRule.AUTO:\n            want: set[str | IntersectionRule] = set()\n            stroke_color = self.stroke_color\n            if self.stroke_width is not None and stroke_color is not None:\n                want.add(\"stroke\")\n            fill_color = self.fill_color\n            if fill_color is not None:\n                intersection_rule = (\n                    self.intersection_rule\n                    if isinstance(self.intersection_rule, IntersectionRule)\n                    else IntersectionRule.NONZERO\n                )\n                want.add(\"fill\")\n                # we need to guarantee that this will not be None. The default will\n                # be \"nonzero\".\n                want.add(intersection_rule)\n\n            try:\n                paint_rule: PathPaintRule = self._PAINT_RULE_LOOKUP[frozenset(want)]\n            except KeyError:\n                # don't default to DONT_PAINT because that's almost certainly not a very\n                # good default.\n                paint_rule = PathPaintRule.STROKE_FILL_NONZERO\n            return paint_rule\n\n        if isinstance(self.paint_rule, InheritType) or self.paint_rule is None:\n            # this shouldn't happen under normal usage, but certain API (ab)use can end\n            # up in this state. We can't resolve anything meaningful, so fall back to a\n            # sane(?) default.\n            return PathPaintRule.STROKE_FILL_NONZERO\n\n        return self.paint_rule",
      "language": "python"
    },
    {
      "code": "class GraphicsStyle:\n    \"\"\"\n    A class representing various style attributes that determine drawing appearance.\n\n    This class uses the convention that the global Python singleton ellipsis (`...`) is\n    exclusively used to represent values that are inherited from the parent style. This\n    is to disambiguate the value None which is used for several values to signal an\n    explicitly disabled style. An example of this is the fill/stroke color styles,\n    which use None as hints to the auto paint style detection code.\n    \"\"\"\n\n    _PRIVATE_SLOTS = (\n        \"_allow_transparency\",\n        \"_auto_close\",\n        \"_fill_color\",\n        \"_intersection_rule\",\n        \"_paint_rule\",\n        \"_stroke_color\",\n        \"_stroke_dash_pattern\",\n        \"_stroke_dash_phase\",\n    )\n\n    __slots__ = _PRIVATE_SLOTS + tuple(\n        k.value\n        for k in PDFStyleKeys\n        # we do not store STROKE_DASH_PATTERN under its PDF key; it's in _stroke_dash_pattern\n        if k is not PDFStyleKeys.STROKE_DASH_PATTERN\n    )\n\n    INHERIT = ...\n    \"\"\"Singleton specifying a style parameter should be inherited from the parent context.\"\"\"\n\n    # order is be important here because some of these properties are entangled, e.g.\n    # fill_color and fill_opacity\n    MERGE_PROPERTIES = (\n        \"paint_rule\",\n        \"allow_transparency\",\n        \"auto_close\",\n        \"intersection_rule\",\n        \"fill_color\",\n        \"fill_opacity\",\n        \"stroke_color\",\n        \"stroke_opacity\",\n        \"blend_mode\",\n        \"stroke_width\",\n        \"stroke_cap_style\",\n        \"stroke_join_style\",\n        \"stroke_miter_limit\",\n        \"stroke_dash_pattern\",\n        \"stroke_dash_phase\",\n        \"soft_mask\",\n    )\n    \"\"\"An ordered collection of properties to use when merging two GraphicsStyles.\"\"\"\n\n    TRANSPARENCY_KEYS = (\n        PDFStyleKeys.FILL_ALPHA.value,\n        PDFStyleKeys.STROKE_ALPHA.value,\n        PDFStyleKeys.BLEND_MODE.value,\n        PDFStyleKeys.SOFT_MASK.value,\n    )\n    \"\"\"An ordered collection of attributes not to emit in no transparency mode.\"\"\"\n\n    PDF_STYLE_KEYS = (\n        *(k.value for k in PDFStyleKeys if k is not PDFStyleKeys.STROKE_DASH_PATTERN),\n    )\n    \"\"\"An ordered collection of keys to directly emit when serializing the style.\"\"\"\n\n    _PAINT_RULE_LOOKUP: dict[frozenset[str | IntersectionRule], PathPaintRule] = {\n        frozenset({}): PathPaintRule.DONT_PAINT,\n        frozenset({\"stroke\"}): PathPaintRule.STROKE,\n        frozenset({\"fill\", IntersectionRule.NONZERO}): PathPaintRule.FILL_NONZERO,\n        frozenset({\"fill\", IntersectionRule.EVENODD}): PathPaintRule.FILL_EVENODD,\n        frozenset(\n            {\"stroke\", \"fill\", IntersectionRule.NONZERO}\n        ): PathPaintRule.STROKE_FILL_NONZERO,\n        frozenset(\n            {\"stroke\", \"fill\", IntersectionRule.EVENODD}\n        ): PathPaintRule.STROKE_FILL_EVENODD,\n    }\n    \"\"\"A dictionary for resolving `PathPaintRule.AUTO`\"\"\"\n\n    @classmethod\n    def merge(cls, parent: \"GraphicsStyle\", child: \"GraphicsStyle\") -> \"GraphicsStyle\":\n        \"\"\"\n        Merge parent and child into a single GraphicsStyle.\n\n        The result contains the properties of the parent as overridden by any properties\n        explicitly set on the child. If both the parent and the child specify to\n        inherit a given property, that property will preserve the inherit value.\n        \"\"\"\n        new = deepcopy(child)\n        for prop in cls.__slots__:\n            cval = getattr(new, prop)\n            if cval is cls.INHERIT:\n                setattr(new, prop, getattr(parent, prop))\n\n        return new\n\n    def __init__(self) -> None:\n        for key in self.__slots__:\n            setattr(self, key, self.INHERIT)\n\n    def __deepcopy__(self: GS, memo: dict[int, Any]) -> GS:\n        cls = self.__class__\n        new = cls.__new__(cls)  # bypass __init__\n        # copy private slots directly\n        for s in cls._PRIVATE_SLOTS:\n            object.__setattr__(new, s, getattr(self, s, cls.INHERIT))\n        # copy PDF-exposed slots (BM, ca, CA, etc.)\n        for key in cls.PDF_STYLE_KEYS:\n            object.__setattr__(new, key, getattr(self, key, cls.INHERIT))\n        return new\n\n    def __setattr__(self, name: str, value: Any) -> None:\n        try:\n            super().__setattr__(name, value)\n        except AttributeError as e:\n            raise AttributeError(\n                f'{self.__class__} does not have style \"{name}\" (a typo?)'\n            ) from e\n\n    # at some point it probably makes sense to turn this into a general compliance\n    # property, but for now this is the simple approach.\n    @property\n    def allow_transparency(self) -> bool | InheritType:\n        allow_transparency = getattr(self, \"_allow_transparency\", self.INHERIT)\n        if allow_transparency is self.INHERIT:\n            return self.INHERIT\n        return cast(bool, allow_transparency)\n\n    @allow_transparency.setter\n    def allow_transparency(self, new: bool | InheritType) -> None:\n        return super().__setattr__(\"_allow_transparency\", new)\n\n    # If these are used in a nested graphics context inside of a painting path\n    # operation, they are no-ops. However, they can be used for outer GraphicsContexts\n    # that painting paths inherit from.\n    @property\n    def paint_rule(self) -> PathPaintRule | InheritType | None:\n        \"\"\"The paint rule to use for this path/group.\"\"\"\n        paint_rule = getattr(self, \"_paint_rule\", self.INHERIT)\n        if paint_rule is self.INHERIT or paint_rule is None:\n            return paint_rule\n        return cast(PathPaintRule, paint_rule)\n\n    @paint_rule.setter\n    def paint_rule(self, new: PathPaintRule | InheritType | str | None) -> None:\n        if new is None:\n            super().__setattr__(\"_paint_rule\", PathPaintRule.DONT_PAINT)\n        elif isinstance(new, InheritType):\n            super().__setattr__(\"_paint_rule\", new)\n        else:\n            super().__setattr__(\"_paint_rule\", PathPaintRule.coerce(new))\n\n    @property\n    def auto_close(self) -> bool | InheritType:\n        \"\"\"If True, unclosed paths will be automatically closed before stroking.\"\"\"\n        auto_close = getattr(self, \"_auto_close\", self.INHERIT)\n        if auto_close is self.INHERIT:\n            return auto_close\n        return cast(bool, auto_close)\n\n    @auto_close.setter\n    def auto_close(self, new: bool | InheritType) -> None:\n        if new not in {True, False, self.INHERIT}:\n            raise TypeError(f\"auto_close must be a bool or self.INHERIT, not {new}\")\n        super().__setattr__(\"_auto_close\", new)\n\n    @property\n    def intersection_rule(self) -> IntersectionRule | InheritType:\n        \"\"\"The desired intersection rule for this path/group.\"\"\"\n        intersection_rule = getattr(self, \"_intersection_rule\", self.INHERIT)\n        if intersection_rule is self.INHERIT:\n            return intersection_rule\n        return cast(IntersectionRule, intersection_rule)\n\n    @intersection_rule.setter\n    def intersection_rule(self, new: IntersectionRule | InheritType | str) -> None:\n        # don't allow None for this one.\n        if isinstance(new, InheritType):\n            super().__setattr__(\"_intersection_rule\", new)\n        else:\n            super().__setattr__(\"_intersection_rule\", IntersectionRule.coerce(new))\n\n    @property\n    def fill_color(self) -> Color | GradientPaint | InheritType | str | None:\n        \"\"\"\n        The desired fill color for this path/group.\n\n        When setting this property, if the color specifies an opacity value, that will\n        be used to set the fill_opacity property as well.\n        \"\"\"\n        fill_color = getattr(self, \"_fill_color\", self.INHERIT)\n        if fill_color is self.INHERIT or fill_color is None:\n            return fill_color\n        assert isinstance(\n            fill_color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)\n        )\n        return fill_color\n\n    @fill_color.setter\n    def fill_color(\n        self, color: Color | GradientPaint | str | InheritType | None\n    ) -> None:\n        if isinstance(color, str):\n            color = color_from_hex_string(color)\n\n        if isinstance(color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)):\n            super().__setattr__(\"_fill_color\", color)\n            if getattr(color, \"a\", None) is not None and not isinstance(\n                color, GradientPaint\n            ):\n                self.fill_opacity = color.a\n\n        elif (color is None) or (color is self.INHERIT):\n            super().__setattr__(\"_fill_color\", color)\n\n        else:\n            raise TypeError(f\"{color} doesn't look like a drawing color\")\n\n    @property\n    def fill_opacity(self) -> float | InheritType | None:\n        \"\"\"The desired fill opacity for this path/group.\"\"\"\n        fill_opacity = getattr(self, PDFStyleKeys.FILL_ALPHA.value, self.INHERIT)\n        if fill_opacity is self.INHERIT or fill_opacity is None:\n            return fill_opacity\n        return cast(float, fill_opacity)\n\n    @fill_opacity.setter\n    def fill_opacity(self, new: float | InheritType | None) -> None:\n        if new not in {None, self.INHERIT}:\n            assert isinstance(new, NumberClass)\n            check_range(new)\n        super().__setattr__(PDFStyleKeys.FILL_ALPHA.value, new)\n\n    @property\n    def stroke_color(self) -> Color | GradientPaint | InheritType | None:\n        \"\"\"\n        The desired stroke color for this path/group.\n\n        When setting this property, if the color specifies an opacity value, that will\n        be used to set the fill_opacity property as well.\n        \"\"\"\n        stroke_color = getattr(self, \"_stroke_color\", self.INHERIT)\n        if stroke_color is self.INHERIT or stroke_color is None:\n            return stroke_color\n        assert isinstance(\n            stroke_color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)\n        )\n        return stroke_color\n\n    @stroke_color.setter\n    def stroke_color(\n        self, color: Color | GradientPaint | str | InheritType | None\n    ) -> None:\n        if isinstance(color, str):\n            color = color_from_hex_string(color)\n\n        if isinstance(color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)):\n            super().__setattr__(\"_stroke_color\", color)\n            if getattr(color, \"a\", None) is not None and not isinstance(\n                color, GradientPaint\n            ):\n                self.stroke_opacity = color.a\n            if self.stroke_width is self.INHERIT:\n                self.stroke_width = 1\n\n        elif (color is None) or (color is self.INHERIT):\n            super().__setattr__(\"_stroke_color\", color)\n\n        else:\n            raise TypeError(f\"{color} doesn't look like a drawing color\")\n\n    @property\n    def stroke_opacity(self) -> float | InheritType | None:\n        \"\"\"The desired stroke opacity for this path/group.\"\"\"\n        stroke_opacity = getattr(self, PDFStyleKeys.STROKE_ALPHA.value, self.INHERIT)\n        if stroke_opacity is self.INHERIT or stroke_opacity is None:\n            return stroke_opacity\n        assert isinstance(stroke_opacity, NumberClass)\n        return float(stroke_opacity)\n\n    @stroke_opacity.setter\n    def stroke_opacity(self, new: float | InheritType | None) -> None:\n        if new not in (None, self.INHERIT):\n            assert isinstance(new, NumberClass)\n            check_range(new)\n        super().__setattr__(PDFStyleKeys.STROKE_ALPHA.value, new)\n\n    @property\n    def blend_mode(self) -> BlendMode | InheritType:\n        \"\"\"The desired blend mode for this path/group.\"\"\"\n        blend_mode = getattr(self, PDFStyleKeys.BLEND_MODE.value, self.INHERIT)\n        if blend_mode is self.INHERIT:\n            return blend_mode\n        return cast(BlendMode, blend_mode)\n\n    @blend_mode.setter\n    def blend_mode(self, value: BlendMode | str | InheritType) -> None:\n        if isinstance(value, InheritType):\n            super().__setattr__(PDFStyleKeys.BLEND_MODE.value, value)\n        else:\n            super().__setattr__(\n                PDFStyleKeys.BLEND_MODE.value, BlendMode.coerce(value).value\n            )\n\n    @property\n    def stroke_width(self) -> float | InheritType | None:\n        \"\"\"The desired stroke width for this path/group.\"\"\"\n        stroke_width = getattr(self, PDFStyleKeys.STROKE_WIDTH.value, self.INHERIT)\n        if stroke_width is self.INHERIT or stroke_width is None:\n            return stroke_width\n        assert isinstance(stroke_width, NumberClass)\n        return float(stroke_width)\n\n    @stroke_width.setter\n    def stroke_width(self, width: float | InheritType | None) -> None:\n        if width not in (None, self.INHERIT) and not isinstance(width, NumberClass):\n            raise TypeError(f\"stroke_width must be a number, not {type(width)}\")\n        super().__setattr__(PDFStyleKeys.STROKE_WIDTH.value, width)\n\n    @property\n    def stroke_cap_style(self) -> StrokeCapStyle | InheritType:\n        \"\"\"The desired stroke cap style for this path/group.\"\"\"\n        stroke_cap_style = getattr(\n            self, PDFStyleKeys.STROKE_CAP_STYLE.value, self.INHERIT\n        )\n        if stroke_cap_style is self.INHERIT:\n            return stroke_cap_style\n        return cast(StrokeCapStyle, stroke_cap_style)\n\n    @stroke_cap_style.setter\n    def stroke_cap_style(self, value: StrokeCapStyle | str | InheritType) -> None:\n        if isinstance(value, InheritType):\n            super().__setattr__(PDFStyleKeys.STROKE_CAP_STYLE.value, value)\n        else:\n            super().__setattr__(\n                PDFStyleKeys.STROKE_CAP_STYLE.value, StrokeCapStyle.coerce(value)\n            )\n\n    @property\n    def stroke_join_style(self) -> StrokeJoinStyle | InheritType:\n        \"\"\"The desired stroke join style for this path/group.\"\"\"\n        stroke_join_style = getattr(\n            self, PDFStyleKeys.STROKE_JOIN_STYLE.value, self.INHERIT\n        )\n        if stroke_join_style is self.INHERIT:\n            return stroke_join_style\n        return cast(StrokeJoinStyle, stroke_join_style)\n\n    @stroke_join_style.setter\n    def stroke_join_style(self, value: StrokeJoinStyle | str | InheritType) -> None:\n        if isinstance(value, InheritType):\n            super().__setattr__(PDFStyleKeys.STROKE_JOIN_STYLE.value, value)\n        else:\n            super().__setattr__(\n                PDFStyleKeys.STROKE_JOIN_STYLE.value, StrokeJoinStyle.coerce(value)\n            )\n\n    @property\n    def stroke_miter_limit(self) -> float | InheritType:\n        \"\"\"The desired stroke miter limit for this path/group.\"\"\"\n        stroke_miter_limit = getattr(\n            self, PDFStyleKeys.STROKE_MITER_LIMIT.value, self.INHERIT\n        )\n        if stroke_miter_limit is self.INHERIT:\n            return stroke_miter_limit\n        assert isinstance(stroke_miter_limit, NumberClass)\n        return float(stroke_miter_limit)\n\n    @stroke_miter_limit.setter\n    def stroke_miter_limit(self, value: Number | InheritType) -> None:\n        if (value is self.INHERIT) or isinstance(value, NumberClass):\n            super().__setattr__(PDFStyleKeys.STROKE_MITER_LIMIT.value, value)\n        else:\n            raise TypeError(f\"{value} is not a number\")\n\n    @property\n    def stroke_dash_pattern(self) -> Optional[InheritType | tuple[float, ...]]:\n        \"\"\"The desired stroke dash pattern for this path/group.\"\"\"\n        stroke_dash_pattern = getattr(self, \"_stroke_dash_pattern\", self.INHERIT)\n        if stroke_dash_pattern is self.INHERIT:\n            return stroke_dash_pattern\n        return cast(tuple[float, ...], stroke_dash_pattern)\n\n    @stroke_dash_pattern.setter\n    def stroke_dash_pattern(\n        self, value: None | InheritType | Number | Sequence[Number]\n    ) -> None:\n        result: None | InheritType | Number | Sequence[Number]\n        if value is None:\n            result = ()\n        elif isinstance(value, InheritType):\n            result = self.INHERIT\n        elif isinstance(value, NumberClass):\n            result = (float(value),)\n        elif isinstance(value, (str, bytes, bytearray)):\n            raise TypeError(\n                f\"stroke_dash_pattern {value!r} must be a number or sequence of numbers\"\n            )\n        else:\n            try:\n                accum: list[float] = []\n                for item in value:\n                    if isinstance(item, (str, bytes, bytearray)):\n                        raise TypeError\n                    accum.append(float(item))\n            except (TypeError, ValueError):\n                raise TypeError(\n                    f\"stroke_dash_pattern {value!r} must be a number or sequence of numbers\"\n                ) from None\n            result = (*accum,)\n        super().__setattr__(\"_stroke_dash_pattern\", result)\n\n    @property\n    def stroke_dash_phase(self) -> InheritType | float:\n        \"\"\"The desired stroke dash pattern phase offset for this path/group.\"\"\"\n        stroke_dash_phase = getattr(self, \"_stroke_dash_phase\", self.INHERIT)\n        if stroke_dash_phase is self.INHERIT:\n            return stroke_dash_phase\n        assert isinstance(stroke_dash_phase, NumberClass)\n        return float(stroke_dash_phase)\n\n    @stroke_dash_phase.setter\n    def stroke_dash_phase(self, value: InheritType | Number) -> None:\n        if value is self.INHERIT or isinstance(value, NumberClass):\n            return super().__setattr__(\"_stroke_dash_phase\", value)\n\n        raise TypeError(f\"{value} isn't a number or GraphicsStyle.INHERIT\")\n\n    @property\n    def soft_mask(self) -> Union[InheritType, \"PaintSoftMask\"]:\n        paint_soft_mask = getattr(self, PDFStyleKeys.SOFT_MASK.value, self.INHERIT)\n        if paint_soft_mask is self.INHERIT:\n            return paint_soft_mask\n        return cast(PaintSoftMask, paint_soft_mask)\n\n    @soft_mask.setter\n    def soft_mask(self, value: Union[InheritType, \"PaintSoftMask\"]) -> None:\n        if value is self.INHERIT or isinstance(value, PaintSoftMask):\n            return super().__setattr__(PDFStyleKeys.SOFT_MASK.value, value)\n        raise TypeError(f\"{value} isn't a PaintSoftMask or GraphicsStyle.INHERIT\")\n\n    def serialize(self) -> Optional[Raw]:\n        \"\"\"\n        Convert this style object to a PDF dictionary with appropriate style keys.\n\n        Only explicitly specified values are emitted.\n        \"\"\"\n        result: dict[Name, Any] = OrderedDict()\n\n        for key in self.PDF_STYLE_KEYS:\n            value = getattr(self, key, self.INHERIT)\n\n            if (value is not self.INHERIT) and (value is not None):\n                # None is used for out-of-band signaling on these, e.g. a stroke_width\n                # of None doesn't need to land here because it signals the\n                # PathPaintRule auto resolution only.\n                result[key] = value\n\n        # There is additional logic in GraphicsContext to ensure that this will work\n        if self.stroke_dash_pattern and self.stroke_dash_pattern is not self.INHERIT:\n            result[PDFStyleKeys.STROKE_DASH_PATTERN.value] = [\n                self.stroke_dash_pattern,\n                self.stroke_dash_phase,\n            ]\n\n        if self.allow_transparency is False:\n            for key in self.TRANSPARENCY_KEYS:\n                if key in result:\n                    del result[key]\n\n        if result:\n            # Only insert this key if there is at least one other item in the result so\n            # that we don't junk up the output PDF with empty ExtGState dictionaries.\n            type_name = Name(\"Type\")\n            result[type_name] = Name(\"ExtGState\")\n            result.move_to_end(type_name, last=False)  # type: ignore[attr-defined]\n\n            return render_pdf_primitive(result)\n\n        # this signals to the graphics state registry that there is nothing to\n        # register. This is a success case.\n        return None\n\n    @force_nodocument\n    def resolve_paint_rule(self) -> PathPaintRule:\n        \"\"\"\n        Resolve `PathPaintRule.AUTO` to a real paint rule based on this style.\n\n        Returns:\n            the resolved `PathPaintRule`.\n        \"\"\"\n        if self.paint_rule is PathPaintRule.AUTO:\n            want: set[str | IntersectionRule] = set()\n            stroke_color = self.stroke_color\n            if self.stroke_width is not None and stroke_color is not None:\n                want.add(\"stroke\")\n            fill_color = self.fill_color\n            if fill_color is not None:\n                intersection_rule = (\n                    self.intersection_rule\n                    if isinstance(self.intersection_rule, IntersectionRule)\n                    else IntersectionRule.NONZERO\n                )\n                want.add(\"fill\")\n                # we need to guarantee that this will not be None. The default will\n                # be \"nonzero\".\n                want.add(intersection_rule)\n\n            try:\n                paint_rule: PathPaintRule = self._PAINT_RULE_LOOKUP[frozenset(want)]\n            except KeyError:\n                # don't default to DONT_PAINT because that's almost certainly not a very\n                # good default.\n                paint_rule = PathPaintRule.STROKE_FILL_NONZERO\n            return paint_rule\n\n        if isinstance(self.paint_rule, InheritType) or self.paint_rule is None:\n            # this shouldn't happen under normal usage, but certain API (ab)use can end\n            # up in this state. We can't resolve anything meaningful, so fall back to a\n            # sane(?) default.\n            return PathPaintRule.STROKE_FILL_NONZERO\n\n        return self.paint_rule",
      "language": "python"
    },
    {
      "code": "class GraphicsStyle:\n    \"\"\"\n    A class representing various style attributes that determine drawing appearance.\n\n    This class uses the convention that the global Python singleton ellipsis (`...`) is\n    exclusively used to represent values that are inherited from the parent style. This\n    is to disambiguate the value None which is used for several values to signal an\n    explicitly disabled style. An example of this is the fill/stroke color styles,\n    which use None as hints to the auto paint style detection code.\n    \"\"\"\n\n    _PRIVATE_SLOTS = (\n        \"_allow_transparency\",\n        \"_auto_close\",\n        \"_fill_color\",\n        \"_intersection_rule\",\n        \"_paint_rule\",\n        \"_stroke_color\",\n        \"_stroke_dash_pattern\",\n        \"_stroke_dash_phase\",\n    )\n\n    __slots__ = _PRIVATE_SLOTS + tuple(\n        k.value\n        for k in PDFStyleKeys\n        # we do not store STROKE_DASH_PATTERN under its PDF key; it's in _stroke_dash_pattern\n        if k is not PDFStyleKeys.STROKE_DASH_PATTERN\n    )\n\n    INHERIT = ...\n    \"\"\"Singleton specifying a style parameter should be inherited from the parent context.\"\"\"\n\n    # order is be important here because some of these properties are entangled, e.g.\n    # fill_color and fill_opacity\n    MERGE_PROPERTIES = (\n        \"paint_rule\",\n        \"allow_transparency\",\n        \"auto_close\",\n        \"intersection_rule\",\n        \"fill_color\",\n        \"fill_opacity\",\n        \"stroke_color\",\n        \"stroke_opacity\",\n        \"blend_mode\",\n        \"stroke_width\",\n        \"stroke_cap_style\",\n        \"stroke_join_style\",\n        \"stroke_miter_limit\",\n        \"stroke_dash_pattern\",\n        \"stroke_dash_phase\",\n        \"soft_mask\",\n    )\n    \"\"\"An ordered collection of properties to use when merging two GraphicsStyles.\"\"\"\n\n    TRANSPARENCY_KEYS = (\n        PDFStyleKeys.FILL_ALPHA.value,\n        PDFStyleKeys.STROKE_ALPHA.value,\n        PDFStyleKeys.BLEND_MODE.value,\n        PDFStyleKeys.SOFT_MASK.value,\n    )\n    \"\"\"An ordered collection of attributes not to emit in no transparency mode.\"\"\"\n\n    PDF_STYLE_KEYS = (\n        *(k.value for k in PDFStyleKeys if k is not PDFStyleKeys.STROKE_DASH_PATTERN),\n    )\n    \"\"\"An ordered collection of keys to directly emit when serializing the style.\"\"\"\n\n    _PAINT_RULE_LOOKUP: dict[frozenset[str | IntersectionRule], PathPaintRule] = {\n        frozenset({}): PathPaintRule.DONT_PAINT,\n        frozenset({\"stroke\"}): PathPaintRule.STROKE,\n        frozenset({\"fill\", IntersectionRule.NONZERO}): PathPaintRule.FILL_NONZERO,\n        frozenset({\"fill\", IntersectionRule.EVENODD}): PathPaintRule.FILL_EVENODD,\n        frozenset(\n            {\"stroke\", \"fill\", IntersectionRule.NONZERO}\n        ): PathPaintRule.STROKE_FILL_NONZERO,\n        frozenset(\n            {\"stroke\", \"fill\", IntersectionRule.EVENODD}\n        ): PathPaintRule.STROKE_FILL_EVENODD,\n    }\n    \"\"\"A dictionary for resolving `PathPaintRule.AUTO`\"\"\"\n\n    @classmethod\n    def merge(cls, parent: \"GraphicsStyle\", child: \"GraphicsStyle\") -> \"GraphicsStyle\":\n        \"\"\"\n        Merge parent and child into a single GraphicsStyle.\n\n        The result contains the properties of the parent as overridden by any properties\n        explicitly set on the child. If both the parent and the child specify to\n        inherit a given property, that property will preserve the inherit value.\n        \"\"\"\n        new = deepcopy(child)\n        for prop in cls.__slots__:\n            cval = getattr(new, prop)\n            if cval is cls.INHERIT:\n                setattr(new, prop, getattr(parent, prop))\n\n        return new\n\n    def __init__(self) -> None:\n        for key in self.__slots__:\n            setattr(self, key, self.INHERIT)\n\n    def __deepcopy__(self: GS, memo: dict[int, Any]) -> GS:\n        cls = self.__class__\n        new = cls.__new__(cls)  # bypass __init__\n        # copy private slots directly\n        for s in cls._PRIVATE_SLOTS:\n            object.__setattr__(new, s, getattr(self, s, cls.INHERIT))\n        # copy PDF-exposed slots (BM, ca, CA, etc.)\n        for key in cls.PDF_STYLE_KEYS:\n            object.__setattr__(new, key, getattr(self, key, cls.INHERIT))\n        return new\n\n    def __setattr__(self, name: str, value: Any) -> None:\n        try:\n            super().__setattr__(name, value)\n        except AttributeError as e:\n            raise AttributeError(\n                f'{self.__class__} does not have style \"{name}\" (a typo?)'\n            ) from e\n\n    # at some point it probably makes sense to turn this into a general compliance\n    # property, but for now this is the simple approach.\n    @property\n    def allow_transparency(self) -> bool | InheritType:\n        allow_transparency = getattr(self, \"_allow_transparency\", self.INHERIT)\n        if allow_transparency is self.INHERIT:\n            return self.INHERIT\n        return cast(bool, allow_transparency)\n\n    @allow_transparency.setter\n    def allow_transparency(self, new: bool | InheritType) -> None:\n        return super().__setattr__(\"_allow_transparency\", new)\n\n    # If these are used in a nested graphics context inside of a painting path\n    # operation, they are no-ops. However, they can be used for outer GraphicsContexts\n    # that painting paths inherit from.\n    @property\n    def paint_rule(self) -> PathPaintRule | InheritType | None:\n        \"\"\"The paint rule to use for this path/group.\"\"\"\n        paint_rule = getattr(self, \"_paint_rule\", self.INHERIT)\n        if paint_rule is self.INHERIT or paint_rule is None:\n            return paint_rule\n        return cast(PathPaintRule, paint_rule)\n\n    @paint_rule.setter\n    def paint_rule(self, new: PathPaintRule | InheritType | str | None) -> None:\n        if new is None:\n            super().__setattr__(\"_paint_rule\", PathPaintRule.DONT_PAINT)\n        elif isinstance(new, InheritType):\n            super().__setattr__(\"_paint_rule\", new)\n        else:\n            super().__setattr__(\"_paint_rule\", PathPaintRule.coerce(new))\n\n    @property\n    def auto_close(self) -> bool | InheritType:\n        \"\"\"If True, unclosed paths will be automatically closed before stroking.\"\"\"\n        auto_close = getattr(self, \"_auto_close\", self.INHERIT)\n        if auto_close is self.INHERIT:\n            return auto_close\n        return cast(bool, auto_close)\n\n    @auto_close.setter\n    def auto_close(self, new: bool | InheritType) -> None:\n        if new not in {True, False, self.INHERIT}:\n            raise TypeError(f\"auto_close must be a bool or self.INHERIT, not {new}\")\n        super().__setattr__(\"_auto_close\", new)\n\n    @property\n    def intersection_rule(self) -> IntersectionRule | InheritType:\n        \"\"\"The desired intersection rule for this path/group.\"\"\"\n        intersection_rule = getattr(self, \"_intersection_rule\", self.INHERIT)\n        if intersection_rule is self.INHERIT:\n            return intersection_rule\n        return cast(IntersectionRule, intersection_rule)\n\n    @intersection_rule.setter\n    def intersection_rule(self, new: IntersectionRule | InheritType | str) -> None:\n        # don't allow None for this one.\n        if isinstance(new, InheritType):\n            super().__setattr__(\"_intersection_rule\", new)\n        else:\n            super().__setattr__(\"_intersection_rule\", IntersectionRule.coerce(new))\n\n    @property\n    def fill_color(self) -> Color | GradientPaint | InheritType | str | None:\n        \"\"\"\n        The desired fill color for this path/group.\n\n        When setting this property, if the color specifies an opacity value, that will\n        be used to set the fill_opacity property as well.\n        \"\"\"\n        fill_color = getattr(self, \"_fill_color\", self.INHERIT)\n        if fill_color is self.INHERIT or fill_color is None:\n            return fill_color\n        assert isinstance(\n            fill_color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)\n        )\n        return fill_color\n\n    @fill_color.setter\n    def fill_color(\n        self, color: Color | GradientPaint | str | InheritType | None\n    ) -> None:\n        if isinstance(color, str):\n            color = color_from_hex_string(color)\n\n        if isinstance(color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)):\n            super().__setattr__(\"_fill_color\", color)\n            if getattr(color, \"a\", None) is not None and not isinstance(\n                color, GradientPaint\n            ):\n                self.fill_opacity = color.a\n\n        elif (color is None) or (color is self.INHERIT):\n            super().__setattr__(\"_fill_color\", color)\n\n        else:\n            raise TypeError(f\"{color} doesn't look like a drawing color\")\n\n    @property\n    def fill_opacity(self) -> float | InheritType | None:\n        \"\"\"The desired fill opacity for this path/group.\"\"\"\n        fill_opacity = getattr(self, PDFStyleKeys.FILL_ALPHA.value, self.INHERIT)\n        if fill_opacity is self.INHERIT or fill_opacity is None:\n            return fill_opacity\n        return cast(float, fill_opacity)\n\n    @fill_opacity.setter\n    def fill_opacity(self, new: float | InheritType | None) -> None:\n        if new not in {None, self.INHERIT}:\n            assert isinstance(new, NumberClass)\n            check_range(new)\n        super().__setattr__(PDFStyleKeys.FILL_ALPHA.value, new)\n\n    @property\n    def stroke_color(self) -> Color | GradientPaint | InheritType | None:\n        \"\"\"\n        The desired stroke color for this path/group.\n\n        When setting this property, if the color specifies an opacity value, that will\n        be used to set the fill_opacity property as well.\n        \"\"\"\n        stroke_color = getattr(self, \"_stroke_color\", self.INHERIT)\n        if stroke_color is self.INHERIT or stroke_color is None:\n            return stroke_color\n        assert isinstance(\n            stroke_color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)\n        )\n        return stroke_color\n\n    @stroke_color.setter\n    def stroke_color(\n        self, color: Color | GradientPaint | str | InheritType | None\n    ) -> None:\n        if isinstance(color, str):\n            color = color_from_hex_string(color)\n\n        if isinstance(color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)):\n            super().__setattr__(\"_stroke_color\", color)\n            if getattr(color, \"a\", None) is not None and not isinstance(\n                color, GradientPaint\n            ):\n                self.stroke_opacity = color.a\n            if self.stroke_width is self.INHERIT:\n                self.stroke_width = 1\n\n        elif (color is None) or (color is self.INHERIT):\n            super().__setattr__(\"_stroke_color\", color)\n\n        else:\n            raise TypeError(f\"{color} doesn't look like a drawing color\")\n\n    @property\n    def stroke_opacity(self) -> float | InheritType | None:\n        \"\"\"The desired stroke opacity for this path/group.\"\"\"\n        stroke_opacity = getattr(self, PDFStyleKeys.STROKE_ALPHA.value, self.INHERIT)\n        if stroke_opacity is self.INHERIT or stroke_opacity is None:\n            return stroke_opacity\n        assert isinstance(stroke_opacity, NumberClass)\n        return float(stroke_opacity)\n\n    @stroke_opacity.setter\n    def stroke_opacity(self, new: float | InheritType | None) -> None:\n        if new not in (None, self.INHERIT):\n            assert isinstance(new, NumberClass)\n            check_range(new)\n        super().__setattr__(PDFStyleKeys.STROKE_ALPHA.value, new)\n\n    @property\n    def blend_mode(self) -> BlendMode | InheritType:\n        \"\"\"The desired blend mode for this path/group.\"\"\"\n        blend_mode = getattr(self, PDFStyleKeys.BLEND_MODE.value, self.INHERIT)\n        if blend_mode is self.INHERIT:\n            return blend_mode\n        return cast(BlendMode, blend_mode)\n\n    @blend_mode.setter\n    def blend_mode(self, value: BlendMode | str | InheritType) -> None:\n        if isinstance(value, InheritType):\n            super().__setattr__(PDFStyleKeys.BLEND_MODE.value, value)\n        else:\n            super().__setattr__(\n                PDFStyleKeys.BLEND_MODE.value, BlendMode.coerce(value).value\n            )\n\n    @property\n    def stroke_width(self) -> float | InheritType | None:\n        \"\"\"The desired stroke width for this path/group.\"\"\"\n        stroke_width = getattr(self, PDFStyleKeys.STROKE_WIDTH.value, self.INHERIT)\n        if stroke_width is self.INHERIT or stroke_width is None:\n            return stroke_width\n        assert isinstance(stroke_width, NumberClass)\n        return float(stroke_width)\n\n    @stroke_width.setter\n    def stroke_width(self, width: float | InheritType | None) -> None:\n        if width not in (None, self.INHERIT) and not isinstance(width, NumberClass):\n            raise TypeError(f\"stroke_width must be a number, not {type(width)}\")\n        super().__setattr__(PDFStyleKeys.STROKE_WIDTH.value, width)\n\n    @property\n    def stroke_cap_style(self) -> StrokeCapStyle | InheritType:\n        \"\"\"The desired stroke cap style for this path/group.\"\"\"\n        stroke_cap_style = getattr(\n            self, PDFStyleKeys.STROKE_CAP_STYLE.value, self.INHERIT\n        )\n        if stroke_cap_style is self.INHERIT:\n            return stroke_cap_style\n        return cast(StrokeCapStyle, stroke_cap_style)\n\n    @stroke_cap_style.setter\n    def stroke_cap_style(self, value: StrokeCapStyle | str | InheritType) -> None:\n        if isinstance(value, InheritType):\n            super().__setattr__(PDFStyleKeys.STROKE_CAP_STYLE.value, value)\n        else:\n            super().__setattr__(\n                PDFStyleKeys.STROKE_CAP_STYLE.value, StrokeCapStyle.coerce(value)\n            )\n\n    @property\n    def stroke_join_style(self) -> StrokeJoinStyle | InheritType:\n        \"\"\"The desired stroke join style for this path/group.\"\"\"\n        stroke_join_style = getattr(\n            self, PDFStyleKeys.STROKE_JOIN_STYLE.value, self.INHERIT\n        )\n        if stroke_join_style is self.INHERIT:\n            return stroke_join_style\n        return cast(StrokeJoinStyle, stroke_join_style)\n\n    @stroke_join_style.setter\n    def stroke_join_style(self, value: StrokeJoinStyle | str | InheritType) -> None:\n        if isinstance(value, InheritType):\n            super().__setattr__(PDFStyleKeys.STROKE_JOIN_STYLE.value, value)\n        else:\n            super().__setattr__(\n                PDFStyleKeys.STROKE_JOIN_STYLE.value, StrokeJoinStyle.coerce(value)\n            )\n\n    @property\n    def stroke_miter_limit(self) -> float | InheritType:\n        \"\"\"The desired stroke miter limit for this path/group.\"\"\"\n        stroke_miter_limit = getattr(\n            self, PDFStyleKeys.STROKE_MITER_LIMIT.value, self.INHERIT\n        )\n        if stroke_miter_limit is self.INHERIT:\n            return stroke_miter_limit\n        assert isinstance(stroke_miter_limit, NumberClass)\n        return float(stroke_miter_limit)\n\n    @stroke_miter_limit.setter\n    def stroke_miter_limit(self, value: Number | InheritType) -> None:\n        if (value is self.INHERIT) or isinstance(value, NumberClass):\n            super().__setattr__(PDFStyleKeys.STROKE_MITER_LIMIT.value, value)\n        else:\n            raise TypeError(f\"{value} is not a number\")\n\n    @property\n    def stroke_dash_pattern(self) -> Optional[InheritType | tuple[float, ...]]:\n        \"\"\"The desired stroke dash pattern for this path/group.\"\"\"\n        stroke_dash_pattern = getattr(self, \"_stroke_dash_pattern\", self.INHERIT)\n        if stroke_dash_pattern is self.INHERIT:\n            return stroke_dash_pattern\n        return cast(tuple[float, ...], stroke_dash_pattern)\n\n    @stroke_dash_pattern.setter\n    def stroke_dash_pattern(\n        self, value: None | InheritType | Number | Sequence[Number]\n    ) -> None:\n        result: None | InheritType | Number | Sequence[Number]\n        if value is None:\n            result = ()\n        elif isinstance(value, InheritType):\n            result = self.INHERIT\n        elif isinstance(value, NumberClass):\n            result = (float(value),)\n        elif isinstance(value, (str, bytes, bytearray)):\n            raise TypeError(\n                f\"stroke_dash_pattern {value!r} must be a number or sequence of numbers\"\n            )\n        else:\n            try:\n                accum: list[float] = []\n                for item in value:\n                    if isinstance(item, (str, bytes, bytearray)):\n                        raise TypeError\n                    accum.append(float(item))\n            except (TypeError, ValueError):\n                raise TypeError(\n                    f\"stroke_dash_pattern {value!r} must be a number or sequence of numbers\"\n                ) from None\n            result = (*accum,)\n        super().__setattr__(\"_stroke_dash_pattern\", result)\n\n    @property\n    def stroke_dash_phase(self) -> InheritType | float:\n        \"\"\"The desired stroke dash pattern phase offset for this path/group.\"\"\"\n        stroke_dash_phase = getattr(self, \"_stroke_dash_phase\", self.INHERIT)\n        if stroke_dash_phase is self.INHERIT:\n            return stroke_dash_phase\n        assert isinstance(stroke_dash_phase, NumberClass)\n        return float(stroke_dash_phase)\n\n    @stroke_dash_phase.setter\n    def stroke_dash_phase(self, value: InheritType | Number) -> None:\n        if value is self.INHERIT or isinstance(value, NumberClass):\n            return super().__setattr__(\"_stroke_dash_phase\", value)\n\n        raise TypeError(f\"{value} isn't a number or GraphicsStyle.INHERIT\")\n\n    @property\n    def soft_mask(self) -> Union[InheritType, \"PaintSoftMask\"]:\n        paint_soft_mask = getattr(self, PDFStyleKeys.SOFT_MASK.value, self.INHERIT)\n        if paint_soft_mask is self.INHERIT:\n            return paint_soft_mask\n        return cast(PaintSoftMask, paint_soft_mask)\n\n    @soft_mask.setter\n    def soft_mask(self, value: Union[InheritType, \"PaintSoftMask\"]) -> None:\n        if value is self.INHERIT or isinstance(value, PaintSoftMask):\n            return super().__setattr__(PDFStyleKeys.SOFT_MASK.value, value)\n        raise TypeError(f\"{value} isn't a PaintSoftMask or GraphicsStyle.INHERIT\")\n\n    def serialize(self) -> Optional[Raw]:\n        \"\"\"\n        Convert this style object to a PDF dictionary with appropriate style keys.\n\n        Only explicitly specified values are emitted.\n        \"\"\"\n        result: dict[Name, Any] = OrderedDict()\n\n        for key in self.PDF_STYLE_KEYS:\n            value = getattr(self, key, self.INHERIT)\n\n            if (value is not self.INHERIT) and (value is not None):\n                # None is used for out-of-band signaling on these, e.g. a stroke_width\n                # of None doesn't need to land here because it signals the\n                # PathPaintRule auto resolution only.\n                result[key] = value\n\n        # There is additional logic in GraphicsContext to ensure that this will work\n        if self.stroke_dash_pattern and self.stroke_dash_pattern is not self.INHERIT:\n            result[PDFStyleKeys.STROKE_DASH_PATTERN.value] = [\n                self.stroke_dash_pattern,\n                self.stroke_dash_phase,\n            ]\n\n        if self.allow_transparency is False:\n            for key in self.TRANSPARENCY_KEYS:\n                if key in result:\n                    del result[key]\n\n        if result:\n            # Only insert this key if there is at least one other item in the result so\n            # that we don't junk up the output PDF with empty ExtGState dictionaries.\n            type_name = Name(\"Type\")\n            result[type_name] = Name(\"ExtGState\")\n            result.move_to_end(type_name, last=False)  # type: ignore[attr-defined]\n\n            return render_pdf_primitive(result)\n\n        # this signals to the graphics state registry that there is nothing to\n        # register. This is a success case.\n        return None\n\n    @force_nodocument\n    def resolve_paint_rule(self) -> PathPaintRule:\n        \"\"\"\n        Resolve `PathPaintRule.AUTO` to a real paint rule based on this style.\n\n        Returns:\n            the resolved `PathPaintRule`.\n        \"\"\"\n        if self.paint_rule is PathPaintRule.AUTO:\n            want: set[str | IntersectionRule] = set()\n            stroke_color = self.stroke_color\n            if self.stroke_width is not None and stroke_color is not None:\n                want.add(\"stroke\")\n            fill_color = self.fill_color\n            if fill_color is not None:\n                intersection_rule = (\n                    self.intersection_rule\n                    if isinstance(self.intersection_rule, IntersectionRule)\n                    else IntersectionRule.NONZERO\n                )\n                want.add(\"fill\")\n                # we need to guarantee that this will not be None. The default will\n                # be \"nonzero\".\n                want.add(intersection_rule)\n\n            try:\n                paint_rule: PathPaintRule = self._PAINT_RULE_LOOKUP[frozenset(want)]\n            except KeyError:\n                # don't default to DONT_PAINT because that's almost certainly not a very\n                # good default.\n                paint_rule = PathPaintRule.STROKE_FILL_NONZERO\n            return paint_rule\n\n        if isinstance(self.paint_rule, InheritType) or self.paint_rule is None:\n            # this shouldn't happen under normal usage, but certain API (ab)use can end\n            # up in this state. We can't resolve anything meaningful, so fall back to a\n            # sane(?) default.\n            return PathPaintRule.STROKE_FILL_NONZERO\n\n        return self.paint_rule",
      "language": "python"
    },
    {
      "code": "@property\ndef allow_transparency(self) -> bool | InheritType:\n    allow_transparency = getattr(self, \"_allow_transparency\", self.INHERIT)\n    if allow_transparency is self.INHERIT:\n        return self.INHERIT\n    return cast(bool, allow_transparency)",
      "language": "python"
    },
    {
      "code": "@property\ndef auto_close(self) -> bool | InheritType:\n    \"\"\"If True, unclosed paths will be automatically closed before stroking.\"\"\"\n    auto_close = getattr(self, \"_auto_close\", self.INHERIT)\n    if auto_close is self.INHERIT:\n        return auto_close\n    return cast(bool, auto_close)",
      "language": "python"
    },
    {
      "code": "@property\ndef blend_mode(self) -> BlendMode | InheritType:\n    \"\"\"The desired blend mode for this path/group.\"\"\"\n    blend_mode = getattr(self, PDFStyleKeys.BLEND_MODE.value, self.INHERIT)\n    if blend_mode is self.INHERIT:\n        return blend_mode\n    return cast(BlendMode, blend_mode)",
      "language": "python"
    },
    {
      "code": "class GraphicsStyle:\n    \"\"\"\n    A class representing various style attributes that determine drawing appearance.\n\n    This class uses the convention that the global Python singleton ellipsis (`...`) is\n    exclusively used to represent values that are inherited from the parent style. This\n    is to disambiguate the value None which is used for several values to signal an\n    explicitly disabled style. An example of this is the fill/stroke color styles,\n    which use None as hints to the auto paint style detection code.\n    \"\"\"\n\n    _PRIVATE_SLOTS = (\n        \"_allow_transparency\",\n        \"_auto_close\",\n        \"_fill_color\",\n        \"_intersection_rule\",\n        \"_paint_rule\",\n        \"_stroke_color\",\n        \"_stroke_dash_pattern\",\n        \"_stroke_dash_phase\",\n    )\n\n    __slots__ = _PRIVATE_SLOTS + tuple(\n        k.value\n        for k in PDFStyleKeys\n        # we do not store STROKE_DASH_PATTERN under its PDF key; it's in _stroke_dash_pattern\n        if k is not PDFStyleKeys.STROKE_DASH_PATTERN\n    )\n\n    INHERIT = ...\n    \"\"\"Singleton specifying a style parameter should be inherited from the parent context.\"\"\"\n\n    # order is be important here because some of these properties are entangled, e.g.\n    # fill_color and fill_opacity\n    MERGE_PROPERTIES = (\n        \"paint_rule\",\n        \"allow_transparency\",\n        \"auto_close\",\n        \"intersection_rule\",\n        \"fill_color\",\n        \"fill_opacity\",\n        \"stroke_color\",\n        \"stroke_opacity\",\n        \"blend_mode\",\n        \"stroke_width\",\n        \"stroke_cap_style\",\n        \"stroke_join_style\",\n        \"stroke_miter_limit\",\n        \"stroke_dash_pattern\",\n        \"stroke_dash_phase\",\n        \"soft_mask\",\n    )\n    \"\"\"An ordered collection of properties to use when merging two GraphicsStyles.\"\"\"\n\n    TRANSPARENCY_KEYS = (\n        PDFStyleKeys.FILL_ALPHA.value,\n        PDFStyleKeys.STROKE_ALPHA.value,\n        PDFStyleKeys.BLEND_MODE.value,\n        PDFStyleKeys.SOFT_MASK.value,\n    )\n    \"\"\"An ordered collection of attributes not to emit in no transparency mode.\"\"\"\n\n    PDF_STYLE_KEYS = (\n        *(k.value for k in PDFStyleKeys if k is not PDFStyleKeys.STROKE_DASH_PATTERN),\n    )\n    \"\"\"An ordered collection of keys to directly emit when serializing the style.\"\"\"\n\n    _PAINT_RULE_LOOKUP: dict[frozenset[str | IntersectionRule], PathPaintRule] = {\n        frozenset({}): PathPaintRule.DONT_PAINT,\n        frozenset({\"stroke\"}): PathPaintRule.STROKE,\n        frozenset({\"fill\", IntersectionRule.NONZERO}): PathPaintRule.FILL_NONZERO,\n        frozenset({\"fill\", IntersectionRule.EVENODD}): PathPaintRule.FILL_EVENODD,\n        frozenset(\n            {\"stroke\", \"fill\", IntersectionRule.NONZERO}\n        ): PathPaintRule.STROKE_FILL_NONZERO,\n        frozenset(\n            {\"stroke\", \"fill\", IntersectionRule.EVENODD}\n        ): PathPaintRule.STROKE_FILL_EVENODD,\n    }\n    \"\"\"A dictionary for resolving `PathPaintRule.AUTO`\"\"\"\n\n    @classmethod\n    def merge(cls, parent: \"GraphicsStyle\", child: \"GraphicsStyle\") -> \"GraphicsStyle\":\n        \"\"\"\n        Merge parent and child into a single GraphicsStyle.\n\n        The result contains the properties of the parent as overridden by any properties\n        explicitly set on the child. If both the parent and the child specify to\n        inherit a given property, that property will preserve the inherit value.\n        \"\"\"\n        new = deepcopy(child)\n        for prop in cls.__slots__:\n            cval = getattr(new, prop)\n            if cval is cls.INHERIT:\n                setattr(new, prop, getattr(parent, prop))\n\n        return new\n\n    def __init__(self) -> None:\n        for key in self.__slots__:\n            setattr(self, key, self.INHERIT)\n\n    def __deepcopy__(self: GS, memo: dict[int, Any]) -> GS:\n        cls = self.__class__\n        new = cls.__new__(cls)  # bypass __init__\n        # copy private slots directly\n        for s in cls._PRIVATE_SLOTS:\n            object.__setattr__(new, s, getattr(self, s, cls.INHERIT))\n        # copy PDF-exposed slots (BM, ca, CA, etc.)\n        for key in cls.PDF_STYLE_KEYS:\n            object.__setattr__(new, key, getattr(self, key, cls.INHERIT))\n        return new\n\n    def __setattr__(self, name: str, value: Any) -> None:\n        try:\n            super().__setattr__(name, value)\n        except AttributeError as e:\n            raise AttributeError(\n                f'{self.__class__} does not have style \"{name}\" (a typo?)'\n            ) from e\n\n    # at some point it probably makes sense to turn this into a general compliance\n    # property, but for now this is the simple approach.\n    @property\n    def allow_transparency(self) -> bool | InheritType:\n        allow_transparency = getattr(self, \"_allow_transparency\", self.INHERIT)\n        if allow_transparency is self.INHERIT:\n            return self.INHERIT\n        return cast(bool, allow_transparency)\n\n    @allow_transparency.setter\n    def allow_transparency(self, new: bool | InheritType) -> None:\n        return super().__setattr__(\"_allow_transparency\", new)\n\n    # If these are used in a nested graphics context inside of a painting path\n    # operation, they are no-ops. However, they can be used for outer GraphicsContexts\n    # that painting paths inherit from.\n    @property\n    def paint_rule(self) -> PathPaintRule | InheritType | None:\n        \"\"\"The paint rule to use for this path/group.\"\"\"\n        paint_rule = getattr(self, \"_paint_rule\", self.INHERIT)\n        if paint_rule is self.INHERIT or paint_rule is None:\n            return paint_rule\n        return cast(PathPaintRule, paint_rule)\n\n    @paint_rule.setter\n    def paint_rule(self, new: PathPaintRule | InheritType | str | None) -> None:\n        if new is None:\n            super().__setattr__(\"_paint_rule\", PathPaintRule.DONT_PAINT)\n        elif isinstance(new, InheritType):\n            super().__setattr__(\"_paint_rule\", new)\n        else:\n            super().__setattr__(\"_paint_rule\", PathPaintRule.coerce(new))\n\n    @property\n    def auto_close(self) -> bool | InheritType:\n        \"\"\"If True, unclosed paths will be automatically closed before stroking.\"\"\"\n        auto_close = getattr(self, \"_auto_close\", self.INHERIT)\n        if auto_close is self.INHERIT:\n            return auto_close\n        return cast(bool, auto_close)\n\n    @auto_close.setter\n    def auto_close(self, new: bool | InheritType) -> None:\n        if new not in {True, False, self.INHERIT}:\n            raise TypeError(f\"auto_close must be a bool or self.INHERIT, not {new}\")\n        super().__setattr__(\"_auto_close\", new)\n\n    @property\n    def intersection_rule(self) -> IntersectionRule | InheritType:\n        \"\"\"The desired intersection rule for this path/group.\"\"\"\n        intersection_rule = getattr(self, \"_intersection_rule\", self.INHERIT)\n        if intersection_rule is self.INHERIT:\n            return intersection_rule\n        return cast(IntersectionRule, intersection_rule)\n\n    @intersection_rule.setter\n    def intersection_rule(self, new: IntersectionRule | InheritType | str) -> None:\n        # don't allow None for this one.\n        if isinstance(new, InheritType):\n            super().__setattr__(\"_intersection_rule\", new)\n        else:\n            super().__setattr__(\"_intersection_rule\", IntersectionRule.coerce(new))\n\n    @property\n    def fill_color(self) -> Color | GradientPaint | InheritType | str | None:\n        \"\"\"\n        The desired fill color for this path/group.\n\n        When setting this property, if the color specifies an opacity value, that will\n        be used to set the fill_opacity property as well.\n        \"\"\"\n        fill_color = getattr(self, \"_fill_color\", self.INHERIT)\n        if fill_color is self.INHERIT or fill_color is None:\n            return fill_color\n        assert isinstance(\n            fill_color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)\n        )\n        return fill_color\n\n    @fill_color.setter\n    def fill_color(\n        self, color: Color | GradientPaint | str | InheritType | None\n    ) -> None:\n        if isinstance(color, str):\n            color = color_from_hex_string(color)\n\n        if isinstance(color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)):\n            super().__setattr__(\"_fill_color\", color)\n            if getattr(color, \"a\", None) is not None and not isinstance(\n                color, GradientPaint\n            ):\n                self.fill_opacity = color.a\n\n        elif (color is None) or (color is self.INHERIT):\n            super().__setattr__(\"_fill_color\", color)\n\n        else:\n            raise TypeError(f\"{color} doesn't look like a drawing color\")\n\n    @property\n    def fill_opacity(self) -> float | InheritType | None:\n        \"\"\"The desired fill opacity for this path/group.\"\"\"\n        fill_opacity = getattr(self, PDFStyleKeys.FILL_ALPHA.value, self.INHERIT)\n        if fill_opacity is self.INHERIT or fill_opacity is None:\n            return fill_opacity\n        return cast(float, fill_opacity)\n\n    @fill_opacity.setter\n    def fill_opacity(self, new: float | InheritType | None) -> None:\n        if new not in {None, self.INHERIT}:\n            assert isinstance(new, NumberClass)\n            check_range(new)\n        super().__setattr__(PDFStyleKeys.FILL_ALPHA.value, new)\n\n    @property\n    def stroke_color(self) -> Color | GradientPaint | InheritType | None:\n        \"\"\"\n        The desired stroke color for this path/group.\n\n        When setting this property, if the color specifies an opacity value, that will\n        be used to set the fill_opacity property as well.\n        \"\"\"\n        stroke_color = getattr(self, \"_stroke_color\", self.INHERIT)\n        if stroke_color is self.INHERIT or stroke_color is None:\n            return stroke_color\n        assert isinstance(\n            stroke_color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)\n        )\n        return stroke_color\n\n    @stroke_color.setter\n    def stroke_color(\n        self, color: Color | GradientPaint | str | InheritType | None\n    ) -> None:\n        if isinstance(color, str):\n            color = color_from_hex_string(color)\n\n        if isinstance(color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)):\n            super().__setattr__(\"_stroke_color\", color)\n            if getattr(color, \"a\", None) is not None and not isinstance(\n                color, GradientPaint\n            ):\n                self.stroke_opacity = color.a\n            if self.stroke_width is self.INHERIT:\n                self.stroke_width = 1\n\n        elif (color is None) or (color is self.INHERIT):\n            super().__setattr__(\"_stroke_color\", color)\n\n        else:\n            raise TypeError(f\"{color} doesn't look like a drawing color\")\n\n    @property\n    def stroke_opacity(self) -> float | InheritType | None:\n        \"\"\"The desired stroke opacity for this path/group.\"\"\"\n        stroke_opacity = getattr(self, PDFStyleKeys.STROKE_ALPHA.value, self.INHERIT)\n        if stroke_opacity is self.INHERIT or stroke_opacity is None:\n            return stroke_opacity\n        assert isinstance(stroke_opacity, NumberClass)\n        return float(stroke_opacity)\n\n    @stroke_opacity.setter\n    def stroke_opacity(self, new: float | InheritType | None) -> None:\n        if new not in (None, self.INHERIT):\n            assert isinstance(new, NumberClass)\n            check_range(new)\n        super().__setattr__(PDFStyleKeys.STROKE_ALPHA.value, new)\n\n    @property\n    def blend_mode(self) -> BlendMode | InheritType:\n        \"\"\"The desired blend mode for this path/group.\"\"\"\n        blend_mode = getattr(self, PDFStyleKeys.BLEND_MODE.value, self.INHERIT)\n        if blend_mode is self.INHERIT:\n            return blend_mode\n        return cast(BlendMode, blend_mode)\n\n    @blend_mode.setter\n    def blend_mode(self, value: BlendMode | str | InheritType) -> None:\n        if isinstance(value, InheritType):\n            super().__setattr__(PDFStyleKeys.BLEND_MODE.value, value)\n        else:\n            super().__setattr__(\n                PDFStyleKeys.BLEND_MODE.value, BlendMode.coerce(value).value\n            )\n\n    @property\n    def stroke_width(self) -> float | InheritType | None:\n        \"\"\"The desired stroke width for this path/group.\"\"\"\n        stroke_width = getattr(self, PDFStyleKeys.STROKE_WIDTH.value, self.INHERIT)\n        if stroke_width is self.INHERIT or stroke_width is None:\n            return stroke_width\n        assert isinstance(stroke_width, NumberClass)\n        return float(stroke_width)\n\n    @stroke_width.setter\n    def stroke_width(self, width: float | InheritType | None) -> None:\n        if width not in (None, self.INHERIT) and not isinstance(width, NumberClass):\n            raise TypeError(f\"stroke_width must be a number, not {type(width)}\")\n        super().__setattr__(PDFStyleKeys.STROKE_WIDTH.value, width)\n\n    @property\n    def stroke_cap_style(self) -> StrokeCapStyle | InheritType:\n        \"\"\"The desired stroke cap style for this path/group.\"\"\"\n        stroke_cap_style = getattr(\n            self, PDFStyleKeys.STROKE_CAP_STYLE.value, self.INHERIT\n        )\n        if stroke_cap_style is self.INHERIT:\n            return stroke_cap_style\n        return cast(StrokeCapStyle, stroke_cap_style)\n\n    @stroke_cap_style.setter\n    def stroke_cap_style(self, value: StrokeCapStyle | str | InheritType) -> None:\n        if isinstance(value, InheritType):\n            super().__setattr__(PDFStyleKeys.STROKE_CAP_STYLE.value, value)\n        else:\n            super().__setattr__(\n                PDFStyleKeys.STROKE_CAP_STYLE.value, StrokeCapStyle.coerce(value)\n            )\n\n    @property\n    def stroke_join_style(self) -> StrokeJoinStyle | InheritType:\n        \"\"\"The desired stroke join style for this path/group.\"\"\"\n        stroke_join_style = getattr(\n            self, PDFStyleKeys.STROKE_JOIN_STYLE.value, self.INHERIT\n        )\n        if stroke_join_style is self.INHERIT:\n            return stroke_join_style\n        return cast(StrokeJoinStyle, stroke_join_style)\n\n    @stroke_join_style.setter\n    def stroke_join_style(self, value: StrokeJoinStyle | str | InheritType) -> None:\n        if isinstance(value, InheritType):\n            super().__setattr__(PDFStyleKeys.STROKE_JOIN_STYLE.value, value)\n        else:\n            super().__setattr__(\n                PDFStyleKeys.STROKE_JOIN_STYLE.value, StrokeJoinStyle.coerce(value)\n            )\n\n    @property\n    def stroke_miter_limit(self) -> float | InheritType:\n        \"\"\"The desired stroke miter limit for this path/group.\"\"\"\n        stroke_miter_limit = getattr(\n            self, PDFStyleKeys.STROKE_MITER_LIMIT.value, self.INHERIT\n        )\n        if stroke_miter_limit is self.INHERIT:\n            return stroke_miter_limit\n        assert isinstance(stroke_miter_limit, NumberClass)\n        return float(stroke_miter_limit)\n\n    @stroke_miter_limit.setter\n    def stroke_miter_limit(self, value: Number | InheritType) -> None:\n        if (value is self.INHERIT) or isinstance(value, NumberClass):\n            super().__setattr__(PDFStyleKeys.STROKE_MITER_LIMIT.value, value)\n        else:\n            raise TypeError(f\"{value} is not a number\")\n\n    @property\n    def stroke_dash_pattern(self) -> Optional[InheritType | tuple[float, ...]]:\n        \"\"\"The desired stroke dash pattern for this path/group.\"\"\"\n        stroke_dash_pattern = getattr(self, \"_stroke_dash_pattern\", self.INHERIT)\n        if stroke_dash_pattern is self.INHERIT:\n            return stroke_dash_pattern\n        return cast(tuple[float, ...], stroke_dash_pattern)\n\n    @stroke_dash_pattern.setter\n    def stroke_dash_pattern(\n        self, value: None | InheritType | Number | Sequence[Number]\n    ) -> None:\n        result: None | InheritType | Number | Sequence[Number]\n        if value is None:\n            result = ()\n        elif isinstance(value, InheritType):\n            result = self.INHERIT\n        elif isinstance(value, NumberClass):\n            result = (float(value),)\n        elif isinstance(value, (str, bytes, bytearray)):\n            raise TypeError(\n                f\"stroke_dash_pattern {value!r} must be a number or sequence of numbers\"\n            )\n        else:\n            try:\n                accum: list[float] = []\n                for item in value:\n                    if isinstance(item, (str, bytes, bytearray)):\n                        raise TypeError\n                    accum.append(float(item))\n            except (TypeError, ValueError):\n                raise TypeError(\n                    f\"stroke_dash_pattern {value!r} must be a number or sequence of numbers\"\n                ) from None\n            result = (*accum,)\n        super().__setattr__(\"_stroke_dash_pattern\", result)\n\n    @property\n    def stroke_dash_phase(self) -> InheritType | float:\n        \"\"\"The desired stroke dash pattern phase offset for this path/group.\"\"\"\n        stroke_dash_phase = getattr(self, \"_stroke_dash_phase\", self.INHERIT)\n        if stroke_dash_phase is self.INHERIT:\n            return stroke_dash_phase\n        assert isinstance(stroke_dash_phase, NumberClass)\n        return float(stroke_dash_phase)\n\n    @stroke_dash_phase.setter\n    def stroke_dash_phase(self, value: InheritType | Number) -> None:\n        if value is self.INHERIT or isinstance(value, NumberClass):\n            return super().__setattr__(\"_stroke_dash_phase\", value)\n\n        raise TypeError(f\"{value} isn't a number or GraphicsStyle.INHERIT\")\n\n    @property\n    def soft_mask(self) -> Union[InheritType, \"PaintSoftMask\"]:\n        paint_soft_mask = getattr(self, PDFStyleKeys.SOFT_MASK.value, self.INHERIT)\n        if paint_soft_mask is self.INHERIT:\n            return paint_soft_mask\n        return cast(PaintSoftMask, paint_soft_mask)\n\n    @soft_mask.setter\n    def soft_mask(self, value: Union[InheritType, \"PaintSoftMask\"]) -> None:\n        if value is self.INHERIT or isinstance(value, PaintSoftMask):\n            return super().__setattr__(PDFStyleKeys.SOFT_MASK.value, value)\n        raise TypeError(f\"{value} isn't a PaintSoftMask or GraphicsStyle.INHERIT\")\n\n    def serialize(self) -> Optional[Raw]:\n        \"\"\"\n        Convert this style object to a PDF dictionary with appropriate style keys.\n\n        Only explicitly specified values are emitted.\n        \"\"\"\n        result: dict[Name, Any] = OrderedDict()\n\n        for key in self.PDF_STYLE_KEYS:\n            value = getattr(self, key, self.INHERIT)\n\n            if (value is not self.INHERIT) and (value is not None):\n                # None is used for out-of-band signaling on these, e.g. a stroke_width\n                # of None doesn't need to land here because it signals the\n                # PathPaintRule auto resolution only.\n                result[key] = value\n\n        # There is additional logic in GraphicsContext to ensure that this will work\n        if self.stroke_dash_pattern and self.stroke_dash_pattern is not self.INHERIT:\n            result[PDFStyleKeys.STROKE_DASH_PATTERN.value] = [\n                self.stroke_dash_pattern,\n                self.stroke_dash_phase,\n            ]\n\n        if self.allow_transparency is False:\n            for key in self.TRANSPARENCY_KEYS:\n                if key in result:\n                    del result[key]\n\n        if result:\n            # Only insert this key if there is at least one other item in the result so\n            # that we don't junk up the output PDF with empty ExtGState dictionaries.\n            type_name = Name(\"Type\")\n            result[type_name] = Name(\"ExtGState\")\n            result.move_to_end(type_name, last=False)  # type: ignore[attr-defined]\n\n            return render_pdf_primitive(result)\n\n        # this signals to the graphics state registry that there is nothing to\n        # register. This is a success case.\n        return None\n\n    @force_nodocument\n    def resolve_paint_rule(self) -> PathPaintRule:\n        \"\"\"\n        Resolve `PathPaintRule.AUTO` to a real paint rule based on this style.\n\n        Returns:\n            the resolved `PathPaintRule`.\n        \"\"\"\n        if self.paint_rule is PathPaintRule.AUTO:\n            want: set[str | IntersectionRule] = set()\n            stroke_color = self.stroke_color\n            if self.stroke_width is not None and stroke_color is not None:\n                want.add(\"stroke\")\n            fill_color = self.fill_color\n            if fill_color is not None:\n                intersection_rule = (\n                    self.intersection_rule\n                    if isinstance(self.intersection_rule, IntersectionRule)\n                    else IntersectionRule.NONZERO\n                )\n                want.add(\"fill\")\n                # we need to guarantee that this will not be None. The default will\n                # be \"nonzero\".\n                want.add(intersection_rule)\n\n            try:\n                paint_rule: PathPaintRule = self._PAINT_RULE_LOOKUP[frozenset(want)]\n            except KeyError:\n                # don't default to DONT_PAINT because that's almost certainly not a very\n                # good default.\n                paint_rule = PathPaintRule.STROKE_FILL_NONZERO\n            return paint_rule\n\n        if isinstance(self.paint_rule, InheritType) or self.paint_rule is None:\n            # this shouldn't happen under normal usage, but certain API (ab)use can end\n            # up in this state. We can't resolve anything meaningful, so fall back to a\n            # sane(?) default.\n            return PathPaintRule.STROKE_FILL_NONZERO\n\n        return self.paint_rule",
      "language": "python"
    },
    {
      "code": "@property\ndef fill_color(self) -> Color | GradientPaint | InheritType | str | None:\n    \"\"\"\n    The desired fill color for this path/group.\n\n    When setting this property, if the color specifies an opacity value, that will\n    be used to set the fill_opacity property as well.\n    \"\"\"\n    fill_color = getattr(self, \"_fill_color\", self.INHERIT)\n    if fill_color is self.INHERIT or fill_color is None:\n        return fill_color\n    assert isinstance(\n        fill_color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)\n    )\n    return fill_color",
      "language": "python"
    },
    {
      "code": "@property\ndef fill_opacity(self) -> float | InheritType | None:\n    \"\"\"The desired fill opacity for this path/group.\"\"\"\n    fill_opacity = getattr(self, PDFStyleKeys.FILL_ALPHA.value, self.INHERIT)\n    if fill_opacity is self.INHERIT or fill_opacity is None:\n        return fill_opacity\n    return cast(float, fill_opacity)",
      "language": "python"
    },
    {
      "code": "@property\ndef intersection_rule(self) -> IntersectionRule | InheritType:\n    \"\"\"The desired intersection rule for this path/group.\"\"\"\n    intersection_rule = getattr(self, \"_intersection_rule\", self.INHERIT)\n    if intersection_rule is self.INHERIT:\n        return intersection_rule\n    return cast(IntersectionRule, intersection_rule)",
      "language": "python"
    },
    {
      "code": "@property\ndef paint_rule(self) -> PathPaintRule | InheritType | None:\n    \"\"\"The paint rule to use for this path/group.\"\"\"\n    paint_rule = getattr(self, \"_paint_rule\", self.INHERIT)\n    if paint_rule is self.INHERIT or paint_rule is None:\n        return paint_rule\n    return cast(PathPaintRule, paint_rule)",
      "language": "python"
    },
    {
      "code": "@property\ndef soft_mask(self) -> Union[InheritType, \"PaintSoftMask\"]:\n    paint_soft_mask = getattr(self, PDFStyleKeys.SOFT_MASK.value, self.INHERIT)\n    if paint_soft_mask is self.INHERIT:\n        return paint_soft_mask\n    return cast(PaintSoftMask, paint_soft_mask)",
      "language": "python"
    },
    {
      "code": "@property\ndef stroke_cap_style(self) -> StrokeCapStyle | InheritType:\n    \"\"\"The desired stroke cap style for this path/group.\"\"\"\n    stroke_cap_style = getattr(\n        self, PDFStyleKeys.STROKE_CAP_STYLE.value, self.INHERIT\n    )\n    if stroke_cap_style is self.INHERIT:\n        return stroke_cap_style\n    return cast(StrokeCapStyle, stroke_cap_style)",
      "language": "python"
    },
    {
      "code": "@property\ndef stroke_color(self) -> Color | GradientPaint | InheritType | None:\n    \"\"\"\n    The desired stroke color for this path/group.\n\n    When setting this property, if the color specifies an opacity value, that will\n    be used to set the fill_opacity property as well.\n    \"\"\"\n    stroke_color = getattr(self, \"_stroke_color\", self.INHERIT)\n    if stroke_color is self.INHERIT or stroke_color is None:\n        return stroke_color\n    assert isinstance(\n        stroke_color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)\n    )\n    return stroke_color",
      "language": "python"
    },
    {
      "code": "@property\ndef stroke_dash_pattern(self) -> Optional[InheritType | tuple[float, ...]]:\n    \"\"\"The desired stroke dash pattern for this path/group.\"\"\"\n    stroke_dash_pattern = getattr(self, \"_stroke_dash_pattern\", self.INHERIT)\n    if stroke_dash_pattern is self.INHERIT:\n        return stroke_dash_pattern\n    return cast(tuple[float, ...], stroke_dash_pattern)",
      "language": "python"
    },
    {
      "code": "@property\ndef stroke_dash_phase(self) -> InheritType | float:\n    \"\"\"The desired stroke dash pattern phase offset for this path/group.\"\"\"\n    stroke_dash_phase = getattr(self, \"_stroke_dash_phase\", self.INHERIT)\n    if stroke_dash_phase is self.INHERIT:\n        return stroke_dash_phase\n    assert isinstance(stroke_dash_phase, NumberClass)\n    return float(stroke_dash_phase)",
      "language": "python"
    },
    {
      "code": "@property\ndef stroke_join_style(self) -> StrokeJoinStyle | InheritType:\n    \"\"\"The desired stroke join style for this path/group.\"\"\"\n    stroke_join_style = getattr(\n        self, PDFStyleKeys.STROKE_JOIN_STYLE.value, self.INHERIT\n    )\n    if stroke_join_style is self.INHERIT:\n        return stroke_join_style\n    return cast(StrokeJoinStyle, stroke_join_style)",
      "language": "python"
    },
    {
      "code": "@property\ndef stroke_miter_limit(self) -> float | InheritType:\n    \"\"\"The desired stroke miter limit for this path/group.\"\"\"\n    stroke_miter_limit = getattr(\n        self, PDFStyleKeys.STROKE_MITER_LIMIT.value, self.INHERIT\n    )\n    if stroke_miter_limit is self.INHERIT:\n        return stroke_miter_limit\n    assert isinstance(stroke_miter_limit, NumberClass)\n    return float(stroke_miter_limit)",
      "language": "python"
    },
    {
      "code": "@property\ndef stroke_opacity(self) -> float | InheritType | None:\n    \"\"\"The desired stroke opacity for this path/group.\"\"\"\n    stroke_opacity = getattr(self, PDFStyleKeys.STROKE_ALPHA.value, self.INHERIT)\n    if stroke_opacity is self.INHERIT or stroke_opacity is None:\n        return stroke_opacity\n    assert isinstance(stroke_opacity, NumberClass)\n    return float(stroke_opacity)",
      "language": "python"
    },
    {
      "code": "@property\ndef stroke_width(self) -> float | InheritType | None:\n    \"\"\"The desired stroke width for this path/group.\"\"\"\n    stroke_width = getattr(self, PDFStyleKeys.STROKE_WIDTH.value, self.INHERIT)\n    if stroke_width is self.INHERIT or stroke_width is None:\n        return stroke_width\n    assert isinstance(stroke_width, NumberClass)\n    return float(stroke_width)",
      "language": "python"
    },
    {
      "code": "@force_nodocument\ndef resolve_paint_rule(self) -> PathPaintRule:\n    \"\"\"\n    Resolve `PathPaintRule.AUTO` to a real paint rule based on this style.\n\n    Returns:\n        the resolved `PathPaintRule`.\n    \"\"\"\n    if self.paint_rule is PathPaintRule.AUTO:\n        want: set[str | IntersectionRule] = set()\n        stroke_color = self.stroke_color\n        if self.stroke_width is not None and stroke_color is not None:\n            want.add(\"stroke\")\n        fill_color = self.fill_color\n        if fill_color is not None:\n            intersection_rule = (\n                self.intersection_rule\n                if isinstance(self.intersection_rule, IntersectionRule)\n                else IntersectionRule.NONZERO\n            )\n            want.add(\"fill\")\n            # we need to guarantee that this will not be None. The default will\n            # be \"nonzero\".\n            want.add(intersection_rule)\n\n        try:\n            paint_rule: PathPaintRule = self._PAINT_RULE_LOOKUP[frozenset(want)]\n        except KeyError:\n            # don't default to DONT_PAINT because that's almost certainly not a very\n            # good default.\n            paint_rule = PathPaintRule.STROKE_FILL_NONZERO\n        return paint_rule\n\n    if isinstance(self.paint_rule, InheritType) or self.paint_rule is None:\n        # this shouldn't happen under normal usage, but certain API (ab)use can end\n        # up in this state. We can't resolve anything meaningful, so fall back to a\n        # sane(?) default.\n        return PathPaintRule.STROKE_FILL_NONZERO\n\n    return self.paint_rule",
      "language": "python"
    },
    {
      "code": "def serialize(self) -> Optional[Raw]:\n    \"\"\"\n    Convert this style object to a PDF dictionary with appropriate style keys.\n\n    Only explicitly specified values are emitted.\n    \"\"\"\n    result: dict[Name, Any] = OrderedDict()\n\n    for key in self.PDF_STYLE_KEYS:\n        value = getattr(self, key, self.INHERIT)\n\n        if (value is not self.INHERIT) and (value is not None):\n            # None is used for out-of-band signaling on these, e.g. a stroke_width\n            # of None doesn't need to land here because it signals the\n            # PathPaintRule auto resolution only.\n            result[key] = value\n\n    # There is additional logic in GraphicsContext to ensure that this will work\n    if self.stroke_dash_pattern and self.stroke_dash_pattern is not self.INHERIT:\n        result[PDFStyleKeys.STROKE_DASH_PATTERN.value] = [\n            self.stroke_dash_pattern,\n            self.stroke_dash_phase,\n        ]\n\n    if self.allow_transparency is False:\n        for key in self.TRANSPARENCY_KEYS:\n            if key in result:\n                del result[key]\n\n    if result:\n        # Only insert this key if there is at least one other item in the result so\n        # that we don't junk up the output PDF with empty ExtGState dictionaries.\n        type_name = Name(\"Type\")\n        result[type_name] = Name(\"ExtGState\")\n        result.move_to_end(type_name, last=False)  # type: ignore[attr-defined]\n\n        return render_pdf_primitive(result)\n\n    # this signals to the graphics state registry that there is nothing to\n    # register. This is a success case.\n    return None",
      "language": "python"
    },
    {
      "code": "class HorizontalLine(NamedTuple):\n    \"\"\"\n    A path line element that takes its ordinate from the end of the previous element.\n\n    See: `PaintedPath.horizontal_line_to`\n    \"\"\"\n\n    x: Number\n    \"\"\"The abscissa of the horizontal line's end point.\"\"\"\n\n    @property\n    def end_point(self) -> Point:\n        raise NotImplementedError\n\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        \"\"\"Compute the bounding box of a horizontal line from the start point to the new x.\"\"\"\n        end = Point(float(self.x), start.y)\n        return BoundingBox.from_points([start, end]), end\n\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        \"\"\"\n        Render this path element to its PDF representation.\n\n        Args:\n            resource_registry (ResourceCatalog): the owner's graphics state\n                dictionary registry.\n            style (GraphicsStyle): the current resolved graphics style\n            last_item: the previous path element.\n            initial_point: last position set by a \"M\" or \"m\" command\n\n        Returns:\n            a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved\n            `Line`.\n        \"\"\"\n        # pylint: disable=unused-argument\n        end_point = Point(x=float(self.x), y=float(last_item.end_point.y))\n        return _render_line(end_point), Line(end_point), initial_point",
      "language": "python"
    },
    {
      "code": "@property\ndef end_point(self) -> Point:\n    raise NotImplementedError",
      "language": "python"
    },
    {
      "code": "class HorizontalLine(NamedTuple):\n    \"\"\"\n    A path line element that takes its ordinate from the end of the previous element.\n\n    See: `PaintedPath.horizontal_line_to`\n    \"\"\"\n\n    x: Number\n    \"\"\"The abscissa of the horizontal line's end point.\"\"\"\n\n    @property\n    def end_point(self) -> Point:\n        raise NotImplementedError\n\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        \"\"\"Compute the bounding box of a horizontal line from the start point to the new x.\"\"\"\n        end = Point(float(self.x), start.y)\n        return BoundingBox.from_points([start, end]), end\n\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        \"\"\"\n        Render this path element to its PDF representation.\n\n        Args:\n            resource_registry (ResourceCatalog): the owner's graphics state\n                dictionary registry.\n            style (GraphicsStyle): the current resolved graphics style\n            last_item: the previous path element.\n            initial_point: last position set by a \"M\" or \"m\" command\n\n        Returns:\n            a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved\n            `Line`.\n        \"\"\"\n        # pylint: disable=unused-argument\n        end_point = Point(x=float(self.x), y=float(last_item.end_point.y))\n        return _render_line(end_point), Line(end_point), initial_point",
      "language": "python"
    },
    {
      "code": "def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n    \"\"\"Compute the bounding box of a horizontal line from the start point to the new x.\"\"\"\n    end = Point(float(self.x), start.y)\n    return BoundingBox.from_points([start, end]), end",
      "language": "python"
    },
    {
      "code": "@force_nodocument\ndef render(\n    self,\n    resource_registry: \"ResourceCatalog\",\n    style: GraphicsStyle,\n    last_item: Renderable,\n    initial_point: Point,\n) -> tuple[str, Renderable, Point]:\n    \"\"\"\n    Render this path element to its PDF representation.\n\n    Args:\n        resource_registry (ResourceCatalog): the owner's graphics state\n            dictionary registry.\n        style (GraphicsStyle): the current resolved graphics style\n        last_item: the previous path element.\n        initial_point: last position set by a \"M\" or \"m\" command\n\n    Returns:\n        a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved\n        `Line`.\n    \"\"\"\n    # pylint: disable=unused-argument\n    end_point = Point(x=float(self.x), y=float(last_item.end_point.y))\n    return _render_line(end_point), Line(end_point), initial_point",
      "language": "python"
    },
    {
      "code": "class ImplicitClose(NamedTuple):\n    \"\"\"\n    A path close element that is conditionally rendered depending on the value of\n    `GraphicsStyle.auto_close`.\n    \"\"\"\n\n    @property\n    def end_point(self) -> Point:\n        raise NotImplementedError\n\n    # pylint: disable=no-self-use\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        \"\"\"Return an empty bounding box; Close does not affect the geometry.\"\"\"\n        return BoundingBox.empty(), start\n\n    # pylint: disable=no-self-use\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        \"\"\"\n        Render this path element to its PDF representation.\n\n        Args:\n            resource_registry (ResourceCatalog): the owner's graphics state\n                dictionary registry.\n            style (GraphicsStyle): the current resolved graphics style\n            last_item: the previous path element.\n            initial_point: last position set by a \"M\" or \"m\" command\n\n        Returns:\n            a tuple of `(str, new_last_item)`, where `new_last_item` is whatever the old\n            last_item was.\n        \"\"\"\n        # pylint: disable=unused-argument\n        if style.auto_close:\n            return \"h\", last_item, initial_point\n\n        return \"\", last_item, initial_point",
      "language": "python"
    },
    {
      "code": "@property\ndef end_point(self) -> Point:\n    raise NotImplementedError",
      "language": "python"
    },
    {
      "code": "def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n    \"\"\"Return an empty bounding box; Close does not affect the geometry.\"\"\"\n    return BoundingBox.empty(), start",
      "language": "python"
    },
    {
      "code": "@force_nodocument\ndef render(\n    self,\n    resource_registry: \"ResourceCatalog\",\n    style: GraphicsStyle,\n    last_item: Renderable,\n    initial_point: Point,\n) -> tuple[str, Renderable, Point]:\n    \"\"\"\n    Render this path element to its PDF representation.\n\n    Args:\n        resource_registry (ResourceCatalog): the owner's graphics state\n            dictionary registry.\n        style (GraphicsStyle): the current resolved graphics style\n        last_item: the previous path element.\n        initial_point: last position set by a \"M\" or \"m\" command\n\n    Returns:\n        a tuple of `(str, new_last_item)`, where `new_last_item` is whatever the old\n        last_item was.\n    \"\"\"\n    # pylint: disable=unused-argument\n    if style.auto_close:\n        return \"h\", last_item, initial_point\n\n    return \"\", last_item, initial_point",
      "language": "python"
    },
    {
      "code": "class Line(NamedTuple):\n    \"\"\"\n    A path line element.\n\n    This draws a straight line from the end point of the previous path element to the\n    point specified by `pt`.\n\n    See: `PaintedPath.line_to`\n    \"\"\"\n\n    pt: Point\n    \"\"\"The point to which the line is drawn.\"\"\"\n\n    @property\n    def end_point(self) -> Point:\n        \"\"\"The end point of this path element.\"\"\"\n        return self.pt\n\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        \"\"\"Compute the bounding box of a line from the start point to the end point.\"\"\"\n        return BoundingBox.from_points([start, self.pt]), self.pt\n\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        \"\"\"\n        Render this path element to its PDF representation.\n\n        Args:\n            resource_registry (ResourceCatalog): the owner's graphics state\n                dictionary registry.\n            style (GraphicsStyle): the current resolved graphics style\n            last_item: the previous path element.\n            initial_point: last position set by a \"M\" or \"m\" command\n\n        Returns:\n            a tuple of `(str, new_last_item)`, where `new_last_item` is `self`\n        \"\"\"\n        # pylint: disable=unused-argument\n        return _render_line(self.pt), self, initial_point",
      "language": "python"
    },
    {
      "code": "@property\ndef end_point(self) -> Point:\n    \"\"\"The end point of this path element.\"\"\"\n    return self.pt",
      "language": "python"
    },
    {
      "code": "class Line(NamedTuple):\n    \"\"\"\n    A path line element.\n\n    This draws a straight line from the end point of the previous path element to the\n    point specified by `pt`.\n\n    See: `PaintedPath.line_to`\n    \"\"\"\n\n    pt: Point\n    \"\"\"The point to which the line is drawn.\"\"\"\n\n    @property\n    def end_point(self) -> Point:\n        \"\"\"The end point of this path element.\"\"\"\n        return self.pt\n\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        \"\"\"Compute the bounding box of a line from the start point to the end point.\"\"\"\n        return BoundingBox.from_points([start, self.pt]), self.pt\n\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        \"\"\"\n        Render this path element to its PDF representation.\n\n        Args:\n            resource_registry (ResourceCatalog): the owner's graphics state\n                dictionary registry.\n            style (GraphicsStyle): the current resolved graphics style\n            last_item: the previous path element.\n            initial_point: last position set by a \"M\" or \"m\" command\n\n        Returns:\n            a tuple of `(str, new_last_item)`, where `new_last_item` is `self`\n        \"\"\"\n        # pylint: disable=unused-argument\n        return _render_line(self.pt), self, initial_point",
      "language": "python"
    },
    {
      "code": "def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n    \"\"\"Compute the bounding box of a line from the start point to the end point.\"\"\"\n    return BoundingBox.from_points([start, self.pt]), self.pt",
      "language": "python"
    },
    {
      "code": "@force_nodocument\ndef render(\n    self,\n    resource_registry: \"ResourceCatalog\",\n    style: GraphicsStyle,\n    last_item: Renderable,\n    initial_point: Point,\n) -> tuple[str, Renderable, Point]:\n    \"\"\"\n    Render this path element to its PDF representation.\n\n    Args:\n        resource_registry (ResourceCatalog): the owner's graphics state\n            dictionary registry.\n        style (GraphicsStyle): the current resolved graphics style\n        last_item: the previous path element.\n        initial_point: last position set by a \"M\" or \"m\" command\n\n    Returns:\n        a tuple of `(str, new_last_item)`, where `new_last_item` is `self`\n    \"\"\"\n    # pylint: disable=unused-argument\n    return _render_line(self.pt), self, initial_point",
      "language": "python"
    },
    {
      "code": "class Move(NamedTuple):\n    \"\"\"\n    A path move element.\n\n    If a path has been created but not yet painted, this will create a new subpath.\n\n    See: `PaintedPath.move_to`\n    \"\"\"\n\n    pt: Point\n    \"\"\"The point to which to move.\"\"\"\n\n    @property\n    def end_point(self) -> Point:\n        \"\"\"The end point of this path element.\"\"\"\n        return self.pt\n\n    # pylint: disable=unused-argument\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        bbox = BoundingBox.empty()\n        return bbox, self.pt\n\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        \"\"\"\n        Render this path element to its PDF representation.\n\n        Args:\n            resource_registry (ResourceCatalog): the owner's graphics state\n                dictionary registry.\n            style (GraphicsStyle): the current resolved graphics style\n            last_item: the previous path element.\n            initial_point: last position set by a \"M\" or \"m\" command\n\n        Returns:\n            a tuple of `(str, new_last_item)`, where `new_last_item` is `self`\n        \"\"\"\n        return _render_move(self.pt), self, self.pt",
      "language": "python"
    },
    {
      "code": "@property\ndef end_point(self) -> Point:\n    \"\"\"The end point of this path element.\"\"\"\n    return self.pt",
      "language": "python"
    },
    {
      "code": "class Move(NamedTuple):\n    \"\"\"\n    A path move element.\n\n    If a path has been created but not yet painted, this will create a new subpath.\n\n    See: `PaintedPath.move_to`\n    \"\"\"\n\n    pt: Point\n    \"\"\"The point to which to move.\"\"\"\n\n    @property\n    def end_point(self) -> Point:\n        \"\"\"The end point of this path element.\"\"\"\n        return self.pt\n\n    # pylint: disable=unused-argument\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        bbox = BoundingBox.empty()\n        return bbox, self.pt\n\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        \"\"\"\n        Render this path element to its PDF representation.\n\n        Args:\n            resource_registry (ResourceCatalog): the owner's graphics state\n                dictionary registry.\n            style (GraphicsStyle): the current resolved graphics style\n            last_item: the previous path element.\n            initial_point: last position set by a \"M\" or \"m\" command\n\n        Returns:\n            a tuple of `(str, new_last_item)`, where `new_last_item` is `self`\n        \"\"\"\n        return _render_move(self.pt), self, self.pt",
      "language": "python"
    },
    {
      "code": "def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n    bbox = BoundingBox.empty()\n    return bbox, self.pt",
      "language": "python"
    },
    {
      "code": "@force_nodocument\ndef render(\n    self,\n    resource_registry: \"ResourceCatalog\",\n    style: GraphicsStyle,\n    last_item: Renderable,\n    initial_point: Point,\n) -> tuple[str, Renderable, Point]:\n    \"\"\"\n    Render this path element to its PDF representation.\n\n    Args:\n        resource_registry (ResourceCatalog): the owner's graphics state\n            dictionary registry.\n        style (GraphicsStyle): the current resolved graphics style\n        last_item: the previous path element.\n        initial_point: last position set by a \"M\" or \"m\" command\n\n    Returns:\n        a tuple of `(str, new_last_item)`, where `new_last_item` is `self`\n    \"\"\"\n    return _render_move(self.pt), self, self.pt",
      "language": "python"
    },
    {
      "code": "class PaintBlendComposite:\n    __slots__ = (\"backdrop\", \"source\", \"blend_mode\", \"_form_index\")\n\n    def __init__(\n        self,\n        backdrop: GraphicsContext | PaintedPath,\n        source: GraphicsContext | PaintedPath,\n        blend_mode: BlendMode,\n    ) -> None:\n        self.backdrop: Optional[GraphicsContext | PaintedPath] = backdrop\n        self.source: Optional[GraphicsContext | PaintedPath] = source\n        self.blend_mode: BlendMode = blend_mode\n        self._form_index: Optional[int] = None\n\n    def _ensure_form_index(\n        self, resource_registry: \"ResourceCatalog\", base_style: GraphicsStyle\n    ) -> int:\n        if self._form_index is not None:\n            return self._form_index\n\n        group = GraphicsContext()\n        backdrop_node = self.backdrop\n        source_node = self.source\n\n        assert isinstance(backdrop_node, (GraphicsContext, PaintedPath))\n        assert isinstance(source_node, (GraphicsContext, PaintedPath))\n\n        source_node.style.blend_mode = self.blend_mode\n        if source_node.style.allow_transparency is False:\n            source_node.style.allow_transparency = GraphicsStyle.INHERIT\n\n        group.add_item(backdrop_node, clone=False)\n        group.add_item(source_node, clone=False)\n\n        effective_style = base_style\n        blend_group = BlendGroup(group, effective_style)\n        self._form_index = resource_registry.register_blend_form(blend_group)\n        self.backdrop = None\n        self.source = None\n        return self._form_index\n\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        form_index = self._ensure_form_index(resource_registry, style)\n        rendered = f\"q /I{form_index} Do Q\"\n        return rendered, last_item, initial_point",
      "language": "python"
    },
    {
      "code": "class PaintBlendComposite:\n    __slots__ = (\"backdrop\", \"source\", \"blend_mode\", \"_form_index\")\n\n    def __init__(\n        self,\n        backdrop: GraphicsContext | PaintedPath,\n        source: GraphicsContext | PaintedPath,\n        blend_mode: BlendMode,\n    ) -> None:\n        self.backdrop: Optional[GraphicsContext | PaintedPath] = backdrop\n        self.source: Optional[GraphicsContext | PaintedPath] = source\n        self.blend_mode: BlendMode = blend_mode\n        self._form_index: Optional[int] = None\n\n    def _ensure_form_index(\n        self, resource_registry: \"ResourceCatalog\", base_style: GraphicsStyle\n    ) -> int:\n        if self._form_index is not None:\n            return self._form_index\n\n        group = GraphicsContext()\n        backdrop_node = self.backdrop\n        source_node = self.source\n\n        assert isinstance(backdrop_node, (GraphicsContext, PaintedPath))\n        assert isinstance(source_node, (GraphicsContext, PaintedPath))\n\n        source_node.style.blend_mode = self.blend_mode\n        if source_node.style.allow_transparency is False:\n            source_node.style.allow_transparency = GraphicsStyle.INHERIT\n\n        group.add_item(backdrop_node, clone=False)\n        group.add_item(source_node, clone=False)\n\n        effective_style = base_style\n        blend_group = BlendGroup(group, effective_style)\n        self._form_index = resource_registry.register_blend_form(blend_group)\n        self.backdrop = None\n        self.source = None\n        return self._form_index\n\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        form_index = self._ensure_form_index(resource_registry, style)\n        rendered = f\"q /I{form_index} Do Q\"\n        return rendered, last_item, initial_point",
      "language": "python"
    },
    {
      "code": "class PaintBlendComposite:\n    __slots__ = (\"backdrop\", \"source\", \"blend_mode\", \"_form_index\")\n\n    def __init__(\n        self,\n        backdrop: GraphicsContext | PaintedPath,\n        source: GraphicsContext | PaintedPath,\n        blend_mode: BlendMode,\n    ) -> None:\n        self.backdrop: Optional[GraphicsContext | PaintedPath] = backdrop\n        self.source: Optional[GraphicsContext | PaintedPath] = source\n        self.blend_mode: BlendMode = blend_mode\n        self._form_index: Optional[int] = None\n\n    def _ensure_form_index(\n        self, resource_registry: \"ResourceCatalog\", base_style: GraphicsStyle\n    ) -> int:\n        if self._form_index is not None:\n            return self._form_index\n\n        group = GraphicsContext()\n        backdrop_node = self.backdrop\n        source_node = self.source\n\n        assert isinstance(backdrop_node, (GraphicsContext, PaintedPath))\n        assert isinstance(source_node, (GraphicsContext, PaintedPath))\n\n        source_node.style.blend_mode = self.blend_mode\n        if source_node.style.allow_transparency is False:\n            source_node.style.allow_transparency = GraphicsStyle.INHERIT\n\n        group.add_item(backdrop_node, clone=False)\n        group.add_item(source_node, clone=False)\n\n        effective_style = base_style\n        blend_group = BlendGroup(group, effective_style)\n        self._form_index = resource_registry.register_blend_form(blend_group)\n        self.backdrop = None\n        self.source = None\n        return self._form_index\n\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        form_index = self._ensure_form_index(resource_registry, style)\n        rendered = f\"q /I{form_index} Do Q\"\n        return rendered, last_item, initial_point",
      "language": "python"
    },
    {
      "code": "class PaintBlendComposite:\n    __slots__ = (\"backdrop\", \"source\", \"blend_mode\", \"_form_index\")\n\n    def __init__(\n        self,\n        backdrop: GraphicsContext | PaintedPath,\n        source: GraphicsContext | PaintedPath,\n        blend_mode: BlendMode,\n    ) -> None:\n        self.backdrop: Optional[GraphicsContext | PaintedPath] = backdrop\n        self.source: Optional[GraphicsContext | PaintedPath] = source\n        self.blend_mode: BlendMode = blend_mode\n        self._form_index: Optional[int] = None\n\n    def _ensure_form_index(\n        self, resource_registry: \"ResourceCatalog\", base_style: GraphicsStyle\n    ) -> int:\n        if self._form_index is not None:\n            return self._form_index\n\n        group = GraphicsContext()\n        backdrop_node = self.backdrop\n        source_node = self.source\n\n        assert isinstance(backdrop_node, (GraphicsContext, PaintedPath))\n        assert isinstance(source_node, (GraphicsContext, PaintedPath))\n\n        source_node.style.blend_mode = self.blend_mode\n        if source_node.style.allow_transparency is False:\n            source_node.style.allow_transparency = GraphicsStyle.INHERIT\n\n        group.add_item(backdrop_node, clone=False)\n        group.add_item(source_node, clone=False)\n\n        effective_style = base_style\n        blend_group = BlendGroup(group, effective_style)\n        self._form_index = resource_registry.register_blend_form(blend_group)\n        self.backdrop = None\n        self.source = None\n        return self._form_index\n\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        form_index = self._ensure_form_index(resource_registry, style)\n        rendered = f\"q /I{form_index} Do Q\"\n        return rendered, last_item, initial_point",
      "language": "python"
    },
    {
      "code": "def render(\n    self,\n    resource_registry: \"ResourceCatalog\",\n    style: GraphicsStyle,\n    last_item: Renderable,\n    initial_point: Point,\n) -> tuple[str, Renderable, Point]:\n    form_index = self._ensure_form_index(resource_registry, style)\n    rendered = f\"q /I{form_index} Do Q\"\n    return rendered, last_item, initial_point",
      "language": "python"
    },
    {
      "code": "class PaintComposite:\n\n    @dataclass(frozen=True)\n    class _Step:\n        draw: str  # \"source\" or \"backdrop\"\n        mask_from: Optional[str]  # \"source\" | \"backdrop\" | None\n        invert: bool = False\n\n    _MODES = {\n        CompositingOperation.SOURCE: (_Step(\"source\", None),),\n        CompositingOperation.DESTINATION: (_Step(\"backdrop\", None),),\n        CompositingOperation.SOURCE_OVER: (\n            _Step(\"backdrop\", None),\n            _Step(\"source\", None),\n        ),\n        CompositingOperation.DESTINATION_OVER: (\n            _Step(\"source\", None),\n            _Step(\"backdrop\", None),\n        ),\n        CompositingOperation.SOURCE_IN: (_Step(\"source\", \"backdrop\"),),\n        CompositingOperation.DESTINATION_IN: (_Step(\"backdrop\", \"source\"),),\n        CompositingOperation.SOURCE_OUT: (_Step(\"source\", \"backdrop\", True),),\n        CompositingOperation.DESTINATION_OUT: (_Step(\"backdrop\", \"source\", True),),\n        CompositingOperation.SOURCE_ATOP: (\n            _Step(\"backdrop\", \"source\", True),\n            _Step(\"source\", \"backdrop\"),\n        ),\n        CompositingOperation.DESTINATION_ATOP: (\n            _Step(\"source\", \"backdrop\", True),\n            _Step(\"backdrop\", \"source\"),\n        ),\n        CompositingOperation.XOR: (\n            _Step(\"source\", \"backdrop\", True),\n            _Step(\"backdrop\", \"source\", True),\n        ),\n        CompositingOperation.CLEAR: tuple(),\n    }\n\n    def __init__(\n        self,\n        backdrop: PaintedPath | GraphicsContext,\n        source: PaintedPath | GraphicsContext,\n        operation: CompositingOperation,\n    ):\n        self.backdrop = backdrop\n        self.source = source\n        self.mode = operation\n\n        if self.mode not in self._MODES:\n            raise NotImplementedError(\n                f\"Compositing mode '{self.mode.value}' is not yet supported.\"\n            )\n\n    @classmethod\n    def _with_mask(\n        cls,\n        path: Union[PaintedPath, GraphicsContext],\n        mask_from: Union[PaintedPath, GraphicsContext],\n        invert: bool,\n        resource_registry: \"ResourceCatalog\",\n    ) -> PaintedPath | GraphicsContext:\n        p = deepcopy(path)\n\n        A = PaintSoftMask.alpha_layers_from(p)\n        B = PaintSoftMask.coverage_white(mask_from)\n\n        bb_p = p.bounding_box(Point(0, 0), expand_for_stroke=False)[0]\n        bb_B = B.bounding_box(Point(0, 0), expand_for_stroke=False)[0]\n        region_bbox = bb_p.merge(bb_B)\n\n        sm = PaintSoftMask.from_AB(\n            A, B, invert, resource_registry, region_bbox=region_bbox\n        )\n        p.style.soft_mask = sm\n        _disable_auto_alpha(p)\n        return p\n\n    def _pick(self, which: str) -> Union[PaintedPath, GraphicsContext]:\n        return self.source if which == \"source\" else self.backdrop\n\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        steps = self._MODES[self.mode]\n        if not steps:  # CLEAR\n            return \"\", last_item, initial_point\n\n        parts: list[str] = []\n        for st in steps:\n            node = self._pick(st.draw)\n            if st.mask_from is not None:\n                node = self._with_mask(\n                    node, self._pick(st.mask_from), st.invert, resource_registry\n                )\n            s, last_item, initial_point = node.render(\n                resource_registry, style, last_item, initial_point\n            )\n            parts.append(s)\n        return \" \".join(parts), last_item, initial_point",
      "language": "python"
    },
    {
      "code": "def render(\n    self,\n    resource_registry: \"ResourceCatalog\",\n    style: GraphicsStyle,\n    last_item: Renderable,\n    initial_point: Point,\n) -> tuple[str, Renderable, Point]:\n    steps = self._MODES[self.mode]\n    if not steps:  # CLEAR\n        return \"\", last_item, initial_point\n\n    parts: list[str] = []\n    for st in steps:\n        node = self._pick(st.draw)\n        if st.mask_from is not None:\n            node = self._with_mask(\n                node, self._pick(st.mask_from), st.invert, resource_registry\n            )\n        s, last_item, initial_point = node.render(\n            resource_registry, style, last_item, initial_point\n        )\n        parts.append(s)\n    return \" \".join(parts), last_item, initial_point",
      "language": "python"
    },
    {
      "code": "class PaintSoftMask:\n    \"\"\"\n    Wraps a vector path as a PDF soft mask (SMask) that can be attached to a\n    graphics state.\n\n    The provided `mask_path` is deep-copied and forced to render as an opaque\n    grayscale fill (white, alpha=1, nonzero rule, transparency disabled). During\n    rendering, the mask’s content stream is generated and its resource\n    dictionary is collected so it can be embedded as a Form XObject and\n    referenced from an ExtGState.\n    \"\"\"\n\n    __slots__ = (\n        \"mask_path\",\n        \"invert\",\n        \"resources\",\n        \"use_luminosity\",\n        \"object_id\",\n        \"matrix\",\n    )\n\n    def __init__(\n        self,\n        mask_path: Union[PaintedPath, GraphicsContext],\n        invert: bool = False,\n        use_luminosity: bool = False,\n        matrix: Transform = Transform.identity(),\n    ):\n        self.mask_path = deepcopy(mask_path)\n        self.invert: bool = invert\n        self.use_luminosity: bool = use_luminosity\n        self.resources: set[tuple[PDFResourceType, str]] = set()\n        self.object_id: int = 0\n        self.matrix: Transform = matrix\n\n        if not self.use_luminosity:\n            # Pure alpha mask -> force opaque white so shape defines coverage\n            self.mask_path.style.paint_rule = PathPaintRule.FILL_NONZERO\n            self.mask_path.style.fill_opacity = 1\n            self.mask_path.style.fill_color = \"#ffffff\"\n\n    def serialize(self) -> str:\n        tr = (\n            \" /TR <</FunctionType 2 /Domain [0 1] /Range [0 1] /C0 [1] /C1 [0] /N 1>>\"\n            if self.invert\n            else \"\"\n        )\n        mask_type = \"/Luminosity\" if self.use_luminosity else \"/Alpha\"\n        return f\"<</S {mask_type} /G {self.object_id} 0 R{tr}>>\"\n\n    def get_bounding_box(self) -> tuple[float, float, float, float]:\n        bounding_box, _ = self.mask_path.bounding_box(Point(0, 0))\n        return bounding_box.to_tuple()\n\n    def get_resource_dictionary(\n        self,\n        gfxstate_objs_per_name: dict[str, PDFObject],\n        pattern_objs_per_name: dict[str, PDFObject],\n    ) -> str:\n        \"\"\"Build the resource dictionary for this soft mask, resolving GS & Pattern ids.\"\"\"\n        resources_registered: dict[str, set[str]] = {}\n        for resource_type, resource_id in self.resources:\n            resources_registered.setdefault(resource_type.value, set()).add(resource_id)\n\n        parts: list[str] = []\n\n        # ExtGState\n        if \"ExtGState\" in resources_registered and resources_registered[\"ExtGState\"]:\n            parts.append(\n                Name(\"ExtGState\").serialize()\n                + \"<<\"\n                + \"\".join(\n                    f\"{Name(gs_name).serialize()} {gfxstate_objs_per_name[gs_name].id} 0 R\"\n                    for gs_name in sorted(resources_registered[\"ExtGState\"])\n                )\n                + \">>\"\n            )\n\n        # Pattern\n        if \"Pattern\" in resources_registered and resources_registered[\"Pattern\"]:\n            parts.append(\n                Name(\"Pattern\").serialize()\n                + \"<<\"\n                + \"\".join(\n                    f\"{Name(pat_name).serialize()} {pattern_objs_per_name[pat_name].id} 0 R\"\n                    for pat_name in sorted(resources_registered[\"Pattern\"])\n                )\n                + \">>\"\n            )\n        return \"<<\" + \"\".join(parts) + \">>\"\n\n    def render(self, resource_registry: \"ResourceCatalog\") -> str:\n        stream, _, _ = self.mask_path.render(\n            resource_registry,\n            style=GraphicsStyle(),\n            last_item=Move(Point(0, 0)),\n            initial_point=Point(0, 0),\n        )\n        self.resources = resource_registry.scan_stream(stream)\n        return stream\n\n    @staticmethod\n    def coverage_white(\n        node: Union[PaintedPath, GraphicsContext],\n    ) -> Union[PaintedPath, GraphicsContext]:\n        \"\"\"\n        Return a deep-copied version of *node* whose appearance encodes only its\n        geometric coverage: every shape is converted to an **opaque white fill**\n        (nonzero rule), with **no stroke**, no soft mask, and inherited blend mode.\n\n        The transform/clipping/structure of the original node is preserved; only\n        paint-related attributes are normalized. This is intended for building the\n        “B” term of soft-mask expressions (coverage), where inside = 1 and\n        outside = 0.\n        \"\"\"\n\n        def _force_white(gc: GraphicsContext) -> None:\n            # normalize the GC's own style\n            gc.style.paint_rule = PathPaintRule.FILL_NONZERO\n            gc.style.fill_color = \"#ffffff\"\n            gc.style.fill_opacity = 1\n            gc.style.stroke_color = None\n            gc.style.blend_mode = GraphicsStyle.INHERIT\n            gc.style.soft_mask = GraphicsStyle.INHERIT\n\n            # recurse into children\n            for child in gc.path_items:\n                if isinstance(child, GraphicsContext):\n                    _force_white(child)\n                elif isinstance(child, PaintedPath):\n                    child.style.paint_rule = PathPaintRule.FILL_NONZERO\n                    child.style.fill_color = \"#ffffff\"\n                    child.style.fill_opacity = 1\n                    child.style.stroke_color = None\n                    child.style.blend_mode = GraphicsStyle.INHERIT\n                    child.style.soft_mask = GraphicsStyle.INHERIT\n\n        new_node = clone_structure(node)\n        gc = (\n            new_node\n            if isinstance(new_node, GraphicsContext)\n            else new_node.get_graphics_context()\n        )\n        _force_white(gc)\n        return new_node\n\n    @staticmethod\n    def alpha_layers_from(\n        node: GraphicsContext | PaintedPath,\n    ) -> Optional[GraphicsContext]:\n        \"\"\"\n        Build a GraphicsContext that encodes the *alpha ramps* contributed by any\n        `GradientPaint` used by *node*. Each contributing PaintedPath yields one\n        rectangle covering its content-space bounding box; that rectangle is filled\n        with an `_AlphaGradientPaint` (the gradient’s *alpha channel only*).\n        Rectangles are stacked with `BM=Multiply` so multiple alpha sources\n        combine multiplicatively.\n        \"\"\"\n        layers: list[GraphicsContext] = []\n        for n in _iter_nodes(node):\n            if isinstance(n, PaintedPath):\n                for paint in (n.style.fill_color, n.style.stroke_color):\n                    if (\n                        isinstance(paint, GradientPaint)\n                        and paint.gradient\n                        and paint.gradient.has_alpha()\n                    ):\n                        bb = n.bounding_box(Point(0, 0), expand_for_stroke=False)[0]\n                        if bb.width <= 0 or bb.height <= 0:\n                            continue\n                        rect = PaintedPath()\n                        rect.rectangle(bb.x0, bb.y0, bb.width, bb.height)\n                        alpha_paint = _AlphaGradientPaint(\n                            gradient=paint.gradient,\n                            units=paint.units,\n                            gradient_transform=paint.gradient_transform,\n                            apply_page_ctm=paint.apply_page_ctm,\n                        )\n                        rect.style.fill_color = alpha_paint\n                        rect.style.stroke_color = None\n                        rect.style.stroke_width = 0\n                        rect.style.paint_rule = PathPaintRule.FILL_NONZERO\n\n                        layer_gc = GraphicsContext()\n                        layer_gc.add_item(rect, clone=False)\n                        # multiply multiple alpha contributors together\n                        layer_gc.style.blend_mode = BlendMode.MULTIPLY\n                        layers.append(layer_gc)\n\n        if not layers:\n            return None\n\n        A = GraphicsContext()\n        for layer in layers:\n            A.add_item(layer)\n        return A\n\n    @classmethod\n    def from_AB(\n        cls,\n        A: Optional[GraphicsContext],\n        B: Union[PaintedPath, GraphicsContext],\n        invert: bool,\n        registry: \"ResourceCatalog\",\n        region_bbox: Optional[\"BoundingBox\"] = None,\n    ) -> \"PaintSoftMask\":\n        \"\"\"\n        Construct a **luminosity soft mask** from two ingredients:\n\n        - **A**: Optional GraphicsContext encoding alpha ramps (e.g., the result of\n        :meth:`alpha_layers_from`). If ``None``, the effective alpha is 1.\n        - **B**: Coverage term (e.g., the result of :meth:`coverage_white`).\n\n        The mask luminance is:\n            - ``A × B``        when ``invert = False``\n            - ``A × (1 − B)``  when ``invert = True``\n\n        Implementation outline:\n        1. Compute the union bbox of A and B (no stroke expansion).\n        2. Paint a background rectangle: **black** for ``A×B`` or **white** for\n        ``A×(1−B)``.\n        3. Paint **B**; when ``invert=True``, set ``BM=Difference`` to obtain\n        ``1−B`` from the white background.\n        4. If A is present, paint it with ``BM=Multiply`` to apply the alpha ramp.\n        5. Wrap the result as a Form XObject and attach it as ``/SMask`` with\n        ``/S /Luminosity``.\n        \"\"\"\n\n        # Decide the canvas/BBox for the soft mask\n        if region_bbox is not None:\n            union = region_bbox\n        else:\n            bb_A = (\n                A.bounding_box(Point(0, 0), expand_for_stroke=False)[0] if A else None\n            )\n            bb_B = B.bounding_box(Point(0, 0), expand_for_stroke=False)[0]\n            union = bb_B if bb_A is None else bb_A.merge(bb_B)\n\n        canvas = GraphicsContext()\n\n        # Background: black for A×B, white for A×(1−B)\n        bg = PaintedPath()\n        bg.rectangle(union.x0, union.y0, union.width, union.height)\n        bg.style.fill_color = \"#000000\" if not invert else \"#ffffff\"\n        bg.style.fill_opacity = 1\n        bg.style.stroke_color = None\n        canvas.add_item(bg)\n\n        # Paint B (optionally build 1−B using Difference on white bg)\n        if invert:\n            B.style.blend_mode = BlendMode.DIFFERENCE\n        canvas.add_item(B)\n\n        # Multiply by A if present\n        if A is not None:\n            A.style.blend_mode = BlendMode.MULTIPLY\n            canvas.add_item(A)\n\n        sm = cls(canvas, invert=False, use_luminosity=True)\n        _ = sm.render(registry)\n        sm.object_id = registry.register_soft_mask(sm)\n        return sm",
      "language": "python"
    },
    {
      "code": "@staticmethod\ndef alpha_layers_from(\n    node: GraphicsContext | PaintedPath,\n) -> Optional[GraphicsContext]:\n    \"\"\"\n    Build a GraphicsContext that encodes the *alpha ramps* contributed by any\n    `GradientPaint` used by *node*. Each contributing PaintedPath yields one\n    rectangle covering its content-space bounding box; that rectangle is filled\n    with an `_AlphaGradientPaint` (the gradient’s *alpha channel only*).\n    Rectangles are stacked with `BM=Multiply` so multiple alpha sources\n    combine multiplicatively.\n    \"\"\"\n    layers: list[GraphicsContext] = []\n    for n in _iter_nodes(node):\n        if isinstance(n, PaintedPath):\n            for paint in (n.style.fill_color, n.style.stroke_color):\n                if (\n                    isinstance(paint, GradientPaint)\n                    and paint.gradient\n                    and paint.gradient.has_alpha()\n                ):\n                    bb = n.bounding_box(Point(0, 0), expand_for_stroke=False)[0]\n                    if bb.width <= 0 or bb.height <= 0:\n                        continue\n                    rect = PaintedPath()\n                    rect.rectangle(bb.x0, bb.y0, bb.width, bb.height)\n                    alpha_paint = _AlphaGradientPaint(\n                        gradient=paint.gradient,\n                        units=paint.units,\n                        gradient_transform=paint.gradient_transform,\n                        apply_page_ctm=paint.apply_page_ctm,\n                    )\n                    rect.style.fill_color = alpha_paint\n                    rect.style.stroke_color = None\n                    rect.style.stroke_width = 0\n                    rect.style.paint_rule = PathPaintRule.FILL_NONZERO\n\n                    layer_gc = GraphicsContext()\n                    layer_gc.add_item(rect, clone=False)\n                    # multiply multiple alpha contributors together\n                    layer_gc.style.blend_mode = BlendMode.MULTIPLY\n                    layers.append(layer_gc)\n\n    if not layers:\n        return None\n\n    A = GraphicsContext()\n    for layer in layers:\n        A.add_item(layer)\n    return A",
      "language": "python"
    },
    {
      "code": "@staticmethod\ndef coverage_white(\n    node: Union[PaintedPath, GraphicsContext],\n) -> Union[PaintedPath, GraphicsContext]:\n    \"\"\"\n    Return a deep-copied version of *node* whose appearance encodes only its\n    geometric coverage: every shape is converted to an **opaque white fill**\n    (nonzero rule), with **no stroke**, no soft mask, and inherited blend mode.\n\n    The transform/clipping/structure of the original node is preserved; only\n    paint-related attributes are normalized. This is intended for building the\n    “B” term of soft-mask expressions (coverage), where inside = 1 and\n    outside = 0.\n    \"\"\"\n\n    def _force_white(gc: GraphicsContext) -> None:\n        # normalize the GC's own style\n        gc.style.paint_rule = PathPaintRule.FILL_NONZERO\n        gc.style.fill_color = \"#ffffff\"\n        gc.style.fill_opacity = 1\n        gc.style.stroke_color = None\n        gc.style.blend_mode = GraphicsStyle.INHERIT\n        gc.style.soft_mask = GraphicsStyle.INHERIT\n\n        # recurse into children\n        for child in gc.path_items:\n            if isinstance(child, GraphicsContext):\n                _force_white(child)\n            elif isinstance(child, PaintedPath):\n                child.style.paint_rule = PathPaintRule.FILL_NONZERO\n                child.style.fill_color = \"#ffffff\"\n                child.style.fill_opacity = 1\n                child.style.stroke_color = None\n                child.style.blend_mode = GraphicsStyle.INHERIT\n                child.style.soft_mask = GraphicsStyle.INHERIT\n\n    new_node = clone_structure(node)\n    gc = (\n        new_node\n        if isinstance(new_node, GraphicsContext)\n        else new_node.get_graphics_context()\n    )\n    _force_white(gc)\n    return new_node",
      "language": "python"
    },
    {
      "code": "class PaintSoftMask:\n    \"\"\"\n    Wraps a vector path as a PDF soft mask (SMask) that can be attached to a\n    graphics state.\n\n    The provided `mask_path` is deep-copied and forced to render as an opaque\n    grayscale fill (white, alpha=1, nonzero rule, transparency disabled). During\n    rendering, the mask’s content stream is generated and its resource\n    dictionary is collected so it can be embedded as a Form XObject and\n    referenced from an ExtGState.\n    \"\"\"\n\n    __slots__ = (\n        \"mask_path\",\n        \"invert\",\n        \"resources\",\n        \"use_luminosity\",\n        \"object_id\",\n        \"matrix\",\n    )\n\n    def __init__(\n        self,\n        mask_path: Union[PaintedPath, GraphicsContext],\n        invert: bool = False,\n        use_luminosity: bool = False,\n        matrix: Transform = Transform.identity(),\n    ):\n        self.mask_path = deepcopy(mask_path)\n        self.invert: bool = invert\n        self.use_luminosity: bool = use_luminosity\n        self.resources: set[tuple[PDFResourceType, str]] = set()\n        self.object_id: int = 0\n        self.matrix: Transform = matrix\n\n        if not self.use_luminosity:\n            # Pure alpha mask -> force opaque white so shape defines coverage\n            self.mask_path.style.paint_rule = PathPaintRule.FILL_NONZERO\n            self.mask_path.style.fill_opacity = 1\n            self.mask_path.style.fill_color = \"#ffffff\"\n\n    def serialize(self) -> str:\n        tr = (\n            \" /TR <</FunctionType 2 /Domain [0 1] /Range [0 1] /C0 [1] /C1 [0] /N 1>>\"\n            if self.invert\n            else \"\"\n        )\n        mask_type = \"/Luminosity\" if self.use_luminosity else \"/Alpha\"\n        return f\"<</S {mask_type} /G {self.object_id} 0 R{tr}>>\"\n\n    def get_bounding_box(self) -> tuple[float, float, float, float]:\n        bounding_box, _ = self.mask_path.bounding_box(Point(0, 0))\n        return bounding_box.to_tuple()\n\n    def get_resource_dictionary(\n        self,\n        gfxstate_objs_per_name: dict[str, PDFObject],\n        pattern_objs_per_name: dict[str, PDFObject],\n    ) -> str:\n        \"\"\"Build the resource dictionary for this soft mask, resolving GS & Pattern ids.\"\"\"\n        resources_registered: dict[str, set[str]] = {}\n        for resource_type, resource_id in self.resources:\n            resources_registered.setdefault(resource_type.value, set()).add(resource_id)\n\n        parts: list[str] = []\n\n        # ExtGState\n        if \"ExtGState\" in resources_registered and resources_registered[\"ExtGState\"]:\n            parts.append(\n                Name(\"ExtGState\").serialize()\n                + \"<<\"\n                + \"\".join(\n                    f\"{Name(gs_name).serialize()} {gfxstate_objs_per_name[gs_name].id} 0 R\"\n                    for gs_name in sorted(resources_registered[\"ExtGState\"])\n                )\n                + \">>\"\n            )\n\n        # Pattern\n        if \"Pattern\" in resources_registered and resources_registered[\"Pattern\"]:\n            parts.append(\n                Name(\"Pattern\").serialize()\n                + \"<<\"\n                + \"\".join(\n                    f\"{Name(pat_name).serialize()} {pattern_objs_per_name[pat_name].id} 0 R\"\n                    for pat_name in sorted(resources_registered[\"Pattern\"])\n                )\n                + \">>\"\n            )\n        return \"<<\" + \"\".join(parts) + \">>\"\n\n    def render(self, resource_registry: \"ResourceCatalog\") -> str:\n        stream, _, _ = self.mask_path.render(\n            resource_registry,\n            style=GraphicsStyle(),\n            last_item=Move(Point(0, 0)),\n            initial_point=Point(0, 0),\n        )\n        self.resources = resource_registry.scan_stream(stream)\n        return stream\n\n    @staticmethod\n    def coverage_white(\n        node: Union[PaintedPath, GraphicsContext],\n    ) -> Union[PaintedPath, GraphicsContext]:\n        \"\"\"\n        Return a deep-copied version of *node* whose appearance encodes only its\n        geometric coverage: every shape is converted to an **opaque white fill**\n        (nonzero rule), with **no stroke**, no soft mask, and inherited blend mode.\n\n        The transform/clipping/structure of the original node is preserved; only\n        paint-related attributes are normalized. This is intended for building the\n        “B” term of soft-mask expressions (coverage), where inside = 1 and\n        outside = 0.\n        \"\"\"\n\n        def _force_white(gc: GraphicsContext) -> None:\n            # normalize the GC's own style\n            gc.style.paint_rule = PathPaintRule.FILL_NONZERO\n            gc.style.fill_color = \"#ffffff\"\n            gc.style.fill_opacity = 1\n            gc.style.stroke_color = None\n            gc.style.blend_mode = GraphicsStyle.INHERIT\n            gc.style.soft_mask = GraphicsStyle.INHERIT\n\n            # recurse into children\n            for child in gc.path_items:\n                if isinstance(child, GraphicsContext):\n                    _force_white(child)\n                elif isinstance(child, PaintedPath):\n                    child.style.paint_rule = PathPaintRule.FILL_NONZERO\n                    child.style.fill_color = \"#ffffff\"\n                    child.style.fill_opacity = 1\n                    child.style.stroke_color = None\n                    child.style.blend_mode = GraphicsStyle.INHERIT\n                    child.style.soft_mask = GraphicsStyle.INHERIT\n\n        new_node = clone_structure(node)\n        gc = (\n            new_node\n            if isinstance(new_node, GraphicsContext)\n            else new_node.get_graphics_context()\n        )\n        _force_white(gc)\n        return new_node\n\n    @staticmethod\n    def alpha_layers_from(\n        node: GraphicsContext | PaintedPath,\n    ) -> Optional[GraphicsContext]:\n        \"\"\"\n        Build a GraphicsContext that encodes the *alpha ramps* contributed by any\n        `GradientPaint` used by *node*. Each contributing PaintedPath yields one\n        rectangle covering its content-space bounding box; that rectangle is filled\n        with an `_AlphaGradientPaint` (the gradient’s *alpha channel only*).\n        Rectangles are stacked with `BM=Multiply` so multiple alpha sources\n        combine multiplicatively.\n        \"\"\"\n        layers: list[GraphicsContext] = []\n        for n in _iter_nodes(node):\n            if isinstance(n, PaintedPath):\n                for paint in (n.style.fill_color, n.style.stroke_color):\n                    if (\n                        isinstance(paint, GradientPaint)\n                        and paint.gradient\n                        and paint.gradient.has_alpha()\n                    ):\n                        bb = n.bounding_box(Point(0, 0), expand_for_stroke=False)[0]\n                        if bb.width <= 0 or bb.height <= 0:\n                            continue\n                        rect = PaintedPath()\n                        rect.rectangle(bb.x0, bb.y0, bb.width, bb.height)\n                        alpha_paint = _AlphaGradientPaint(\n                            gradient=paint.gradient,\n                            units=paint.units,\n                            gradient_transform=paint.gradient_transform,\n                            apply_page_ctm=paint.apply_page_ctm,\n                        )\n                        rect.style.fill_color = alpha_paint\n                        rect.style.stroke_color = None\n                        rect.style.stroke_width = 0\n                        rect.style.paint_rule = PathPaintRule.FILL_NONZERO\n\n                        layer_gc = GraphicsContext()\n                        layer_gc.add_item(rect, clone=False)\n                        # multiply multiple alpha contributors together\n                        layer_gc.style.blend_mode = BlendMode.MULTIPLY\n                        layers.append(layer_gc)\n\n        if not layers:\n            return None\n\n        A = GraphicsContext()\n        for layer in layers:\n            A.add_item(layer)\n        return A\n\n    @classmethod\n    def from_AB(\n        cls,\n        A: Optional[GraphicsContext],\n        B: Union[PaintedPath, GraphicsContext],\n        invert: bool,\n        registry: \"ResourceCatalog\",\n        region_bbox: Optional[\"BoundingBox\"] = None,\n    ) -> \"PaintSoftMask\":\n        \"\"\"\n        Construct a **luminosity soft mask** from two ingredients:\n\n        - **A**: Optional GraphicsContext encoding alpha ramps (e.g., the result of\n        :meth:`alpha_layers_from`). If ``None``, the effective alpha is 1.\n        - **B**: Coverage term (e.g., the result of :meth:`coverage_white`).\n\n        The mask luminance is:\n            - ``A × B``        when ``invert = False``\n            - ``A × (1 − B)``  when ``invert = True``\n\n        Implementation outline:\n        1. Compute the union bbox of A and B (no stroke expansion).\n        2. Paint a background rectangle: **black** for ``A×B`` or **white** for\n        ``A×(1−B)``.\n        3. Paint **B**; when ``invert=True``, set ``BM=Difference`` to obtain\n        ``1−B`` from the white background.\n        4. If A is present, paint it with ``BM=Multiply`` to apply the alpha ramp.\n        5. Wrap the result as a Form XObject and attach it as ``/SMask`` with\n        ``/S /Luminosity``.\n        \"\"\"\n\n        # Decide the canvas/BBox for the soft mask\n        if region_bbox is not None:\n            union = region_bbox\n        else:\n            bb_A = (\n                A.bounding_box(Point(0, 0), expand_for_stroke=False)[0] if A else None\n            )\n            bb_B = B.bounding_box(Point(0, 0), expand_for_stroke=False)[0]\n            union = bb_B if bb_A is None else bb_A.merge(bb_B)\n\n        canvas = GraphicsContext()\n\n        # Background: black for A×B, white for A×(1−B)\n        bg = PaintedPath()\n        bg.rectangle(union.x0, union.y0, union.width, union.height)\n        bg.style.fill_color = \"#000000\" if not invert else \"#ffffff\"\n        bg.style.fill_opacity = 1\n        bg.style.stroke_color = None\n        canvas.add_item(bg)\n\n        # Paint B (optionally build 1−B using Difference on white bg)\n        if invert:\n            B.style.blend_mode = BlendMode.DIFFERENCE\n        canvas.add_item(B)\n\n        # Multiply by A if present\n        if A is not None:\n            A.style.blend_mode = BlendMode.MULTIPLY\n            canvas.add_item(A)\n\n        sm = cls(canvas, invert=False, use_luminosity=True)\n        _ = sm.render(registry)\n        sm.object_id = registry.register_soft_mask(sm)\n        return sm",
      "language": "python"
    },
    {
      "code": "class PaintSoftMask:\n    \"\"\"\n    Wraps a vector path as a PDF soft mask (SMask) that can be attached to a\n    graphics state.\n\n    The provided `mask_path` is deep-copied and forced to render as an opaque\n    grayscale fill (white, alpha=1, nonzero rule, transparency disabled). During\n    rendering, the mask’s content stream is generated and its resource\n    dictionary is collected so it can be embedded as a Form XObject and\n    referenced from an ExtGState.\n    \"\"\"\n\n    __slots__ = (\n        \"mask_path\",\n        \"invert\",\n        \"resources\",\n        \"use_luminosity\",\n        \"object_id\",\n        \"matrix\",\n    )\n\n    def __init__(\n        self,\n        mask_path: Union[PaintedPath, GraphicsContext],\n        invert: bool = False,\n        use_luminosity: bool = False,\n        matrix: Transform = Transform.identity(),\n    ):\n        self.mask_path = deepcopy(mask_path)\n        self.invert: bool = invert\n        self.use_luminosity: bool = use_luminosity\n        self.resources: set[tuple[PDFResourceType, str]] = set()\n        self.object_id: int = 0\n        self.matrix: Transform = matrix\n\n        if not self.use_luminosity:\n            # Pure alpha mask -> force opaque white so shape defines coverage\n            self.mask_path.style.paint_rule = PathPaintRule.FILL_NONZERO\n            self.mask_path.style.fill_opacity = 1\n            self.mask_path.style.fill_color = \"#ffffff\"\n\n    def serialize(self) -> str:\n        tr = (\n            \" /TR <</FunctionType 2 /Domain [0 1] /Range [0 1] /C0 [1] /C1 [0] /N 1>>\"\n            if self.invert\n            else \"\"\n        )\n        mask_type = \"/Luminosity\" if self.use_luminosity else \"/Alpha\"\n        return f\"<</S {mask_type} /G {self.object_id} 0 R{tr}>>\"\n\n    def get_bounding_box(self) -> tuple[float, float, float, float]:\n        bounding_box, _ = self.mask_path.bounding_box(Point(0, 0))\n        return bounding_box.to_tuple()\n\n    def get_resource_dictionary(\n        self,\n        gfxstate_objs_per_name: dict[str, PDFObject],\n        pattern_objs_per_name: dict[str, PDFObject],\n    ) -> str:\n        \"\"\"Build the resource dictionary for this soft mask, resolving GS & Pattern ids.\"\"\"\n        resources_registered: dict[str, set[str]] = {}\n        for resource_type, resource_id in self.resources:\n            resources_registered.setdefault(resource_type.value, set()).add(resource_id)\n\n        parts: list[str] = []\n\n        # ExtGState\n        if \"ExtGState\" in resources_registered and resources_registered[\"ExtGState\"]:\n            parts.append(\n                Name(\"ExtGState\").serialize()\n                + \"<<\"\n                + \"\".join(\n                    f\"{Name(gs_name).serialize()} {gfxstate_objs_per_name[gs_name].id} 0 R\"\n                    for gs_name in sorted(resources_registered[\"ExtGState\"])\n                )\n                + \">>\"\n            )\n\n        # Pattern\n        if \"Pattern\" in resources_registered and resources_registered[\"Pattern\"]:\n            parts.append(\n                Name(\"Pattern\").serialize()\n                + \"<<\"\n                + \"\".join(\n                    f\"{Name(pat_name).serialize()} {pattern_objs_per_name[pat_name].id} 0 R\"\n                    for pat_name in sorted(resources_registered[\"Pattern\"])\n                )\n                + \">>\"\n            )\n        return \"<<\" + \"\".join(parts) + \">>\"\n\n    def render(self, resource_registry: \"ResourceCatalog\") -> str:\n        stream, _, _ = self.mask_path.render(\n            resource_registry,\n            style=GraphicsStyle(),\n            last_item=Move(Point(0, 0)),\n            initial_point=Point(0, 0),\n        )\n        self.resources = resource_registry.scan_stream(stream)\n        return stream\n\n    @staticmethod\n    def coverage_white(\n        node: Union[PaintedPath, GraphicsContext],\n    ) -> Union[PaintedPath, GraphicsContext]:\n        \"\"\"\n        Return a deep-copied version of *node* whose appearance encodes only its\n        geometric coverage: every shape is converted to an **opaque white fill**\n        (nonzero rule), with **no stroke**, no soft mask, and inherited blend mode.\n\n        The transform/clipping/structure of the original node is preserved; only\n        paint-related attributes are normalized. This is intended for building the\n        “B” term of soft-mask expressions (coverage), where inside = 1 and\n        outside = 0.\n        \"\"\"\n\n        def _force_white(gc: GraphicsContext) -> None:\n            # normalize the GC's own style\n            gc.style.paint_rule = PathPaintRule.FILL_NONZERO\n            gc.style.fill_color = \"#ffffff\"\n            gc.style.fill_opacity = 1\n            gc.style.stroke_color = None\n            gc.style.blend_mode = GraphicsStyle.INHERIT\n            gc.style.soft_mask = GraphicsStyle.INHERIT\n\n            # recurse into children\n            for child in gc.path_items:\n                if isinstance(child, GraphicsContext):\n                    _force_white(child)\n                elif isinstance(child, PaintedPath):\n                    child.style.paint_rule = PathPaintRule.FILL_NONZERO\n                    child.style.fill_color = \"#ffffff\"\n                    child.style.fill_opacity = 1\n                    child.style.stroke_color = None\n                    child.style.blend_mode = GraphicsStyle.INHERIT\n                    child.style.soft_mask = GraphicsStyle.INHERIT\n\n        new_node = clone_structure(node)\n        gc = (\n            new_node\n            if isinstance(new_node, GraphicsContext)\n            else new_node.get_graphics_context()\n        )\n        _force_white(gc)\n        return new_node\n\n    @staticmethod\n    def alpha_layers_from(\n        node: GraphicsContext | PaintedPath,\n    ) -> Optional[GraphicsContext]:\n        \"\"\"\n        Build a GraphicsContext that encodes the *alpha ramps* contributed by any\n        `GradientPaint` used by *node*. Each contributing PaintedPath yields one\n        rectangle covering its content-space bounding box; that rectangle is filled\n        with an `_AlphaGradientPaint` (the gradient’s *alpha channel only*).\n        Rectangles are stacked with `BM=Multiply` so multiple alpha sources\n        combine multiplicatively.\n        \"\"\"\n        layers: list[GraphicsContext] = []\n        for n in _iter_nodes(node):\n            if isinstance(n, PaintedPath):\n                for paint in (n.style.fill_color, n.style.stroke_color):\n                    if (\n                        isinstance(paint, GradientPaint)\n                        and paint.gradient\n                        and paint.gradient.has_alpha()\n                    ):\n                        bb = n.bounding_box(Point(0, 0), expand_for_stroke=False)[0]\n                        if bb.width <= 0 or bb.height <= 0:\n                            continue\n                        rect = PaintedPath()\n                        rect.rectangle(bb.x0, bb.y0, bb.width, bb.height)\n                        alpha_paint = _AlphaGradientPaint(\n                            gradient=paint.gradient,\n                            units=paint.units,\n                            gradient_transform=paint.gradient_transform,\n                            apply_page_ctm=paint.apply_page_ctm,\n                        )\n                        rect.style.fill_color = alpha_paint\n                        rect.style.stroke_color = None\n                        rect.style.stroke_width = 0\n                        rect.style.paint_rule = PathPaintRule.FILL_NONZERO\n\n                        layer_gc = GraphicsContext()\n                        layer_gc.add_item(rect, clone=False)\n                        # multiply multiple alpha contributors together\n                        layer_gc.style.blend_mode = BlendMode.MULTIPLY\n                        layers.append(layer_gc)\n\n        if not layers:\n            return None\n\n        A = GraphicsContext()\n        for layer in layers:\n            A.add_item(layer)\n        return A\n\n    @classmethod\n    def from_AB(\n        cls,\n        A: Optional[GraphicsContext],\n        B: Union[PaintedPath, GraphicsContext],\n        invert: bool,\n        registry: \"ResourceCatalog\",\n        region_bbox: Optional[\"BoundingBox\"] = None,\n    ) -> \"PaintSoftMask\":\n        \"\"\"\n        Construct a **luminosity soft mask** from two ingredients:\n\n        - **A**: Optional GraphicsContext encoding alpha ramps (e.g., the result of\n        :meth:`alpha_layers_from`). If ``None``, the effective alpha is 1.\n        - **B**: Coverage term (e.g., the result of :meth:`coverage_white`).\n\n        The mask luminance is:\n            - ``A × B``        when ``invert = False``\n            - ``A × (1 − B)``  when ``invert = True``\n\n        Implementation outline:\n        1. Compute the union bbox of A and B (no stroke expansion).\n        2. Paint a background rectangle: **black** for ``A×B`` or **white** for\n        ``A×(1−B)``.\n        3. Paint **B**; when ``invert=True``, set ``BM=Difference`` to obtain\n        ``1−B`` from the white background.\n        4. If A is present, paint it with ``BM=Multiply`` to apply the alpha ramp.\n        5. Wrap the result as a Form XObject and attach it as ``/SMask`` with\n        ``/S /Luminosity``.\n        \"\"\"\n\n        # Decide the canvas/BBox for the soft mask\n        if region_bbox is not None:\n            union = region_bbox\n        else:\n            bb_A = (\n                A.bounding_box(Point(0, 0), expand_for_stroke=False)[0] if A else None\n            )\n            bb_B = B.bounding_box(Point(0, 0), expand_for_stroke=False)[0]\n            union = bb_B if bb_A is None else bb_A.merge(bb_B)\n\n        canvas = GraphicsContext()\n\n        # Background: black for A×B, white for A×(1−B)\n        bg = PaintedPath()\n        bg.rectangle(union.x0, union.y0, union.width, union.height)\n        bg.style.fill_color = \"#000000\" if not invert else \"#ffffff\"\n        bg.style.fill_opacity = 1\n        bg.style.stroke_color = None\n        canvas.add_item(bg)\n\n        # Paint B (optionally build 1−B using Difference on white bg)\n        if invert:\n            B.style.blend_mode = BlendMode.DIFFERENCE\n        canvas.add_item(B)\n\n        # Multiply by A if present\n        if A is not None:\n            A.style.blend_mode = BlendMode.MULTIPLY\n            canvas.add_item(A)\n\n        sm = cls(canvas, invert=False, use_luminosity=True)\n        _ = sm.render(registry)\n        sm.object_id = registry.register_soft_mask(sm)\n        return sm",
      "language": "python"
    },
    {
      "code": "class PaintSoftMask:\n    \"\"\"\n    Wraps a vector path as a PDF soft mask (SMask) that can be attached to a\n    graphics state.\n\n    The provided `mask_path` is deep-copied and forced to render as an opaque\n    grayscale fill (white, alpha=1, nonzero rule, transparency disabled). During\n    rendering, the mask’s content stream is generated and its resource\n    dictionary is collected so it can be embedded as a Form XObject and\n    referenced from an ExtGState.\n    \"\"\"\n\n    __slots__ = (\n        \"mask_path\",\n        \"invert\",\n        \"resources\",\n        \"use_luminosity\",\n        \"object_id\",\n        \"matrix\",\n    )\n\n    def __init__(\n        self,\n        mask_path: Union[PaintedPath, GraphicsContext],\n        invert: bool = False,\n        use_luminosity: bool = False,\n        matrix: Transform = Transform.identity(),\n    ):\n        self.mask_path = deepcopy(mask_path)\n        self.invert: bool = invert\n        self.use_luminosity: bool = use_luminosity\n        self.resources: set[tuple[PDFResourceType, str]] = set()\n        self.object_id: int = 0\n        self.matrix: Transform = matrix\n\n        if not self.use_luminosity:\n            # Pure alpha mask -> force opaque white so shape defines coverage\n            self.mask_path.style.paint_rule = PathPaintRule.FILL_NONZERO\n            self.mask_path.style.fill_opacity = 1\n            self.mask_path.style.fill_color = \"#ffffff\"\n\n    def serialize(self) -> str:\n        tr = (\n            \" /TR <</FunctionType 2 /Domain [0 1] /Range [0 1] /C0 [1] /C1 [0] /N 1>>\"\n            if self.invert\n            else \"\"\n        )\n        mask_type = \"/Luminosity\" if self.use_luminosity else \"/Alpha\"\n        return f\"<</S {mask_type} /G {self.object_id} 0 R{tr}>>\"\n\n    def get_bounding_box(self) -> tuple[float, float, float, float]:\n        bounding_box, _ = self.mask_path.bounding_box(Point(0, 0))\n        return bounding_box.to_tuple()\n\n    def get_resource_dictionary(\n        self,\n        gfxstate_objs_per_name: dict[str, PDFObject],\n        pattern_objs_per_name: dict[str, PDFObject],\n    ) -> str:\n        \"\"\"Build the resource dictionary for this soft mask, resolving GS & Pattern ids.\"\"\"\n        resources_registered: dict[str, set[str]] = {}\n        for resource_type, resource_id in self.resources:\n            resources_registered.setdefault(resource_type.value, set()).add(resource_id)\n\n        parts: list[str] = []\n\n        # ExtGState\n        if \"ExtGState\" in resources_registered and resources_registered[\"ExtGState\"]:\n            parts.append(\n                Name(\"ExtGState\").serialize()\n                + \"<<\"\n                + \"\".join(\n                    f\"{Name(gs_name).serialize()} {gfxstate_objs_per_name[gs_name].id} 0 R\"\n                    for gs_name in sorted(resources_registered[\"ExtGState\"])\n                )\n                + \">>\"\n            )\n\n        # Pattern\n        if \"Pattern\" in resources_registered and resources_registered[\"Pattern\"]:\n            parts.append(\n                Name(\"Pattern\").serialize()\n                + \"<<\"\n                + \"\".join(\n                    f\"{Name(pat_name).serialize()} {pattern_objs_per_name[pat_name].id} 0 R\"\n                    for pat_name in sorted(resources_registered[\"Pattern\"])\n                )\n                + \">>\"\n            )\n        return \"<<\" + \"\".join(parts) + \">>\"\n\n    def render(self, resource_registry: \"ResourceCatalog\") -> str:\n        stream, _, _ = self.mask_path.render(\n            resource_registry,\n            style=GraphicsStyle(),\n            last_item=Move(Point(0, 0)),\n            initial_point=Point(0, 0),\n        )\n        self.resources = resource_registry.scan_stream(stream)\n        return stream\n\n    @staticmethod\n    def coverage_white(\n        node: Union[PaintedPath, GraphicsContext],\n    ) -> Union[PaintedPath, GraphicsContext]:\n        \"\"\"\n        Return a deep-copied version of *node* whose appearance encodes only its\n        geometric coverage: every shape is converted to an **opaque white fill**\n        (nonzero rule), with **no stroke**, no soft mask, and inherited blend mode.\n\n        The transform/clipping/structure of the original node is preserved; only\n        paint-related attributes are normalized. This is intended for building the\n        “B” term of soft-mask expressions (coverage), where inside = 1 and\n        outside = 0.\n        \"\"\"\n\n        def _force_white(gc: GraphicsContext) -> None:\n            # normalize the GC's own style\n            gc.style.paint_rule = PathPaintRule.FILL_NONZERO\n            gc.style.fill_color = \"#ffffff\"\n            gc.style.fill_opacity = 1\n            gc.style.stroke_color = None\n            gc.style.blend_mode = GraphicsStyle.INHERIT\n            gc.style.soft_mask = GraphicsStyle.INHERIT\n\n            # recurse into children\n            for child in gc.path_items:\n                if isinstance(child, GraphicsContext):\n                    _force_white(child)\n                elif isinstance(child, PaintedPath):\n                    child.style.paint_rule = PathPaintRule.FILL_NONZERO\n                    child.style.fill_color = \"#ffffff\"\n                    child.style.fill_opacity = 1\n                    child.style.stroke_color = None\n                    child.style.blend_mode = GraphicsStyle.INHERIT\n                    child.style.soft_mask = GraphicsStyle.INHERIT\n\n        new_node = clone_structure(node)\n        gc = (\n            new_node\n            if isinstance(new_node, GraphicsContext)\n            else new_node.get_graphics_context()\n        )\n        _force_white(gc)\n        return new_node\n\n    @staticmethod\n    def alpha_layers_from(\n        node: GraphicsContext | PaintedPath,\n    ) -> Optional[GraphicsContext]:\n        \"\"\"\n        Build a GraphicsContext that encodes the *alpha ramps* contributed by any\n        `GradientPaint` used by *node*. Each contributing PaintedPath yields one\n        rectangle covering its content-space bounding box; that rectangle is filled\n        with an `_AlphaGradientPaint` (the gradient’s *alpha channel only*).\n        Rectangles are stacked with `BM=Multiply` so multiple alpha sources\n        combine multiplicatively.\n        \"\"\"\n        layers: list[GraphicsContext] = []\n        for n in _iter_nodes(node):\n            if isinstance(n, PaintedPath):\n                for paint in (n.style.fill_color, n.style.stroke_color):\n                    if (\n                        isinstance(paint, GradientPaint)\n                        and paint.gradient\n                        and paint.gradient.has_alpha()\n                    ):\n                        bb = n.bounding_box(Point(0, 0), expand_for_stroke=False)[0]\n                        if bb.width <= 0 or bb.height <= 0:\n                            continue\n                        rect = PaintedPath()\n                        rect.rectangle(bb.x0, bb.y0, bb.width, bb.height)\n                        alpha_paint = _AlphaGradientPaint(\n                            gradient=paint.gradient,\n                            units=paint.units,\n                            gradient_transform=paint.gradient_transform,\n                            apply_page_ctm=paint.apply_page_ctm,\n                        )\n                        rect.style.fill_color = alpha_paint\n                        rect.style.stroke_color = None\n                        rect.style.stroke_width = 0\n                        rect.style.paint_rule = PathPaintRule.FILL_NONZERO\n\n                        layer_gc = GraphicsContext()\n                        layer_gc.add_item(rect, clone=False)\n                        # multiply multiple alpha contributors together\n                        layer_gc.style.blend_mode = BlendMode.MULTIPLY\n                        layers.append(layer_gc)\n\n        if not layers:\n            return None\n\n        A = GraphicsContext()\n        for layer in layers:\n            A.add_item(layer)\n        return A\n\n    @classmethod\n    def from_AB(\n        cls,\n        A: Optional[GraphicsContext],\n        B: Union[PaintedPath, GraphicsContext],\n        invert: bool,\n        registry: \"ResourceCatalog\",\n        region_bbox: Optional[\"BoundingBox\"] = None,\n    ) -> \"PaintSoftMask\":\n        \"\"\"\n        Construct a **luminosity soft mask** from two ingredients:\n\n        - **A**: Optional GraphicsContext encoding alpha ramps (e.g., the result of\n        :meth:`alpha_layers_from`). If ``None``, the effective alpha is 1.\n        - **B**: Coverage term (e.g., the result of :meth:`coverage_white`).\n\n        The mask luminance is:\n            - ``A × B``        when ``invert = False``\n            - ``A × (1 − B)``  when ``invert = True``\n\n        Implementation outline:\n        1. Compute the union bbox of A and B (no stroke expansion).\n        2. Paint a background rectangle: **black** for ``A×B`` or **white** for\n        ``A×(1−B)``.\n        3. Paint **B**; when ``invert=True``, set ``BM=Difference`` to obtain\n        ``1−B`` from the white background.\n        4. If A is present, paint it with ``BM=Multiply`` to apply the alpha ramp.\n        5. Wrap the result as a Form XObject and attach it as ``/SMask`` with\n        ``/S /Luminosity``.\n        \"\"\"\n\n        # Decide the canvas/BBox for the soft mask\n        if region_bbox is not None:\n            union = region_bbox\n        else:\n            bb_A = (\n                A.bounding_box(Point(0, 0), expand_for_stroke=False)[0] if A else None\n            )\n            bb_B = B.bounding_box(Point(0, 0), expand_for_stroke=False)[0]\n            union = bb_B if bb_A is None else bb_A.merge(bb_B)\n\n        canvas = GraphicsContext()\n\n        # Background: black for A×B, white for A×(1−B)\n        bg = PaintedPath()\n        bg.rectangle(union.x0, union.y0, union.width, union.height)\n        bg.style.fill_color = \"#000000\" if not invert else \"#ffffff\"\n        bg.style.fill_opacity = 1\n        bg.style.stroke_color = None\n        canvas.add_item(bg)\n\n        # Paint B (optionally build 1−B using Difference on white bg)\n        if invert:\n            B.style.blend_mode = BlendMode.DIFFERENCE\n        canvas.add_item(B)\n\n        # Multiply by A if present\n        if A is not None:\n            A.style.blend_mode = BlendMode.MULTIPLY\n            canvas.add_item(A)\n\n        sm = cls(canvas, invert=False, use_luminosity=True)\n        _ = sm.render(registry)\n        sm.object_id = registry.register_soft_mask(sm)\n        return sm",
      "language": "python"
    },
    {
      "code": "class PaintSoftMask:\n    \"\"\"\n    Wraps a vector path as a PDF soft mask (SMask) that can be attached to a\n    graphics state.\n\n    The provided `mask_path` is deep-copied and forced to render as an opaque\n    grayscale fill (white, alpha=1, nonzero rule, transparency disabled). During\n    rendering, the mask’s content stream is generated and its resource\n    dictionary is collected so it can be embedded as a Form XObject and\n    referenced from an ExtGState.\n    \"\"\"\n\n    __slots__ = (\n        \"mask_path\",\n        \"invert\",\n        \"resources\",\n        \"use_luminosity\",\n        \"object_id\",\n        \"matrix\",\n    )\n\n    def __init__(\n        self,\n        mask_path: Union[PaintedPath, GraphicsContext],\n        invert: bool = False,\n        use_luminosity: bool = False,\n        matrix: Transform = Transform.identity(),\n    ):\n        self.mask_path = deepcopy(mask_path)\n        self.invert: bool = invert\n        self.use_luminosity: bool = use_luminosity\n        self.resources: set[tuple[PDFResourceType, str]] = set()\n        self.object_id: int = 0\n        self.matrix: Transform = matrix\n\n        if not self.use_luminosity:\n            # Pure alpha mask -> force opaque white so shape defines coverage\n            self.mask_path.style.paint_rule = PathPaintRule.FILL_NONZERO\n            self.mask_path.style.fill_opacity = 1\n            self.mask_path.style.fill_color = \"#ffffff\"\n\n    def serialize(self) -> str:\n        tr = (\n            \" /TR <</FunctionType 2 /Domain [0 1] /Range [0 1] /C0 [1] /C1 [0] /N 1>>\"\n            if self.invert\n            else \"\"\n        )\n        mask_type = \"/Luminosity\" if self.use_luminosity else \"/Alpha\"\n        return f\"<</S {mask_type} /G {self.object_id} 0 R{tr}>>\"\n\n    def get_bounding_box(self) -> tuple[float, float, float, float]:\n        bounding_box, _ = self.mask_path.bounding_box(Point(0, 0))\n        return bounding_box.to_tuple()\n\n    def get_resource_dictionary(\n        self,\n        gfxstate_objs_per_name: dict[str, PDFObject],\n        pattern_objs_per_name: dict[str, PDFObject],\n    ) -> str:\n        \"\"\"Build the resource dictionary for this soft mask, resolving GS & Pattern ids.\"\"\"\n        resources_registered: dict[str, set[str]] = {}\n        for resource_type, resource_id in self.resources:\n            resources_registered.setdefault(resource_type.value, set()).add(resource_id)\n\n        parts: list[str] = []\n\n        # ExtGState\n        if \"ExtGState\" in resources_registered and resources_registered[\"ExtGState\"]:\n            parts.append(\n                Name(\"ExtGState\").serialize()\n                + \"<<\"\n                + \"\".join(\n                    f\"{Name(gs_name).serialize()} {gfxstate_objs_per_name[gs_name].id} 0 R\"\n                    for gs_name in sorted(resources_registered[\"ExtGState\"])\n                )\n                + \">>\"\n            )\n\n        # Pattern\n        if \"Pattern\" in resources_registered and resources_registered[\"Pattern\"]:\n            parts.append(\n                Name(\"Pattern\").serialize()\n                + \"<<\"\n                + \"\".join(\n                    f\"{Name(pat_name).serialize()} {pattern_objs_per_name[pat_name].id} 0 R\"\n                    for pat_name in sorted(resources_registered[\"Pattern\"])\n                )\n                + \">>\"\n            )\n        return \"<<\" + \"\".join(parts) + \">>\"\n\n    def render(self, resource_registry: \"ResourceCatalog\") -> str:\n        stream, _, _ = self.mask_path.render(\n            resource_registry,\n            style=GraphicsStyle(),\n            last_item=Move(Point(0, 0)),\n            initial_point=Point(0, 0),\n        )\n        self.resources = resource_registry.scan_stream(stream)\n        return stream\n\n    @staticmethod\n    def coverage_white(\n        node: Union[PaintedPath, GraphicsContext],\n    ) -> Union[PaintedPath, GraphicsContext]:\n        \"\"\"\n        Return a deep-copied version of *node* whose appearance encodes only its\n        geometric coverage: every shape is converted to an **opaque white fill**\n        (nonzero rule), with **no stroke**, no soft mask, and inherited blend mode.\n\n        The transform/clipping/structure of the original node is preserved; only\n        paint-related attributes are normalized. This is intended for building the\n        “B” term of soft-mask expressions (coverage), where inside = 1 and\n        outside = 0.\n        \"\"\"\n\n        def _force_white(gc: GraphicsContext) -> None:\n            # normalize the GC's own style\n            gc.style.paint_rule = PathPaintRule.FILL_NONZERO\n            gc.style.fill_color = \"#ffffff\"\n            gc.style.fill_opacity = 1\n            gc.style.stroke_color = None\n            gc.style.blend_mode = GraphicsStyle.INHERIT\n            gc.style.soft_mask = GraphicsStyle.INHERIT\n\n            # recurse into children\n            for child in gc.path_items:\n                if isinstance(child, GraphicsContext):\n                    _force_white(child)\n                elif isinstance(child, PaintedPath):\n                    child.style.paint_rule = PathPaintRule.FILL_NONZERO\n                    child.style.fill_color = \"#ffffff\"\n                    child.style.fill_opacity = 1\n                    child.style.stroke_color = None\n                    child.style.blend_mode = GraphicsStyle.INHERIT\n                    child.style.soft_mask = GraphicsStyle.INHERIT\n\n        new_node = clone_structure(node)\n        gc = (\n            new_node\n            if isinstance(new_node, GraphicsContext)\n            else new_node.get_graphics_context()\n        )\n        _force_white(gc)\n        return new_node\n\n    @staticmethod\n    def alpha_layers_from(\n        node: GraphicsContext | PaintedPath,\n    ) -> Optional[GraphicsContext]:\n        \"\"\"\n        Build a GraphicsContext that encodes the *alpha ramps* contributed by any\n        `GradientPaint` used by *node*. Each contributing PaintedPath yields one\n        rectangle covering its content-space bounding box; that rectangle is filled\n        with an `_AlphaGradientPaint` (the gradient’s *alpha channel only*).\n        Rectangles are stacked with `BM=Multiply` so multiple alpha sources\n        combine multiplicatively.\n        \"\"\"\n        layers: list[GraphicsContext] = []\n        for n in _iter_nodes(node):\n            if isinstance(n, PaintedPath):\n                for paint in (n.style.fill_color, n.style.stroke_color):\n                    if (\n                        isinstance(paint, GradientPaint)\n                        and paint.gradient\n                        and paint.gradient.has_alpha()\n                    ):\n                        bb = n.bounding_box(Point(0, 0), expand_for_stroke=False)[0]\n                        if bb.width <= 0 or bb.height <= 0:\n                            continue\n                        rect = PaintedPath()\n                        rect.rectangle(bb.x0, bb.y0, bb.width, bb.height)\n                        alpha_paint = _AlphaGradientPaint(\n                            gradient=paint.gradient,\n                            units=paint.units,\n                            gradient_transform=paint.gradient_transform,\n                            apply_page_ctm=paint.apply_page_ctm,\n                        )\n                        rect.style.fill_color = alpha_paint\n                        rect.style.stroke_color = None\n                        rect.style.stroke_width = 0\n                        rect.style.paint_rule = PathPaintRule.FILL_NONZERO\n\n                        layer_gc = GraphicsContext()\n                        layer_gc.add_item(rect, clone=False)\n                        # multiply multiple alpha contributors together\n                        layer_gc.style.blend_mode = BlendMode.MULTIPLY\n                        layers.append(layer_gc)\n\n        if not layers:\n            return None\n\n        A = GraphicsContext()\n        for layer in layers:\n            A.add_item(layer)\n        return A\n\n    @classmethod\n    def from_AB(\n        cls,\n        A: Optional[GraphicsContext],\n        B: Union[PaintedPath, GraphicsContext],\n        invert: bool,\n        registry: \"ResourceCatalog\",\n        region_bbox: Optional[\"BoundingBox\"] = None,\n    ) -> \"PaintSoftMask\":\n        \"\"\"\n        Construct a **luminosity soft mask** from two ingredients:\n\n        - **A**: Optional GraphicsContext encoding alpha ramps (e.g., the result of\n        :meth:`alpha_layers_from`). If ``None``, the effective alpha is 1.\n        - **B**: Coverage term (e.g., the result of :meth:`coverage_white`).\n\n        The mask luminance is:\n            - ``A × B``        when ``invert = False``\n            - ``A × (1 − B)``  when ``invert = True``\n\n        Implementation outline:\n        1. Compute the union bbox of A and B (no stroke expansion).\n        2. Paint a background rectangle: **black** for ``A×B`` or **white** for\n        ``A×(1−B)``.\n        3. Paint **B**; when ``invert=True``, set ``BM=Difference`` to obtain\n        ``1−B`` from the white background.\n        4. If A is present, paint it with ``BM=Multiply`` to apply the alpha ramp.\n        5. Wrap the result as a Form XObject and attach it as ``/SMask`` with\n        ``/S /Luminosity``.\n        \"\"\"\n\n        # Decide the canvas/BBox for the soft mask\n        if region_bbox is not None:\n            union = region_bbox\n        else:\n            bb_A = (\n                A.bounding_box(Point(0, 0), expand_for_stroke=False)[0] if A else None\n            )\n            bb_B = B.bounding_box(Point(0, 0), expand_for_stroke=False)[0]\n            union = bb_B if bb_A is None else bb_A.merge(bb_B)\n\n        canvas = GraphicsContext()\n\n        # Background: black for A×B, white for A×(1−B)\n        bg = PaintedPath()\n        bg.rectangle(union.x0, union.y0, union.width, union.height)\n        bg.style.fill_color = \"#000000\" if not invert else \"#ffffff\"\n        bg.style.fill_opacity = 1\n        bg.style.stroke_color = None\n        canvas.add_item(bg)\n\n        # Paint B (optionally build 1−B using Difference on white bg)\n        if invert:\n            B.style.blend_mode = BlendMode.DIFFERENCE\n        canvas.add_item(B)\n\n        # Multiply by A if present\n        if A is not None:\n            A.style.blend_mode = BlendMode.MULTIPLY\n            canvas.add_item(A)\n\n        sm = cls(canvas, invert=False, use_luminosity=True)\n        _ = sm.render(registry)\n        sm.object_id = registry.register_soft_mask(sm)\n        return sm",
      "language": "python"
    },
    {
      "code": "class PaintSoftMask:\n    \"\"\"\n    Wraps a vector path as a PDF soft mask (SMask) that can be attached to a\n    graphics state.\n\n    The provided `mask_path` is deep-copied and forced to render as an opaque\n    grayscale fill (white, alpha=1, nonzero rule, transparency disabled). During\n    rendering, the mask’s content stream is generated and its resource\n    dictionary is collected so it can be embedded as a Form XObject and\n    referenced from an ExtGState.\n    \"\"\"\n\n    __slots__ = (\n        \"mask_path\",\n        \"invert\",\n        \"resources\",\n        \"use_luminosity\",\n        \"object_id\",\n        \"matrix\",\n    )\n\n    def __init__(\n        self,\n        mask_path: Union[PaintedPath, GraphicsContext],\n        invert: bool = False,\n        use_luminosity: bool = False,\n        matrix: Transform = Transform.identity(),\n    ):\n        self.mask_path = deepcopy(mask_path)\n        self.invert: bool = invert\n        self.use_luminosity: bool = use_luminosity\n        self.resources: set[tuple[PDFResourceType, str]] = set()\n        self.object_id: int = 0\n        self.matrix: Transform = matrix\n\n        if not self.use_luminosity:\n            # Pure alpha mask -> force opaque white so shape defines coverage\n            self.mask_path.style.paint_rule = PathPaintRule.FILL_NONZERO\n            self.mask_path.style.fill_opacity = 1\n            self.mask_path.style.fill_color = \"#ffffff\"\n\n    def serialize(self) -> str:\n        tr = (\n            \" /TR <</FunctionType 2 /Domain [0 1] /Range [0 1] /C0 [1] /C1 [0] /N 1>>\"\n            if self.invert\n            else \"\"\n        )\n        mask_type = \"/Luminosity\" if self.use_luminosity else \"/Alpha\"\n        return f\"<</S {mask_type} /G {self.object_id} 0 R{tr}>>\"\n\n    def get_bounding_box(self) -> tuple[float, float, float, float]:\n        bounding_box, _ = self.mask_path.bounding_box(Point(0, 0))\n        return bounding_box.to_tuple()\n\n    def get_resource_dictionary(\n        self,\n        gfxstate_objs_per_name: dict[str, PDFObject],\n        pattern_objs_per_name: dict[str, PDFObject],\n    ) -> str:\n        \"\"\"Build the resource dictionary for this soft mask, resolving GS & Pattern ids.\"\"\"\n        resources_registered: dict[str, set[str]] = {}\n        for resource_type, resource_id in self.resources:\n            resources_registered.setdefault(resource_type.value, set()).add(resource_id)\n\n        parts: list[str] = []\n\n        # ExtGState\n        if \"ExtGState\" in resources_registered and resources_registered[\"ExtGState\"]:\n            parts.append(\n                Name(\"ExtGState\").serialize()\n                + \"<<\"\n                + \"\".join(\n                    f\"{Name(gs_name).serialize()} {gfxstate_objs_per_name[gs_name].id} 0 R\"\n                    for gs_name in sorted(resources_registered[\"ExtGState\"])\n                )\n                + \">>\"\n            )\n\n        # Pattern\n        if \"Pattern\" in resources_registered and resources_registered[\"Pattern\"]:\n            parts.append(\n                Name(\"Pattern\").serialize()\n                + \"<<\"\n                + \"\".join(\n                    f\"{Name(pat_name).serialize()} {pattern_objs_per_name[pat_name].id} 0 R\"\n                    for pat_name in sorted(resources_registered[\"Pattern\"])\n                )\n                + \">>\"\n            )\n        return \"<<\" + \"\".join(parts) + \">>\"\n\n    def render(self, resource_registry: \"ResourceCatalog\") -> str:\n        stream, _, _ = self.mask_path.render(\n            resource_registry,\n            style=GraphicsStyle(),\n            last_item=Move(Point(0, 0)),\n            initial_point=Point(0, 0),\n        )\n        self.resources = resource_registry.scan_stream(stream)\n        return stream\n\n    @staticmethod\n    def coverage_white(\n        node: Union[PaintedPath, GraphicsContext],\n    ) -> Union[PaintedPath, GraphicsContext]:\n        \"\"\"\n        Return a deep-copied version of *node* whose appearance encodes only its\n        geometric coverage: every shape is converted to an **opaque white fill**\n        (nonzero rule), with **no stroke**, no soft mask, and inherited blend mode.\n\n        The transform/clipping/structure of the original node is preserved; only\n        paint-related attributes are normalized. This is intended for building the\n        “B” term of soft-mask expressions (coverage), where inside = 1 and\n        outside = 0.\n        \"\"\"\n\n        def _force_white(gc: GraphicsContext) -> None:\n            # normalize the GC's own style\n            gc.style.paint_rule = PathPaintRule.FILL_NONZERO\n            gc.style.fill_color = \"#ffffff\"\n            gc.style.fill_opacity = 1\n            gc.style.stroke_color = None\n            gc.style.blend_mode = GraphicsStyle.INHERIT\n            gc.style.soft_mask = GraphicsStyle.INHERIT\n\n            # recurse into children\n            for child in gc.path_items:\n                if isinstance(child, GraphicsContext):\n                    _force_white(child)\n                elif isinstance(child, PaintedPath):\n                    child.style.paint_rule = PathPaintRule.FILL_NONZERO\n                    child.style.fill_color = \"#ffffff\"\n                    child.style.fill_opacity = 1\n                    child.style.stroke_color = None\n                    child.style.blend_mode = GraphicsStyle.INHERIT\n                    child.style.soft_mask = GraphicsStyle.INHERIT\n\n        new_node = clone_structure(node)\n        gc = (\n            new_node\n            if isinstance(new_node, GraphicsContext)\n            else new_node.get_graphics_context()\n        )\n        _force_white(gc)\n        return new_node\n\n    @staticmethod\n    def alpha_layers_from(\n        node: GraphicsContext | PaintedPath,\n    ) -> Optional[GraphicsContext]:\n        \"\"\"\n        Build a GraphicsContext that encodes the *alpha ramps* contributed by any\n        `GradientPaint` used by *node*. Each contributing PaintedPath yields one\n        rectangle covering its content-space bounding box; that rectangle is filled\n        with an `_AlphaGradientPaint` (the gradient’s *alpha channel only*).\n        Rectangles are stacked with `BM=Multiply` so multiple alpha sources\n        combine multiplicatively.\n        \"\"\"\n        layers: list[GraphicsContext] = []\n        for n in _iter_nodes(node):\n            if isinstance(n, PaintedPath):\n                for paint in (n.style.fill_color, n.style.stroke_color):\n                    if (\n                        isinstance(paint, GradientPaint)\n                        and paint.gradient\n                        and paint.gradient.has_alpha()\n                    ):\n                        bb = n.bounding_box(Point(0, 0), expand_for_stroke=False)[0]\n                        if bb.width <= 0 or bb.height <= 0:\n                            continue\n                        rect = PaintedPath()\n                        rect.rectangle(bb.x0, bb.y0, bb.width, bb.height)\n                        alpha_paint = _AlphaGradientPaint(\n                            gradient=paint.gradient,\n                            units=paint.units,\n                            gradient_transform=paint.gradient_transform,\n                            apply_page_ctm=paint.apply_page_ctm,\n                        )\n                        rect.style.fill_color = alpha_paint\n                        rect.style.stroke_color = None\n                        rect.style.stroke_width = 0\n                        rect.style.paint_rule = PathPaintRule.FILL_NONZERO\n\n                        layer_gc = GraphicsContext()\n                        layer_gc.add_item(rect, clone=False)\n                        # multiply multiple alpha contributors together\n                        layer_gc.style.blend_mode = BlendMode.MULTIPLY\n                        layers.append(layer_gc)\n\n        if not layers:\n            return None\n\n        A = GraphicsContext()\n        for layer in layers:\n            A.add_item(layer)\n        return A\n\n    @classmethod\n    def from_AB(\n        cls,\n        A: Optional[GraphicsContext],\n        B: Union[PaintedPath, GraphicsContext],\n        invert: bool,\n        registry: \"ResourceCatalog\",\n        region_bbox: Optional[\"BoundingBox\"] = None,\n    ) -> \"PaintSoftMask\":\n        \"\"\"\n        Construct a **luminosity soft mask** from two ingredients:\n\n        - **A**: Optional GraphicsContext encoding alpha ramps (e.g., the result of\n        :meth:`alpha_layers_from`). If ``None``, the effective alpha is 1.\n        - **B**: Coverage term (e.g., the result of :meth:`coverage_white`).\n\n        The mask luminance is:\n            - ``A × B``        when ``invert = False``\n            - ``A × (1 − B)``  when ``invert = True``\n\n        Implementation outline:\n        1. Compute the union bbox of A and B (no stroke expansion).\n        2. Paint a background rectangle: **black** for ``A×B`` or **white** for\n        ``A×(1−B)``.\n        3. Paint **B**; when ``invert=True``, set ``BM=Difference`` to obtain\n        ``1−B`` from the white background.\n        4. If A is present, paint it with ``BM=Multiply`` to apply the alpha ramp.\n        5. Wrap the result as a Form XObject and attach it as ``/SMask`` with\n        ``/S /Luminosity``.\n        \"\"\"\n\n        # Decide the canvas/BBox for the soft mask\n        if region_bbox is not None:\n            union = region_bbox\n        else:\n            bb_A = (\n                A.bounding_box(Point(0, 0), expand_for_stroke=False)[0] if A else None\n            )\n            bb_B = B.bounding_box(Point(0, 0), expand_for_stroke=False)[0]\n            union = bb_B if bb_A is None else bb_A.merge(bb_B)\n\n        canvas = GraphicsContext()\n\n        # Background: black for A×B, white for A×(1−B)\n        bg = PaintedPath()\n        bg.rectangle(union.x0, union.y0, union.width, union.height)\n        bg.style.fill_color = \"#000000\" if not invert else \"#ffffff\"\n        bg.style.fill_opacity = 1\n        bg.style.stroke_color = None\n        canvas.add_item(bg)\n\n        # Paint B (optionally build 1−B using Difference on white bg)\n        if invert:\n            B.style.blend_mode = BlendMode.DIFFERENCE\n        canvas.add_item(B)\n\n        # Multiply by A if present\n        if A is not None:\n            A.style.blend_mode = BlendMode.MULTIPLY\n            canvas.add_item(A)\n\n        sm = cls(canvas, invert=False, use_luminosity=True)\n        _ = sm.render(registry)\n        sm.object_id = registry.register_soft_mask(sm)\n        return sm",
      "language": "python"
    },
    {
      "code": "class PaintSoftMask:\n    \"\"\"\n    Wraps a vector path as a PDF soft mask (SMask) that can be attached to a\n    graphics state.\n\n    The provided `mask_path` is deep-copied and forced to render as an opaque\n    grayscale fill (white, alpha=1, nonzero rule, transparency disabled). During\n    rendering, the mask’s content stream is generated and its resource\n    dictionary is collected so it can be embedded as a Form XObject and\n    referenced from an ExtGState.\n    \"\"\"\n\n    __slots__ = (\n        \"mask_path\",\n        \"invert\",\n        \"resources\",\n        \"use_luminosity\",\n        \"object_id\",\n        \"matrix\",\n    )\n\n    def __init__(\n        self,\n        mask_path: Union[PaintedPath, GraphicsContext],\n        invert: bool = False,\n        use_luminosity: bool = False,\n        matrix: Transform = Transform.identity(),\n    ):\n        self.mask_path = deepcopy(mask_path)\n        self.invert: bool = invert\n        self.use_luminosity: bool = use_luminosity\n        self.resources: set[tuple[PDFResourceType, str]] = set()\n        self.object_id: int = 0\n        self.matrix: Transform = matrix\n\n        if not self.use_luminosity:\n            # Pure alpha mask -> force opaque white so shape defines coverage\n            self.mask_path.style.paint_rule = PathPaintRule.FILL_NONZERO\n            self.mask_path.style.fill_opacity = 1\n            self.mask_path.style.fill_color = \"#ffffff\"\n\n    def serialize(self) -> str:\n        tr = (\n            \" /TR <</FunctionType 2 /Domain [0 1] /Range [0 1] /C0 [1] /C1 [0] /N 1>>\"\n            if self.invert\n            else \"\"\n        )\n        mask_type = \"/Luminosity\" if self.use_luminosity else \"/Alpha\"\n        return f\"<</S {mask_type} /G {self.object_id} 0 R{tr}>>\"\n\n    def get_bounding_box(self) -> tuple[float, float, float, float]:\n        bounding_box, _ = self.mask_path.bounding_box(Point(0, 0))\n        return bounding_box.to_tuple()\n\n    def get_resource_dictionary(\n        self,\n        gfxstate_objs_per_name: dict[str, PDFObject],\n        pattern_objs_per_name: dict[str, PDFObject],\n    ) -> str:\n        \"\"\"Build the resource dictionary for this soft mask, resolving GS & Pattern ids.\"\"\"\n        resources_registered: dict[str, set[str]] = {}\n        for resource_type, resource_id in self.resources:\n            resources_registered.setdefault(resource_type.value, set()).add(resource_id)\n\n        parts: list[str] = []\n\n        # ExtGState\n        if \"ExtGState\" in resources_registered and resources_registered[\"ExtGState\"]:\n            parts.append(\n                Name(\"ExtGState\").serialize()\n                + \"<<\"\n                + \"\".join(\n                    f\"{Name(gs_name).serialize()} {gfxstate_objs_per_name[gs_name].id} 0 R\"\n                    for gs_name in sorted(resources_registered[\"ExtGState\"])\n                )\n                + \">>\"\n            )\n\n        # Pattern\n        if \"Pattern\" in resources_registered and resources_registered[\"Pattern\"]:\n            parts.append(\n                Name(\"Pattern\").serialize()\n                + \"<<\"\n                + \"\".join(\n                    f\"{Name(pat_name).serialize()} {pattern_objs_per_name[pat_name].id} 0 R\"\n                    for pat_name in sorted(resources_registered[\"Pattern\"])\n                )\n                + \">>\"\n            )\n        return \"<<\" + \"\".join(parts) + \">>\"\n\n    def render(self, resource_registry: \"ResourceCatalog\") -> str:\n        stream, _, _ = self.mask_path.render(\n            resource_registry,\n            style=GraphicsStyle(),\n            last_item=Move(Point(0, 0)),\n            initial_point=Point(0, 0),\n        )\n        self.resources = resource_registry.scan_stream(stream)\n        return stream\n\n    @staticmethod\n    def coverage_white(\n        node: Union[PaintedPath, GraphicsContext],\n    ) -> Union[PaintedPath, GraphicsContext]:\n        \"\"\"\n        Return a deep-copied version of *node* whose appearance encodes only its\n        geometric coverage: every shape is converted to an **opaque white fill**\n        (nonzero rule), with **no stroke**, no soft mask, and inherited blend mode.\n\n        The transform/clipping/structure of the original node is preserved; only\n        paint-related attributes are normalized. This is intended for building the\n        “B” term of soft-mask expressions (coverage), where inside = 1 and\n        outside = 0.\n        \"\"\"\n\n        def _force_white(gc: GraphicsContext) -> None:\n            # normalize the GC's own style\n            gc.style.paint_rule = PathPaintRule.FILL_NONZERO\n            gc.style.fill_color = \"#ffffff\"\n            gc.style.fill_opacity = 1\n            gc.style.stroke_color = None\n            gc.style.blend_mode = GraphicsStyle.INHERIT\n            gc.style.soft_mask = GraphicsStyle.INHERIT\n\n            # recurse into children\n            for child in gc.path_items:\n                if isinstance(child, GraphicsContext):\n                    _force_white(child)\n                elif isinstance(child, PaintedPath):\n                    child.style.paint_rule = PathPaintRule.FILL_NONZERO\n                    child.style.fill_color = \"#ffffff\"\n                    child.style.fill_opacity = 1\n                    child.style.stroke_color = None\n                    child.style.blend_mode = GraphicsStyle.INHERIT\n                    child.style.soft_mask = GraphicsStyle.INHERIT\n\n        new_node = clone_structure(node)\n        gc = (\n            new_node\n            if isinstance(new_node, GraphicsContext)\n            else new_node.get_graphics_context()\n        )\n        _force_white(gc)\n        return new_node\n\n    @staticmethod\n    def alpha_layers_from(\n        node: GraphicsContext | PaintedPath,\n    ) -> Optional[GraphicsContext]:\n        \"\"\"\n        Build a GraphicsContext that encodes the *alpha ramps* contributed by any\n        `GradientPaint` used by *node*. Each contributing PaintedPath yields one\n        rectangle covering its content-space bounding box; that rectangle is filled\n        with an `_AlphaGradientPaint` (the gradient’s *alpha channel only*).\n        Rectangles are stacked with `BM=Multiply` so multiple alpha sources\n        combine multiplicatively.\n        \"\"\"\n        layers: list[GraphicsContext] = []\n        for n in _iter_nodes(node):\n            if isinstance(n, PaintedPath):\n                for paint in (n.style.fill_color, n.style.stroke_color):\n                    if (\n                        isinstance(paint, GradientPaint)\n                        and paint.gradient\n                        and paint.gradient.has_alpha()\n                    ):\n                        bb = n.bounding_box(Point(0, 0), expand_for_stroke=False)[0]\n                        if bb.width <= 0 or bb.height <= 0:\n                            continue\n                        rect = PaintedPath()\n                        rect.rectangle(bb.x0, bb.y0, bb.width, bb.height)\n                        alpha_paint = _AlphaGradientPaint(\n                            gradient=paint.gradient,\n                            units=paint.units,\n                            gradient_transform=paint.gradient_transform,\n                            apply_page_ctm=paint.apply_page_ctm,\n                        )\n                        rect.style.fill_color = alpha_paint\n                        rect.style.stroke_color = None\n                        rect.style.stroke_width = 0\n                        rect.style.paint_rule = PathPaintRule.FILL_NONZERO\n\n                        layer_gc = GraphicsContext()\n                        layer_gc.add_item(rect, clone=False)\n                        # multiply multiple alpha contributors together\n                        layer_gc.style.blend_mode = BlendMode.MULTIPLY\n                        layers.append(layer_gc)\n\n        if not layers:\n            return None\n\n        A = GraphicsContext()\n        for layer in layers:\n            A.add_item(layer)\n        return A\n\n    @classmethod\n    def from_AB(\n        cls,\n        A: Optional[GraphicsContext],\n        B: Union[PaintedPath, GraphicsContext],\n        invert: bool,\n        registry: \"ResourceCatalog\",\n        region_bbox: Optional[\"BoundingBox\"] = None,\n    ) -> \"PaintSoftMask\":\n        \"\"\"\n        Construct a **luminosity soft mask** from two ingredients:\n\n        - **A**: Optional GraphicsContext encoding alpha ramps (e.g., the result of\n        :meth:`alpha_layers_from`). If ``None``, the effective alpha is 1.\n        - **B**: Coverage term (e.g., the result of :meth:`coverage_white`).\n\n        The mask luminance is:\n            - ``A × B``        when ``invert = False``\n            - ``A × (1 − B)``  when ``invert = True``\n\n        Implementation outline:\n        1. Compute the union bbox of A and B (no stroke expansion).\n        2. Paint a background rectangle: **black** for ``A×B`` or **white** for\n        ``A×(1−B)``.\n        3. Paint **B**; when ``invert=True``, set ``BM=Difference`` to obtain\n        ``1−B`` from the white background.\n        4. If A is present, paint it with ``BM=Multiply`` to apply the alpha ramp.\n        5. Wrap the result as a Form XObject and attach it as ``/SMask`` with\n        ``/S /Luminosity``.\n        \"\"\"\n\n        # Decide the canvas/BBox for the soft mask\n        if region_bbox is not None:\n            union = region_bbox\n        else:\n            bb_A = (\n                A.bounding_box(Point(0, 0), expand_for_stroke=False)[0] if A else None\n            )\n            bb_B = B.bounding_box(Point(0, 0), expand_for_stroke=False)[0]\n            union = bb_B if bb_A is None else bb_A.merge(bb_B)\n\n        canvas = GraphicsContext()\n\n        # Background: black for A×B, white for A×(1−B)\n        bg = PaintedPath()\n        bg.rectangle(union.x0, union.y0, union.width, union.height)\n        bg.style.fill_color = \"#000000\" if not invert else \"#ffffff\"\n        bg.style.fill_opacity = 1\n        bg.style.stroke_color = None\n        canvas.add_item(bg)\n\n        # Paint B (optionally build 1−B using Difference on white bg)\n        if invert:\n            B.style.blend_mode = BlendMode.DIFFERENCE\n        canvas.add_item(B)\n\n        # Multiply by A if present\n        if A is not None:\n            A.style.blend_mode = BlendMode.MULTIPLY\n            canvas.add_item(A)\n\n        sm = cls(canvas, invert=False, use_luminosity=True)\n        _ = sm.render(registry)\n        sm.object_id = registry.register_soft_mask(sm)\n        return sm",
      "language": "python"
    },
    {
      "code": "def get_bounding_box(self) -> tuple[float, float, float, float]:\n    bounding_box, _ = self.mask_path.bounding_box(Point(0, 0))\n    return bounding_box.to_tuple()",
      "language": "python"
    },
    {
      "code": "def get_resource_dictionary(\n    self,\n    gfxstate_objs_per_name: dict[str, PDFObject],\n    pattern_objs_per_name: dict[str, PDFObject],\n) -> str:\n    \"\"\"Build the resource dictionary for this soft mask, resolving GS & Pattern ids.\"\"\"\n    resources_registered: dict[str, set[str]] = {}\n    for resource_type, resource_id in self.resources:\n        resources_registered.setdefault(resource_type.value, set()).add(resource_id)\n\n    parts: list[str] = []\n\n    # ExtGState\n    if \"ExtGState\" in resources_registered and resources_registered[\"ExtGState\"]:\n        parts.append(\n            Name(\"ExtGState\").serialize()\n            + \"<<\"\n            + \"\".join(\n                f\"{Name(gs_name).serialize()} {gfxstate_objs_per_name[gs_name].id} 0 R\"\n                for gs_name in sorted(resources_registered[\"ExtGState\"])\n            )\n            + \">>\"\n        )\n\n    # Pattern\n    if \"Pattern\" in resources_registered and resources_registered[\"Pattern\"]:\n        parts.append(\n            Name(\"Pattern\").serialize()\n            + \"<<\"\n            + \"\".join(\n                f\"{Name(pat_name).serialize()} {pattern_objs_per_name[pat_name].id} 0 R\"\n                for pat_name in sorted(resources_registered[\"Pattern\"])\n            )\n            + \">>\"\n        )\n    return \"<<\" + \"\".join(parts) + \">>\"",
      "language": "python"
    },
    {
      "code": "def render(self, resource_registry: \"ResourceCatalog\") -> str:\n    stream, _, _ = self.mask_path.render(\n        resource_registry,\n        style=GraphicsStyle(),\n        last_item=Move(Point(0, 0)),\n        initial_point=Point(0, 0),\n    )\n    self.resources = resource_registry.scan_stream(stream)\n    return stream",
      "language": "python"
    },
    {
      "code": "def serialize(self) -> str:\n    tr = (\n        \" /TR <</FunctionType 2 /Domain [0 1] /Range [0 1] /C0 [1] /C1 [0] /N 1>>\"\n        if self.invert\n        else \"\"\n    )\n    mask_type = \"/Luminosity\" if self.use_luminosity else \"/Alpha\"\n    return f\"<</S {mask_type} /G {self.object_id} 0 R{tr}>>\"",
      "language": "python"
    },
    {
      "code": "class PaintedPath:\n    \"\"\"\n    A path to be drawn by the PDF renderer.\n\n    A painted path is defined by a style and an arbitrary sequence of path elements,\n    which include the primitive path elements (`Move`, `Line`, `BezierCurve`, ...) as\n    well as arbitrarily nested `GraphicsContext` containing their own sequence of\n    primitive path elements and `GraphicsContext`.\n    \"\"\"\n\n    __slots__ = (\n        \"_root_graphics_context\",\n        \"_graphics_context\",\n        \"_closed\",\n        \"_close_context\",\n        \"_starter_move\",\n    )\n\n    def __init__(self, x: float = 0, y: float = 0) -> None:\n        self._root_graphics_context: GraphicsContext = GraphicsContext()\n        self._graphics_context: GraphicsContext = self._root_graphics_context\n\n        self._closed: bool = True\n        self._close_context: GraphicsContext = self._graphics_context\n\n        self._starter_move: Optional[Renderable] = Move(Point(x, y))\n\n    def __deepcopy__(self: PP, memo: dict[int, Any]) -> PP:\n        # there's no real way to recover the matching current _graphics_context after\n        # copying the root context, but that's ok because we can just disallow copying\n        # of paths under modification as that is almost certainly wrong usage.\n        if self._graphics_context is not self._root_graphics_context:\n            raise RuntimeError(f\"cannot copy path {self} while it is being modified\")\n\n        copied = self.__class__()\n        copied._root_graphics_context = deepcopy(self._root_graphics_context, memo)\n        copied._graphics_context = copied._root_graphics_context\n        copied._closed = self._closed\n        copied._close_context = copied._graphics_context\n\n        return copied\n\n    @property\n    def style(self) -> GraphicsStyle:\n        \"\"\"The `GraphicsStyle` applied to all elements of this path.\"\"\"\n        return self._root_graphics_context.style\n\n    @property\n    def transform(self) -> Optional[Transform]:\n        \"\"\"The `Transform` that applies to all of the elements of this path.\"\"\"\n        return self._root_graphics_context.transform\n\n    @transform.setter\n    def transform(self, tf: Transform) -> None:\n        self._root_graphics_context.transform = tf\n\n    @property\n    def auto_close(self) -> bool | InheritType:\n        \"\"\"If true, the path should automatically close itself before painting.\"\"\"\n        return self.style.auto_close\n\n    @auto_close.setter\n    def auto_close(self, should: bool) -> None:\n        self.style.auto_close = should\n\n    @property\n    def paint_rule(self) -> PathPaintRule | InheritType | None:\n        \"\"\"Manually specify the `PathPaintRule` to use for rendering the path.\"\"\"\n        return self.style.paint_rule\n\n    @paint_rule.setter\n    def paint_rule(self, style: PathPaintRule) -> None:\n        self.style.paint_rule = style\n\n    @property\n    def clipping_path(self) -> Optional[\"ClippingPath\"]:\n        \"\"\"Set the clipping path for this path.\"\"\"\n        return self._root_graphics_context.clipping_path\n\n    @clipping_path.setter\n    def clipping_path(self, new_clipath: Optional[\"ClippingPath\"]) -> None:\n        self._root_graphics_context.clipping_path = new_clipath\n\n    def get_graphics_context(self) -> \"GraphicsContext\":\n        return self._graphics_context\n\n    @contextmanager\n    def _new_graphics_context(\n        self, _attach: bool = True\n    ) -> Iterator[\"GraphicsContext\"]:\n        old_graphics_context = self._graphics_context\n        new_graphics_context = GraphicsContext()\n        self._graphics_context = new_graphics_context\n        try:\n            yield new_graphics_context\n            if _attach:\n                old_graphics_context.add_item(new_graphics_context)\n        finally:\n            self._graphics_context = old_graphics_context\n\n    @contextmanager\n    def transform_group(self, transform: Transform) -> Iterator[\"PaintedPath\"]:\n        \"\"\"\n        Apply the provided `Transform` to all points added within this context.\n        \"\"\"\n        with self._new_graphics_context() as ctxt:\n            ctxt.transform = transform\n            yield self\n\n    def add_path_element(self, item: Renderable, clone: bool = True) -> None:\n        \"\"\"\n        Add the given element as a path item of this path.\n\n        Args:\n            item: the item to add to this path.\n            clone (bool): if true (the default), the item will be copied before being\n                appended. This prevents modifications to a referenced object from\n                \"retroactively\" altering its style/shape and should be disabled with\n                caution.\n        \"\"\"\n        if self._starter_move is not None:\n            self._closed = False\n            self._graphics_context.add_item(self._starter_move, clone=False)\n            self._close_context = self._graphics_context\n            self._starter_move = None\n\n        self._graphics_context.add_item(item, clone=clone)\n\n    def remove_last_path_element(self) -> None:\n        self._graphics_context.remove_last_item()\n\n    def rectangle(\n        self, x: Number, y: Number, w: Number, h: Number, rx: Number = 0, ry: Number = 0\n    ) -> \"PaintedPath\":\n        \"\"\"\n        Append a rectangle as a closed subpath to the current path.\n\n        If the width or the height are 0, the rectangle will be collapsed to a line\n        (unless they're both 0, in which case it's collapsed to nothing).\n\n        Args:\n            x (Number): the abscissa of the starting corner of the rectangle.\n            y (Number): the ordinate of the starting corner of the rectangle.\n            w (Number): the width of the rectangle (if 0, the rectangle will be\n                rendered as a vertical line).\n            h (Number): the height of the rectangle (if 0, the rectangle will be\n                rendered as a horizontal line).\n            rx (Number): the x-radius of the rectangle rounded corner (if 0 the corners\n                will not be rounded).\n            ry (Number): the y-radius of the rectangle rounded corner (if 0 the corners\n                will not be rounded).\n\n        Returns:\n            The path, to allow chaining method calls.\n        \"\"\"\n\n        self._insert_implicit_close_if_open()\n        self.add_path_element(\n            RoundedRectangle(\n                Point(float(x), float(y)),\n                Point(float(w), float(h)),\n                Point(float(rx), float(ry)),\n            ),\n            clone=False,\n        )\n        self._closed = True\n        self.move_to(x, y)\n\n        return self\n\n    def circle(self, cx: Number, cy: Number, r: Number) -> \"PaintedPath\":\n        \"\"\"\n        Append a circle as a closed subpath to the current path.\n\n        Args:\n            cx (Number): the abscissa of the circle's center point.\n            cy (Number): the ordinate of the circle's center point.\n            r (Number): the radius of the circle.\n\n        Returns:\n            The path, to allow chaining method calls.\n        \"\"\"\n        return self.ellipse(cx, cy, r, r)\n\n    def ellipse(self, cx: Number, cy: Number, rx: Number, ry: Number) -> \"PaintedPath\":\n        \"\"\"\n        Append an ellipse as a closed subpath to the current path.\n\n        Args:\n            cx (Number): the abscissa of the ellipse's center point.\n            cy (Number): the ordinate of the ellipse's center point.\n            rx (Number): the x-radius of the ellipse.\n            ry (Number): the y-radius of the ellipse.\n\n        Returns:\n            The path, to allow chaining method calls.\n        \"\"\"\n        self._insert_implicit_close_if_open()\n        self.add_path_element(\n            Ellipse(Point(float(rx), float(ry)), Point(float(cx), float(cy))),\n            clone=False,\n        )\n        self._closed = True\n        self.move_to(cx, cy)\n\n        return self\n\n    def move_to(self, x: Number, y: Number) -> \"PaintedPath\":\n        \"\"\"\n        Start a new subpath or move the path starting point.\n\n        If no path elements have been added yet, this will change the path starting\n        point. If path elements have been added, this will insert an implicit close in\n        order to start a new subpath.\n\n        Args:\n            x (Number): abscissa of the (sub)path starting point.\n            y (Number): ordinate of the (sub)path starting point.\n\n        Returns:\n            The path, to allow chaining method calls.\n        \"\"\"\n        self._insert_implicit_close_if_open()\n        self._starter_move = Move(Point(float(x), float(y)))\n        return self\n\n    def move_relative(self, x: Number, y: Number) -> \"PaintedPath\":\n        \"\"\"\n        Start a new subpath or move the path start point relative to the previous point.\n\n        If no path elements have been added yet, this will change the path starting\n        point. If path elements have been added, this will insert an implicit close in\n        order to start a new subpath.\n\n        This will overwrite an absolute move_to as long as no non-move path items have\n        been appended. The relative position is resolved from the previous item when\n        the path is being rendered, or from 0, 0 if it is the first item.\n\n        Args:\n            x (Number): abscissa of the (sub)path starting point relative to the previous point.\n            y (Number): ordinate of the (sub)path starting point relative to the previous point.\n        \"\"\"\n        self._insert_implicit_close_if_open()\n        if self._starter_move is not None:\n            self._closed = False\n            self._graphics_context.add_item(self._starter_move, clone=False)\n            self._close_context = self._graphics_context\n        self._starter_move = RelativeMove(Point(float(x), float(y)))\n        return self\n\n    def line_to(self, x: Number, y: Number) -> \"PaintedPath\":\n        \"\"\"\n        Append a straight line to this path.\n\n        Args:\n            x (Number): abscissa the line's end point.\n            y (Number): ordinate of the line's end point.\n\n        Returns:\n            The path, to allow chaining method calls.\n        \"\"\"\n        self.add_path_element(Line(Point(float(x), float(y))), clone=False)\n        return self\n\n    def line_relative(self, dx: Number, dy: Number) -> \"PaintedPath\":\n        \"\"\"\n        Append a straight line whose end is computed as an offset from the end of the\n        previous path element.\n\n        Args:\n            x (Number): abscissa the line's end point relative to the end point of the\n                previous path element.\n            y (Number): ordinate of the line's end point relative to the end point of\n                the previous path element.\n\n        Returns:\n            The path, to allow chaining method calls.\n        \"\"\"\n        self.add_path_element(RelativeLine(Point(float(dx), float(dy))), clone=False)\n        return self\n\n    def horizontal_line_to(self, x: Number) -> \"PaintedPath\":\n        \"\"\"\n        Append a straight horizontal line to the given abscissa. The ordinate is\n        retrieved from the end point of the previous path element.\n\n        Args:\n            x (Number): abscissa of the line's end point.\n\n        Returns:\n            The path, to allow chaining method calls.\n        \"\"\"\n        self.add_path_element(HorizontalLine(float(x)), clone=False)\n        return self\n\n    def horizontal_line_relative(self, dx: Number) -> \"PaintedPath\":\n        \"\"\"\n        Append a straight horizontal line to the given offset from the previous path\n        element. The ordinate is retrieved from the end point of the previous path\n        element.\n\n        Args:\n            x (Number): abscissa of the line's end point relative to the end point of\n                the previous path element.\n\n        Returns:\n            The path, to allow chaining method calls.\n        \"\"\"\n        self.add_path_element(RelativeHorizontalLine(float(dx)), clone=False)\n        return self\n\n    def vertical_line_to(self, y: Number) -> \"PaintedPath\":\n        \"\"\"\n        Append a straight vertical line to the given ordinate. The abscissa is\n        retrieved from the end point of the previous path element.\n\n        Args:\n            y (Number): ordinate of the line's end point.\n\n        Returns:\n            The path, to allow chaining method calls.\n        \"\"\"\n        self.add_path_element(VerticalLine(float(y)), clone=False)\n        return self\n\n    def vertical_line_relative(self, dy: Number) -> \"PaintedPath\":\n        \"\"\"\n        Append a straight vertical line to the given offset from the previous path\n        element. The abscissa is retrieved from the end point of the previous path\n        element.\n\n        Args:\n            y (Number): ordinate of the line's end point relative to the end point of\n                the previous path element.\n\n        Returns:\n            The path, to allow chaining method calls.\n        \"\"\"\n        self.add_path_element(RelativeVerticalLine(float(dy)), clone=False)\n        return self\n\n    def curve_to(\n        self, x1: Number, y1: Number, x2: Number, y2: Number, x3: Number, y3: Number\n    ) -> \"PaintedPath\":\n        \"\"\"\n        Append a cubic Bézier curve to this path.\n\n        Args:\n            x1 (Number): abscissa of the first control point\n            y1 (Number): ordinate of the first control point\n            x2 (Number): abscissa of the second control point\n            y2 (Number): ordinate of the second control point\n            x3 (Number): abscissa of the end point\n            y3 (Number): ordinate of the end point\n\n        Returns:\n            The path, to allow chaining method calls.\n        \"\"\"\n        ctrl1 = Point(float(x1), float(y1))\n        ctrl2 = Point(float(x2), float(y2))\n        end = Point(float(x3), float(y3))\n\n        self.add_path_element(BezierCurve(ctrl1, ctrl2, end), clone=False)\n        return self\n\n    def curve_relative(\n        self,\n        dx1: Number,\n        dy1: Number,\n        dx2: Number,\n        dy2: Number,\n        dx3: Number,\n        dy3: Number,\n    ) -> \"PaintedPath\":\n        \"\"\"\n        Append a cubic Bézier curve whose points are expressed relative to the\n        end point of the previous path element.\n\n        E.g. with a start point of (0, 0), given (1, 1), (2, 2), (3, 3), the output\n        curve would have the points:\n\n        (0, 0) c1 (1, 1) c2 (3, 3) e (6, 6)\n\n        Args:\n            dx1 (Number): abscissa of the first control point relative to the end point\n                of the previous path element\n            dy1 (Number): ordinate of the first control point relative to the end point\n                of the previous path element\n            dx2 (Number): abscissa offset of the second control point relative to the\n                end point of the previous path element\n            dy2 (Number): ordinate offset of the second control point relative to the\n                end point of the previous path element\n            dx3 (Number): abscissa offset of the end point relative to the end point of\n                the previous path element\n            dy3 (Number): ordinate offset of the end point relative to the end point of\n                the previous path element\n\n        Returns:\n            The path, to allow chaining method calls.\n        \"\"\"\n        c1d = Point(float(dx1), float(dy1))\n        c2d = Point(float(dx2), float(dy2))\n        end = Point(float(dx3), float(dy3))\n\n        self.add_path_element(RelativeBezierCurve(c1d, c2d, end), clone=False)\n        return self\n\n    def quadratic_curve_to(\n        self, x1: Number, y1: Number, x2: Number, y2: Number\n    ) -> \"PaintedPath\":\n        \"\"\"\n        Append a cubic Bézier curve mimicking the specified quadratic Bézier curve.\n\n        Args:\n            x1 (Number): abscissa of the control point\n            y1 (Number): ordinate of the control point\n            x2 (Number): abscissa of the end point\n            y2 (Number): ordinate of the end point\n\n        Returns:\n            The path, to allow chaining method calls.\n        \"\"\"\n        ctrl = Point(float(x1), float(y1))\n        end = Point(float(x2), float(y2))\n        self.add_path_element(QuadraticBezierCurve(ctrl, end), clone=False)\n        return self\n\n    def quadratic_curve_relative(\n        self, dx1: Number, dy1: Number, dx2: Number, dy2: Number\n    ) -> \"PaintedPath\":\n        \"\"\"\n        Append a cubic Bézier curve mimicking the specified quadratic Bézier curve.\n\n        Args:\n            dx1 (Number): abscissa of the control point relative to the end point of\n                the previous path element\n            dy1 (Number): ordinate of the control point relative to the end point of\n                the previous path element\n            dx2 (Number): abscissa offset of the end point relative to the end point of\n                the previous path element\n            dy2 (Number): ordinate offset of the end point relative to the end point of\n                the previous path element\n\n        Returns:\n            The path, to allow chaining method calls.\n        \"\"\"\n        ctrl = Point(float(dx1), float(dy1))\n        end = Point(float(dx2), float(dy2))\n        self.add_path_element(RelativeQuadraticBezierCurve(ctrl, end), clone=False)\n        return self\n\n    def arc_to(\n        self,\n        rx: Number,\n        ry: Number,\n        rotation: Number,\n        large_arc: bool,\n        positive_sweep: bool,\n        x: Number,\n        y: Number,\n    ) -> \"PaintedPath\":\n        \"\"\"\n        Append an elliptical arc from the end of the previous path point to the\n        specified end point.\n\n        The arc is approximated using Bézier curves, so it is not perfectly accurate.\n        However, the error is small enough to not be noticeable at any reasonable\n        (and even most unreasonable) scales, with a worst-case deviation of around 3‱.\n\n        Notes:\n            - The signs of the radii arguments (`rx` and `ry`) are ignored (i.e. their\n              absolute values are used instead).\n            - If either radius is 0, then a straight line will be emitted instead of an\n              arc.\n            - If the radii are too small for the arc to reach from the current point to\n              the specified end point (`x` and `y`), then they will be proportionally\n              scaled up until they are big enough, which will always result in a\n              half-ellipse arc (i.e. an 180 degree sweep)\n\n        Args:\n            rx (Number): radius in the x-direction.\n            ry (Number): radius in the y-direction.\n            rotation (Number): angle (in degrees) that the arc should be rotated\n                clockwise from the principle axes. This parameter does not have\n                a visual effect in the case that `rx == ry`.\n            large_arc (bool): if True, the arc will cover a sweep angle of at least 180\n                degrees. Otherwise, the sweep angle will be at most 180 degrees.\n            positive_sweep (bool): if True, the arc will be swept over a positive angle,\n                i.e. clockwise. Otherwise, the arc will be swept over a negative\n                angle.\n            x (Number): abscissa of the arc's end point.\n            y (Number): ordinate of the arc's end point.\n        \"\"\"\n\n        if rx == 0 or ry == 0:\n            return self.line_to(x, y)\n        rx_float = float(rx)\n        ry_float = float(ry)\n        radii = Point(abs(rx_float), abs(ry_float))\n        large_arc = bool(large_arc)\n        rotation = math.radians(rotation)\n        positive_sweep = bool(positive_sweep)\n        end = Point(float(x), float(y))\n\n        self.add_path_element(\n            Arc(radii, rotation, large_arc, positive_sweep, end), clone=False\n        )\n        return self\n\n    def arc_relative(\n        self,\n        rx: Number,\n        ry: Number,\n        rotation: Number,\n        large_arc: bool,\n        positive_sweep: bool,\n        dx: Number,\n        dy: Number,\n    ) -> \"PaintedPath\":\n        \"\"\"\n        Append an elliptical arc from the end of the previous path point to an offset\n        point.\n\n        The arc is approximated using Bézier curves, so it is not perfectly accurate.\n        However, the error is small enough to not be noticeable at any reasonable\n        (and even most unreasonable) scales, with a worst-case deviation of around 3‱.\n\n        Notes:\n            - The signs of the radii arguments (`rx` and `ry`) are ignored (i.e. their\n              absolute values are used instead).\n            - If either radius is 0, then a straight line will be emitted instead of an\n              arc.\n            - If the radii are too small for the arc to reach from the current point to\n              the specified end point (`x` and `y`), then they will be proportionally\n              scaled up until they are big enough, which will always result in a\n              half-ellipse arc (i.e. an 180 degree sweep)\n\n        Args:\n            rx (Number): radius in the x-direction.\n            ry (Number): radius in the y-direction.\n            rotation (Number): angle (in degrees) that the arc should be rotated\n                clockwise from the principle axes. This parameter does not have\n                a visual effect in the case that `rx == ry`.\n            large_arc (bool): if True, the arc will cover a sweep angle of at least 180\n                degrees. Otherwise, the sweep angle will be at most 180 degrees.\n            positive_sweep (bool): if True, the arc will be swept over a positive angle,\n                i.e. clockwise. Otherwise, the arc will be swept over a negative\n                angle.\n            dx (Number): abscissa of the arc's end point relative to the end point of\n                the previous path element.\n            dy (Number): ordinate of the arc's end point relative to the end point of\n                the previous path element.\n        \"\"\"\n        if rx == 0 or ry == 0:\n            return self.line_relative(dx, dy)\n        rx_float = float(rx)\n        ry_float = float(ry)\n        radii = Point(abs(rx_float), abs(ry_float))\n        large_arc = bool(large_arc)\n        rotation = math.radians(rotation)\n        positive_sweep = bool(positive_sweep)\n        end = Point(float(dx), float(dy))\n\n        self.add_path_element(\n            RelativeArc(radii, rotation, large_arc, positive_sweep, end), clone=False\n        )\n        return self\n\n    def text(\n        self,\n        x: float,\n        y: float,\n        content: str,\n        font_family: str = \"helvetica\",\n        font_style: str = \"\",  # \"\", \"B\", \"I\", \"BI\"\n        font_size: float = 12.0,\n        text_anchor: str = \"start\",  # \"start\" | \"middle\" | \"end\"\n    ) -> \"PaintedPath\":\n        \"\"\"\n        Append a text run at (x, y) to this path.\n\n        The baseline is at (x, y). `text_anchor` controls alignment about x.\n        `font_style` accepts \"\", \"B\", \"I\", or \"BI\". `font_family` can be a single\n        name or a comma-separated fallback list (handled at render-time).\n\n        Returns:\n            self (to allow chaining)\n        \"\"\"\n        # Normalize style just in case e.g. \"ib\" -> \"BI\"\n        s = \"\".join(sorted(font_style.upper()))\n\n        self.add_path_element(\n            Text(\n                x=x,\n                y=y,\n                text_runs=(\n                    TextRun(\n                        text=content,\n                        family=font_family,\n                        emphasis=s,\n                        size=font_size,\n                    ),\n                ),\n                text_anchor=text_anchor,\n            ),\n            clone=False,\n        )\n        return self\n\n    def close(self) -> None:\n        \"\"\"\n        Explicitly close the current (sub)path.\n        \"\"\"\n        self.add_path_element(Close(), clone=False)\n        self._closed = True\n        self.move_relative(0, 0)\n\n    def _insert_implicit_close_if_open(self) -> None:\n        if not self._closed:\n            self._close_context.add_item(ImplicitClose(), clone=False)\n            self._close_context = self._graphics_context\n            self._closed = True\n\n    def bounding_box(\n        self, start: Point, expand_for_stroke: bool = True\n    ) -> tuple[BoundingBox, Point]:\n        \"\"\"Compute the bounding box of this painted path, including nested contexts and transformations.\"\"\"\n        return self._root_graphics_context.bounding_box(\n            start, self.style, expand_for_stroke=expand_for_stroke\n        )\n\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        self._insert_implicit_close_if_open()\n\n        (\n            render_list,\n            last_item,\n            initial_point,\n        ) = self._root_graphics_context.build_render_list(\n            resource_registry, style, last_item, initial_point\n        )\n\n        paint_rule = GraphicsStyle.merge(style, self.style).resolve_paint_rule()\n        render_list.insert(-1, paint_rule.value)\n        return \" \".join(render_list), last_item, initial_point",
      "language": "python"
    },
    {
      "code": "@property\ndef auto_close(self) -> bool | InheritType:\n    \"\"\"If true, the path should automatically close itself before painting.\"\"\"\n    return self.style.auto_close",
      "language": "python"
    },
    {
      "code": "@property\ndef clipping_path(self) -> Optional[\"ClippingPath\"]:\n    \"\"\"Set the clipping path for this path.\"\"\"\n    return self._root_graphics_context.clipping_path",
      "language": "python"
    },
    {
      "code": "@property\ndef paint_rule(self) -> PathPaintRule | InheritType | None:\n    \"\"\"Manually specify the `PathPaintRule` to use for rendering the path.\"\"\"\n    return self.style.paint_rule",
      "language": "python"
    },
    {
      "code": "@property\ndef style(self) -> GraphicsStyle:\n    \"\"\"The `GraphicsStyle` applied to all elements of this path.\"\"\"\n    return self._root_graphics_context.style",
      "language": "python"
    },
    {
      "code": "@property\ndef transform(self) -> Optional[Transform]:\n    \"\"\"The `Transform` that applies to all of the elements of this path.\"\"\"\n    return self._root_graphics_context.transform",
      "language": "python"
    },
    {
      "code": "def add_path_element(self, item: Renderable, clone: bool = True) -> None:\n    \"\"\"\n    Add the given element as a path item of this path.\n\n    Args:\n        item: the item to add to this path.\n        clone (bool): if true (the default), the item will be copied before being\n            appended. This prevents modifications to a referenced object from\n            \"retroactively\" altering its style/shape and should be disabled with\n            caution.\n    \"\"\"\n    if self._starter_move is not None:\n        self._closed = False\n        self._graphics_context.add_item(self._starter_move, clone=False)\n        self._close_context = self._graphics_context\n        self._starter_move = None\n\n    self._graphics_context.add_item(item, clone=clone)",
      "language": "python"
    },
    {
      "code": "def arc_relative(\n    self,\n    rx: Number,\n    ry: Number,\n    rotation: Number,\n    large_arc: bool,\n    positive_sweep: bool,\n    dx: Number,\n    dy: Number,\n) -> \"PaintedPath\":\n    \"\"\"\n    Append an elliptical arc from the end of the previous path point to an offset\n    point.\n\n    The arc is approximated using Bézier curves, so it is not perfectly accurate.\n    However, the error is small enough to not be noticeable at any reasonable\n    (and even most unreasonable) scales, with a worst-case deviation of around 3‱.\n\n    Notes:\n        - The signs of the radii arguments (`rx` and `ry`) are ignored (i.e. their\n          absolute values are used instead).\n        - If either radius is 0, then a straight line will be emitted instead of an\n          arc.\n        - If the radii are too small for the arc to reach from the current point to\n          the specified end point (`x` and `y`), then they will be proportionally\n          scaled up until they are big enough, which will always result in a\n          half-ellipse arc (i.e. an 180 degree sweep)\n\n    Args:\n        rx (Number): radius in the x-direction.\n        ry (Number): radius in the y-direction.\n        rotation (Number): angle (in degrees) that the arc should be rotated\n            clockwise from the principle axes. This parameter does not have\n            a visual effect in the case that `rx == ry`.\n        large_arc (bool): if True, the arc will cover a sweep angle of at least 180\n            degrees. Otherwise, the sweep angle will be at most 180 degrees.\n        positive_sweep (bool): if True, the arc will be swept over a positive angle,\n            i.e. clockwise. Otherwise, the arc will be swept over a negative\n            angle.\n        dx (Number): abscissa of the arc's end point relative to the end point of\n            the previous path element.\n        dy (Number): ordinate of the arc's end point relative to the end point of\n            the previous path element.\n    \"\"\"\n    if rx == 0 or ry == 0:\n        return self.line_relative(dx, dy)\n    rx_float = float(rx)\n    ry_float = float(ry)\n    radii = Point(abs(rx_float), abs(ry_float))\n    large_arc = bool(large_arc)\n    rotation = math.radians(rotation)\n    positive_sweep = bool(positive_sweep)\n    end = Point(float(dx), float(dy))\n\n    self.add_path_element(\n        RelativeArc(radii, rotation, large_arc, positive_sweep, end), clone=False\n    )\n    return self",
      "language": "python"
    },
    {
      "code": "def arc_to(\n    self,\n    rx: Number,\n    ry: Number,\n    rotation: Number,\n    large_arc: bool,\n    positive_sweep: bool,\n    x: Number,\n    y: Number,\n) -> \"PaintedPath\":\n    \"\"\"\n    Append an elliptical arc from the end of the previous path point to the\n    specified end point.\n\n    The arc is approximated using Bézier curves, so it is not perfectly accurate.\n    However, the error is small enough to not be noticeable at any reasonable\n    (and even most unreasonable) scales, with a worst-case deviation of around 3‱.\n\n    Notes:\n        - The signs of the radii arguments (`rx` and `ry`) are ignored (i.e. their\n          absolute values are used instead).\n        - If either radius is 0, then a straight line will be emitted instead of an\n          arc.\n        - If the radii are too small for the arc to reach from the current point to\n          the specified end point (`x` and `y`), then they will be proportionally\n          scaled up until they are big enough, which will always result in a\n          half-ellipse arc (i.e. an 180 degree sweep)\n\n    Args:\n        rx (Number): radius in the x-direction.\n        ry (Number): radius in the y-direction.\n        rotation (Number): angle (in degrees) that the arc should be rotated\n            clockwise from the principle axes. This parameter does not have\n            a visual effect in the case that `rx == ry`.\n        large_arc (bool): if True, the arc will cover a sweep angle of at least 180\n            degrees. Otherwise, the sweep angle will be at most 180 degrees.\n        positive_sweep (bool): if True, the arc will be swept over a positive angle,\n            i.e. clockwise. Otherwise, the arc will be swept over a negative\n            angle.\n        x (Number): abscissa of the arc's end point.\n        y (Number): ordinate of the arc's end point.\n    \"\"\"\n\n    if rx == 0 or ry == 0:\n        return self.line_to(x, y)\n    rx_float = float(rx)\n    ry_float = float(ry)\n    radii = Point(abs(rx_float), abs(ry_float))\n    large_arc = bool(large_arc)\n    rotation = math.radians(rotation)\n    positive_sweep = bool(positive_sweep)\n    end = Point(float(x), float(y))\n\n    self.add_path_element(\n        Arc(radii, rotation, large_arc, positive_sweep, end), clone=False\n    )\n    return self",
      "language": "python"
    },
    {
      "code": "def bounding_box(\n    self, start: Point, expand_for_stroke: bool = True\n) -> tuple[BoundingBox, Point]:\n    \"\"\"Compute the bounding box of this painted path, including nested contexts and transformations.\"\"\"\n    return self._root_graphics_context.bounding_box(\n        start, self.style, expand_for_stroke=expand_for_stroke\n    )",
      "language": "python"
    },
    {
      "code": "def circle(self, cx: Number, cy: Number, r: Number) -> \"PaintedPath\":\n    \"\"\"\n    Append a circle as a closed subpath to the current path.\n\n    Args:\n        cx (Number): the abscissa of the circle's center point.\n        cy (Number): the ordinate of the circle's center point.\n        r (Number): the radius of the circle.\n\n    Returns:\n        The path, to allow chaining method calls.\n    \"\"\"\n    return self.ellipse(cx, cy, r, r)",
      "language": "python"
    },
    {
      "code": "def close(self) -> None:\n    \"\"\"\n    Explicitly close the current (sub)path.\n    \"\"\"\n    self.add_path_element(Close(), clone=False)\n    self._closed = True\n    self.move_relative(0, 0)",
      "language": "python"
    },
    {
      "code": "def curve_relative(\n    self,\n    dx1: Number,\n    dy1: Number,\n    dx2: Number,\n    dy2: Number,\n    dx3: Number,\n    dy3: Number,\n) -> \"PaintedPath\":\n    \"\"\"\n    Append a cubic Bézier curve whose points are expressed relative to the\n    end point of the previous path element.\n\n    E.g. with a start point of (0, 0), given (1, 1), (2, 2), (3, 3), the output\n    curve would have the points:\n\n    (0, 0) c1 (1, 1) c2 (3, 3) e (6, 6)\n\n    Args:\n        dx1 (Number): abscissa of the first control point relative to the end point\n            of the previous path element\n        dy1 (Number): ordinate of the first control point relative to the end point\n            of the previous path element\n        dx2 (Number): abscissa offset of the second control point relative to the\n            end point of the previous path element\n        dy2 (Number): ordinate offset of the second control point relative to the\n            end point of the previous path element\n        dx3 (Number): abscissa offset of the end point relative to the end point of\n            the previous path element\n        dy3 (Number): ordinate offset of the end point relative to the end point of\n            the previous path element\n\n    Returns:\n        The path, to allow chaining method calls.\n    \"\"\"\n    c1d = Point(float(dx1), float(dy1))\n    c2d = Point(float(dx2), float(dy2))\n    end = Point(float(dx3), float(dy3))\n\n    self.add_path_element(RelativeBezierCurve(c1d, c2d, end), clone=False)\n    return self",
      "language": "python"
    },
    {
      "code": "def curve_to(\n    self, x1: Number, y1: Number, x2: Number, y2: Number, x3: Number, y3: Number\n) -> \"PaintedPath\":\n    \"\"\"\n    Append a cubic Bézier curve to this path.\n\n    Args:\n        x1 (Number): abscissa of the first control point\n        y1 (Number): ordinate of the first control point\n        x2 (Number): abscissa of the second control point\n        y2 (Number): ordinate of the second control point\n        x3 (Number): abscissa of the end point\n        y3 (Number): ordinate of the end point\n\n    Returns:\n        The path, to allow chaining method calls.\n    \"\"\"\n    ctrl1 = Point(float(x1), float(y1))\n    ctrl2 = Point(float(x2), float(y2))\n    end = Point(float(x3), float(y3))\n\n    self.add_path_element(BezierCurve(ctrl1, ctrl2, end), clone=False)\n    return self",
      "language": "python"
    },
    {
      "code": "def ellipse(self, cx: Number, cy: Number, rx: Number, ry: Number) -> \"PaintedPath\":\n    \"\"\"\n    Append an ellipse as a closed subpath to the current path.\n\n    Args:\n        cx (Number): the abscissa of the ellipse's center point.\n        cy (Number): the ordinate of the ellipse's center point.\n        rx (Number): the x-radius of the ellipse.\n        ry (Number): the y-radius of the ellipse.\n\n    Returns:\n        The path, to allow chaining method calls.\n    \"\"\"\n    self._insert_implicit_close_if_open()\n    self.add_path_element(\n        Ellipse(Point(float(rx), float(ry)), Point(float(cx), float(cy))),\n        clone=False,\n    )\n    self._closed = True\n    self.move_to(cx, cy)\n\n    return self",
      "language": "python"
    },
    {
      "code": "def get_graphics_context(self) -> \"GraphicsContext\":\n    return self._graphics_context",
      "language": "python"
    },
    {
      "code": "def horizontal_line_relative(self, dx: Number) -> \"PaintedPath\":\n    \"\"\"\n    Append a straight horizontal line to the given offset from the previous path\n    element. The ordinate is retrieved from the end point of the previous path\n    element.\n\n    Args:\n        x (Number): abscissa of the line's end point relative to the end point of\n            the previous path element.\n\n    Returns:\n        The path, to allow chaining method calls.\n    \"\"\"\n    self.add_path_element(RelativeHorizontalLine(float(dx)), clone=False)\n    return self",
      "language": "python"
    },
    {
      "code": "def horizontal_line_to(self, x: Number) -> \"PaintedPath\":\n    \"\"\"\n    Append a straight horizontal line to the given abscissa. The ordinate is\n    retrieved from the end point of the previous path element.\n\n    Args:\n        x (Number): abscissa of the line's end point.\n\n    Returns:\n        The path, to allow chaining method calls.\n    \"\"\"\n    self.add_path_element(HorizontalLine(float(x)), clone=False)\n    return self",
      "language": "python"
    },
    {
      "code": "def line_relative(self, dx: Number, dy: Number) -> \"PaintedPath\":\n    \"\"\"\n    Append a straight line whose end is computed as an offset from the end of the\n    previous path element.\n\n    Args:\n        x (Number): abscissa the line's end point relative to the end point of the\n            previous path element.\n        y (Number): ordinate of the line's end point relative to the end point of\n            the previous path element.\n\n    Returns:\n        The path, to allow chaining method calls.\n    \"\"\"\n    self.add_path_element(RelativeLine(Point(float(dx), float(dy))), clone=False)\n    return self",
      "language": "python"
    },
    {
      "code": "def line_to(self, x: Number, y: Number) -> \"PaintedPath\":\n    \"\"\"\n    Append a straight line to this path.\n\n    Args:\n        x (Number): abscissa the line's end point.\n        y (Number): ordinate of the line's end point.\n\n    Returns:\n        The path, to allow chaining method calls.\n    \"\"\"\n    self.add_path_element(Line(Point(float(x), float(y))), clone=False)\n    return self",
      "language": "python"
    },
    {
      "code": "def move_relative(self, x: Number, y: Number) -> \"PaintedPath\":\n    \"\"\"\n    Start a new subpath or move the path start point relative to the previous point.\n\n    If no path elements have been added yet, this will change the path starting\n    point. If path elements have been added, this will insert an implicit close in\n    order to start a new subpath.\n\n    This will overwrite an absolute move_to as long as no non-move path items have\n    been appended. The relative position is resolved from the previous item when\n    the path is being rendered, or from 0, 0 if it is the first item.\n\n    Args:\n        x (Number): abscissa of the (sub)path starting point relative to the previous point.\n        y (Number): ordinate of the (sub)path starting point relative to the previous point.\n    \"\"\"\n    self._insert_implicit_close_if_open()\n    if self._starter_move is not None:\n        self._closed = False\n        self._graphics_context.add_item(self._starter_move, clone=False)\n        self._close_context = self._graphics_context\n    self._starter_move = RelativeMove(Point(float(x), float(y)))\n    return self",
      "language": "python"
    },
    {
      "code": "def move_to(self, x: Number, y: Number) -> \"PaintedPath\":\n    \"\"\"\n    Start a new subpath or move the path starting point.\n\n    If no path elements have been added yet, this will change the path starting\n    point. If path elements have been added, this will insert an implicit close in\n    order to start a new subpath.\n\n    Args:\n        x (Number): abscissa of the (sub)path starting point.\n        y (Number): ordinate of the (sub)path starting point.\n\n    Returns:\n        The path, to allow chaining method calls.\n    \"\"\"\n    self._insert_implicit_close_if_open()\n    self._starter_move = Move(Point(float(x), float(y)))\n    return self",
      "language": "python"
    },
    {
      "code": "def quadratic_curve_relative(\n    self, dx1: Number, dy1: Number, dx2: Number, dy2: Number\n) -> \"PaintedPath\":\n    \"\"\"\n    Append a cubic Bézier curve mimicking the specified quadratic Bézier curve.\n\n    Args:\n        dx1 (Number): abscissa of the control point relative to the end point of\n            the previous path element\n        dy1 (Number): ordinate of the control point relative to the end point of\n            the previous path element\n        dx2 (Number): abscissa offset of the end point relative to the end point of\n            the previous path element\n        dy2 (Number): ordinate offset of the end point relative to the end point of\n            the previous path element\n\n    Returns:\n        The path, to allow chaining method calls.\n    \"\"\"\n    ctrl = Point(float(dx1), float(dy1))\n    end = Point(float(dx2), float(dy2))\n    self.add_path_element(RelativeQuadraticBezierCurve(ctrl, end), clone=False)\n    return self",
      "language": "python"
    },
    {
      "code": "def quadratic_curve_to(\n    self, x1: Number, y1: Number, x2: Number, y2: Number\n) -> \"PaintedPath\":\n    \"\"\"\n    Append a cubic Bézier curve mimicking the specified quadratic Bézier curve.\n\n    Args:\n        x1 (Number): abscissa of the control point\n        y1 (Number): ordinate of the control point\n        x2 (Number): abscissa of the end point\n        y2 (Number): ordinate of the end point\n\n    Returns:\n        The path, to allow chaining method calls.\n    \"\"\"\n    ctrl = Point(float(x1), float(y1))\n    end = Point(float(x2), float(y2))\n    self.add_path_element(QuadraticBezierCurve(ctrl, end), clone=False)\n    return self",
      "language": "python"
    },
    {
      "code": "def rectangle(\n    self, x: Number, y: Number, w: Number, h: Number, rx: Number = 0, ry: Number = 0\n) -> \"PaintedPath\":\n    \"\"\"\n    Append a rectangle as a closed subpath to the current path.\n\n    If the width or the height are 0, the rectangle will be collapsed to a line\n    (unless they're both 0, in which case it's collapsed to nothing).\n\n    Args:\n        x (Number): the abscissa of the starting corner of the rectangle.\n        y (Number): the ordinate of the starting corner of the rectangle.\n        w (Number): the width of the rectangle (if 0, the rectangle will be\n            rendered as a vertical line).\n        h (Number): the height of the rectangle (if 0, the rectangle will be\n            rendered as a horizontal line).\n        rx (Number): the x-radius of the rectangle rounded corner (if 0 the corners\n            will not be rounded).\n        ry (Number): the y-radius of the rectangle rounded corner (if 0 the corners\n            will not be rounded).\n\n    Returns:\n        The path, to allow chaining method calls.\n    \"\"\"\n\n    self._insert_implicit_close_if_open()\n    self.add_path_element(\n        RoundedRectangle(\n            Point(float(x), float(y)),\n            Point(float(w), float(h)),\n            Point(float(rx), float(ry)),\n        ),\n        clone=False,\n    )\n    self._closed = True\n    self.move_to(x, y)\n\n    return self",
      "language": "python"
    },
    {
      "code": "def remove_last_path_element(self) -> None:\n    self._graphics_context.remove_last_item()",
      "language": "python"
    },
    {
      "code": "def render(\n    self,\n    resource_registry: \"ResourceCatalog\",\n    style: GraphicsStyle,\n    last_item: Renderable,\n    initial_point: Point,\n) -> tuple[str, Renderable, Point]:\n    self._insert_implicit_close_if_open()\n\n    (\n        render_list,\n        last_item,\n        initial_point,\n    ) = self._root_graphics_context.build_render_list(\n        resource_registry, style, last_item, initial_point\n    )\n\n    paint_rule = GraphicsStyle.merge(style, self.style).resolve_paint_rule()\n    render_list.insert(-1, paint_rule.value)\n    return \" \".join(render_list), last_item, initial_point",
      "language": "python"
    },
    {
      "code": "def text(\n    self,\n    x: float,\n    y: float,\n    content: str,\n    font_family: str = \"helvetica\",\n    font_style: str = \"\",  # \"\", \"B\", \"I\", \"BI\"\n    font_size: float = 12.0,\n    text_anchor: str = \"start\",  # \"start\" | \"middle\" | \"end\"\n) -> \"PaintedPath\":\n    \"\"\"\n    Append a text run at (x, y) to this path.\n\n    The baseline is at (x, y). `text_anchor` controls alignment about x.\n    `font_style` accepts \"\", \"B\", \"I\", or \"BI\". `font_family` can be a single\n    name or a comma-separated fallback list (handled at render-time).\n\n    Returns:\n        self (to allow chaining)\n    \"\"\"\n    # Normalize style just in case e.g. \"ib\" -> \"BI\"\n    s = \"\".join(sorted(font_style.upper()))\n\n    self.add_path_element(\n        Text(\n            x=x,\n            y=y,\n            text_runs=(\n                TextRun(\n                    text=content,\n                    family=font_family,\n                    emphasis=s,\n                    size=font_size,\n                ),\n            ),\n            text_anchor=text_anchor,\n        ),\n        clone=False,\n    )\n    return self",
      "language": "python"
    },
    {
      "code": "@contextmanager\ndef transform_group(self, transform: Transform) -> Iterator[\"PaintedPath\"]:\n    \"\"\"\n    Apply the provided `Transform` to all points added within this context.\n    \"\"\"\n    with self._new_graphics_context() as ctxt:\n        ctxt.transform = transform\n        yield self",
      "language": "python"
    },
    {
      "code": "def vertical_line_relative(self, dy: Number) -> \"PaintedPath\":\n    \"\"\"\n    Append a straight vertical line to the given offset from the previous path\n    element. The abscissa is retrieved from the end point of the previous path\n    element.\n\n    Args:\n        y (Number): ordinate of the line's end point relative to the end point of\n            the previous path element.\n\n    Returns:\n        The path, to allow chaining method calls.\n    \"\"\"\n    self.add_path_element(RelativeVerticalLine(float(dy)), clone=False)\n    return self",
      "language": "python"
    },
    {
      "code": "def vertical_line_to(self, y: Number) -> \"PaintedPath\":\n    \"\"\"\n    Append a straight vertical line to the given ordinate. The abscissa is\n    retrieved from the end point of the previous path element.\n\n    Args:\n        y (Number): ordinate of the line's end point.\n\n    Returns:\n        The path, to allow chaining method calls.\n    \"\"\"\n    self.add_path_element(VerticalLine(float(y)), clone=False)\n    return self",
      "language": "python"
    },
    {
      "code": "class PathPen(BasePen):  # type: ignore[misc]\n    def __init__(\n        self,\n        pdf_path: ClippingPath | PaintedPath,\n        glyphSet: Optional[  # pyright: ignore[reportUnknownParameterType]\n            \"ttGlyphSet\"  # pyright: ignore[reportInvalidTypeForm]\n        ] = None,\n    ) -> None:\n        self.pdf_path: ClippingPath | PaintedPath = pdf_path\n        self.last_was_line_to: bool = False\n        self.first_is_move: Optional[bool] = None\n        super().__init__(glyphSet=glyphSet)  # pyright: ignore[reportUnknownMemberType]\n\n    def _moveTo(self, pt: tuple[float, float]) -> None:\n        self.pdf_path.move_to(*pt)\n        self.last_was_line_to = False\n        if self.first_is_move is None:\n            self.first_is_move = True\n\n    def _lineTo(self, pt: tuple[float, float]) -> None:\n        self.pdf_path.line_to(*pt)\n        self.last_was_line_to = True\n        if self.first_is_move is None:\n            self.first_is_move = False\n\n    def _curveToOne(\n        self,\n        pt1: tuple[float, float],\n        pt2: tuple[float, float],\n        pt3: tuple[float, float],\n    ) -> None:\n        self.pdf_path.curve_to(\n            x1=pt1[0], y1=pt1[1], x2=pt2[0], y2=pt2[1], x3=pt3[0], y3=pt3[1]\n        )\n        self.last_was_line_to = False\n        if self.first_is_move is None:\n            self.first_is_move = False\n\n    def _qCurveToOne(self, pt1: tuple[float, float], pt2: tuple[float, float]) -> None:\n        self.pdf_path.quadratic_curve_to(x1=pt1[0], y1=pt1[1], x2=pt2[0], y2=pt2[1])\n        self.last_was_line_to = False\n        if self.first_is_move is None:\n            self.first_is_move = False\n\n    def arcTo(\n        self,\n        rx: float,\n        ry: float,\n        rotation: float,\n        arc: bool,\n        sweep: bool,\n        end: tuple[float, float],\n    ) -> None:\n        self.pdf_path.arc_to(\n            rx=rx,\n            ry=ry,\n            rotation=rotation,\n            large_arc=arc,\n            positive_sweep=sweep,\n            x=end[0],\n            y=end[1],\n        )\n        self.last_was_line_to = False\n        if self.first_is_move is None:\n            self.first_is_move = False\n\n    def _closePath(self) -> None:\n        # The fonttools parser inserts an unnecessary explicit line back to the start\n        # point of the path before actually closing it. Let's get rid of that again.\n        if self.last_was_line_to:\n            self.pdf_path.remove_last_path_element()\n        self.pdf_path.close()",
      "language": "python"
    },
    {
      "code": "def arcTo(\n    self,\n    rx: float,\n    ry: float,\n    rotation: float,\n    arc: bool,\n    sweep: bool,\n    end: tuple[float, float],\n) -> None:\n    self.pdf_path.arc_to(\n        rx=rx,\n        ry=ry,\n        rotation=rotation,\n        large_arc=arc,\n        positive_sweep=sweep,\n        x=end[0],\n        y=end[1],\n    )\n    self.last_was_line_to = False\n    if self.first_is_move is None:\n        self.first_is_move = False",
      "language": "python"
    },
    {
      "code": "class QuadraticBezierCurve(NamedTuple):\n    \"\"\"\n    A quadratic Bézier curve path element.\n\n    This draws a Bézier curve parameterized by the end point of the previous path\n    element, one off-curve control point, and an end point.\n\n    See: `PaintedPath.quadratic_curve_to`\n    \"\"\"\n\n    ctrl: Point\n    \"\"\"The curve's control point.\"\"\"\n    end: Point\n    \"\"\"The curve's end point.\"\"\"\n\n    @property\n    def end_point(self) -> Point:\n        \"\"\"The end point of this path element.\"\"\"\n        return self.end\n\n    def to_cubic_curve(self, start_point: Point) -> BezierCurve:\n        ctrl = self.ctrl\n        end = self.end\n\n        ctrl1 = Point(\n            x=start_point.x + 2 * (ctrl.x - start_point.x) / 3,\n            y=start_point.y + 2 * (ctrl.y - start_point.y) / 3,\n        )\n        ctrl2 = Point(\n            x=end.x + 2 * (ctrl.x - end.x) / 3,\n            y=end.y + 2 * (ctrl.y - end.y) / 3,\n        )\n\n        return BezierCurve(ctrl1, ctrl2, end)\n\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        \"\"\"Compute the bounding box of this quadratic Bézier curve by converting it to a cubic Bézier.\"\"\"\n        cubic = self.to_cubic_curve(start)\n        return cubic.bounding_box(start)\n\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        \"\"\"\n        Render this path element to its PDF representation.\n\n        Args:\n            resource_registry (ResourceCatalog): the owner's graphics state\n                dictionary registry.\n            style (GraphicsStyle): the current resolved graphics style\n            last_item: the previous path element.\n            initial_point: last position set by a \"M\" or \"m\" command\n\n        Returns:\n            a tuple of `(str, new_last_item)`, where `new_last_item` is `self`.\n        \"\"\"\n        return (\n            self.to_cubic_curve(last_item.end_point).render(\n                resource_registry, style, last_item, initial_point\n            )[0],\n            self,\n            initial_point,\n        )",
      "language": "python"
    },
    {
      "code": "class QuadraticBezierCurve(NamedTuple):\n    \"\"\"\n    A quadratic Bézier curve path element.\n\n    This draws a Bézier curve parameterized by the end point of the previous path\n    element, one off-curve control point, and an end point.\n\n    See: `PaintedPath.quadratic_curve_to`\n    \"\"\"\n\n    ctrl: Point\n    \"\"\"The curve's control point.\"\"\"\n    end: Point\n    \"\"\"The curve's end point.\"\"\"\n\n    @property\n    def end_point(self) -> Point:\n        \"\"\"The end point of this path element.\"\"\"\n        return self.end\n\n    def to_cubic_curve(self, start_point: Point) -> BezierCurve:\n        ctrl = self.ctrl\n        end = self.end\n\n        ctrl1 = Point(\n            x=start_point.x + 2 * (ctrl.x - start_point.x) / 3,\n            y=start_point.y + 2 * (ctrl.y - start_point.y) / 3,\n        )\n        ctrl2 = Point(\n            x=end.x + 2 * (ctrl.x - end.x) / 3,\n            y=end.y + 2 * (ctrl.y - end.y) / 3,\n        )\n\n        return BezierCurve(ctrl1, ctrl2, end)\n\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        \"\"\"Compute the bounding box of this quadratic Bézier curve by converting it to a cubic Bézier.\"\"\"\n        cubic = self.to_cubic_curve(start)\n        return cubic.bounding_box(start)\n\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        \"\"\"\n        Render this path element to its PDF representation.\n\n        Args:\n            resource_registry (ResourceCatalog): the owner's graphics state\n                dictionary registry.\n            style (GraphicsStyle): the current resolved graphics style\n            last_item: the previous path element.\n            initial_point: last position set by a \"M\" or \"m\" command\n\n        Returns:\n            a tuple of `(str, new_last_item)`, where `new_last_item` is `self`.\n        \"\"\"\n        return (\n            self.to_cubic_curve(last_item.end_point).render(\n                resource_registry, style, last_item, initial_point\n            )[0],\n            self,\n            initial_point,\n        )",
      "language": "python"
    },
    {
      "code": "class QuadraticBezierCurve(NamedTuple):\n    \"\"\"\n    A quadratic Bézier curve path element.\n\n    This draws a Bézier curve parameterized by the end point of the previous path\n    element, one off-curve control point, and an end point.\n\n    See: `PaintedPath.quadratic_curve_to`\n    \"\"\"\n\n    ctrl: Point\n    \"\"\"The curve's control point.\"\"\"\n    end: Point\n    \"\"\"The curve's end point.\"\"\"\n\n    @property\n    def end_point(self) -> Point:\n        \"\"\"The end point of this path element.\"\"\"\n        return self.end\n\n    def to_cubic_curve(self, start_point: Point) -> BezierCurve:\n        ctrl = self.ctrl\n        end = self.end\n\n        ctrl1 = Point(\n            x=start_point.x + 2 * (ctrl.x - start_point.x) / 3,\n            y=start_point.y + 2 * (ctrl.y - start_point.y) / 3,\n        )\n        ctrl2 = Point(\n            x=end.x + 2 * (ctrl.x - end.x) / 3,\n            y=end.y + 2 * (ctrl.y - end.y) / 3,\n        )\n\n        return BezierCurve(ctrl1, ctrl2, end)\n\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        \"\"\"Compute the bounding box of this quadratic Bézier curve by converting it to a cubic Bézier.\"\"\"\n        cubic = self.to_cubic_curve(start)\n        return cubic.bounding_box(start)\n\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        \"\"\"\n        Render this path element to its PDF representation.\n\n        Args:\n            resource_registry (ResourceCatalog): the owner's graphics state\n                dictionary registry.\n            style (GraphicsStyle): the current resolved graphics style\n            last_item: the previous path element.\n            initial_point: last position set by a \"M\" or \"m\" command\n\n        Returns:\n            a tuple of `(str, new_last_item)`, where `new_last_item` is `self`.\n        \"\"\"\n        return (\n            self.to_cubic_curve(last_item.end_point).render(\n                resource_registry, style, last_item, initial_point\n            )[0],\n            self,\n            initial_point,\n        )",
      "language": "python"
    },
    {
      "code": "@property\ndef end_point(self) -> Point:\n    \"\"\"The end point of this path element.\"\"\"\n    return self.end",
      "language": "python"
    },
    {
      "code": "def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n    \"\"\"Compute the bounding box of this quadratic Bézier curve by converting it to a cubic Bézier.\"\"\"\n    cubic = self.to_cubic_curve(start)\n    return cubic.bounding_box(start)",
      "language": "python"
    },
    {
      "code": "@force_nodocument\ndef render(\n    self,\n    resource_registry: \"ResourceCatalog\",\n    style: GraphicsStyle,\n    last_item: Renderable,\n    initial_point: Point,\n) -> tuple[str, Renderable, Point]:\n    \"\"\"\n    Render this path element to its PDF representation.\n\n    Args:\n        resource_registry (ResourceCatalog): the owner's graphics state\n            dictionary registry.\n        style (GraphicsStyle): the current resolved graphics style\n        last_item: the previous path element.\n        initial_point: last position set by a \"M\" or \"m\" command\n\n    Returns:\n        a tuple of `(str, new_last_item)`, where `new_last_item` is `self`.\n    \"\"\"\n    return (\n        self.to_cubic_curve(last_item.end_point).render(\n            resource_registry, style, last_item, initial_point\n        )[0],\n        self,\n        initial_point,\n    )",
      "language": "python"
    },
    {
      "code": "def to_cubic_curve(self, start_point: Point) -> BezierCurve:\n    ctrl = self.ctrl\n    end = self.end\n\n    ctrl1 = Point(\n        x=start_point.x + 2 * (ctrl.x - start_point.x) / 3,\n        y=start_point.y + 2 * (ctrl.y - start_point.y) / 3,\n    )\n    ctrl2 = Point(\n        x=end.x + 2 * (ctrl.x - end.x) / 3,\n        y=end.y + 2 * (ctrl.y - end.y) / 3,\n    )\n\n    return BezierCurve(ctrl1, ctrl2, end)",
      "language": "python"
    },
    {
      "code": "class Rectangle(NamedTuple):\n    \"\"\"A pdf primitive rectangle.\"\"\"\n\n    org: Point\n    \"\"\"The top-left corner of the rectangle.\"\"\"\n    size: Point\n    \"\"\"The width and height of the rectangle.\"\"\"\n\n    @property\n    def end_point(self) -> Point:\n        \"\"\"The end point of a rectangle is the origin.\"\"\"\n        return self.org\n\n    # pylint: disable=unused-argument\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        \"\"\"Compute the bounding box of this rectangle.\"\"\"\n        x0, y0 = self.org.x, self.org.y\n        x1 = float(x0) + float(self.size.x)\n        y1 = float(y0) + float(self.size.y)\n\n        bbox = BoundingBox.from_points(\n            [\n                Point(x0, y0),\n                Point(x1, y0),\n                Point(x0, y1),\n                Point(x1, y1),\n            ]\n        )\n        return bbox, self.org\n\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        \"\"\"\n        Render this path element to its PDF representation.\n\n        Args:\n            resource_registry (ResourceCatalog): the owner's graphics state\n                dictionary registry.\n            style (GraphicsStyle): the current resolved graphics style\n            last_item: the previous path element.\n            initial_point: last position set by a \"M\" or \"m\" command\n\n        Returns:\n            a tuple of `(str, new_last_item)`, where `new_last_item` is a `Line` back to\n            the rectangle's origin.\n        \"\"\"\n\n        return (\n            f\"{self.org.render()} {self.size.render()} re\",\n            Line(self.org),\n            initial_point,\n        )",
      "language": "python"
    },
    {
      "code": "@property\ndef end_point(self) -> Point:\n    \"\"\"The end point of a rectangle is the origin.\"\"\"\n    return self.org",
      "language": "python"
    },
    {
      "code": "class Rectangle(NamedTuple):\n    \"\"\"A pdf primitive rectangle.\"\"\"\n\n    org: Point\n    \"\"\"The top-left corner of the rectangle.\"\"\"\n    size: Point\n    \"\"\"The width and height of the rectangle.\"\"\"\n\n    @property\n    def end_point(self) -> Point:\n        \"\"\"The end point of a rectangle is the origin.\"\"\"\n        return self.org\n\n    # pylint: disable=unused-argument\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        \"\"\"Compute the bounding box of this rectangle.\"\"\"\n        x0, y0 = self.org.x, self.org.y\n        x1 = float(x0) + float(self.size.x)\n        y1 = float(y0) + float(self.size.y)\n\n        bbox = BoundingBox.from_points(\n            [\n                Point(x0, y0),\n                Point(x1, y0),\n                Point(x0, y1),\n                Point(x1, y1),\n            ]\n        )\n        return bbox, self.org\n\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        \"\"\"\n        Render this path element to its PDF representation.\n\n        Args:\n            resource_registry (ResourceCatalog): the owner's graphics state\n                dictionary registry.\n            style (GraphicsStyle): the current resolved graphics style\n            last_item: the previous path element.\n            initial_point: last position set by a \"M\" or \"m\" command\n\n        Returns:\n            a tuple of `(str, new_last_item)`, where `new_last_item` is a `Line` back to\n            the rectangle's origin.\n        \"\"\"\n\n        return (\n            f\"{self.org.render()} {self.size.render()} re\",\n            Line(self.org),\n            initial_point,\n        )",
      "language": "python"
    },
    {
      "code": "class Rectangle(NamedTuple):\n    \"\"\"A pdf primitive rectangle.\"\"\"\n\n    org: Point\n    \"\"\"The top-left corner of the rectangle.\"\"\"\n    size: Point\n    \"\"\"The width and height of the rectangle.\"\"\"\n\n    @property\n    def end_point(self) -> Point:\n        \"\"\"The end point of a rectangle is the origin.\"\"\"\n        return self.org\n\n    # pylint: disable=unused-argument\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        \"\"\"Compute the bounding box of this rectangle.\"\"\"\n        x0, y0 = self.org.x, self.org.y\n        x1 = float(x0) + float(self.size.x)\n        y1 = float(y0) + float(self.size.y)\n\n        bbox = BoundingBox.from_points(\n            [\n                Point(x0, y0),\n                Point(x1, y0),\n                Point(x0, y1),\n                Point(x1, y1),\n            ]\n        )\n        return bbox, self.org\n\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        \"\"\"\n        Render this path element to its PDF representation.\n\n        Args:\n            resource_registry (ResourceCatalog): the owner's graphics state\n                dictionary registry.\n            style (GraphicsStyle): the current resolved graphics style\n            last_item: the previous path element.\n            initial_point: last position set by a \"M\" or \"m\" command\n\n        Returns:\n            a tuple of `(str, new_last_item)`, where `new_last_item` is a `Line` back to\n            the rectangle's origin.\n        \"\"\"\n\n        return (\n            f\"{self.org.render()} {self.size.render()} re\",\n            Line(self.org),\n            initial_point,\n        )",
      "language": "python"
    },
    {
      "code": "def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n    \"\"\"Compute the bounding box of this rectangle.\"\"\"\n    x0, y0 = self.org.x, self.org.y\n    x1 = float(x0) + float(self.size.x)\n    y1 = float(y0) + float(self.size.y)\n\n    bbox = BoundingBox.from_points(\n        [\n            Point(x0, y0),\n            Point(x1, y0),\n            Point(x0, y1),\n            Point(x1, y1),\n        ]\n    )\n    return bbox, self.org",
      "language": "python"
    },
    {
      "code": "@force_nodocument\ndef render(\n    self,\n    resource_registry: \"ResourceCatalog\",\n    style: GraphicsStyle,\n    last_item: Renderable,\n    initial_point: Point,\n) -> tuple[str, Renderable, Point]:\n    \"\"\"\n    Render this path element to its PDF representation.\n\n    Args:\n        resource_registry (ResourceCatalog): the owner's graphics state\n            dictionary registry.\n        style (GraphicsStyle): the current resolved graphics style\n        last_item: the previous path element.\n        initial_point: last position set by a \"M\" or \"m\" command\n\n    Returns:\n        a tuple of `(str, new_last_item)`, where `new_last_item` is a `Line` back to\n        the rectangle's origin.\n    \"\"\"\n\n    return (\n        f\"{self.org.render()} {self.size.render()} re\",\n        Line(self.org),\n        initial_point,\n    )",
      "language": "python"
    },
    {
      "code": "class RelativeArc(NamedTuple):\n    \"\"\"\n    An elliptical arc path element.\n\n    The arc is drawn from the end of the current path element to its specified end point\n    using a number of parameters to determine how it is constructed.\n\n    See: `PaintedPath.arc_relative`\n    \"\"\"\n\n    radii: Point\n    \"\"\"\n    The x- and y-radii of the arc. If `radii.x == radii.y` the arc will be circular.\n    \"\"\"\n    rotation: Number\n    \"\"\"The rotation of the arc's major/minor axes relative to the coordinate frame.\"\"\"\n    large: bool\n    \"\"\"If True, sweep the arc over an angle greater than or equal to 180 degrees.\"\"\"\n    sweep: bool\n    \"\"\"If True, the arc is swept in the positive angular direction.\"\"\"\n    end: Point\n    \"\"\"The end point of the arc relative to the end of the previous path element.\"\"\"\n\n    @property\n    def end_point(self) -> Point:\n        raise NotImplementedError\n\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        \"\"\"Compute the bounding box of the resolved arc from the given start point.\"\"\"\n        end_point = start + self.end\n        arc = Arc(\n            radii=self.radii,\n            rotation=self.rotation,\n            large=self.large,\n            sweep=self.sweep,\n            end=end_point,\n        )\n        return arc.bounding_box(start)\n\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        \"\"\"\n        Render this path element to its PDF representation.\n\n        Args:\n            resource_registry (ResourceCatalog): the owner's graphics state\n                dictionary registry.\n            style (GraphicsStyle): the current resolved graphics style\n            last_item: the previous path element.\n            initial_point: last position set by a \"M\" or \"m\" command\n\n        Returns:\n            a tuple of `(str, new_last_item)`, where `new_last_item` is a resolved\n            `BezierCurve`.\n        \"\"\"\n        return Arc(\n            self.radii,\n            self.rotation,\n            self.large,\n            self.sweep,\n            last_item.end_point + self.end,\n        ).render(resource_registry, style, last_item, initial_point)",
      "language": "python"
    },
    {
      "code": "class RelativeArc(NamedTuple):\n    \"\"\"\n    An elliptical arc path element.\n\n    The arc is drawn from the end of the current path element to its specified end point\n    using a number of parameters to determine how it is constructed.\n\n    See: `PaintedPath.arc_relative`\n    \"\"\"\n\n    radii: Point\n    \"\"\"\n    The x- and y-radii of the arc. If `radii.x == radii.y` the arc will be circular.\n    \"\"\"\n    rotation: Number\n    \"\"\"The rotation of the arc's major/minor axes relative to the coordinate frame.\"\"\"\n    large: bool\n    \"\"\"If True, sweep the arc over an angle greater than or equal to 180 degrees.\"\"\"\n    sweep: bool\n    \"\"\"If True, the arc is swept in the positive angular direction.\"\"\"\n    end: Point\n    \"\"\"The end point of the arc relative to the end of the previous path element.\"\"\"\n\n    @property\n    def end_point(self) -> Point:\n        raise NotImplementedError\n\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        \"\"\"Compute the bounding box of the resolved arc from the given start point.\"\"\"\n        end_point = start + self.end\n        arc = Arc(\n            radii=self.radii,\n            rotation=self.rotation,\n            large=self.large,\n            sweep=self.sweep,\n            end=end_point,\n        )\n        return arc.bounding_box(start)\n\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        \"\"\"\n        Render this path element to its PDF representation.\n\n        Args:\n            resource_registry (ResourceCatalog): the owner's graphics state\n                dictionary registry.\n            style (GraphicsStyle): the current resolved graphics style\n            last_item: the previous path element.\n            initial_point: last position set by a \"M\" or \"m\" command\n\n        Returns:\n            a tuple of `(str, new_last_item)`, where `new_last_item` is a resolved\n            `BezierCurve`.\n        \"\"\"\n        return Arc(\n            self.radii,\n            self.rotation,\n            self.large,\n            self.sweep,\n            last_item.end_point + self.end,\n        ).render(resource_registry, style, last_item, initial_point)",
      "language": "python"
    },
    {
      "code": "@property\ndef end_point(self) -> Point:\n    raise NotImplementedError",
      "language": "python"
    },
    {
      "code": "class RelativeArc(NamedTuple):\n    \"\"\"\n    An elliptical arc path element.\n\n    The arc is drawn from the end of the current path element to its specified end point\n    using a number of parameters to determine how it is constructed.\n\n    See: `PaintedPath.arc_relative`\n    \"\"\"\n\n    radii: Point\n    \"\"\"\n    The x- and y-radii of the arc. If `radii.x == radii.y` the arc will be circular.\n    \"\"\"\n    rotation: Number\n    \"\"\"The rotation of the arc's major/minor axes relative to the coordinate frame.\"\"\"\n    large: bool\n    \"\"\"If True, sweep the arc over an angle greater than or equal to 180 degrees.\"\"\"\n    sweep: bool\n    \"\"\"If True, the arc is swept in the positive angular direction.\"\"\"\n    end: Point\n    \"\"\"The end point of the arc relative to the end of the previous path element.\"\"\"\n\n    @property\n    def end_point(self) -> Point:\n        raise NotImplementedError\n\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        \"\"\"Compute the bounding box of the resolved arc from the given start point.\"\"\"\n        end_point = start + self.end\n        arc = Arc(\n            radii=self.radii,\n            rotation=self.rotation,\n            large=self.large,\n            sweep=self.sweep,\n            end=end_point,\n        )\n        return arc.bounding_box(start)\n\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        \"\"\"\n        Render this path element to its PDF representation.\n\n        Args:\n            resource_registry (ResourceCatalog): the owner's graphics state\n                dictionary registry.\n            style (GraphicsStyle): the current resolved graphics style\n            last_item: the previous path element.\n            initial_point: last position set by a \"M\" or \"m\" command\n\n        Returns:\n            a tuple of `(str, new_last_item)`, where `new_last_item` is a resolved\n            `BezierCurve`.\n        \"\"\"\n        return Arc(\n            self.radii,\n            self.rotation,\n            self.large,\n            self.sweep,\n            last_item.end_point + self.end,\n        ).render(resource_registry, style, last_item, initial_point)",
      "language": "python"
    },
    {
      "code": "class RelativeArc(NamedTuple):\n    \"\"\"\n    An elliptical arc path element.\n\n    The arc is drawn from the end of the current path element to its specified end point\n    using a number of parameters to determine how it is constructed.\n\n    See: `PaintedPath.arc_relative`\n    \"\"\"\n\n    radii: Point\n    \"\"\"\n    The x- and y-radii of the arc. If `radii.x == radii.y` the arc will be circular.\n    \"\"\"\n    rotation: Number\n    \"\"\"The rotation of the arc's major/minor axes relative to the coordinate frame.\"\"\"\n    large: bool\n    \"\"\"If True, sweep the arc over an angle greater than or equal to 180 degrees.\"\"\"\n    sweep: bool\n    \"\"\"If True, the arc is swept in the positive angular direction.\"\"\"\n    end: Point\n    \"\"\"The end point of the arc relative to the end of the previous path element.\"\"\"\n\n    @property\n    def end_point(self) -> Point:\n        raise NotImplementedError\n\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        \"\"\"Compute the bounding box of the resolved arc from the given start point.\"\"\"\n        end_point = start + self.end\n        arc = Arc(\n            radii=self.radii,\n            rotation=self.rotation,\n            large=self.large,\n            sweep=self.sweep,\n            end=end_point,\n        )\n        return arc.bounding_box(start)\n\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        \"\"\"\n        Render this path element to its PDF representation.\n\n        Args:\n            resource_registry (ResourceCatalog): the owner's graphics state\n                dictionary registry.\n            style (GraphicsStyle): the current resolved graphics style\n            last_item: the previous path element.\n            initial_point: last position set by a \"M\" or \"m\" command\n\n        Returns:\n            a tuple of `(str, new_last_item)`, where `new_last_item` is a resolved\n            `BezierCurve`.\n        \"\"\"\n        return Arc(\n            self.radii,\n            self.rotation,\n            self.large,\n            self.sweep,\n            last_item.end_point + self.end,\n        ).render(resource_registry, style, last_item, initial_point)",
      "language": "python"
    },
    {
      "code": "class RelativeArc(NamedTuple):\n    \"\"\"\n    An elliptical arc path element.\n\n    The arc is drawn from the end of the current path element to its specified end point\n    using a number of parameters to determine how it is constructed.\n\n    See: `PaintedPath.arc_relative`\n    \"\"\"\n\n    radii: Point\n    \"\"\"\n    The x- and y-radii of the arc. If `radii.x == radii.y` the arc will be circular.\n    \"\"\"\n    rotation: Number\n    \"\"\"The rotation of the arc's major/minor axes relative to the coordinate frame.\"\"\"\n    large: bool\n    \"\"\"If True, sweep the arc over an angle greater than or equal to 180 degrees.\"\"\"\n    sweep: bool\n    \"\"\"If True, the arc is swept in the positive angular direction.\"\"\"\n    end: Point\n    \"\"\"The end point of the arc relative to the end of the previous path element.\"\"\"\n\n    @property\n    def end_point(self) -> Point:\n        raise NotImplementedError\n\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        \"\"\"Compute the bounding box of the resolved arc from the given start point.\"\"\"\n        end_point = start + self.end\n        arc = Arc(\n            radii=self.radii,\n            rotation=self.rotation,\n            large=self.large,\n            sweep=self.sweep,\n            end=end_point,\n        )\n        return arc.bounding_box(start)\n\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        \"\"\"\n        Render this path element to its PDF representation.\n\n        Args:\n            resource_registry (ResourceCatalog): the owner's graphics state\n                dictionary registry.\n            style (GraphicsStyle): the current resolved graphics style\n            last_item: the previous path element.\n            initial_point: last position set by a \"M\" or \"m\" command\n\n        Returns:\n            a tuple of `(str, new_last_item)`, where `new_last_item` is a resolved\n            `BezierCurve`.\n        \"\"\"\n        return Arc(\n            self.radii,\n            self.rotation,\n            self.large,\n            self.sweep,\n            last_item.end_point + self.end,\n        ).render(resource_registry, style, last_item, initial_point)",
      "language": "python"
    },
    {
      "code": "class RelativeArc(NamedTuple):\n    \"\"\"\n    An elliptical arc path element.\n\n    The arc is drawn from the end of the current path element to its specified end point\n    using a number of parameters to determine how it is constructed.\n\n    See: `PaintedPath.arc_relative`\n    \"\"\"\n\n    radii: Point\n    \"\"\"\n    The x- and y-radii of the arc. If `radii.x == radii.y` the arc will be circular.\n    \"\"\"\n    rotation: Number\n    \"\"\"The rotation of the arc's major/minor axes relative to the coordinate frame.\"\"\"\n    large: bool\n    \"\"\"If True, sweep the arc over an angle greater than or equal to 180 degrees.\"\"\"\n    sweep: bool\n    \"\"\"If True, the arc is swept in the positive angular direction.\"\"\"\n    end: Point\n    \"\"\"The end point of the arc relative to the end of the previous path element.\"\"\"\n\n    @property\n    def end_point(self) -> Point:\n        raise NotImplementedError\n\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        \"\"\"Compute the bounding box of the resolved arc from the given start point.\"\"\"\n        end_point = start + self.end\n        arc = Arc(\n            radii=self.radii,\n            rotation=self.rotation,\n            large=self.large,\n            sweep=self.sweep,\n            end=end_point,\n        )\n        return arc.bounding_box(start)\n\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        \"\"\"\n        Render this path element to its PDF representation.\n\n        Args:\n            resource_registry (ResourceCatalog): the owner's graphics state\n                dictionary registry.\n            style (GraphicsStyle): the current resolved graphics style\n            last_item: the previous path element.\n            initial_point: last position set by a \"M\" or \"m\" command\n\n        Returns:\n            a tuple of `(str, new_last_item)`, where `new_last_item` is a resolved\n            `BezierCurve`.\n        \"\"\"\n        return Arc(\n            self.radii,\n            self.rotation,\n            self.large,\n            self.sweep,\n            last_item.end_point + self.end,\n        ).render(resource_registry, style, last_item, initial_point)",
      "language": "python"
    },
    {
      "code": "def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n    \"\"\"Compute the bounding box of the resolved arc from the given start point.\"\"\"\n    end_point = start + self.end\n    arc = Arc(\n        radii=self.radii,\n        rotation=self.rotation,\n        large=self.large,\n        sweep=self.sweep,\n        end=end_point,\n    )\n    return arc.bounding_box(start)",
      "language": "python"
    },
    {
      "code": "@force_nodocument\ndef render(\n    self,\n    resource_registry: \"ResourceCatalog\",\n    style: GraphicsStyle,\n    last_item: Renderable,\n    initial_point: Point,\n) -> tuple[str, Renderable, Point]:\n    \"\"\"\n    Render this path element to its PDF representation.\n\n    Args:\n        resource_registry (ResourceCatalog): the owner's graphics state\n            dictionary registry.\n        style (GraphicsStyle): the current resolved graphics style\n        last_item: the previous path element.\n        initial_point: last position set by a \"M\" or \"m\" command\n\n    Returns:\n        a tuple of `(str, new_last_item)`, where `new_last_item` is a resolved\n        `BezierCurve`.\n    \"\"\"\n    return Arc(\n        self.radii,\n        self.rotation,\n        self.large,\n        self.sweep,\n        last_item.end_point + self.end,\n    ).render(resource_registry, style, last_item, initial_point)",
      "language": "python"
    },
    {
      "code": "class RelativeBezierCurve(NamedTuple):\n    \"\"\"\n    A cubic Bézier curve path element whose points are specified relative to the end\n    point of the previous path element.\n\n    See: `PaintedPath.curve_relative`\n    \"\"\"\n\n    c1: Point\n    \"\"\"\n    The curve's first control point relative to the end of the previous path element.\n    \"\"\"\n    c2: Point\n    \"\"\"\n    The curve's second control point relative to the end of the previous path element.\n    \"\"\"\n    end: Point\n    \"\"\"The curve's end point relative to the end of the previous path element.\"\"\"\n\n    @property\n    def end_point(self) -> Point:\n        raise NotImplementedError\n\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        \"\"\"\n        Compute the bounding box of this relative cubic Bézier curve.\n\n        Args:\n            start (Point): The starting point of the curve (i.e., the end of the previous path element).\n\n        Returns:\n            A tuple containing:\n                - BoundingBox: the axis-aligned bounding box containing the entire curve.\n                - Point: the end point of the curve.\n        \"\"\"\n        # Resolve absolute coordinates\n        p0 = start\n        p1 = start + self.c1\n        p2 = start + self.c2\n        p3 = start + self.end\n\n        tx = [0, 1] + _cubic_bezier_critical_ts_1d(p0.x, p1.x, p2.x, p3.x)\n        ty = [0, 1] + _cubic_bezier_critical_ts_1d(p0.y, p1.y, p2.y, p3.y)\n\n        xs = [\n            _eval_cubic_bezier_1d(t, float(p0.x), float(p1.x), float(p2.x), float(p3.x))\n            for t in tx\n        ]\n        ys = [\n            _eval_cubic_bezier_1d(t, float(p0.y), float(p1.y), float(p2.y), float(p3.y))\n            for t in ty\n        ]\n\n        bbox = BoundingBox(min(xs), min(ys), max(xs), max(ys))\n        return bbox, p3\n\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        \"\"\"\n        Render this path element to its PDF representation.\n\n        Args:\n            resource_registry (ResourceCatalog): the owner's graphics state\n                dictionary registry.\n            style (GraphicsStyle): the current resolved graphics style\n            last_item: the previous path element.\n            initial_point: last position set by a \"M\" or \"m\" command\n\n        Returns:\n            a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved\n            `BezierCurve`.\n        \"\"\"\n        # pylint: disable=unused-argument\n        last_point = last_item.end_point\n\n        c1 = last_point + self.c1\n        c2 = last_point + self.c2\n        end = last_point + self.end\n\n        return (\n            _render_curve(c1, c2, end),\n            BezierCurve(c1=c1, c2=c2, end=end),\n            initial_point,\n        )",
      "language": "python"
    },
    {
      "code": "class RelativeBezierCurve(NamedTuple):\n    \"\"\"\n    A cubic Bézier curve path element whose points are specified relative to the end\n    point of the previous path element.\n\n    See: `PaintedPath.curve_relative`\n    \"\"\"\n\n    c1: Point\n    \"\"\"\n    The curve's first control point relative to the end of the previous path element.\n    \"\"\"\n    c2: Point\n    \"\"\"\n    The curve's second control point relative to the end of the previous path element.\n    \"\"\"\n    end: Point\n    \"\"\"The curve's end point relative to the end of the previous path element.\"\"\"\n\n    @property\n    def end_point(self) -> Point:\n        raise NotImplementedError\n\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        \"\"\"\n        Compute the bounding box of this relative cubic Bézier curve.\n\n        Args:\n            start (Point): The starting point of the curve (i.e., the end of the previous path element).\n\n        Returns:\n            A tuple containing:\n                - BoundingBox: the axis-aligned bounding box containing the entire curve.\n                - Point: the end point of the curve.\n        \"\"\"\n        # Resolve absolute coordinates\n        p0 = start\n        p1 = start + self.c1\n        p2 = start + self.c2\n        p3 = start + self.end\n\n        tx = [0, 1] + _cubic_bezier_critical_ts_1d(p0.x, p1.x, p2.x, p3.x)\n        ty = [0, 1] + _cubic_bezier_critical_ts_1d(p0.y, p1.y, p2.y, p3.y)\n\n        xs = [\n            _eval_cubic_bezier_1d(t, float(p0.x), float(p1.x), float(p2.x), float(p3.x))\n            for t in tx\n        ]\n        ys = [\n            _eval_cubic_bezier_1d(t, float(p0.y), float(p1.y), float(p2.y), float(p3.y))\n            for t in ty\n        ]\n\n        bbox = BoundingBox(min(xs), min(ys), max(xs), max(ys))\n        return bbox, p3\n\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        \"\"\"\n        Render this path element to its PDF representation.\n\n        Args:\n            resource_registry (ResourceCatalog): the owner's graphics state\n                dictionary registry.\n            style (GraphicsStyle): the current resolved graphics style\n            last_item: the previous path element.\n            initial_point: last position set by a \"M\" or \"m\" command\n\n        Returns:\n            a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved\n            `BezierCurve`.\n        \"\"\"\n        # pylint: disable=unused-argument\n        last_point = last_item.end_point\n\n        c1 = last_point + self.c1\n        c2 = last_point + self.c2\n        end = last_point + self.end\n\n        return (\n            _render_curve(c1, c2, end),\n            BezierCurve(c1=c1, c2=c2, end=end),\n            initial_point,\n        )",
      "language": "python"
    },
    {
      "code": "class RelativeBezierCurve(NamedTuple):\n    \"\"\"\n    A cubic Bézier curve path element whose points are specified relative to the end\n    point of the previous path element.\n\n    See: `PaintedPath.curve_relative`\n    \"\"\"\n\n    c1: Point\n    \"\"\"\n    The curve's first control point relative to the end of the previous path element.\n    \"\"\"\n    c2: Point\n    \"\"\"\n    The curve's second control point relative to the end of the previous path element.\n    \"\"\"\n    end: Point\n    \"\"\"The curve's end point relative to the end of the previous path element.\"\"\"\n\n    @property\n    def end_point(self) -> Point:\n        raise NotImplementedError\n\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        \"\"\"\n        Compute the bounding box of this relative cubic Bézier curve.\n\n        Args:\n            start (Point): The starting point of the curve (i.e., the end of the previous path element).\n\n        Returns:\n            A tuple containing:\n                - BoundingBox: the axis-aligned bounding box containing the entire curve.\n                - Point: the end point of the curve.\n        \"\"\"\n        # Resolve absolute coordinates\n        p0 = start\n        p1 = start + self.c1\n        p2 = start + self.c2\n        p3 = start + self.end\n\n        tx = [0, 1] + _cubic_bezier_critical_ts_1d(p0.x, p1.x, p2.x, p3.x)\n        ty = [0, 1] + _cubic_bezier_critical_ts_1d(p0.y, p1.y, p2.y, p3.y)\n\n        xs = [\n            _eval_cubic_bezier_1d(t, float(p0.x), float(p1.x), float(p2.x), float(p3.x))\n            for t in tx\n        ]\n        ys = [\n            _eval_cubic_bezier_1d(t, float(p0.y), float(p1.y), float(p2.y), float(p3.y))\n            for t in ty\n        ]\n\n        bbox = BoundingBox(min(xs), min(ys), max(xs), max(ys))\n        return bbox, p3\n\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        \"\"\"\n        Render this path element to its PDF representation.\n\n        Args:\n            resource_registry (ResourceCatalog): the owner's graphics state\n                dictionary registry.\n            style (GraphicsStyle): the current resolved graphics style\n            last_item: the previous path element.\n            initial_point: last position set by a \"M\" or \"m\" command\n\n        Returns:\n            a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved\n            `BezierCurve`.\n        \"\"\"\n        # pylint: disable=unused-argument\n        last_point = last_item.end_point\n\n        c1 = last_point + self.c1\n        c2 = last_point + self.c2\n        end = last_point + self.end\n\n        return (\n            _render_curve(c1, c2, end),\n            BezierCurve(c1=c1, c2=c2, end=end),\n            initial_point,\n        )",
      "language": "python"
    },
    {
      "code": "class RelativeBezierCurve(NamedTuple):\n    \"\"\"\n    A cubic Bézier curve path element whose points are specified relative to the end\n    point of the previous path element.\n\n    See: `PaintedPath.curve_relative`\n    \"\"\"\n\n    c1: Point\n    \"\"\"\n    The curve's first control point relative to the end of the previous path element.\n    \"\"\"\n    c2: Point\n    \"\"\"\n    The curve's second control point relative to the end of the previous path element.\n    \"\"\"\n    end: Point\n    \"\"\"The curve's end point relative to the end of the previous path element.\"\"\"\n\n    @property\n    def end_point(self) -> Point:\n        raise NotImplementedError\n\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        \"\"\"\n        Compute the bounding box of this relative cubic Bézier curve.\n\n        Args:\n            start (Point): The starting point of the curve (i.e., the end of the previous path element).\n\n        Returns:\n            A tuple containing:\n                - BoundingBox: the axis-aligned bounding box containing the entire curve.\n                - Point: the end point of the curve.\n        \"\"\"\n        # Resolve absolute coordinates\n        p0 = start\n        p1 = start + self.c1\n        p2 = start + self.c2\n        p3 = start + self.end\n\n        tx = [0, 1] + _cubic_bezier_critical_ts_1d(p0.x, p1.x, p2.x, p3.x)\n        ty = [0, 1] + _cubic_bezier_critical_ts_1d(p0.y, p1.y, p2.y, p3.y)\n\n        xs = [\n            _eval_cubic_bezier_1d(t, float(p0.x), float(p1.x), float(p2.x), float(p3.x))\n            for t in tx\n        ]\n        ys = [\n            _eval_cubic_bezier_1d(t, float(p0.y), float(p1.y), float(p2.y), float(p3.y))\n            for t in ty\n        ]\n\n        bbox = BoundingBox(min(xs), min(ys), max(xs), max(ys))\n        return bbox, p3\n\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        \"\"\"\n        Render this path element to its PDF representation.\n\n        Args:\n            resource_registry (ResourceCatalog): the owner's graphics state\n                dictionary registry.\n            style (GraphicsStyle): the current resolved graphics style\n            last_item: the previous path element.\n            initial_point: last position set by a \"M\" or \"m\" command\n\n        Returns:\n            a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved\n            `BezierCurve`.\n        \"\"\"\n        # pylint: disable=unused-argument\n        last_point = last_item.end_point\n\n        c1 = last_point + self.c1\n        c2 = last_point + self.c2\n        end = last_point + self.end\n\n        return (\n            _render_curve(c1, c2, end),\n            BezierCurve(c1=c1, c2=c2, end=end),\n            initial_point,\n        )",
      "language": "python"
    },
    {
      "code": "@property\ndef end_point(self) -> Point:\n    raise NotImplementedError",
      "language": "python"
    },
    {
      "code": "def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n    \"\"\"\n    Compute the bounding box of this relative cubic Bézier curve.\n\n    Args:\n        start (Point): The starting point of the curve (i.e., the end of the previous path element).\n\n    Returns:\n        A tuple containing:\n            - BoundingBox: the axis-aligned bounding box containing the entire curve.\n            - Point: the end point of the curve.\n    \"\"\"\n    # Resolve absolute coordinates\n    p0 = start\n    p1 = start + self.c1\n    p2 = start + self.c2\n    p3 = start + self.end\n\n    tx = [0, 1] + _cubic_bezier_critical_ts_1d(p0.x, p1.x, p2.x, p3.x)\n    ty = [0, 1] + _cubic_bezier_critical_ts_1d(p0.y, p1.y, p2.y, p3.y)\n\n    xs = [\n        _eval_cubic_bezier_1d(t, float(p0.x), float(p1.x), float(p2.x), float(p3.x))\n        for t in tx\n    ]\n    ys = [\n        _eval_cubic_bezier_1d(t, float(p0.y), float(p1.y), float(p2.y), float(p3.y))\n        for t in ty\n    ]\n\n    bbox = BoundingBox(min(xs), min(ys), max(xs), max(ys))\n    return bbox, p3",
      "language": "python"
    },
    {
      "code": "@force_nodocument\ndef render(\n    self,\n    resource_registry: \"ResourceCatalog\",\n    style: GraphicsStyle,\n    last_item: Renderable,\n    initial_point: Point,\n) -> tuple[str, Renderable, Point]:\n    \"\"\"\n    Render this path element to its PDF representation.\n\n    Args:\n        resource_registry (ResourceCatalog): the owner's graphics state\n            dictionary registry.\n        style (GraphicsStyle): the current resolved graphics style\n        last_item: the previous path element.\n        initial_point: last position set by a \"M\" or \"m\" command\n\n    Returns:\n        a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved\n        `BezierCurve`.\n    \"\"\"\n    # pylint: disable=unused-argument\n    last_point = last_item.end_point\n\n    c1 = last_point + self.c1\n    c2 = last_point + self.c2\n    end = last_point + self.end\n\n    return (\n        _render_curve(c1, c2, end),\n        BezierCurve(c1=c1, c2=c2, end=end),\n        initial_point,\n    )",
      "language": "python"
    },
    {
      "code": "class RelativeHorizontalLine(NamedTuple):\n    \"\"\"\n    A path line element that takes its ordinate from the end of the previous element and\n    computes its abscissa offset from the end of that element.\n\n    See: `PaintedPath.horizontal_line_relative`\n    \"\"\"\n\n    x: Number\n    \"\"\"\n    The abscissa of the horizontal line's end point relative to the abscissa of the\n    previous path element.\n    \"\"\"\n\n    @property\n    def end_point(self) -> Point:\n        raise NotImplementedError\n\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        \"\"\"Compute the bounding box of a relative horizontal line.\"\"\"\n        end = Point(float(start.x) + float(self.x), start.y)\n        bbox = BoundingBox.from_points([start, end])\n        return bbox, end\n\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        \"\"\"\n        Render this path element to its PDF representation.\n\n        Args:\n            resource_registry (ResourceCatalog): the owner's graphics state\n                dictionary registry.\n            style (GraphicsStyle): the current resolved graphics style\n            last_item: the previous path element.\n            initial_point: last position set by a \"M\" or \"m\" command\n\n        Returns:\n            a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved\n            `Line`.\n        \"\"\"\n        # pylint: disable=unused-argument\n        end_point = Point(\n            x=last_item.end_point.x + float(self.x), y=last_item.end_point.y\n        )\n        return _render_line(end_point), Line(end_point), initial_point",
      "language": "python"
    },
    {
      "code": "@property\ndef end_point(self) -> Point:\n    raise NotImplementedError",
      "language": "python"
    },
    {
      "code": "class RelativeHorizontalLine(NamedTuple):\n    \"\"\"\n    A path line element that takes its ordinate from the end of the previous element and\n    computes its abscissa offset from the end of that element.\n\n    See: `PaintedPath.horizontal_line_relative`\n    \"\"\"\n\n    x: Number\n    \"\"\"\n    The abscissa of the horizontal line's end point relative to the abscissa of the\n    previous path element.\n    \"\"\"\n\n    @property\n    def end_point(self) -> Point:\n        raise NotImplementedError\n\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        \"\"\"Compute the bounding box of a relative horizontal line.\"\"\"\n        end = Point(float(start.x) + float(self.x), start.y)\n        bbox = BoundingBox.from_points([start, end])\n        return bbox, end\n\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        \"\"\"\n        Render this path element to its PDF representation.\n\n        Args:\n            resource_registry (ResourceCatalog): the owner's graphics state\n                dictionary registry.\n            style (GraphicsStyle): the current resolved graphics style\n            last_item: the previous path element.\n            initial_point: last position set by a \"M\" or \"m\" command\n\n        Returns:\n            a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved\n            `Line`.\n        \"\"\"\n        # pylint: disable=unused-argument\n        end_point = Point(\n            x=last_item.end_point.x + float(self.x), y=last_item.end_point.y\n        )\n        return _render_line(end_point), Line(end_point), initial_point",
      "language": "python"
    },
    {
      "code": "def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n    \"\"\"Compute the bounding box of a relative horizontal line.\"\"\"\n    end = Point(float(start.x) + float(self.x), start.y)\n    bbox = BoundingBox.from_points([start, end])\n    return bbox, end",
      "language": "python"
    },
    {
      "code": "@force_nodocument\ndef render(\n    self,\n    resource_registry: \"ResourceCatalog\",\n    style: GraphicsStyle,\n    last_item: Renderable,\n    initial_point: Point,\n) -> tuple[str, Renderable, Point]:\n    \"\"\"\n    Render this path element to its PDF representation.\n\n    Args:\n        resource_registry (ResourceCatalog): the owner's graphics state\n            dictionary registry.\n        style (GraphicsStyle): the current resolved graphics style\n        last_item: the previous path element.\n        initial_point: last position set by a \"M\" or \"m\" command\n\n    Returns:\n        a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved\n        `Line`.\n    \"\"\"\n    # pylint: disable=unused-argument\n    end_point = Point(\n        x=last_item.end_point.x + float(self.x), y=last_item.end_point.y\n    )\n    return _render_line(end_point), Line(end_point), initial_point",
      "language": "python"
    },
    {
      "code": "class RelativeLine(NamedTuple):\n    \"\"\"\n    A path line element with an endpoint relative to the end of the previous element.\n\n    This draws a straight line from the end point of the previous path element to the\n    point specified by `last_item.end_point + pt`. The absolute coordinates of the end\n    point are resolved during the rendering process.\n\n    See: `PaintedPath.line_relative`\n    \"\"\"\n\n    pt: Point\n    \"\"\"The endpoint of the line relative to the previous path element.\"\"\"\n\n    @property\n    def end_point(self) -> Point:\n        raise NotImplementedError\n\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        \"\"\"Compute the bounding box of a relative line from the start point to the new end point.\"\"\"\n        return BoundingBox.from_points([start, start + self.pt]), start + self.pt\n\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        \"\"\"\n        Render this path element to its PDF representation.\n\n        Args:\n            resource_registry (ResourceCatalog): the owner's graphics state\n                dictionary registry.\n            style (GraphicsStyle): the current resolved graphics style\n            last_item: the previous path element.\n            initial_point: last position set by a \"M\" or \"m\" command\n\n        Returns:\n            a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved\n            `Line`.\n        \"\"\"\n        # pylint: disable=unused-argument\n        point = last_item.end_point + self.pt\n        return _render_line(point), Line(point), initial_point",
      "language": "python"
    },
    {
      "code": "@property\ndef end_point(self) -> Point:\n    raise NotImplementedError",
      "language": "python"
    },
    {
      "code": "class RelativeLine(NamedTuple):\n    \"\"\"\n    A path line element with an endpoint relative to the end of the previous element.\n\n    This draws a straight line from the end point of the previous path element to the\n    point specified by `last_item.end_point + pt`. The absolute coordinates of the end\n    point are resolved during the rendering process.\n\n    See: `PaintedPath.line_relative`\n    \"\"\"\n\n    pt: Point\n    \"\"\"The endpoint of the line relative to the previous path element.\"\"\"\n\n    @property\n    def end_point(self) -> Point:\n        raise NotImplementedError\n\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        \"\"\"Compute the bounding box of a relative line from the start point to the new end point.\"\"\"\n        return BoundingBox.from_points([start, start + self.pt]), start + self.pt\n\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        \"\"\"\n        Render this path element to its PDF representation.\n\n        Args:\n            resource_registry (ResourceCatalog): the owner's graphics state\n                dictionary registry.\n            style (GraphicsStyle): the current resolved graphics style\n            last_item: the previous path element.\n            initial_point: last position set by a \"M\" or \"m\" command\n\n        Returns:\n            a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved\n            `Line`.\n        \"\"\"\n        # pylint: disable=unused-argument\n        point = last_item.end_point + self.pt\n        return _render_line(point), Line(point), initial_point",
      "language": "python"
    },
    {
      "code": "def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n    \"\"\"Compute the bounding box of a relative line from the start point to the new end point.\"\"\"\n    return BoundingBox.from_points([start, start + self.pt]), start + self.pt",
      "language": "python"
    },
    {
      "code": "@force_nodocument\ndef render(\n    self,\n    resource_registry: \"ResourceCatalog\",\n    style: GraphicsStyle,\n    last_item: Renderable,\n    initial_point: Point,\n) -> tuple[str, Renderable, Point]:\n    \"\"\"\n    Render this path element to its PDF representation.\n\n    Args:\n        resource_registry (ResourceCatalog): the owner's graphics state\n            dictionary registry.\n        style (GraphicsStyle): the current resolved graphics style\n        last_item: the previous path element.\n        initial_point: last position set by a \"M\" or \"m\" command\n\n    Returns:\n        a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved\n        `Line`.\n    \"\"\"\n    # pylint: disable=unused-argument\n    point = last_item.end_point + self.pt\n    return _render_line(point), Line(point), initial_point",
      "language": "python"
    },
    {
      "code": "class RelativeMove(NamedTuple):\n    \"\"\"\n    A path move element with an end point relative to the end of the previous path\n    element.\n\n    If a path has been created but not yet painted, this will create a new subpath.\n\n    See: `PaintedPath.move_relative`\n    \"\"\"\n\n    pt: Point\n    \"\"\"The offset by which to move.\"\"\"\n\n    @property\n    def end_point(self) -> Point:\n        raise NotImplementedError\n\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        \"\"\"RelativeMove doesn't draw anything, so it has no bounding box.\"\"\"\n        return BoundingBox.empty(), start + self.pt\n\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        \"\"\"\n        Render this path element to its PDF representation.\n\n        Args:\n            resource_registry (ResourceCatalog): the owner's graphics state\n                dictionary registry.\n            style (GraphicsStyle): the current resolved graphics style\n            last_item: the previous path element.\n            initial_point: last position set by a \"M\" or \"m\" command\n\n        Returns:\n            a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved\n            `Move`\n        \"\"\"\n        # pylint: disable=unused-argument\n        point = last_item.end_point + self.pt\n        return _render_move(point), Move(point), point",
      "language": "python"
    },
    {
      "code": "@property\ndef end_point(self) -> Point:\n    raise NotImplementedError",
      "language": "python"
    },
    {
      "code": "class RelativeMove(NamedTuple):\n    \"\"\"\n    A path move element with an end point relative to the end of the previous path\n    element.\n\n    If a path has been created but not yet painted, this will create a new subpath.\n\n    See: `PaintedPath.move_relative`\n    \"\"\"\n\n    pt: Point\n    \"\"\"The offset by which to move.\"\"\"\n\n    @property\n    def end_point(self) -> Point:\n        raise NotImplementedError\n\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        \"\"\"RelativeMove doesn't draw anything, so it has no bounding box.\"\"\"\n        return BoundingBox.empty(), start + self.pt\n\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        \"\"\"\n        Render this path element to its PDF representation.\n\n        Args:\n            resource_registry (ResourceCatalog): the owner's graphics state\n                dictionary registry.\n            style (GraphicsStyle): the current resolved graphics style\n            last_item: the previous path element.\n            initial_point: last position set by a \"M\" or \"m\" command\n\n        Returns:\n            a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved\n            `Move`\n        \"\"\"\n        # pylint: disable=unused-argument\n        point = last_item.end_point + self.pt\n        return _render_move(point), Move(point), point",
      "language": "python"
    },
    {
      "code": "def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n    \"\"\"RelativeMove doesn't draw anything, so it has no bounding box.\"\"\"\n    return BoundingBox.empty(), start + self.pt",
      "language": "python"
    },
    {
      "code": "@force_nodocument\ndef render(\n    self,\n    resource_registry: \"ResourceCatalog\",\n    style: GraphicsStyle,\n    last_item: Renderable,\n    initial_point: Point,\n) -> tuple[str, Renderable, Point]:\n    \"\"\"\n    Render this path element to its PDF representation.\n\n    Args:\n        resource_registry (ResourceCatalog): the owner's graphics state\n            dictionary registry.\n        style (GraphicsStyle): the current resolved graphics style\n        last_item: the previous path element.\n        initial_point: last position set by a \"M\" or \"m\" command\n\n    Returns:\n        a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved\n        `Move`\n    \"\"\"\n    # pylint: disable=unused-argument\n    point = last_item.end_point + self.pt\n    return _render_move(point), Move(point), point",
      "language": "python"
    },
    {
      "code": "class RelativeQuadraticBezierCurve(NamedTuple):\n    \"\"\"\n    A quadratic Bézier curve path element whose points are specified relative to the end\n    point of the previous path element.\n\n    See: `PaintedPath.quadratic_curve_relative`\n    \"\"\"\n\n    ctrl: Point\n    \"\"\"The curve's control point relative to the end of the previous path element.\"\"\"\n    end: Point\n    \"\"\"The curve's end point relative to the end of the previous path element.\"\"\"\n\n    @property\n    def end_point(self) -> Point:\n        raise NotImplementedError\n\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        \"\"\"Compute the bounding box of this relative quadratic Bézier curve.\"\"\"\n        ctrl = start + self.ctrl\n        end = start + self.end\n        return QuadraticBezierCurve(ctrl=ctrl, end=end).bounding_box(start)\n\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        \"\"\"\n        Render this path element to its PDF representation.\n\n        Args:\n            resource_registry (ResourceCatalog): the owner's graphics state\n                dictionary registry.\n            style (GraphicsStyle): the current resolved graphics style\n            last_item: the previous path element.\n            initial_point: last position set by a \"M\" or \"m\" command\n\n        Returns:\n            a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved\n            `QuadraticBezierCurve`.\n        \"\"\"\n        last_point = last_item.end_point\n\n        ctrl = last_point + self.ctrl\n        end = last_point + self.end\n\n        absolute = QuadraticBezierCurve(ctrl=ctrl, end=end)\n        return absolute.render(resource_registry, style, last_item, initial_point)",
      "language": "python"
    },
    {
      "code": "class RelativeQuadraticBezierCurve(NamedTuple):\n    \"\"\"\n    A quadratic Bézier curve path element whose points are specified relative to the end\n    point of the previous path element.\n\n    See: `PaintedPath.quadratic_curve_relative`\n    \"\"\"\n\n    ctrl: Point\n    \"\"\"The curve's control point relative to the end of the previous path element.\"\"\"\n    end: Point\n    \"\"\"The curve's end point relative to the end of the previous path element.\"\"\"\n\n    @property\n    def end_point(self) -> Point:\n        raise NotImplementedError\n\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        \"\"\"Compute the bounding box of this relative quadratic Bézier curve.\"\"\"\n        ctrl = start + self.ctrl\n        end = start + self.end\n        return QuadraticBezierCurve(ctrl=ctrl, end=end).bounding_box(start)\n\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        \"\"\"\n        Render this path element to its PDF representation.\n\n        Args:\n            resource_registry (ResourceCatalog): the owner's graphics state\n                dictionary registry.\n            style (GraphicsStyle): the current resolved graphics style\n            last_item: the previous path element.\n            initial_point: last position set by a \"M\" or \"m\" command\n\n        Returns:\n            a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved\n            `QuadraticBezierCurve`.\n        \"\"\"\n        last_point = last_item.end_point\n\n        ctrl = last_point + self.ctrl\n        end = last_point + self.end\n\n        absolute = QuadraticBezierCurve(ctrl=ctrl, end=end)\n        return absolute.render(resource_registry, style, last_item, initial_point)",
      "language": "python"
    },
    {
      "code": "class RelativeQuadraticBezierCurve(NamedTuple):\n    \"\"\"\n    A quadratic Bézier curve path element whose points are specified relative to the end\n    point of the previous path element.\n\n    See: `PaintedPath.quadratic_curve_relative`\n    \"\"\"\n\n    ctrl: Point\n    \"\"\"The curve's control point relative to the end of the previous path element.\"\"\"\n    end: Point\n    \"\"\"The curve's end point relative to the end of the previous path element.\"\"\"\n\n    @property\n    def end_point(self) -> Point:\n        raise NotImplementedError\n\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        \"\"\"Compute the bounding box of this relative quadratic Bézier curve.\"\"\"\n        ctrl = start + self.ctrl\n        end = start + self.end\n        return QuadraticBezierCurve(ctrl=ctrl, end=end).bounding_box(start)\n\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        \"\"\"\n        Render this path element to its PDF representation.\n\n        Args:\n            resource_registry (ResourceCatalog): the owner's graphics state\n                dictionary registry.\n            style (GraphicsStyle): the current resolved graphics style\n            last_item: the previous path element.\n            initial_point: last position set by a \"M\" or \"m\" command\n\n        Returns:\n            a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved\n            `QuadraticBezierCurve`.\n        \"\"\"\n        last_point = last_item.end_point\n\n        ctrl = last_point + self.ctrl\n        end = last_point + self.end\n\n        absolute = QuadraticBezierCurve(ctrl=ctrl, end=end)\n        return absolute.render(resource_registry, style, last_item, initial_point)",
      "language": "python"
    },
    {
      "code": "@property\ndef end_point(self) -> Point:\n    raise NotImplementedError",
      "language": "python"
    },
    {
      "code": "def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n    \"\"\"Compute the bounding box of this relative quadratic Bézier curve.\"\"\"\n    ctrl = start + self.ctrl\n    end = start + self.end\n    return QuadraticBezierCurve(ctrl=ctrl, end=end).bounding_box(start)",
      "language": "python"
    },
    {
      "code": "@force_nodocument\ndef render(\n    self,\n    resource_registry: \"ResourceCatalog\",\n    style: GraphicsStyle,\n    last_item: Renderable,\n    initial_point: Point,\n) -> tuple[str, Renderable, Point]:\n    \"\"\"\n    Render this path element to its PDF representation.\n\n    Args:\n        resource_registry (ResourceCatalog): the owner's graphics state\n            dictionary registry.\n        style (GraphicsStyle): the current resolved graphics style\n        last_item: the previous path element.\n        initial_point: last position set by a \"M\" or \"m\" command\n\n    Returns:\n        a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved\n        `QuadraticBezierCurve`.\n    \"\"\"\n    last_point = last_item.end_point\n\n    ctrl = last_point + self.ctrl\n    end = last_point + self.end\n\n    absolute = QuadraticBezierCurve(ctrl=ctrl, end=end)\n    return absolute.render(resource_registry, style, last_item, initial_point)",
      "language": "python"
    },
    {
      "code": "class RelativeVerticalLine(NamedTuple):\n    \"\"\"\n    A path line element that takes its abscissa from the end of the previous element and\n    computes its ordinate offset from the end of that element.\n\n    See: `PaintedPath.vertical_line_relative`\n    \"\"\"\n\n    y: Number\n    \"\"\"\n    The ordinate of the vertical line's end point relative to the ordinate of the\n    previous path element.\n    \"\"\"\n\n    @property\n    def end_point(self) -> Point:\n        raise NotImplementedError\n\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        \"\"\"Compute the bounding box of this relative vertical line.\"\"\"\n        end = Point(start.x, float(start.y) + float(self.y))\n        bbox = BoundingBox.from_points([start, end])\n        return bbox, end\n\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        \"\"\"\n        Render this path element to its PDF representation.\n\n        Args:\n            resource_registry (ResourceCatalog): the owner's graphics state\n                dictionary registry.\n            style (GraphicsStyle): the current resolved graphics style\n            last_item: the previous path element.\n            initial_point: last position set by a \"M\" or \"m\" command\n\n        Returns:\n            a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved\n            `Line`.\n        \"\"\"\n        # pylint: disable=unused-argument\n        end_point = Point(\n            x=last_item.end_point.x, y=last_item.end_point.y + float(self.y)\n        )\n        return _render_line(end_point), Line(end_point), initial_point",
      "language": "python"
    },
    {
      "code": "@property\ndef end_point(self) -> Point:\n    raise NotImplementedError",
      "language": "python"
    },
    {
      "code": "class RelativeVerticalLine(NamedTuple):\n    \"\"\"\n    A path line element that takes its abscissa from the end of the previous element and\n    computes its ordinate offset from the end of that element.\n\n    See: `PaintedPath.vertical_line_relative`\n    \"\"\"\n\n    y: Number\n    \"\"\"\n    The ordinate of the vertical line's end point relative to the ordinate of the\n    previous path element.\n    \"\"\"\n\n    @property\n    def end_point(self) -> Point:\n        raise NotImplementedError\n\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        \"\"\"Compute the bounding box of this relative vertical line.\"\"\"\n        end = Point(start.x, float(start.y) + float(self.y))\n        bbox = BoundingBox.from_points([start, end])\n        return bbox, end\n\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        \"\"\"\n        Render this path element to its PDF representation.\n\n        Args:\n            resource_registry (ResourceCatalog): the owner's graphics state\n                dictionary registry.\n            style (GraphicsStyle): the current resolved graphics style\n            last_item: the previous path element.\n            initial_point: last position set by a \"M\" or \"m\" command\n\n        Returns:\n            a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved\n            `Line`.\n        \"\"\"\n        # pylint: disable=unused-argument\n        end_point = Point(\n            x=last_item.end_point.x, y=last_item.end_point.y + float(self.y)\n        )\n        return _render_line(end_point), Line(end_point), initial_point",
      "language": "python"
    },
    {
      "code": "def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n    \"\"\"Compute the bounding box of this relative vertical line.\"\"\"\n    end = Point(start.x, float(start.y) + float(self.y))\n    bbox = BoundingBox.from_points([start, end])\n    return bbox, end",
      "language": "python"
    },
    {
      "code": "@force_nodocument\ndef render(\n    self,\n    resource_registry: \"ResourceCatalog\",\n    style: GraphicsStyle,\n    last_item: Renderable,\n    initial_point: Point,\n) -> tuple[str, Renderable, Point]:\n    \"\"\"\n    Render this path element to its PDF representation.\n\n    Args:\n        resource_registry (ResourceCatalog): the owner's graphics state\n            dictionary registry.\n        style (GraphicsStyle): the current resolved graphics style\n        last_item: the previous path element.\n        initial_point: last position set by a \"M\" or \"m\" command\n\n    Returns:\n        a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved\n        `Line`.\n    \"\"\"\n    # pylint: disable=unused-argument\n    end_point = Point(\n        x=last_item.end_point.x, y=last_item.end_point.y + float(self.y)\n    )\n    return _render_line(end_point), Line(end_point), initial_point",
      "language": "python"
    },
    {
      "code": "@runtime_checkable\nclass Renderable(Protocol):\n    \"\"\"\n    Structural type for things that can render themselves into PDF operators\n    and report a geometric bounding box.\n    \"\"\"\n\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: \"Renderable\",\n        initial_point: Point,\n    ) -> tuple[str, \"Renderable\", Point]: ...\n\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]: ...\n\n    @property\n    def end_point(self) -> Point: ...",
      "language": "python"
    },
    {
      "code": "@property\ndef end_point(self) -> Point: ...",
      "language": "python"
    },
    {
      "code": "def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]: ...",
      "language": "python"
    },
    {
      "code": "def render(\n    self,\n    resource_registry: \"ResourceCatalog\",\n    style: GraphicsStyle,\n    last_item: \"Renderable\",\n    initial_point: Point,\n) -> tuple[str, \"Renderable\", Point]: ...",
      "language": "python"
    },
    {
      "code": "class RoundedRectangle(NamedTuple):\n    \"\"\"\n    A rectangle with rounded corners.\n\n    See: `PaintedPath.rectangle`\n    \"\"\"\n\n    org: Point\n    \"\"\"The top-left corner of the rectangle.\"\"\"\n    size: Point\n    \"\"\"The width and height of the rectangle.\"\"\"\n    corner_radii: Point\n    \"\"\"The x- and y-radius of the corners.\"\"\"\n\n    @property\n    def end_point(self) -> Point:\n        return self.org\n\n    def _decompose(self) -> list[Renderable]:\n        items: list[Renderable] = []\n\n        if (self.size.x == 0) and (self.size.y == 0):\n            pass\n        elif (self.size.x == 0) or (self.size.y == 0):\n            items.append(Move(self.org))\n            items.append(Line(self.org + self.size))\n            items.append(Close())\n        elif (self.corner_radii.x == 0) or (self.corner_radii.y == 0):\n            items.append(Rectangle(self.org, self.size))\n        else:\n            x, y = self.org\n            w, h = self.size\n            rx, ry = self.corner_radii\n            sign_width = (self.size.x >= 0) - (self.size.x < 0)\n            sign_height = (self.size.y >= 0) - (self.size.y < 0)\n\n            if abs(rx) > abs(w):\n                rx = self.size.x\n\n            if abs(ry) > abs(h):\n                ry = self.size.y\n\n            rx = sign_width * abs(rx)\n            ry = sign_height * abs(ry)\n            arc_rad = Point(rx, ry)\n\n            items.append(Move(Point(x + rx, y)))\n            items.append(Line(Point(x + w - rx, y)))\n            items.append(Arc(arc_rad, 0, False, True, Point(x + w, y + ry)))\n            items.append(Line(Point(x + w, y + h - ry)))\n            items.append(Arc(arc_rad, 0, False, True, Point(x + w - rx, y + h)))\n            items.append(Line(Point(x + rx, y + h)))\n            items.append(Arc(arc_rad, 0, False, True, Point(x, y + h - ry)))\n            items.append(Line(Point(x, y + ry)))\n            items.append(Arc(arc_rad, 0, False, True, Point(x + rx, y)))\n            items.append(Close())\n\n        return items\n\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        \"\"\"\n        Compute the bounding box of this rounded rectangle by decomposing into primitives\n        and merging their individual bounding boxes.\n        \"\"\"\n        bbox = BoundingBox.empty()\n        current_point = start\n\n        for item in self._decompose():\n            b, current_point = item.bounding_box(current_point)\n            bbox = bbox.merge(b)\n\n        return bbox, self.org\n\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        \"\"\"\n        Render this path element to its PDF representation.\n\n        Args:\n            resource_registry (ResourceCatalog): the owner's graphics state\n                dictionary registry.\n            style (GraphicsStyle): the current resolved graphics style\n            last_item: the previous path element.\n            initial_point: last position set by a \"M\" or \"m\" command\n\n        Returns:\n            a tuple of `(str, new_last_item)`, where `new_last_item` is a resolved\n            `Line`.\n        \"\"\"\n        components = self._decompose()\n\n        if not components:\n            return \"\", last_item, initial_point\n\n        render_list: list[str] = []\n        for item in components:\n            rendered, last_item, initial_point = item.render(\n                resource_registry, style, last_item, initial_point\n            )\n            render_list.append(rendered)\n\n        return \" \".join(render_list), Line(self.org), initial_point",
      "language": "python"
    },
    {
      "code": "class RoundedRectangle(NamedTuple):\n    \"\"\"\n    A rectangle with rounded corners.\n\n    See: `PaintedPath.rectangle`\n    \"\"\"\n\n    org: Point\n    \"\"\"The top-left corner of the rectangle.\"\"\"\n    size: Point\n    \"\"\"The width and height of the rectangle.\"\"\"\n    corner_radii: Point\n    \"\"\"The x- and y-radius of the corners.\"\"\"\n\n    @property\n    def end_point(self) -> Point:\n        return self.org\n\n    def _decompose(self) -> list[Renderable]:\n        items: list[Renderable] = []\n\n        if (self.size.x == 0) and (self.size.y == 0):\n            pass\n        elif (self.size.x == 0) or (self.size.y == 0):\n            items.append(Move(self.org))\n            items.append(Line(self.org + self.size))\n            items.append(Close())\n        elif (self.corner_radii.x == 0) or (self.corner_radii.y == 0):\n            items.append(Rectangle(self.org, self.size))\n        else:\n            x, y = self.org\n            w, h = self.size\n            rx, ry = self.corner_radii\n            sign_width = (self.size.x >= 0) - (self.size.x < 0)\n            sign_height = (self.size.y >= 0) - (self.size.y < 0)\n\n            if abs(rx) > abs(w):\n                rx = self.size.x\n\n            if abs(ry) > abs(h):\n                ry = self.size.y\n\n            rx = sign_width * abs(rx)\n            ry = sign_height * abs(ry)\n            arc_rad = Point(rx, ry)\n\n            items.append(Move(Point(x + rx, y)))\n            items.append(Line(Point(x + w - rx, y)))\n            items.append(Arc(arc_rad, 0, False, True, Point(x + w, y + ry)))\n            items.append(Line(Point(x + w, y + h - ry)))\n            items.append(Arc(arc_rad, 0, False, True, Point(x + w - rx, y + h)))\n            items.append(Line(Point(x + rx, y + h)))\n            items.append(Arc(arc_rad, 0, False, True, Point(x, y + h - ry)))\n            items.append(Line(Point(x, y + ry)))\n            items.append(Arc(arc_rad, 0, False, True, Point(x + rx, y)))\n            items.append(Close())\n\n        return items\n\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        \"\"\"\n        Compute the bounding box of this rounded rectangle by decomposing into primitives\n        and merging their individual bounding boxes.\n        \"\"\"\n        bbox = BoundingBox.empty()\n        current_point = start\n\n        for item in self._decompose():\n            b, current_point = item.bounding_box(current_point)\n            bbox = bbox.merge(b)\n\n        return bbox, self.org\n\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        \"\"\"\n        Render this path element to its PDF representation.\n\n        Args:\n            resource_registry (ResourceCatalog): the owner's graphics state\n                dictionary registry.\n            style (GraphicsStyle): the current resolved graphics style\n            last_item: the previous path element.\n            initial_point: last position set by a \"M\" or \"m\" command\n\n        Returns:\n            a tuple of `(str, new_last_item)`, where `new_last_item` is a resolved\n            `Line`.\n        \"\"\"\n        components = self._decompose()\n\n        if not components:\n            return \"\", last_item, initial_point\n\n        render_list: list[str] = []\n        for item in components:\n            rendered, last_item, initial_point = item.render(\n                resource_registry, style, last_item, initial_point\n            )\n            render_list.append(rendered)\n\n        return \" \".join(render_list), Line(self.org), initial_point",
      "language": "python"
    },
    {
      "code": "@property\ndef end_point(self) -> Point:\n    return self.org",
      "language": "python"
    },
    {
      "code": "class RoundedRectangle(NamedTuple):\n    \"\"\"\n    A rectangle with rounded corners.\n\n    See: `PaintedPath.rectangle`\n    \"\"\"\n\n    org: Point\n    \"\"\"The top-left corner of the rectangle.\"\"\"\n    size: Point\n    \"\"\"The width and height of the rectangle.\"\"\"\n    corner_radii: Point\n    \"\"\"The x- and y-radius of the corners.\"\"\"\n\n    @property\n    def end_point(self) -> Point:\n        return self.org\n\n    def _decompose(self) -> list[Renderable]:\n        items: list[Renderable] = []\n\n        if (self.size.x == 0) and (self.size.y == 0):\n            pass\n        elif (self.size.x == 0) or (self.size.y == 0):\n            items.append(Move(self.org))\n            items.append(Line(self.org + self.size))\n            items.append(Close())\n        elif (self.corner_radii.x == 0) or (self.corner_radii.y == 0):\n            items.append(Rectangle(self.org, self.size))\n        else:\n            x, y = self.org\n            w, h = self.size\n            rx, ry = self.corner_radii\n            sign_width = (self.size.x >= 0) - (self.size.x < 0)\n            sign_height = (self.size.y >= 0) - (self.size.y < 0)\n\n            if abs(rx) > abs(w):\n                rx = self.size.x\n\n            if abs(ry) > abs(h):\n                ry = self.size.y\n\n            rx = sign_width * abs(rx)\n            ry = sign_height * abs(ry)\n            arc_rad = Point(rx, ry)\n\n            items.append(Move(Point(x + rx, y)))\n            items.append(Line(Point(x + w - rx, y)))\n            items.append(Arc(arc_rad, 0, False, True, Point(x + w, y + ry)))\n            items.append(Line(Point(x + w, y + h - ry)))\n            items.append(Arc(arc_rad, 0, False, True, Point(x + w - rx, y + h)))\n            items.append(Line(Point(x + rx, y + h)))\n            items.append(Arc(arc_rad, 0, False, True, Point(x, y + h - ry)))\n            items.append(Line(Point(x, y + ry)))\n            items.append(Arc(arc_rad, 0, False, True, Point(x + rx, y)))\n            items.append(Close())\n\n        return items\n\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        \"\"\"\n        Compute the bounding box of this rounded rectangle by decomposing into primitives\n        and merging their individual bounding boxes.\n        \"\"\"\n        bbox = BoundingBox.empty()\n        current_point = start\n\n        for item in self._decompose():\n            b, current_point = item.bounding_box(current_point)\n            bbox = bbox.merge(b)\n\n        return bbox, self.org\n\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        \"\"\"\n        Render this path element to its PDF representation.\n\n        Args:\n            resource_registry (ResourceCatalog): the owner's graphics state\n                dictionary registry.\n            style (GraphicsStyle): the current resolved graphics style\n            last_item: the previous path element.\n            initial_point: last position set by a \"M\" or \"m\" command\n\n        Returns:\n            a tuple of `(str, new_last_item)`, where `new_last_item` is a resolved\n            `Line`.\n        \"\"\"\n        components = self._decompose()\n\n        if not components:\n            return \"\", last_item, initial_point\n\n        render_list: list[str] = []\n        for item in components:\n            rendered, last_item, initial_point = item.render(\n                resource_registry, style, last_item, initial_point\n            )\n            render_list.append(rendered)\n\n        return \" \".join(render_list), Line(self.org), initial_point",
      "language": "python"
    },
    {
      "code": "class RoundedRectangle(NamedTuple):\n    \"\"\"\n    A rectangle with rounded corners.\n\n    See: `PaintedPath.rectangle`\n    \"\"\"\n\n    org: Point\n    \"\"\"The top-left corner of the rectangle.\"\"\"\n    size: Point\n    \"\"\"The width and height of the rectangle.\"\"\"\n    corner_radii: Point\n    \"\"\"The x- and y-radius of the corners.\"\"\"\n\n    @property\n    def end_point(self) -> Point:\n        return self.org\n\n    def _decompose(self) -> list[Renderable]:\n        items: list[Renderable] = []\n\n        if (self.size.x == 0) and (self.size.y == 0):\n            pass\n        elif (self.size.x == 0) or (self.size.y == 0):\n            items.append(Move(self.org))\n            items.append(Line(self.org + self.size))\n            items.append(Close())\n        elif (self.corner_radii.x == 0) or (self.corner_radii.y == 0):\n            items.append(Rectangle(self.org, self.size))\n        else:\n            x, y = self.org\n            w, h = self.size\n            rx, ry = self.corner_radii\n            sign_width = (self.size.x >= 0) - (self.size.x < 0)\n            sign_height = (self.size.y >= 0) - (self.size.y < 0)\n\n            if abs(rx) > abs(w):\n                rx = self.size.x\n\n            if abs(ry) > abs(h):\n                ry = self.size.y\n\n            rx = sign_width * abs(rx)\n            ry = sign_height * abs(ry)\n            arc_rad = Point(rx, ry)\n\n            items.append(Move(Point(x + rx, y)))\n            items.append(Line(Point(x + w - rx, y)))\n            items.append(Arc(arc_rad, 0, False, True, Point(x + w, y + ry)))\n            items.append(Line(Point(x + w, y + h - ry)))\n            items.append(Arc(arc_rad, 0, False, True, Point(x + w - rx, y + h)))\n            items.append(Line(Point(x + rx, y + h)))\n            items.append(Arc(arc_rad, 0, False, True, Point(x, y + h - ry)))\n            items.append(Line(Point(x, y + ry)))\n            items.append(Arc(arc_rad, 0, False, True, Point(x + rx, y)))\n            items.append(Close())\n\n        return items\n\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        \"\"\"\n        Compute the bounding box of this rounded rectangle by decomposing into primitives\n        and merging their individual bounding boxes.\n        \"\"\"\n        bbox = BoundingBox.empty()\n        current_point = start\n\n        for item in self._decompose():\n            b, current_point = item.bounding_box(current_point)\n            bbox = bbox.merge(b)\n\n        return bbox, self.org\n\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        \"\"\"\n        Render this path element to its PDF representation.\n\n        Args:\n            resource_registry (ResourceCatalog): the owner's graphics state\n                dictionary registry.\n            style (GraphicsStyle): the current resolved graphics style\n            last_item: the previous path element.\n            initial_point: last position set by a \"M\" or \"m\" command\n\n        Returns:\n            a tuple of `(str, new_last_item)`, where `new_last_item` is a resolved\n            `Line`.\n        \"\"\"\n        components = self._decompose()\n\n        if not components:\n            return \"\", last_item, initial_point\n\n        render_list: list[str] = []\n        for item in components:\n            rendered, last_item, initial_point = item.render(\n                resource_registry, style, last_item, initial_point\n            )\n            render_list.append(rendered)\n\n        return \" \".join(render_list), Line(self.org), initial_point",
      "language": "python"
    },
    {
      "code": "def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n    \"\"\"\n    Compute the bounding box of this rounded rectangle by decomposing into primitives\n    and merging their individual bounding boxes.\n    \"\"\"\n    bbox = BoundingBox.empty()\n    current_point = start\n\n    for item in self._decompose():\n        b, current_point = item.bounding_box(current_point)\n        bbox = bbox.merge(b)\n\n    return bbox, self.org",
      "language": "python"
    },
    {
      "code": "@force_nodocument\ndef render(\n    self,\n    resource_registry: \"ResourceCatalog\",\n    style: GraphicsStyle,\n    last_item: Renderable,\n    initial_point: Point,\n) -> tuple[str, Renderable, Point]:\n    \"\"\"\n    Render this path element to its PDF representation.\n\n    Args:\n        resource_registry (ResourceCatalog): the owner's graphics state\n            dictionary registry.\n        style (GraphicsStyle): the current resolved graphics style\n        last_item: the previous path element.\n        initial_point: last position set by a \"M\" or \"m\" command\n\n    Returns:\n        a tuple of `(str, new_last_item)`, where `new_last_item` is a resolved\n        `Line`.\n    \"\"\"\n    components = self._decompose()\n\n    if not components:\n        return \"\", last_item, initial_point\n\n    render_list: list[str] = []\n    for item in components:\n        rendered, last_item, initial_point = item.render(\n            resource_registry, style, last_item, initial_point\n        )\n        render_list.append(rendered)\n\n    return \" \".join(render_list), Line(self.org), initial_point",
      "language": "python"
    },
    {
      "code": "class Text(NamedTuple):\n    \"\"\"\n    SVG-like text renderable.\n    Stores the anchor position (x, y) and one or more TextRuns that include\n    relative positioning offsets. Accurate glyph positioning is resolved\n    during rendering once font metrics are available.\n    \"\"\"\n\n    x: float\n    y: float\n    text_runs: tuple[TextRun, ...]\n    text_anchor: str = \"start\"  # \"start\" | \"middle\" | \"end\"\n\n    @property\n    def end_point(self) -> Point:\n        raise NotImplementedError\n\n    def _approximate_layout(self) -> tuple[list[tuple[float, float, float]], float]:\n        \"\"\"\n        Produce an approximate layout for bounding-box estimation.\n\n        Returns:\n            A tuple of (per-run layout list, total width estimate).  Each layout\n            entry is (x, y, width) in user space.\n        \"\"\"\n        positions: list[tuple[float, float, float]] = []\n        pen_x = self.x\n        pen_y = self.y\n        max_right = pen_x\n        min_left = pen_x\n\n        for run in self.text_runs:\n            if run.abs_x is not None:\n                pen_x = run.abs_x\n            if run.abs_y is not None:\n                pen_y = run.abs_y\n            pen_x += run.dx\n            pen_y += run.dy\n            # Fallback width estimation: ~0.5em per glyph\n            approx_width = 0.5 * run.size * max(0, len(run.text))\n            positions.append((pen_x, pen_y, approx_width))\n            min_left = min(min_left, pen_x)\n            max_right = max(max_right, pen_x + approx_width)\n            pen_x += approx_width\n\n        total_width = max_right - min_left\n        return positions, total_width\n\n    def _anchor_offset(self, positions: list[tuple[float, float, float]]) -> float:\n        \"\"\"Compute anchor offset for the provided approximate layout.\"\"\"\n        if not positions:\n            return 0.0\n\n        if any(run.abs_x is not None for run in self.text_runs):\n            return 0.0\n\n        min_x = min(pos[0] for pos in positions)\n        max_x = max(pos[0] + pos[2] for pos in positions)\n\n        if self.text_anchor == \"middle\":\n            return self.x - (min_x + max_x) / 2.0\n        if self.text_anchor == \"end\":\n            return self.x - max_x\n        return self.x - min_x\n\n    def bounding_box(self, start: Point) -> tuple[\"BoundingBox\", Point]:\n        \"\"\"\n        Compute a conservative bbox for the text.\n\n        Font metrics are not available at this stage so the layout relies on\n        approximate glyph widths proportional to the run font size. The actual\n        layout is computed precisely in render().\n        \"\"\"\n        if not self.text_runs:\n            return BoundingBox.empty(), start\n\n        positions, _ = self._approximate_layout()\n        anchor_offset = self._anchor_offset(positions)\n\n        min_x = float(\"inf\")\n        max_x = float(\"-inf\")\n        min_y = float(\"inf\")\n        max_y = float(\"-inf\")\n\n        for (run_x, run_y, run_width), run in zip(positions, self.text_runs):\n            adj_x = run_x + anchor_offset\n            asc = 0.8 * run.size\n            desc = 0.2 * run.size\n            min_x = min(min_x, adj_x)\n            max_x = max(max_x, adj_x + run_width)\n            min_y = min(min_y, run_y - asc)\n            max_y = max(max_y, run_y + desc)\n\n        if min_x == float(\"inf\"):\n            return BoundingBox.empty(), start\n\n        x0 = min_x\n        x1 = max_x\n        y0 = min_y\n        y1 = max_y\n\n        return BoundingBox.from_points([Point(x0, y0), Point(x1, y1)]), start\n\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: \"GraphicsStyle\",\n        last_item: \"Renderable\",\n        initial_point: Point,\n    ) -> tuple[str, \"Renderable\", Point]:\n        \"\"\"\n        Emit PDF text operators:\n\n          BT\n            <font_id> <font_size> Tf\n            Tr <mode>               (map from GraphicsStyle->PathPaintRule)\n            1 0 0 1 x y Tm\n            (escaped-text) Tj\n          ET\n        \"\"\"\n        if not self.text_runs:\n            return \"\", last_item, initial_point\n\n        # Precise layout resolution with actual font metrics\n        layout: list[\n            tuple[float, float, float, TextRun, Union[\"CoreFont\", \"TTFFont\"]]\n        ] = []\n        pen_x = self.x\n        pen_y = self.y\n        min_x = pen_x\n        max_x = pen_x\n\n        for run in self.text_runs:\n            font = resource_registry.get_font_from_family(run.family, run.emphasis)\n            _, width = font.get_text_width(run.text, run.size, None)\n            if run.abs_x is not None:\n                pen_x = run.abs_x\n            if run.abs_y is not None:\n                pen_y = run.abs_y\n            pen_x += run.dx\n            pen_y += run.dy\n            min_x = min(min_x, pen_x)\n            max_x = max(max_x, pen_x + width)\n            layout.append((pen_x, pen_y, width, run, font))\n            pen_x += width\n\n        has_absolute = any(run.abs_x is not None for _, _, _, run, _ in layout)\n\n        if layout and not has_absolute:\n            if self.text_anchor == \"middle\":\n                anchor_offset = self.x - (min_x + max_x) / 2.0\n            elif self.text_anchor == \"end\":\n                anchor_offset = self.x - max_x\n            else:\n                anchor_offset = self.x - min_x\n        else:\n            anchor_offset = 0.0\n\n        ops: list[str] = []\n        NO_EMIT_SET = (None, GraphicsStyle.INHERIT)\n\n        for run_x, run_y, width, run, font in layout:\n            effective_style = (\n                GraphicsStyle.merge(style, run.run_style)\n                if run.run_style is not None\n                else style\n            )\n\n            # Determine text rendering mode\n            rule = effective_style.resolve_paint_rule()\n            if rule in (PathPaintRule.FILL_NONZERO, PathPaintRule.FILL_EVENODD):\n                tr = 0\n            elif rule is PathPaintRule.STROKE:\n                tr = 1\n            elif rule in (\n                PathPaintRule.STROKE_FILL_NONZERO,\n                PathPaintRule.STROKE_FILL_EVENODD,\n            ):\n                tr = 2\n            else:  # PathPaintRule.DONT_PAINT:\n                tr = 3\n\n            run_ops: list[str] = []\n\n            if run.run_style is not None:\n                merged_style = effective_style\n                style_dict_name = resource_registry.register_graphics_style(\n                    merged_style\n                )\n\n                if style_dict_name is not None:\n                    run_ops.append(f\"{render_pdf_primitive(style_dict_name)} gs\")\n\n                fill_color = merged_style.fill_color\n                stroke_color = merged_style.stroke_color\n\n                run_bbox = BoundingBox.from_points(\n                    [\n                        Point(run_x + anchor_offset, run_y - 0.8 * run.size),\n                        Point(run_x + anchor_offset + width, run_y + 0.2 * run.size),\n                    ]\n                )\n\n                if fill_color not in NO_EMIT_SET:\n                    if isinstance(fill_color, GradientPaint):\n                        run_ops.append(\n                            fill_color.emit_fill(resource_registry, run_bbox)\n                        )\n                    else:\n                        assert isinstance(\n                            fill_color, (DeviceCMYK, DeviceRGB, DeviceRGB)\n                        )\n                        run_ops.append(fill_color.serialize().lower())\n                if stroke_color not in NO_EMIT_SET:\n                    if isinstance(stroke_color, GradientPaint):\n                        run_ops.append(\n                            stroke_color.emit_stroke(resource_registry, run_bbox)\n                        )\n                    else:\n                        assert isinstance(\n                            stroke_color, (DeviceCMYK, DeviceRGB, DeviceRGB)\n                        )\n                        run_ops.append(stroke_color.serialize().upper())\n\n                dash_pattern = merged_style.stroke_dash_pattern\n                dash_phase = merged_style.stroke_dash_phase\n                assert isinstance(dash_phase, NumberClass)\n                if dash_pattern not in NO_EMIT_SET:\n                    run_ops.append(\n                        render_pdf_primitive(dash_pattern)\n                        + f\" {number_to_str(dash_phase)} d\"\n                    )\n\n            run_ops.extend(\n                [\n                    \"BT\",\n                    f\"/F{font.i} {number_to_str(run.size)} Tf\",\n                    f\"{number_to_str(tr)} Tr\",\n                    f\"1 0 0 -1 {number_to_str(run_x + anchor_offset)} {number_to_str(run_y)} Tm\",\n                    font.encode_text(run.text),\n                    \"ET\",\n                ]\n            )\n\n            if run.run_style is not None:\n                run_ops = [\"q\"] + run_ops + [\"Q\"]\n\n            ops.extend(run_ops)\n\n        return \" \".join(ops), last_item, initial_point",
      "language": "python"
    },
    {
      "code": "@property\ndef end_point(self) -> Point:\n    raise NotImplementedError",
      "language": "python"
    },
    {
      "code": "class Text(NamedTuple):\n    \"\"\"\n    SVG-like text renderable.\n    Stores the anchor position (x, y) and one or more TextRuns that include\n    relative positioning offsets. Accurate glyph positioning is resolved\n    during rendering once font metrics are available.\n    \"\"\"\n\n    x: float\n    y: float\n    text_runs: tuple[TextRun, ...]\n    text_anchor: str = \"start\"  # \"start\" | \"middle\" | \"end\"\n\n    @property\n    def end_point(self) -> Point:\n        raise NotImplementedError\n\n    def _approximate_layout(self) -> tuple[list[tuple[float, float, float]], float]:\n        \"\"\"\n        Produce an approximate layout for bounding-box estimation.\n\n        Returns:\n            A tuple of (per-run layout list, total width estimate).  Each layout\n            entry is (x, y, width) in user space.\n        \"\"\"\n        positions: list[tuple[float, float, float]] = []\n        pen_x = self.x\n        pen_y = self.y\n        max_right = pen_x\n        min_left = pen_x\n\n        for run in self.text_runs:\n            if run.abs_x is not None:\n                pen_x = run.abs_x\n            if run.abs_y is not None:\n                pen_y = run.abs_y\n            pen_x += run.dx\n            pen_y += run.dy\n            # Fallback width estimation: ~0.5em per glyph\n            approx_width = 0.5 * run.size * max(0, len(run.text))\n            positions.append((pen_x, pen_y, approx_width))\n            min_left = min(min_left, pen_x)\n            max_right = max(max_right, pen_x + approx_width)\n            pen_x += approx_width\n\n        total_width = max_right - min_left\n        return positions, total_width\n\n    def _anchor_offset(self, positions: list[tuple[float, float, float]]) -> float:\n        \"\"\"Compute anchor offset for the provided approximate layout.\"\"\"\n        if not positions:\n            return 0.0\n\n        if any(run.abs_x is not None for run in self.text_runs):\n            return 0.0\n\n        min_x = min(pos[0] for pos in positions)\n        max_x = max(pos[0] + pos[2] for pos in positions)\n\n        if self.text_anchor == \"middle\":\n            return self.x - (min_x + max_x) / 2.0\n        if self.text_anchor == \"end\":\n            return self.x - max_x\n        return self.x - min_x\n\n    def bounding_box(self, start: Point) -> tuple[\"BoundingBox\", Point]:\n        \"\"\"\n        Compute a conservative bbox for the text.\n\n        Font metrics are not available at this stage so the layout relies on\n        approximate glyph widths proportional to the run font size. The actual\n        layout is computed precisely in render().\n        \"\"\"\n        if not self.text_runs:\n            return BoundingBox.empty(), start\n\n        positions, _ = self._approximate_layout()\n        anchor_offset = self._anchor_offset(positions)\n\n        min_x = float(\"inf\")\n        max_x = float(\"-inf\")\n        min_y = float(\"inf\")\n        max_y = float(\"-inf\")\n\n        for (run_x, run_y, run_width), run in zip(positions, self.text_runs):\n            adj_x = run_x + anchor_offset\n            asc = 0.8 * run.size\n            desc = 0.2 * run.size\n            min_x = min(min_x, adj_x)\n            max_x = max(max_x, adj_x + run_width)\n            min_y = min(min_y, run_y - asc)\n            max_y = max(max_y, run_y + desc)\n\n        if min_x == float(\"inf\"):\n            return BoundingBox.empty(), start\n\n        x0 = min_x\n        x1 = max_x\n        y0 = min_y\n        y1 = max_y\n\n        return BoundingBox.from_points([Point(x0, y0), Point(x1, y1)]), start\n\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: \"GraphicsStyle\",\n        last_item: \"Renderable\",\n        initial_point: Point,\n    ) -> tuple[str, \"Renderable\", Point]:\n        \"\"\"\n        Emit PDF text operators:\n\n          BT\n            <font_id> <font_size> Tf\n            Tr <mode>               (map from GraphicsStyle->PathPaintRule)\n            1 0 0 1 x y Tm\n            (escaped-text) Tj\n          ET\n        \"\"\"\n        if not self.text_runs:\n            return \"\", last_item, initial_point\n\n        # Precise layout resolution with actual font metrics\n        layout: list[\n            tuple[float, float, float, TextRun, Union[\"CoreFont\", \"TTFFont\"]]\n        ] = []\n        pen_x = self.x\n        pen_y = self.y\n        min_x = pen_x\n        max_x = pen_x\n\n        for run in self.text_runs:\n            font = resource_registry.get_font_from_family(run.family, run.emphasis)\n            _, width = font.get_text_width(run.text, run.size, None)\n            if run.abs_x is not None:\n                pen_x = run.abs_x\n            if run.abs_y is not None:\n                pen_y = run.abs_y\n            pen_x += run.dx\n            pen_y += run.dy\n            min_x = min(min_x, pen_x)\n            max_x = max(max_x, pen_x + width)\n            layout.append((pen_x, pen_y, width, run, font))\n            pen_x += width\n\n        has_absolute = any(run.abs_x is not None for _, _, _, run, _ in layout)\n\n        if layout and not has_absolute:\n            if self.text_anchor == \"middle\":\n                anchor_offset = self.x - (min_x + max_x) / 2.0\n            elif self.text_anchor == \"end\":\n                anchor_offset = self.x - max_x\n            else:\n                anchor_offset = self.x - min_x\n        else:\n            anchor_offset = 0.0\n\n        ops: list[str] = []\n        NO_EMIT_SET = (None, GraphicsStyle.INHERIT)\n\n        for run_x, run_y, width, run, font in layout:\n            effective_style = (\n                GraphicsStyle.merge(style, run.run_style)\n                if run.run_style is not None\n                else style\n            )\n\n            # Determine text rendering mode\n            rule = effective_style.resolve_paint_rule()\n            if rule in (PathPaintRule.FILL_NONZERO, PathPaintRule.FILL_EVENODD):\n                tr = 0\n            elif rule is PathPaintRule.STROKE:\n                tr = 1\n            elif rule in (\n                PathPaintRule.STROKE_FILL_NONZERO,\n                PathPaintRule.STROKE_FILL_EVENODD,\n            ):\n                tr = 2\n            else:  # PathPaintRule.DONT_PAINT:\n                tr = 3\n\n            run_ops: list[str] = []\n\n            if run.run_style is not None:\n                merged_style = effective_style\n                style_dict_name = resource_registry.register_graphics_style(\n                    merged_style\n                )\n\n                if style_dict_name is not None:\n                    run_ops.append(f\"{render_pdf_primitive(style_dict_name)} gs\")\n\n                fill_color = merged_style.fill_color\n                stroke_color = merged_style.stroke_color\n\n                run_bbox = BoundingBox.from_points(\n                    [\n                        Point(run_x + anchor_offset, run_y - 0.8 * run.size),\n                        Point(run_x + anchor_offset + width, run_y + 0.2 * run.size),\n                    ]\n                )\n\n                if fill_color not in NO_EMIT_SET:\n                    if isinstance(fill_color, GradientPaint):\n                        run_ops.append(\n                            fill_color.emit_fill(resource_registry, run_bbox)\n                        )\n                    else:\n                        assert isinstance(\n                            fill_color, (DeviceCMYK, DeviceRGB, DeviceRGB)\n                        )\n                        run_ops.append(fill_color.serialize().lower())\n                if stroke_color not in NO_EMIT_SET:\n                    if isinstance(stroke_color, GradientPaint):\n                        run_ops.append(\n                            stroke_color.emit_stroke(resource_registry, run_bbox)\n                        )\n                    else:\n                        assert isinstance(\n                            stroke_color, (DeviceCMYK, DeviceRGB, DeviceRGB)\n                        )\n                        run_ops.append(stroke_color.serialize().upper())\n\n                dash_pattern = merged_style.stroke_dash_pattern\n                dash_phase = merged_style.stroke_dash_phase\n                assert isinstance(dash_phase, NumberClass)\n                if dash_pattern not in NO_EMIT_SET:\n                    run_ops.append(\n                        render_pdf_primitive(dash_pattern)\n                        + f\" {number_to_str(dash_phase)} d\"\n                    )\n\n            run_ops.extend(\n                [\n                    \"BT\",\n                    f\"/F{font.i} {number_to_str(run.size)} Tf\",\n                    f\"{number_to_str(tr)} Tr\",\n                    f\"1 0 0 -1 {number_to_str(run_x + anchor_offset)} {number_to_str(run_y)} Tm\",\n                    font.encode_text(run.text),\n                    \"ET\",\n                ]\n            )\n\n            if run.run_style is not None:\n                run_ops = [\"q\"] + run_ops + [\"Q\"]\n\n            ops.extend(run_ops)\n\n        return \" \".join(ops), last_item, initial_point",
      "language": "python"
    },
    {
      "code": "class Text(NamedTuple):\n    \"\"\"\n    SVG-like text renderable.\n    Stores the anchor position (x, y) and one or more TextRuns that include\n    relative positioning offsets. Accurate glyph positioning is resolved\n    during rendering once font metrics are available.\n    \"\"\"\n\n    x: float\n    y: float\n    text_runs: tuple[TextRun, ...]\n    text_anchor: str = \"start\"  # \"start\" | \"middle\" | \"end\"\n\n    @property\n    def end_point(self) -> Point:\n        raise NotImplementedError\n\n    def _approximate_layout(self) -> tuple[list[tuple[float, float, float]], float]:\n        \"\"\"\n        Produce an approximate layout for bounding-box estimation.\n\n        Returns:\n            A tuple of (per-run layout list, total width estimate).  Each layout\n            entry is (x, y, width) in user space.\n        \"\"\"\n        positions: list[tuple[float, float, float]] = []\n        pen_x = self.x\n        pen_y = self.y\n        max_right = pen_x\n        min_left = pen_x\n\n        for run in self.text_runs:\n            if run.abs_x is not None:\n                pen_x = run.abs_x\n            if run.abs_y is not None:\n                pen_y = run.abs_y\n            pen_x += run.dx\n            pen_y += run.dy\n            # Fallback width estimation: ~0.5em per glyph\n            approx_width = 0.5 * run.size * max(0, len(run.text))\n            positions.append((pen_x, pen_y, approx_width))\n            min_left = min(min_left, pen_x)\n            max_right = max(max_right, pen_x + approx_width)\n            pen_x += approx_width\n\n        total_width = max_right - min_left\n        return positions, total_width\n\n    def _anchor_offset(self, positions: list[tuple[float, float, float]]) -> float:\n        \"\"\"Compute anchor offset for the provided approximate layout.\"\"\"\n        if not positions:\n            return 0.0\n\n        if any(run.abs_x is not None for run in self.text_runs):\n            return 0.0\n\n        min_x = min(pos[0] for pos in positions)\n        max_x = max(pos[0] + pos[2] for pos in positions)\n\n        if self.text_anchor == \"middle\":\n            return self.x - (min_x + max_x) / 2.0\n        if self.text_anchor == \"end\":\n            return self.x - max_x\n        return self.x - min_x\n\n    def bounding_box(self, start: Point) -> tuple[\"BoundingBox\", Point]:\n        \"\"\"\n        Compute a conservative bbox for the text.\n\n        Font metrics are not available at this stage so the layout relies on\n        approximate glyph widths proportional to the run font size. The actual\n        layout is computed precisely in render().\n        \"\"\"\n        if not self.text_runs:\n            return BoundingBox.empty(), start\n\n        positions, _ = self._approximate_layout()\n        anchor_offset = self._anchor_offset(positions)\n\n        min_x = float(\"inf\")\n        max_x = float(\"-inf\")\n        min_y = float(\"inf\")\n        max_y = float(\"-inf\")\n\n        for (run_x, run_y, run_width), run in zip(positions, self.text_runs):\n            adj_x = run_x + anchor_offset\n            asc = 0.8 * run.size\n            desc = 0.2 * run.size\n            min_x = min(min_x, adj_x)\n            max_x = max(max_x, adj_x + run_width)\n            min_y = min(min_y, run_y - asc)\n            max_y = max(max_y, run_y + desc)\n\n        if min_x == float(\"inf\"):\n            return BoundingBox.empty(), start\n\n        x0 = min_x\n        x1 = max_x\n        y0 = min_y\n        y1 = max_y\n\n        return BoundingBox.from_points([Point(x0, y0), Point(x1, y1)]), start\n\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: \"GraphicsStyle\",\n        last_item: \"Renderable\",\n        initial_point: Point,\n    ) -> tuple[str, \"Renderable\", Point]:\n        \"\"\"\n        Emit PDF text operators:\n\n          BT\n            <font_id> <font_size> Tf\n            Tr <mode>               (map from GraphicsStyle->PathPaintRule)\n            1 0 0 1 x y Tm\n            (escaped-text) Tj\n          ET\n        \"\"\"\n        if not self.text_runs:\n            return \"\", last_item, initial_point\n\n        # Precise layout resolution with actual font metrics\n        layout: list[\n            tuple[float, float, float, TextRun, Union[\"CoreFont\", \"TTFFont\"]]\n        ] = []\n        pen_x = self.x\n        pen_y = self.y\n        min_x = pen_x\n        max_x = pen_x\n\n        for run in self.text_runs:\n            font = resource_registry.get_font_from_family(run.family, run.emphasis)\n            _, width = font.get_text_width(run.text, run.size, None)\n            if run.abs_x is not None:\n                pen_x = run.abs_x\n            if run.abs_y is not None:\n                pen_y = run.abs_y\n            pen_x += run.dx\n            pen_y += run.dy\n            min_x = min(min_x, pen_x)\n            max_x = max(max_x, pen_x + width)\n            layout.append((pen_x, pen_y, width, run, font))\n            pen_x += width\n\n        has_absolute = any(run.abs_x is not None for _, _, _, run, _ in layout)\n\n        if layout and not has_absolute:\n            if self.text_anchor == \"middle\":\n                anchor_offset = self.x - (min_x + max_x) / 2.0\n            elif self.text_anchor == \"end\":\n                anchor_offset = self.x - max_x\n            else:\n                anchor_offset = self.x - min_x\n        else:\n            anchor_offset = 0.0\n\n        ops: list[str] = []\n        NO_EMIT_SET = (None, GraphicsStyle.INHERIT)\n\n        for run_x, run_y, width, run, font in layout:\n            effective_style = (\n                GraphicsStyle.merge(style, run.run_style)\n                if run.run_style is not None\n                else style\n            )\n\n            # Determine text rendering mode\n            rule = effective_style.resolve_paint_rule()\n            if rule in (PathPaintRule.FILL_NONZERO, PathPaintRule.FILL_EVENODD):\n                tr = 0\n            elif rule is PathPaintRule.STROKE:\n                tr = 1\n            elif rule in (\n                PathPaintRule.STROKE_FILL_NONZERO,\n                PathPaintRule.STROKE_FILL_EVENODD,\n            ):\n                tr = 2\n            else:  # PathPaintRule.DONT_PAINT:\n                tr = 3\n\n            run_ops: list[str] = []\n\n            if run.run_style is not None:\n                merged_style = effective_style\n                style_dict_name = resource_registry.register_graphics_style(\n                    merged_style\n                )\n\n                if style_dict_name is not None:\n                    run_ops.append(f\"{render_pdf_primitive(style_dict_name)} gs\")\n\n                fill_color = merged_style.fill_color\n                stroke_color = merged_style.stroke_color\n\n                run_bbox = BoundingBox.from_points(\n                    [\n                        Point(run_x + anchor_offset, run_y - 0.8 * run.size),\n                        Point(run_x + anchor_offset + width, run_y + 0.2 * run.size),\n                    ]\n                )\n\n                if fill_color not in NO_EMIT_SET:\n                    if isinstance(fill_color, GradientPaint):\n                        run_ops.append(\n                            fill_color.emit_fill(resource_registry, run_bbox)\n                        )\n                    else:\n                        assert isinstance(\n                            fill_color, (DeviceCMYK, DeviceRGB, DeviceRGB)\n                        )\n                        run_ops.append(fill_color.serialize().lower())\n                if stroke_color not in NO_EMIT_SET:\n                    if isinstance(stroke_color, GradientPaint):\n                        run_ops.append(\n                            stroke_color.emit_stroke(resource_registry, run_bbox)\n                        )\n                    else:\n                        assert isinstance(\n                            stroke_color, (DeviceCMYK, DeviceRGB, DeviceRGB)\n                        )\n                        run_ops.append(stroke_color.serialize().upper())\n\n                dash_pattern = merged_style.stroke_dash_pattern\n                dash_phase = merged_style.stroke_dash_phase\n                assert isinstance(dash_phase, NumberClass)\n                if dash_pattern not in NO_EMIT_SET:\n                    run_ops.append(\n                        render_pdf_primitive(dash_pattern)\n                        + f\" {number_to_str(dash_phase)} d\"\n                    )\n\n            run_ops.extend(\n                [\n                    \"BT\",\n                    f\"/F{font.i} {number_to_str(run.size)} Tf\",\n                    f\"{number_to_str(tr)} Tr\",\n                    f\"1 0 0 -1 {number_to_str(run_x + anchor_offset)} {number_to_str(run_y)} Tm\",\n                    font.encode_text(run.text),\n                    \"ET\",\n                ]\n            )\n\n            if run.run_style is not None:\n                run_ops = [\"q\"] + run_ops + [\"Q\"]\n\n            ops.extend(run_ops)\n\n        return \" \".join(ops), last_item, initial_point",
      "language": "python"
    },
    {
      "code": "class Text(NamedTuple):\n    \"\"\"\n    SVG-like text renderable.\n    Stores the anchor position (x, y) and one or more TextRuns that include\n    relative positioning offsets. Accurate glyph positioning is resolved\n    during rendering once font metrics are available.\n    \"\"\"\n\n    x: float\n    y: float\n    text_runs: tuple[TextRun, ...]\n    text_anchor: str = \"start\"  # \"start\" | \"middle\" | \"end\"\n\n    @property\n    def end_point(self) -> Point:\n        raise NotImplementedError\n\n    def _approximate_layout(self) -> tuple[list[tuple[float, float, float]], float]:\n        \"\"\"\n        Produce an approximate layout for bounding-box estimation.\n\n        Returns:\n            A tuple of (per-run layout list, total width estimate).  Each layout\n            entry is (x, y, width) in user space.\n        \"\"\"\n        positions: list[tuple[float, float, float]] = []\n        pen_x = self.x\n        pen_y = self.y\n        max_right = pen_x\n        min_left = pen_x\n\n        for run in self.text_runs:\n            if run.abs_x is not None:\n                pen_x = run.abs_x\n            if run.abs_y is not None:\n                pen_y = run.abs_y\n            pen_x += run.dx\n            pen_y += run.dy\n            # Fallback width estimation: ~0.5em per glyph\n            approx_width = 0.5 * run.size * max(0, len(run.text))\n            positions.append((pen_x, pen_y, approx_width))\n            min_left = min(min_left, pen_x)\n            max_right = max(max_right, pen_x + approx_width)\n            pen_x += approx_width\n\n        total_width = max_right - min_left\n        return positions, total_width\n\n    def _anchor_offset(self, positions: list[tuple[float, float, float]]) -> float:\n        \"\"\"Compute anchor offset for the provided approximate layout.\"\"\"\n        if not positions:\n            return 0.0\n\n        if any(run.abs_x is not None for run in self.text_runs):\n            return 0.0\n\n        min_x = min(pos[0] for pos in positions)\n        max_x = max(pos[0] + pos[2] for pos in positions)\n\n        if self.text_anchor == \"middle\":\n            return self.x - (min_x + max_x) / 2.0\n        if self.text_anchor == \"end\":\n            return self.x - max_x\n        return self.x - min_x\n\n    def bounding_box(self, start: Point) -> tuple[\"BoundingBox\", Point]:\n        \"\"\"\n        Compute a conservative bbox for the text.\n\n        Font metrics are not available at this stage so the layout relies on\n        approximate glyph widths proportional to the run font size. The actual\n        layout is computed precisely in render().\n        \"\"\"\n        if not self.text_runs:\n            return BoundingBox.empty(), start\n\n        positions, _ = self._approximate_layout()\n        anchor_offset = self._anchor_offset(positions)\n\n        min_x = float(\"inf\")\n        max_x = float(\"-inf\")\n        min_y = float(\"inf\")\n        max_y = float(\"-inf\")\n\n        for (run_x, run_y, run_width), run in zip(positions, self.text_runs):\n            adj_x = run_x + anchor_offset\n            asc = 0.8 * run.size\n            desc = 0.2 * run.size\n            min_x = min(min_x, adj_x)\n            max_x = max(max_x, adj_x + run_width)\n            min_y = min(min_y, run_y - asc)\n            max_y = max(max_y, run_y + desc)\n\n        if min_x == float(\"inf\"):\n            return BoundingBox.empty(), start\n\n        x0 = min_x\n        x1 = max_x\n        y0 = min_y\n        y1 = max_y\n\n        return BoundingBox.from_points([Point(x0, y0), Point(x1, y1)]), start\n\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: \"GraphicsStyle\",\n        last_item: \"Renderable\",\n        initial_point: Point,\n    ) -> tuple[str, \"Renderable\", Point]:\n        \"\"\"\n        Emit PDF text operators:\n\n          BT\n            <font_id> <font_size> Tf\n            Tr <mode>               (map from GraphicsStyle->PathPaintRule)\n            1 0 0 1 x y Tm\n            (escaped-text) Tj\n          ET\n        \"\"\"\n        if not self.text_runs:\n            return \"\", last_item, initial_point\n\n        # Precise layout resolution with actual font metrics\n        layout: list[\n            tuple[float, float, float, TextRun, Union[\"CoreFont\", \"TTFFont\"]]\n        ] = []\n        pen_x = self.x\n        pen_y = self.y\n        min_x = pen_x\n        max_x = pen_x\n\n        for run in self.text_runs:\n            font = resource_registry.get_font_from_family(run.family, run.emphasis)\n            _, width = font.get_text_width(run.text, run.size, None)\n            if run.abs_x is not None:\n                pen_x = run.abs_x\n            if run.abs_y is not None:\n                pen_y = run.abs_y\n            pen_x += run.dx\n            pen_y += run.dy\n            min_x = min(min_x, pen_x)\n            max_x = max(max_x, pen_x + width)\n            layout.append((pen_x, pen_y, width, run, font))\n            pen_x += width\n\n        has_absolute = any(run.abs_x is not None for _, _, _, run, _ in layout)\n\n        if layout and not has_absolute:\n            if self.text_anchor == \"middle\":\n                anchor_offset = self.x - (min_x + max_x) / 2.0\n            elif self.text_anchor == \"end\":\n                anchor_offset = self.x - max_x\n            else:\n                anchor_offset = self.x - min_x\n        else:\n            anchor_offset = 0.0\n\n        ops: list[str] = []\n        NO_EMIT_SET = (None, GraphicsStyle.INHERIT)\n\n        for run_x, run_y, width, run, font in layout:\n            effective_style = (\n                GraphicsStyle.merge(style, run.run_style)\n                if run.run_style is not None\n                else style\n            )\n\n            # Determine text rendering mode\n            rule = effective_style.resolve_paint_rule()\n            if rule in (PathPaintRule.FILL_NONZERO, PathPaintRule.FILL_EVENODD):\n                tr = 0\n            elif rule is PathPaintRule.STROKE:\n                tr = 1\n            elif rule in (\n                PathPaintRule.STROKE_FILL_NONZERO,\n                PathPaintRule.STROKE_FILL_EVENODD,\n            ):\n                tr = 2\n            else:  # PathPaintRule.DONT_PAINT:\n                tr = 3\n\n            run_ops: list[str] = []\n\n            if run.run_style is not None:\n                merged_style = effective_style\n                style_dict_name = resource_registry.register_graphics_style(\n                    merged_style\n                )\n\n                if style_dict_name is not None:\n                    run_ops.append(f\"{render_pdf_primitive(style_dict_name)} gs\")\n\n                fill_color = merged_style.fill_color\n                stroke_color = merged_style.stroke_color\n\n                run_bbox = BoundingBox.from_points(\n                    [\n                        Point(run_x + anchor_offset, run_y - 0.8 * run.size),\n                        Point(run_x + anchor_offset + width, run_y + 0.2 * run.size),\n                    ]\n                )\n\n                if fill_color not in NO_EMIT_SET:\n                    if isinstance(fill_color, GradientPaint):\n                        run_ops.append(\n                            fill_color.emit_fill(resource_registry, run_bbox)\n                        )\n                    else:\n                        assert isinstance(\n                            fill_color, (DeviceCMYK, DeviceRGB, DeviceRGB)\n                        )\n                        run_ops.append(fill_color.serialize().lower())\n                if stroke_color not in NO_EMIT_SET:\n                    if isinstance(stroke_color, GradientPaint):\n                        run_ops.append(\n                            stroke_color.emit_stroke(resource_registry, run_bbox)\n                        )\n                    else:\n                        assert isinstance(\n                            stroke_color, (DeviceCMYK, DeviceRGB, DeviceRGB)\n                        )\n                        run_ops.append(stroke_color.serialize().upper())\n\n                dash_pattern = merged_style.stroke_dash_pattern\n                dash_phase = merged_style.stroke_dash_phase\n                assert isinstance(dash_phase, NumberClass)\n                if dash_pattern not in NO_EMIT_SET:\n                    run_ops.append(\n                        render_pdf_primitive(dash_pattern)\n                        + f\" {number_to_str(dash_phase)} d\"\n                    )\n\n            run_ops.extend(\n                [\n                    \"BT\",\n                    f\"/F{font.i} {number_to_str(run.size)} Tf\",\n                    f\"{number_to_str(tr)} Tr\",\n                    f\"1 0 0 -1 {number_to_str(run_x + anchor_offset)} {number_to_str(run_y)} Tm\",\n                    font.encode_text(run.text),\n                    \"ET\",\n                ]\n            )\n\n            if run.run_style is not None:\n                run_ops = [\"q\"] + run_ops + [\"Q\"]\n\n            ops.extend(run_ops)\n\n        return \" \".join(ops), last_item, initial_point",
      "language": "python"
    },
    {
      "code": "class Text(NamedTuple):\n    \"\"\"\n    SVG-like text renderable.\n    Stores the anchor position (x, y) and one or more TextRuns that include\n    relative positioning offsets. Accurate glyph positioning is resolved\n    during rendering once font metrics are available.\n    \"\"\"\n\n    x: float\n    y: float\n    text_runs: tuple[TextRun, ...]\n    text_anchor: str = \"start\"  # \"start\" | \"middle\" | \"end\"\n\n    @property\n    def end_point(self) -> Point:\n        raise NotImplementedError\n\n    def _approximate_layout(self) -> tuple[list[tuple[float, float, float]], float]:\n        \"\"\"\n        Produce an approximate layout for bounding-box estimation.\n\n        Returns:\n            A tuple of (per-run layout list, total width estimate).  Each layout\n            entry is (x, y, width) in user space.\n        \"\"\"\n        positions: list[tuple[float, float, float]] = []\n        pen_x = self.x\n        pen_y = self.y\n        max_right = pen_x\n        min_left = pen_x\n\n        for run in self.text_runs:\n            if run.abs_x is not None:\n                pen_x = run.abs_x\n            if run.abs_y is not None:\n                pen_y = run.abs_y\n            pen_x += run.dx\n            pen_y += run.dy\n            # Fallback width estimation: ~0.5em per glyph\n            approx_width = 0.5 * run.size * max(0, len(run.text))\n            positions.append((pen_x, pen_y, approx_width))\n            min_left = min(min_left, pen_x)\n            max_right = max(max_right, pen_x + approx_width)\n            pen_x += approx_width\n\n        total_width = max_right - min_left\n        return positions, total_width\n\n    def _anchor_offset(self, positions: list[tuple[float, float, float]]) -> float:\n        \"\"\"Compute anchor offset for the provided approximate layout.\"\"\"\n        if not positions:\n            return 0.0\n\n        if any(run.abs_x is not None for run in self.text_runs):\n            return 0.0\n\n        min_x = min(pos[0] for pos in positions)\n        max_x = max(pos[0] + pos[2] for pos in positions)\n\n        if self.text_anchor == \"middle\":\n            return self.x - (min_x + max_x) / 2.0\n        if self.text_anchor == \"end\":\n            return self.x - max_x\n        return self.x - min_x\n\n    def bounding_box(self, start: Point) -> tuple[\"BoundingBox\", Point]:\n        \"\"\"\n        Compute a conservative bbox for the text.\n\n        Font metrics are not available at this stage so the layout relies on\n        approximate glyph widths proportional to the run font size. The actual\n        layout is computed precisely in render().\n        \"\"\"\n        if not self.text_runs:\n            return BoundingBox.empty(), start\n\n        positions, _ = self._approximate_layout()\n        anchor_offset = self._anchor_offset(positions)\n\n        min_x = float(\"inf\")\n        max_x = float(\"-inf\")\n        min_y = float(\"inf\")\n        max_y = float(\"-inf\")\n\n        for (run_x, run_y, run_width), run in zip(positions, self.text_runs):\n            adj_x = run_x + anchor_offset\n            asc = 0.8 * run.size\n            desc = 0.2 * run.size\n            min_x = min(min_x, adj_x)\n            max_x = max(max_x, adj_x + run_width)\n            min_y = min(min_y, run_y - asc)\n            max_y = max(max_y, run_y + desc)\n\n        if min_x == float(\"inf\"):\n            return BoundingBox.empty(), start\n\n        x0 = min_x\n        x1 = max_x\n        y0 = min_y\n        y1 = max_y\n\n        return BoundingBox.from_points([Point(x0, y0), Point(x1, y1)]), start\n\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: \"GraphicsStyle\",\n        last_item: \"Renderable\",\n        initial_point: Point,\n    ) -> tuple[str, \"Renderable\", Point]:\n        \"\"\"\n        Emit PDF text operators:\n\n          BT\n            <font_id> <font_size> Tf\n            Tr <mode>               (map from GraphicsStyle->PathPaintRule)\n            1 0 0 1 x y Tm\n            (escaped-text) Tj\n          ET\n        \"\"\"\n        if not self.text_runs:\n            return \"\", last_item, initial_point\n\n        # Precise layout resolution with actual font metrics\n        layout: list[\n            tuple[float, float, float, TextRun, Union[\"CoreFont\", \"TTFFont\"]]\n        ] = []\n        pen_x = self.x\n        pen_y = self.y\n        min_x = pen_x\n        max_x = pen_x\n\n        for run in self.text_runs:\n            font = resource_registry.get_font_from_family(run.family, run.emphasis)\n            _, width = font.get_text_width(run.text, run.size, None)\n            if run.abs_x is not None:\n                pen_x = run.abs_x\n            if run.abs_y is not None:\n                pen_y = run.abs_y\n            pen_x += run.dx\n            pen_y += run.dy\n            min_x = min(min_x, pen_x)\n            max_x = max(max_x, pen_x + width)\n            layout.append((pen_x, pen_y, width, run, font))\n            pen_x += width\n\n        has_absolute = any(run.abs_x is not None for _, _, _, run, _ in layout)\n\n        if layout and not has_absolute:\n            if self.text_anchor == \"middle\":\n                anchor_offset = self.x - (min_x + max_x) / 2.0\n            elif self.text_anchor == \"end\":\n                anchor_offset = self.x - max_x\n            else:\n                anchor_offset = self.x - min_x\n        else:\n            anchor_offset = 0.0\n\n        ops: list[str] = []\n        NO_EMIT_SET = (None, GraphicsStyle.INHERIT)\n\n        for run_x, run_y, width, run, font in layout:\n            effective_style = (\n                GraphicsStyle.merge(style, run.run_style)\n                if run.run_style is not None\n                else style\n            )\n\n            # Determine text rendering mode\n            rule = effective_style.resolve_paint_rule()\n            if rule in (PathPaintRule.FILL_NONZERO, PathPaintRule.FILL_EVENODD):\n                tr = 0\n            elif rule is PathPaintRule.STROKE:\n                tr = 1\n            elif rule in (\n                PathPaintRule.STROKE_FILL_NONZERO,\n                PathPaintRule.STROKE_FILL_EVENODD,\n            ):\n                tr = 2\n            else:  # PathPaintRule.DONT_PAINT:\n                tr = 3\n\n            run_ops: list[str] = []\n\n            if run.run_style is not None:\n                merged_style = effective_style\n                style_dict_name = resource_registry.register_graphics_style(\n                    merged_style\n                )\n\n                if style_dict_name is not None:\n                    run_ops.append(f\"{render_pdf_primitive(style_dict_name)} gs\")\n\n                fill_color = merged_style.fill_color\n                stroke_color = merged_style.stroke_color\n\n                run_bbox = BoundingBox.from_points(\n                    [\n                        Point(run_x + anchor_offset, run_y - 0.8 * run.size),\n                        Point(run_x + anchor_offset + width, run_y + 0.2 * run.size),\n                    ]\n                )\n\n                if fill_color not in NO_EMIT_SET:\n                    if isinstance(fill_color, GradientPaint):\n                        run_ops.append(\n                            fill_color.emit_fill(resource_registry, run_bbox)\n                        )\n                    else:\n                        assert isinstance(\n                            fill_color, (DeviceCMYK, DeviceRGB, DeviceRGB)\n                        )\n                        run_ops.append(fill_color.serialize().lower())\n                if stroke_color not in NO_EMIT_SET:\n                    if isinstance(stroke_color, GradientPaint):\n                        run_ops.append(\n                            stroke_color.emit_stroke(resource_registry, run_bbox)\n                        )\n                    else:\n                        assert isinstance(\n                            stroke_color, (DeviceCMYK, DeviceRGB, DeviceRGB)\n                        )\n                        run_ops.append(stroke_color.serialize().upper())\n\n                dash_pattern = merged_style.stroke_dash_pattern\n                dash_phase = merged_style.stroke_dash_phase\n                assert isinstance(dash_phase, NumberClass)\n                if dash_pattern not in NO_EMIT_SET:\n                    run_ops.append(\n                        render_pdf_primitive(dash_pattern)\n                        + f\" {number_to_str(dash_phase)} d\"\n                    )\n\n            run_ops.extend(\n                [\n                    \"BT\",\n                    f\"/F{font.i} {number_to_str(run.size)} Tf\",\n                    f\"{number_to_str(tr)} Tr\",\n                    f\"1 0 0 -1 {number_to_str(run_x + anchor_offset)} {number_to_str(run_y)} Tm\",\n                    font.encode_text(run.text),\n                    \"ET\",\n                ]\n            )\n\n            if run.run_style is not None:\n                run_ops = [\"q\"] + run_ops + [\"Q\"]\n\n            ops.extend(run_ops)\n\n        return \" \".join(ops), last_item, initial_point",
      "language": "python"
    },
    {
      "code": "def bounding_box(self, start: Point) -> tuple[\"BoundingBox\", Point]:\n    \"\"\"\n    Compute a conservative bbox for the text.\n\n    Font metrics are not available at this stage so the layout relies on\n    approximate glyph widths proportional to the run font size. The actual\n    layout is computed precisely in render().\n    \"\"\"\n    if not self.text_runs:\n        return BoundingBox.empty(), start\n\n    positions, _ = self._approximate_layout()\n    anchor_offset = self._anchor_offset(positions)\n\n    min_x = float(\"inf\")\n    max_x = float(\"-inf\")\n    min_y = float(\"inf\")\n    max_y = float(\"-inf\")\n\n    for (run_x, run_y, run_width), run in zip(positions, self.text_runs):\n        adj_x = run_x + anchor_offset\n        asc = 0.8 * run.size\n        desc = 0.2 * run.size\n        min_x = min(min_x, adj_x)\n        max_x = max(max_x, adj_x + run_width)\n        min_y = min(min_y, run_y - asc)\n        max_y = max(max_y, run_y + desc)\n\n    if min_x == float(\"inf\"):\n        return BoundingBox.empty(), start\n\n    x0 = min_x\n    x1 = max_x\n    y0 = min_y\n    y1 = max_y\n\n    return BoundingBox.from_points([Point(x0, y0), Point(x1, y1)]), start",
      "language": "python"
    },
    {
      "code": "@force_nodocument\ndef render(\n    self,\n    resource_registry: \"ResourceCatalog\",\n    style: \"GraphicsStyle\",\n    last_item: \"Renderable\",\n    initial_point: Point,\n) -> tuple[str, \"Renderable\", Point]:\n    \"\"\"\n    Emit PDF text operators:\n\n      BT\n        <font_id> <font_size> Tf\n        Tr <mode>               (map from GraphicsStyle->PathPaintRule)\n        1 0 0 1 x y Tm\n        (escaped-text) Tj\n      ET\n    \"\"\"\n    if not self.text_runs:\n        return \"\", last_item, initial_point\n\n    # Precise layout resolution with actual font metrics\n    layout: list[\n        tuple[float, float, float, TextRun, Union[\"CoreFont\", \"TTFFont\"]]\n    ] = []\n    pen_x = self.x\n    pen_y = self.y\n    min_x = pen_x\n    max_x = pen_x\n\n    for run in self.text_runs:\n        font = resource_registry.get_font_from_family(run.family, run.emphasis)\n        _, width = font.get_text_width(run.text, run.size, None)\n        if run.abs_x is not None:\n            pen_x = run.abs_x\n        if run.abs_y is not None:\n            pen_y = run.abs_y\n        pen_x += run.dx\n        pen_y += run.dy\n        min_x = min(min_x, pen_x)\n        max_x = max(max_x, pen_x + width)\n        layout.append((pen_x, pen_y, width, run, font))\n        pen_x += width\n\n    has_absolute = any(run.abs_x is not None for _, _, _, run, _ in layout)\n\n    if layout and not has_absolute:\n        if self.text_anchor == \"middle\":\n            anchor_offset = self.x - (min_x + max_x) / 2.0\n        elif self.text_anchor == \"end\":\n            anchor_offset = self.x - max_x\n        else:\n            anchor_offset = self.x - min_x\n    else:\n        anchor_offset = 0.0\n\n    ops: list[str] = []\n    NO_EMIT_SET = (None, GraphicsStyle.INHERIT)\n\n    for run_x, run_y, width, run, font in layout:\n        effective_style = (\n            GraphicsStyle.merge(style, run.run_style)\n            if run.run_style is not None\n            else style\n        )\n\n        # Determine text rendering mode\n        rule = effective_style.resolve_paint_rule()\n        if rule in (PathPaintRule.FILL_NONZERO, PathPaintRule.FILL_EVENODD):\n            tr = 0\n        elif rule is PathPaintRule.STROKE:\n            tr = 1\n        elif rule in (\n            PathPaintRule.STROKE_FILL_NONZERO,\n            PathPaintRule.STROKE_FILL_EVENODD,\n        ):\n            tr = 2\n        else:  # PathPaintRule.DONT_PAINT:\n            tr = 3\n\n        run_ops: list[str] = []\n\n        if run.run_style is not None:\n            merged_style = effective_style\n            style_dict_name = resource_registry.register_graphics_style(\n                merged_style\n            )\n\n            if style_dict_name is not None:\n                run_ops.append(f\"{render_pdf_primitive(style_dict_name)} gs\")\n\n            fill_color = merged_style.fill_color\n            stroke_color = merged_style.stroke_color\n\n            run_bbox = BoundingBox.from_points(\n                [\n                    Point(run_x + anchor_offset, run_y - 0.8 * run.size),\n                    Point(run_x + anchor_offset + width, run_y + 0.2 * run.size),\n                ]\n            )\n\n            if fill_color not in NO_EMIT_SET:\n                if isinstance(fill_color, GradientPaint):\n                    run_ops.append(\n                        fill_color.emit_fill(resource_registry, run_bbox)\n                    )\n                else:\n                    assert isinstance(\n                        fill_color, (DeviceCMYK, DeviceRGB, DeviceRGB)\n                    )\n                    run_ops.append(fill_color.serialize().lower())\n            if stroke_color not in NO_EMIT_SET:\n                if isinstance(stroke_color, GradientPaint):\n                    run_ops.append(\n                        stroke_color.emit_stroke(resource_registry, run_bbox)\n                    )\n                else:\n                    assert isinstance(\n                        stroke_color, (DeviceCMYK, DeviceRGB, DeviceRGB)\n                    )\n                    run_ops.append(stroke_color.serialize().upper())\n\n            dash_pattern = merged_style.stroke_dash_pattern\n            dash_phase = merged_style.stroke_dash_phase\n            assert isinstance(dash_phase, NumberClass)\n            if dash_pattern not in NO_EMIT_SET:\n                run_ops.append(\n                    render_pdf_primitive(dash_pattern)\n                    + f\" {number_to_str(dash_phase)} d\"\n                )\n\n        run_ops.extend(\n            [\n                \"BT\",\n                f\"/F{font.i} {number_to_str(run.size)} Tf\",\n                f\"{number_to_str(tr)} Tr\",\n                f\"1 0 0 -1 {number_to_str(run_x + anchor_offset)} {number_to_str(run_y)} Tm\",\n                font.encode_text(run.text),\n                \"ET\",\n            ]\n        )\n\n        if run.run_style is not None:\n            run_ops = [\"q\"] + run_ops + [\"Q\"]\n\n        ops.extend(run_ops)\n\n    return \" \".join(ops), last_item, initial_point",
      "language": "python"
    },
    {
      "code": "class TextRun(NamedTuple):\n    text: str\n    family: str\n    emphasis: str\n    size: float\n    dx: float = 0.0\n    dy: float = 0.0\n    abs_x: Optional[float] = None\n    abs_y: Optional[float] = None\n    transform: Optional[Transform] = None\n    run_style: Optional[GraphicsStyle] = None",
      "language": "python"
    },
    {
      "code": "class TextRun(NamedTuple):\n    text: str\n    family: str\n    emphasis: str\n    size: float\n    dx: float = 0.0\n    dy: float = 0.0\n    abs_x: Optional[float] = None\n    abs_y: Optional[float] = None\n    transform: Optional[Transform] = None\n    run_style: Optional[GraphicsStyle] = None",
      "language": "python"
    },
    {
      "code": "class TextRun(NamedTuple):\n    text: str\n    family: str\n    emphasis: str\n    size: float\n    dx: float = 0.0\n    dy: float = 0.0\n    abs_x: Optional[float] = None\n    abs_y: Optional[float] = None\n    transform: Optional[Transform] = None\n    run_style: Optional[GraphicsStyle] = None",
      "language": "python"
    },
    {
      "code": "class TextRun(NamedTuple):\n    text: str\n    family: str\n    emphasis: str\n    size: float\n    dx: float = 0.0\n    dy: float = 0.0\n    abs_x: Optional[float] = None\n    abs_y: Optional[float] = None\n    transform: Optional[Transform] = None\n    run_style: Optional[GraphicsStyle] = None",
      "language": "python"
    },
    {
      "code": "class TextRun(NamedTuple):\n    text: str\n    family: str\n    emphasis: str\n    size: float\n    dx: float = 0.0\n    dy: float = 0.0\n    abs_x: Optional[float] = None\n    abs_y: Optional[float] = None\n    transform: Optional[Transform] = None\n    run_style: Optional[GraphicsStyle] = None",
      "language": "python"
    },
    {
      "code": "class TextRun(NamedTuple):\n    text: str\n    family: str\n    emphasis: str\n    size: float\n    dx: float = 0.0\n    dy: float = 0.0\n    abs_x: Optional[float] = None\n    abs_y: Optional[float] = None\n    transform: Optional[Transform] = None\n    run_style: Optional[GraphicsStyle] = None",
      "language": "python"
    },
    {
      "code": "class TextRun(NamedTuple):\n    text: str\n    family: str\n    emphasis: str\n    size: float\n    dx: float = 0.0\n    dy: float = 0.0\n    abs_x: Optional[float] = None\n    abs_y: Optional[float] = None\n    transform: Optional[Transform] = None\n    run_style: Optional[GraphicsStyle] = None",
      "language": "python"
    },
    {
      "code": "class TextRun(NamedTuple):\n    text: str\n    family: str\n    emphasis: str\n    size: float\n    dx: float = 0.0\n    dy: float = 0.0\n    abs_x: Optional[float] = None\n    abs_y: Optional[float] = None\n    transform: Optional[Transform] = None\n    run_style: Optional[GraphicsStyle] = None",
      "language": "python"
    },
    {
      "code": "class TextRun(NamedTuple):\n    text: str\n    family: str\n    emphasis: str\n    size: float\n    dx: float = 0.0\n    dy: float = 0.0\n    abs_x: Optional[float] = None\n    abs_y: Optional[float] = None\n    transform: Optional[Transform] = None\n    run_style: Optional[GraphicsStyle] = None",
      "language": "python"
    },
    {
      "code": "class TextRun(NamedTuple):\n    text: str\n    family: str\n    emphasis: str\n    size: float\n    dx: float = 0.0\n    dy: float = 0.0\n    abs_x: Optional[float] = None\n    abs_y: Optional[float] = None\n    transform: Optional[Transform] = None\n    run_style: Optional[GraphicsStyle] = None",
      "language": "python"
    },
    {
      "code": "class TextRun(NamedTuple):\n    text: str\n    family: str\n    emphasis: str\n    size: float\n    dx: float = 0.0\n    dy: float = 0.0\n    abs_x: Optional[float] = None\n    abs_y: Optional[float] = None\n    transform: Optional[Transform] = None\n    run_style: Optional[GraphicsStyle] = None",
      "language": "python"
    },
    {
      "code": "class VerticalLine(NamedTuple):\n    \"\"\"\n    A path line element that takes its abscissa from the end of the previous element.\n\n    See: `PaintedPath.vertical_line_to`\n    \"\"\"\n\n    y: Number\n    \"\"\"The ordinate of the vertical line's end point.\"\"\"\n\n    @property\n    def end_point(self) -> Point:\n        raise NotImplementedError\n\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        \"\"\"Compute the bounding box of this vertical line.\"\"\"\n        end = Point(start.x, float(self.y))\n        bbox = BoundingBox.from_points([start, end])\n        return bbox, end\n\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        \"\"\"\n        Render this path element to its PDF representation.\n\n        Args:\n            resource_registry (ResourceCatalog): the owner's graphics state\n                dictionary registry.\n            style (GraphicsStyle): the current resolved graphics style\n            last_item: the previous path element.\n            initial_point: last position set by a \"M\" or \"m\" command\n\n        Returns:\n            a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved\n            `Line`.\n        \"\"\"\n        # pylint: disable=unused-argument\n        end_point = Point(x=last_item.end_point.x, y=float(self.y))\n        return _render_line(end_point), Line(end_point), initial_point",
      "language": "python"
    },
    {
      "code": "@property\ndef end_point(self) -> Point:\n    raise NotImplementedError",
      "language": "python"
    },
    {
      "code": "class VerticalLine(NamedTuple):\n    \"\"\"\n    A path line element that takes its abscissa from the end of the previous element.\n\n    See: `PaintedPath.vertical_line_to`\n    \"\"\"\n\n    y: Number\n    \"\"\"The ordinate of the vertical line's end point.\"\"\"\n\n    @property\n    def end_point(self) -> Point:\n        raise NotImplementedError\n\n    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n        \"\"\"Compute the bounding box of this vertical line.\"\"\"\n        end = Point(start.x, float(self.y))\n        bbox = BoundingBox.from_points([start, end])\n        return bbox, end\n\n    @force_nodocument\n    def render(\n        self,\n        resource_registry: \"ResourceCatalog\",\n        style: GraphicsStyle,\n        last_item: Renderable,\n        initial_point: Point,\n    ) -> tuple[str, Renderable, Point]:\n        \"\"\"\n        Render this path element to its PDF representation.\n\n        Args:\n            resource_registry (ResourceCatalog): the owner's graphics state\n                dictionary registry.\n            style (GraphicsStyle): the current resolved graphics style\n            last_item: the previous path element.\n            initial_point: last position set by a \"M\" or \"m\" command\n\n        Returns:\n            a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved\n            `Line`.\n        \"\"\"\n        # pylint: disable=unused-argument\n        end_point = Point(x=last_item.end_point.x, y=float(self.y))\n        return _render_line(end_point), Line(end_point), initial_point",
      "language": "python"
    },
    {
      "code": "def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:\n    \"\"\"Compute the bounding box of this vertical line.\"\"\"\n    end = Point(start.x, float(self.y))\n    bbox = BoundingBox.from_points([start, end])\n    return bbox, end",
      "language": "python"
    },
    {
      "code": "@force_nodocument\ndef render(\n    self,\n    resource_registry: \"ResourceCatalog\",\n    style: GraphicsStyle,\n    last_item: Renderable,\n    initial_point: Point,\n) -> tuple[str, Renderable, Point]:\n    \"\"\"\n    Render this path element to its PDF representation.\n\n    Args:\n        resource_registry (ResourceCatalog): the owner's graphics state\n            dictionary registry.\n        style (GraphicsStyle): the current resolved graphics style\n        last_item: the previous path element.\n        initial_point: last position set by a \"M\" or \"m\" command\n\n    Returns:\n        a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved\n        `Line`.\n    \"\"\"\n    # pylint: disable=unused-argument\n    end_point = Point(x=last_item.end_point.x, y=float(self.y))\n    return _render_line(end_point), Line(end_point), initial_point",
      "language": "python"
    }
  ],
  "patterns": [],
  "links": [
    "https://py-pdf.github.io/fpdf2/Drawing.html",
    "https://py-pdf.github.io/fpdf2/fpdf/drawing.html",
    "https://py-pdf.github.io/fpdf2/fpdf/drawing_primitives.html",
    "https://py-pdf.github.io/fpdf2/fpdf/syntax.html",
    "https://py-pdf.github.io/fpdf2/fpdf/enums.html",
    "https://py-pdf.github.io/fpdf2/fpdf/index.html"
  ]
}