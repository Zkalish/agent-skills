{
  "url": "https://py-pdf.github.io/fpdf2/fpdf/outline.html",
  "title": "Module fpdf.outline",
  "content": "Quoting section 8.2.2 \"Document Outline\" of the 2006 PDF spec 1.7:\n\nThe document outline consists of a tree-structured hierarchy of outline items (sometimes called bookmarks), which serve as a visual table of contents to display the documentâ€™s structure to the user.\n\nThe contents of this module are internal to fpdf2, and not part of the public API. They may change at any time without prior warning or any deprecation period, in non-backward-compatible ways.\n\nUsage documentation at: https://py-pdf.github.io/fpdf2/DocumentOutlineAndTableOfContents.html\n\nBuild PDF objects constitutive of the documents outline, and yield them one by one, starting with the outline dictionary\n\nInherited from: PDFObject.content_stream\n\nSubclasses can override this method to indicate the presence of a content stream\n\nInherited from: PDFObject.serialize\n\nSerialize the PDF object as an obj<</>>endobj text block\n\nInherited from: PDFObject.content_stream\n\nSubclasses can override this method to indicate the presence of a content stream\n\nInherited from: PDFObject.serialize\n\nSerialize the PDF object as an obj<</>>endobj text block\n\nOutlineSection(name: str, level: int, page_number: int, dest: fpdf.syntax.DestinationXYZ, struct_elem: fpdf.structure_tree.StructElem | None = None)\n\nA reference implementation of a Table of Contents (ToC) for use with fpdf2.\n\nThis class provides a customizable Table of Contents that can be used directly or subclassed for additional functionality. To use this class, create an instance of TableOfContents, configure it as needed, and pass its render_toc method as the render_toc_function argument to FPDF.insert_toc_placeholder().\n\nThis method can be overridden by subclasses to customize the Table of Contents style.",
  "headings": [
    {
      "level": "h1",
      "text": "Module fpdf.outline",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Functions",
      "id": "header-functions"
    },
    {
      "level": "h2",
      "text": "Classes",
      "id": "header-classes"
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    }
  ],
  "code_samples": [
    {
      "code": "def build_outline_objs(\n    sections: Sequence[OutlineSection],\n) -> Iterator[OutlineDictionary | OutlineItemDictionary]:\n    \"\"\"\n    Build PDF objects constitutive of the documents outline,\n    and yield them one by one, starting with the outline dictionary\n    \"\"\"\n    outline = OutlineDictionary()\n    yield outline\n\n    outline_items: list[OutlineItemDictionary] = []\n    last_outline_item_per_level: dict[int, OutlineItemDictionary] = {}\n    parent_outline_item: OutlineDictionary | OutlineItemDictionary\n\n    for section in sections:\n        outline_item = OutlineItemDictionary(\n            title=section.name,\n            dest=section.dest,\n            struct_elem=section.struct_elem,\n        )\n        yield outline_item\n\n        if section.level in last_outline_item_per_level:\n            last_outline_item_at_level = last_outline_item_per_level[section.level]\n            last_outline_item_at_level.next = outline_item\n            outline_item.prev = last_outline_item_at_level\n\n        if section.level - 1 in last_outline_item_per_level:\n            parent_outline_item = last_outline_item_per_level[section.level - 1]\n        else:\n            parent_outline_item = outline\n\n        outline_item.parent = parent_outline_item\n        if parent_outline_item.first is None:\n            parent_outline_item.first = (  # pyright: ignore[reportAttributeAccessIssue]\n                outline_item\n            )\n        parent_outline_item.last = (  # pyright: ignore[reportAttributeAccessIssue]\n            outline_item\n        )\n        parent_outline_item.count += 1\n\n        outline_items.append(outline_item)\n        last_outline_item_per_level[section.level] = outline_item\n        last_outline_item_per_level = {\n            level: oitem\n            for level, oitem in last_outline_item_per_level.items()\n            if level <= section.level\n        }",
      "language": "python"
    },
    {
      "code": "class OutlineDictionary(PDFObject):\n    __slots__ = (\"_id\", \"type\", \"first\", \"last\", \"count\")  # RAM usage optimization\n\n    def __init__(self, **kwargs: Any) -> None:\n        super().__init__(**kwargs)\n        self.type = \"/Outlines\"\n        self.first = None\n        self.last = None\n        self.count = 0\n\n    def __str__(self) -> str:\n        return f\"OutlineDictionary(count={self.count})\"",
      "language": "python"
    },
    {
      "code": "class OutlineDictionary(PDFObject):\n    __slots__ = (\"_id\", \"type\", \"first\", \"last\", \"count\")  # RAM usage optimization\n\n    def __init__(self, **kwargs: Any) -> None:\n        super().__init__(**kwargs)\n        self.type = \"/Outlines\"\n        self.first = None\n        self.last = None\n        self.count = 0\n\n    def __str__(self) -> str:\n        return f\"OutlineDictionary(count={self.count})\"",
      "language": "python"
    },
    {
      "code": "class OutlineDictionary(PDFObject):\n    __slots__ = (\"_id\", \"type\", \"first\", \"last\", \"count\")  # RAM usage optimization\n\n    def __init__(self, **kwargs: Any) -> None:\n        super().__init__(**kwargs)\n        self.type = \"/Outlines\"\n        self.first = None\n        self.last = None\n        self.count = 0\n\n    def __str__(self) -> str:\n        return f\"OutlineDictionary(count={self.count})\"",
      "language": "python"
    },
    {
      "code": "class OutlineDictionary(PDFObject):\n    __slots__ = (\"_id\", \"type\", \"first\", \"last\", \"count\")  # RAM usage optimization\n\n    def __init__(self, **kwargs: Any) -> None:\n        super().__init__(**kwargs)\n        self.type = \"/Outlines\"\n        self.first = None\n        self.last = None\n        self.count = 0\n\n    def __str__(self) -> str:\n        return f\"OutlineDictionary(count={self.count})\"",
      "language": "python"
    },
    {
      "code": "class OutlineDictionary(PDFObject):\n    __slots__ = (\"_id\", \"type\", \"first\", \"last\", \"count\")  # RAM usage optimization\n\n    def __init__(self, **kwargs: Any) -> None:\n        super().__init__(**kwargs)\n        self.type = \"/Outlines\"\n        self.first = None\n        self.last = None\n        self.count = 0\n\n    def __str__(self) -> str:\n        return f\"OutlineDictionary(count={self.count})\"",
      "language": "python"
    },
    {
      "code": "class OutlineItemDictionary(PDFObject):\n    __slots__ = (  # RAM usage optimization\n        \"_id\",\n        \"title\",\n        \"parent\",\n        \"prev\",\n        \"next\",\n        \"first\",\n        \"last\",\n        \"count\",\n        \"dest\",\n        \"struct_elem\",\n    )\n\n    def __init__(\n        self,\n        title: str,\n        dest: Optional[DestinationXYZ] = None,\n        struct_elem: Optional[StructElem] = None,\n    ) -> None:\n        super().__init__()\n        self.title = PDFString(title, encrypt=True)\n        self.parent: Optional[OutlineDictionary | OutlineItemDictionary] = None\n        self.prev: Optional[OutlineItemDictionary] = None\n        self.next: Optional[OutlineItemDictionary] = None\n        self.first: Optional[OutlineItemDictionary] = None\n        self.last: Optional[OutlineItemDictionary] = None\n        self.count: int = 0\n        self.dest: Optional[DestinationXYZ] = dest\n        self.struct_elem: Optional[StructElem] = struct_elem\n\n    def __str__(self) -> str:\n        return f\"OutlineItemDictionary(title={self.title}, dest={self.dest})\"",
      "language": "python"
    },
    {
      "code": "class OutlineItemDictionary(PDFObject):\n    __slots__ = (  # RAM usage optimization\n        \"_id\",\n        \"title\",\n        \"parent\",\n        \"prev\",\n        \"next\",\n        \"first\",\n        \"last\",\n        \"count\",\n        \"dest\",\n        \"struct_elem\",\n    )\n\n    def __init__(\n        self,\n        title: str,\n        dest: Optional[DestinationXYZ] = None,\n        struct_elem: Optional[StructElem] = None,\n    ) -> None:\n        super().__init__()\n        self.title = PDFString(title, encrypt=True)\n        self.parent: Optional[OutlineDictionary | OutlineItemDictionary] = None\n        self.prev: Optional[OutlineItemDictionary] = None\n        self.next: Optional[OutlineItemDictionary] = None\n        self.first: Optional[OutlineItemDictionary] = None\n        self.last: Optional[OutlineItemDictionary] = None\n        self.count: int = 0\n        self.dest: Optional[DestinationXYZ] = dest\n        self.struct_elem: Optional[StructElem] = struct_elem\n\n    def __str__(self) -> str:\n        return f\"OutlineItemDictionary(title={self.title}, dest={self.dest})\"",
      "language": "python"
    },
    {
      "code": "class OutlineItemDictionary(PDFObject):\n    __slots__ = (  # RAM usage optimization\n        \"_id\",\n        \"title\",\n        \"parent\",\n        \"prev\",\n        \"next\",\n        \"first\",\n        \"last\",\n        \"count\",\n        \"dest\",\n        \"struct_elem\",\n    )\n\n    def __init__(\n        self,\n        title: str,\n        dest: Optional[DestinationXYZ] = None,\n        struct_elem: Optional[StructElem] = None,\n    ) -> None:\n        super().__init__()\n        self.title = PDFString(title, encrypt=True)\n        self.parent: Optional[OutlineDictionary | OutlineItemDictionary] = None\n        self.prev: Optional[OutlineItemDictionary] = None\n        self.next: Optional[OutlineItemDictionary] = None\n        self.first: Optional[OutlineItemDictionary] = None\n        self.last: Optional[OutlineItemDictionary] = None\n        self.count: int = 0\n        self.dest: Optional[DestinationXYZ] = dest\n        self.struct_elem: Optional[StructElem] = struct_elem\n\n    def __str__(self) -> str:\n        return f\"OutlineItemDictionary(title={self.title}, dest={self.dest})\"",
      "language": "python"
    },
    {
      "code": "class OutlineItemDictionary(PDFObject):\n    __slots__ = (  # RAM usage optimization\n        \"_id\",\n        \"title\",\n        \"parent\",\n        \"prev\",\n        \"next\",\n        \"first\",\n        \"last\",\n        \"count\",\n        \"dest\",\n        \"struct_elem\",\n    )\n\n    def __init__(\n        self,\n        title: str,\n        dest: Optional[DestinationXYZ] = None,\n        struct_elem: Optional[StructElem] = None,\n    ) -> None:\n        super().__init__()\n        self.title = PDFString(title, encrypt=True)\n        self.parent: Optional[OutlineDictionary | OutlineItemDictionary] = None\n        self.prev: Optional[OutlineItemDictionary] = None\n        self.next: Optional[OutlineItemDictionary] = None\n        self.first: Optional[OutlineItemDictionary] = None\n        self.last: Optional[OutlineItemDictionary] = None\n        self.count: int = 0\n        self.dest: Optional[DestinationXYZ] = dest\n        self.struct_elem: Optional[StructElem] = struct_elem\n\n    def __str__(self) -> str:\n        return f\"OutlineItemDictionary(title={self.title}, dest={self.dest})\"",
      "language": "python"
    },
    {
      "code": "class OutlineItemDictionary(PDFObject):\n    __slots__ = (  # RAM usage optimization\n        \"_id\",\n        \"title\",\n        \"parent\",\n        \"prev\",\n        \"next\",\n        \"first\",\n        \"last\",\n        \"count\",\n        \"dest\",\n        \"struct_elem\",\n    )\n\n    def __init__(\n        self,\n        title: str,\n        dest: Optional[DestinationXYZ] = None,\n        struct_elem: Optional[StructElem] = None,\n    ) -> None:\n        super().__init__()\n        self.title = PDFString(title, encrypt=True)\n        self.parent: Optional[OutlineDictionary | OutlineItemDictionary] = None\n        self.prev: Optional[OutlineItemDictionary] = None\n        self.next: Optional[OutlineItemDictionary] = None\n        self.first: Optional[OutlineItemDictionary] = None\n        self.last: Optional[OutlineItemDictionary] = None\n        self.count: int = 0\n        self.dest: Optional[DestinationXYZ] = dest\n        self.struct_elem: Optional[StructElem] = struct_elem\n\n    def __str__(self) -> str:\n        return f\"OutlineItemDictionary(title={self.title}, dest={self.dest})\"",
      "language": "python"
    },
    {
      "code": "class OutlineItemDictionary(PDFObject):\n    __slots__ = (  # RAM usage optimization\n        \"_id\",\n        \"title\",\n        \"parent\",\n        \"prev\",\n        \"next\",\n        \"first\",\n        \"last\",\n        \"count\",\n        \"dest\",\n        \"struct_elem\",\n    )\n\n    def __init__(\n        self,\n        title: str,\n        dest: Optional[DestinationXYZ] = None,\n        struct_elem: Optional[StructElem] = None,\n    ) -> None:\n        super().__init__()\n        self.title = PDFString(title, encrypt=True)\n        self.parent: Optional[OutlineDictionary | OutlineItemDictionary] = None\n        self.prev: Optional[OutlineItemDictionary] = None\n        self.next: Optional[OutlineItemDictionary] = None\n        self.first: Optional[OutlineItemDictionary] = None\n        self.last: Optional[OutlineItemDictionary] = None\n        self.count: int = 0\n        self.dest: Optional[DestinationXYZ] = dest\n        self.struct_elem: Optional[StructElem] = struct_elem\n\n    def __str__(self) -> str:\n        return f\"OutlineItemDictionary(title={self.title}, dest={self.dest})\"",
      "language": "python"
    },
    {
      "code": "class OutlineItemDictionary(PDFObject):\n    __slots__ = (  # RAM usage optimization\n        \"_id\",\n        \"title\",\n        \"parent\",\n        \"prev\",\n        \"next\",\n        \"first\",\n        \"last\",\n        \"count\",\n        \"dest\",\n        \"struct_elem\",\n    )\n\n    def __init__(\n        self,\n        title: str,\n        dest: Optional[DestinationXYZ] = None,\n        struct_elem: Optional[StructElem] = None,\n    ) -> None:\n        super().__init__()\n        self.title = PDFString(title, encrypt=True)\n        self.parent: Optional[OutlineDictionary | OutlineItemDictionary] = None\n        self.prev: Optional[OutlineItemDictionary] = None\n        self.next: Optional[OutlineItemDictionary] = None\n        self.first: Optional[OutlineItemDictionary] = None\n        self.last: Optional[OutlineItemDictionary] = None\n        self.count: int = 0\n        self.dest: Optional[DestinationXYZ] = dest\n        self.struct_elem: Optional[StructElem] = struct_elem\n\n    def __str__(self) -> str:\n        return f\"OutlineItemDictionary(title={self.title}, dest={self.dest})\"",
      "language": "python"
    },
    {
      "code": "class OutlineItemDictionary(PDFObject):\n    __slots__ = (  # RAM usage optimization\n        \"_id\",\n        \"title\",\n        \"parent\",\n        \"prev\",\n        \"next\",\n        \"first\",\n        \"last\",\n        \"count\",\n        \"dest\",\n        \"struct_elem\",\n    )\n\n    def __init__(\n        self,\n        title: str,\n        dest: Optional[DestinationXYZ] = None,\n        struct_elem: Optional[StructElem] = None,\n    ) -> None:\n        super().__init__()\n        self.title = PDFString(title, encrypt=True)\n        self.parent: Optional[OutlineDictionary | OutlineItemDictionary] = None\n        self.prev: Optional[OutlineItemDictionary] = None\n        self.next: Optional[OutlineItemDictionary] = None\n        self.first: Optional[OutlineItemDictionary] = None\n        self.last: Optional[OutlineItemDictionary] = None\n        self.count: int = 0\n        self.dest: Optional[DestinationXYZ] = dest\n        self.struct_elem: Optional[StructElem] = struct_elem\n\n    def __str__(self) -> str:\n        return f\"OutlineItemDictionary(title={self.title}, dest={self.dest})\"",
      "language": "python"
    },
    {
      "code": "class OutlineItemDictionary(PDFObject):\n    __slots__ = (  # RAM usage optimization\n        \"_id\",\n        \"title\",\n        \"parent\",\n        \"prev\",\n        \"next\",\n        \"first\",\n        \"last\",\n        \"count\",\n        \"dest\",\n        \"struct_elem\",\n    )\n\n    def __init__(\n        self,\n        title: str,\n        dest: Optional[DestinationXYZ] = None,\n        struct_elem: Optional[StructElem] = None,\n    ) -> None:\n        super().__init__()\n        self.title = PDFString(title, encrypt=True)\n        self.parent: Optional[OutlineDictionary | OutlineItemDictionary] = None\n        self.prev: Optional[OutlineItemDictionary] = None\n        self.next: Optional[OutlineItemDictionary] = None\n        self.first: Optional[OutlineItemDictionary] = None\n        self.last: Optional[OutlineItemDictionary] = None\n        self.count: int = 0\n        self.dest: Optional[DestinationXYZ] = dest\n        self.struct_elem: Optional[StructElem] = struct_elem\n\n    def __str__(self) -> str:\n        return f\"OutlineItemDictionary(title={self.title}, dest={self.dest})\"",
      "language": "python"
    },
    {
      "code": "class OutlineItemDictionary(PDFObject):\n    __slots__ = (  # RAM usage optimization\n        \"_id\",\n        \"title\",\n        \"parent\",\n        \"prev\",\n        \"next\",\n        \"first\",\n        \"last\",\n        \"count\",\n        \"dest\",\n        \"struct_elem\",\n    )\n\n    def __init__(\n        self,\n        title: str,\n        dest: Optional[DestinationXYZ] = None,\n        struct_elem: Optional[StructElem] = None,\n    ) -> None:\n        super().__init__()\n        self.title = PDFString(title, encrypt=True)\n        self.parent: Optional[OutlineDictionary | OutlineItemDictionary] = None\n        self.prev: Optional[OutlineItemDictionary] = None\n        self.next: Optional[OutlineItemDictionary] = None\n        self.first: Optional[OutlineItemDictionary] = None\n        self.last: Optional[OutlineItemDictionary] = None\n        self.count: int = 0\n        self.dest: Optional[DestinationXYZ] = dest\n        self.struct_elem: Optional[StructElem] = struct_elem\n\n    def __str__(self) -> str:\n        return f\"OutlineItemDictionary(title={self.title}, dest={self.dest})\"",
      "language": "python"
    },
    {
      "code": "@dataclass\nclass OutlineSection:\n    # RAM usage optimization\n    __slots__ = (\"name\", \"level\", \"page_number\", \"dest\", \"struct_elem\")\n    name: str\n    level: int\n    page_number: int\n    dest: DestinationXYZ\n    struct_elem: Optional[StructElem]\n\n    def __init__(\n        self,\n        name: str,\n        level: int,\n        page_number: int,\n        dest: DestinationXYZ,\n        struct_elem: Optional[StructElem] = None,\n    ) -> None:\n        self.name = name\n        self.level = level\n        self.page_number = page_number\n        self.dest = dest\n        self.struct_elem = struct_elem",
      "language": "python"
    },
    {
      "code": "@dataclass\nclass OutlineSection:\n    # RAM usage optimization\n    __slots__ = (\"name\", \"level\", \"page_number\", \"dest\", \"struct_elem\")\n    name: str\n    level: int\n    page_number: int\n    dest: DestinationXYZ\n    struct_elem: Optional[StructElem]\n\n    def __init__(\n        self,\n        name: str,\n        level: int,\n        page_number: int,\n        dest: DestinationXYZ,\n        struct_elem: Optional[StructElem] = None,\n    ) -> None:\n        self.name = name\n        self.level = level\n        self.page_number = page_number\n        self.dest = dest\n        self.struct_elem = struct_elem",
      "language": "python"
    },
    {
      "code": "@dataclass\nclass OutlineSection:\n    # RAM usage optimization\n    __slots__ = (\"name\", \"level\", \"page_number\", \"dest\", \"struct_elem\")\n    name: str\n    level: int\n    page_number: int\n    dest: DestinationXYZ\n    struct_elem: Optional[StructElem]\n\n    def __init__(\n        self,\n        name: str,\n        level: int,\n        page_number: int,\n        dest: DestinationXYZ,\n        struct_elem: Optional[StructElem] = None,\n    ) -> None:\n        self.name = name\n        self.level = level\n        self.page_number = page_number\n        self.dest = dest\n        self.struct_elem = struct_elem",
      "language": "python"
    },
    {
      "code": "@dataclass\nclass OutlineSection:\n    # RAM usage optimization\n    __slots__ = (\"name\", \"level\", \"page_number\", \"dest\", \"struct_elem\")\n    name: str\n    level: int\n    page_number: int\n    dest: DestinationXYZ\n    struct_elem: Optional[StructElem]\n\n    def __init__(\n        self,\n        name: str,\n        level: int,\n        page_number: int,\n        dest: DestinationXYZ,\n        struct_elem: Optional[StructElem] = None,\n    ) -> None:\n        self.name = name\n        self.level = level\n        self.page_number = page_number\n        self.dest = dest\n        self.struct_elem = struct_elem",
      "language": "python"
    },
    {
      "code": "@dataclass\nclass OutlineSection:\n    # RAM usage optimization\n    __slots__ = (\"name\", \"level\", \"page_number\", \"dest\", \"struct_elem\")\n    name: str\n    level: int\n    page_number: int\n    dest: DestinationXYZ\n    struct_elem: Optional[StructElem]\n\n    def __init__(\n        self,\n        name: str,\n        level: int,\n        page_number: int,\n        dest: DestinationXYZ,\n        struct_elem: Optional[StructElem] = None,\n    ) -> None:\n        self.name = name\n        self.level = level\n        self.page_number = page_number\n        self.dest = dest\n        self.struct_elem = struct_elem",
      "language": "python"
    },
    {
      "code": "@dataclass\nclass OutlineSection:\n    # RAM usage optimization\n    __slots__ = (\"name\", \"level\", \"page_number\", \"dest\", \"struct_elem\")\n    name: str\n    level: int\n    page_number: int\n    dest: DestinationXYZ\n    struct_elem: Optional[StructElem]\n\n    def __init__(\n        self,\n        name: str,\n        level: int,\n        page_number: int,\n        dest: DestinationXYZ,\n        struct_elem: Optional[StructElem] = None,\n    ) -> None:\n        self.name = name\n        self.level = level\n        self.page_number = page_number\n        self.dest = dest\n        self.struct_elem = struct_elem",
      "language": "python"
    },
    {
      "code": "class TableOfContents:\n    \"\"\"\n    A reference implementation of a Table of Contents (ToC) for use with `fpdf2`.\n\n    This class provides a customizable Table of Contents that can be used directly or subclassed\n    for additional functionality. To use this class, create an instance of `TableOfContents`,\n    configure it as needed, and pass its `render_toc` method as the `render_toc_function` argument\n    to `FPDF.insert_toc_placeholder()`.\n    \"\"\"\n\n    def __init__(\n        self,\n        text_style: Optional[TextStyle] = None,\n        use_section_title_styles: bool = False,\n        level_indent: float = 7.5,\n        line_spacing: float = 1.5,\n        ignore_pages_before_toc: bool = True,\n    ) -> None:\n        self.text_style = text_style or TextStyle()\n        self.use_section_title_styles = use_section_title_styles\n        self.level_indent = level_indent\n        self.line_spacing = line_spacing\n        self.ignore_pages_before_toc = ignore_pages_before_toc\n\n    def get_text_style(self, pdf: \"FPDF\", item: OutlineSection) -> TextStyle:\n        if self.use_section_title_styles and pdf.section_title_styles[item.level]:\n            return pdf.section_title_styles[item.level]\n        if isinstance(self.text_style.l_margin, (str, Align)):\n            raise ValueError(\n                f\"Unsupported l_margin value provided as TextStyle: {self.text_style.l_margin}\"\n            )\n        return self.text_style\n\n    def render_toc_item(self, pdf: \"FPDF\", item: OutlineSection) -> None:\n        link = pdf.add_link(page=item.page_number)\n        page_label = pdf.pages[item.page_number].get_label()\n\n        # render the text on the left\n        with pdf.use_text_style(self.get_text_style(pdf, item)):\n            indent = item.level * self.level_indent\n            pdf.set_x(pdf.l_margin + indent)\n            pdf.multi_cell(\n                w=pdf.epw - indent,\n                text=item.name,\n                new_x=XPos.END,\n                new_y=YPos.LAST,\n                link=link,\n                align=Align.J,\n                h=pdf.font_size * self.line_spacing,\n            )\n\n            # fill in-between with dots\n            clearance_margin = pdf.c_margin * 2\n            current_x = pdf.get_x()\n            page_label_length = pdf.get_string_width(page_label)\n            in_between_space = (\n                pdf.w - current_x - page_label_length - clearance_margin - pdf.r_margin\n            )\n            if in_between_space < 0:\n                # no space to render the page number - go to next line\n                pdf.ln()\n                pdf.set_x(pdf.l_margin + indent)\n                current_x = pdf.get_x()\n                in_between_space = pdf.w - current_x - page_label_length - pdf.r_margin\n            in_between = \"\"\n            if in_between_space > 0:\n                while (\n                    pdf.get_string_width(in_between) + clearance_margin\n                    < in_between_space\n                ):\n                    in_between += \".\"\n\n                if len(in_between) > 1:\n                    pdf.multi_cell(\n                        w=pdf.w - current_x - pdf.r_margin,\n                        text=in_between[:-1],\n                        new_x=XPos.END,\n                        new_y=YPos.LAST,\n                        link=link,\n                        align=Align.L,\n                        h=pdf.font_size * self.line_spacing,\n                    )\n\n            # render the page number on the right\n            pdf.set_x(current_x)\n            pdf.multi_cell(\n                w=pdf.w - current_x - pdf.r_margin,\n                text=page_label,\n                new_x=XPos.LMARGIN,\n                new_y=YPos.NEXT,\n                link=link,\n                align=Align.R,\n                h=pdf.font_size * self.line_spacing,\n            )\n\n    def render_toc(self, pdf: \"FPDF\", outline: list[OutlineSection]) -> None:\n        \"This method can be overridden by subclasses to customize the Table of Contents style.\"\n        assert pdf.toc_placeholder is not None\n        for section in outline:\n            if (\n                self.ignore_pages_before_toc\n                and section.page_number <= pdf.toc_placeholder.start_page\n            ):\n                continue\n            self.render_toc_item(pdf, section)",
      "language": "python"
    },
    {
      "code": "def get_text_style(self, pdf: \"FPDF\", item: OutlineSection) -> TextStyle:\n    if self.use_section_title_styles and pdf.section_title_styles[item.level]:\n        return pdf.section_title_styles[item.level]\n    if isinstance(self.text_style.l_margin, (str, Align)):\n        raise ValueError(\n            f\"Unsupported l_margin value provided as TextStyle: {self.text_style.l_margin}\"\n        )\n    return self.text_style",
      "language": "python"
    },
    {
      "code": "def render_toc(self, pdf: \"FPDF\", outline: list[OutlineSection]) -> None:\n    \"This method can be overridden by subclasses to customize the Table of Contents style.\"\n    assert pdf.toc_placeholder is not None\n    for section in outline:\n        if (\n            self.ignore_pages_before_toc\n            and section.page_number <= pdf.toc_placeholder.start_page\n        ):\n            continue\n        self.render_toc_item(pdf, section)",
      "language": "python"
    },
    {
      "code": "def render_toc_item(self, pdf: \"FPDF\", item: OutlineSection) -> None:\n    link = pdf.add_link(page=item.page_number)\n    page_label = pdf.pages[item.page_number].get_label()\n\n    # render the text on the left\n    with pdf.use_text_style(self.get_text_style(pdf, item)):\n        indent = item.level * self.level_indent\n        pdf.set_x(pdf.l_margin + indent)\n        pdf.multi_cell(\n            w=pdf.epw - indent,\n            text=item.name,\n            new_x=XPos.END,\n            new_y=YPos.LAST,\n            link=link,\n            align=Align.J,\n            h=pdf.font_size * self.line_spacing,\n        )\n\n        # fill in-between with dots\n        clearance_margin = pdf.c_margin * 2\n        current_x = pdf.get_x()\n        page_label_length = pdf.get_string_width(page_label)\n        in_between_space = (\n            pdf.w - current_x - page_label_length - clearance_margin - pdf.r_margin\n        )\n        if in_between_space < 0:\n            # no space to render the page number - go to next line\n            pdf.ln()\n            pdf.set_x(pdf.l_margin + indent)\n            current_x = pdf.get_x()\n            in_between_space = pdf.w - current_x - page_label_length - pdf.r_margin\n        in_between = \"\"\n        if in_between_space > 0:\n            while (\n                pdf.get_string_width(in_between) + clearance_margin\n                < in_between_space\n            ):\n                in_between += \".\"\n\n            if len(in_between) > 1:\n                pdf.multi_cell(\n                    w=pdf.w - current_x - pdf.r_margin,\n                    text=in_between[:-1],\n                    new_x=XPos.END,\n                    new_y=YPos.LAST,\n                    link=link,\n                    align=Align.L,\n                    h=pdf.font_size * self.line_spacing,\n                )\n\n        # render the page number on the right\n        pdf.set_x(current_x)\n        pdf.multi_cell(\n            w=pdf.w - current_x - pdf.r_margin,\n            text=page_label,\n            new_x=XPos.LMARGIN,\n            new_y=YPos.NEXT,\n            link=link,\n            align=Align.R,\n            h=pdf.font_size * self.line_spacing,\n        )",
      "language": "python"
    }
  ],
  "patterns": [],
  "links": [
    "https://py-pdf.github.io/fpdf2/DocumentOutlineAndTableOfContents.html",
    "https://py-pdf.github.io/fpdf2/fpdf/outline.html",
    "https://py-pdf.github.io/fpdf2/fpdf/syntax.html",
    "https://py-pdf.github.io/fpdf2/fpdf/structure_tree.html",
    "https://py-pdf.github.io/fpdf2/fpdf/fonts.html",
    "https://py-pdf.github.io/fpdf2/fpdf/index.html"
  ]
}