{
  "url": "https://py-pdf.github.io/fpdf2/fpdf/output.html",
  "title": "Module fpdf.output",
  "content": "This module contains the serialization logic that produces a PDF document from a FPDF instance. Most of the code in this module is used when FPDF.output() is called.\n\nThe contents of this module are internal to fpdf2, and not part of the public API. They may change at any time without prior warning or any deprecation period, in non-backward-compatible ways.\n\nConvert a blend group into a Form XObject with an isolated transparency group.\n\nConverts a PaintedSoftMask into a PDF XObject Form suitable for use as a soft mask.\n\nInherited from: PDFObject.content_stream\n\nSubclasses can override this method to indicate the presence of a content stream\n\nInherited from: PDFObject.serialize\n\nSerialize the PDF object as an obj<</>>endobj text block\n\nHelper class that provides a standard way to create an ABC using inheritance.\n\nThe optional OutputIntents (PDF 1.4) entry in the document catalog dictionary holds an array of output intent dictionaries, each describing the colour reproduction characteristics of a possible output device.\n\ndest_output_profile (PDFICCProfile, required/optional): PDFICCProfile | None # (required if output_condition_identifier does not specify a standard production condition; optional otherwise) info (str, required/optional see dest_output_profile): human readable description of profile\n\nGenerates the final bytearray representing the PDF document, based on a FPDF instance.\n\nThis method alters the target FPDF instance by assigning IDs to all PDF objects, plus a few other properties on PDFPage instances\n\nInherited from: PDFObject.content_stream\n\nSubclasses can override this method to indicate the presence of a content stream\n\nInherited from: PDFObject.serialize\n\nSerialize the PDF object as an obj<</>>endobj text block\n\nInherited from: PDFObject.content_stream\n\nSubclasses can override this method to indicate the presence of a content stream\n\nInherited from: PDFObject.serialize\n\nSerialize the PDF object as an obj<</>>endobj text block\n\nInherited from: PDFObject.content_stream\n\nSubclasses can override this method to indicate the presence of a content stream\n\nInherited from: PDFObject.serialize\n\nSerialize the PDF object as an obj<</>>endobj text block\n\nInherited from: PDFContentStream.content_stream\n\nSubclasses can override this method to indicate the presence of a content stream\n\nInherited from: PDFContentStream.serialize\n\nSerialize the PDF object as an obj<</>>endobj text block\n\nEmit the PDF file header as required by ISO 32000-1, §7.5.2 “File header”.\n\nThe header consists of: 1) A line starting with the literal \"%PDF-\" followed by the file version 2) If the file contains binary data an immediate second line that is a comment starting with \"%\" and containing at least four bytes with values ≥ 128 (non-ASCII). This helps file-transfer tools treat the content as binary rather than text.\n\nHolds values for ICC Profile Stream\n\nInherited from: PDFContentStream.content_stream\n\nSubclasses can override this method to indicate the presence of a content stream\n\nInherited from: PDFContentStream.serialize\n\nSerialize the PDF object as an obj<</>>endobj text block\n\nInherited from: PDFObject.content_stream\n\nSubclasses can override this method to indicate the presence of a content stream\n\nInherited from: PDFObject.serialize\n\nSerialize the PDF object as an obj<</>>endobj text block\n\nInherited from: PDFObject.content_stream\n\nSubclasses can override this method to indicate the presence of a content stream\n\nReturn a pair (width, height) in the unit specified to FPDF constructor\n\nInherited from: PDFObject.serialize\n\nSerialize the PDF object as an obj<</>>endobj text block\n\nAccepts a pair (width, height) in the unit specified to FPDF constructor\n\nThis will be displayed by some PDF readers to identify pages.\n\nInherited from: PDFObject.content_stream\n\nSubclasses can override this method to indicate the presence of a content stream\n\nInherited from: PDFObject.serialize\n\nSerialize the PDF object as an obj<</>>endobj text block\n\nInherited from: PDFObject.content_stream\n\nSubclasses can override this method to indicate the presence of a content stream\n\nInherited from: PDFObject.serialize\n\nSerialize the PDF object as an obj<</>>endobj text block\n\nInherited from: PDFObject.content_stream\n\nSubclasses can override this method to indicate the presence of a content stream\n\nInherited from: PDFObject.serialize\n\nSerialize the PDF object as an obj<</>>endobj text block\n\nInherited from: PDFContentStream.content_stream\n\nSubclasses can override this method to indicate the presence of a content stream\n\nInherited from: PDFContentStream.serialize\n\nSerialize the PDF object as an obj<</>>endobj text block\n\nInherited from: PDFContentStream.content_stream\n\nSubclasses can override this method to indicate the presence of a content stream\n\nInherited from: PDFContentStream.serialize\n\nSerialize the PDF object as an obj<</>>endobj text block\n\nCross-reference table & file trailer\n\nManage the indexing of resources and association to the pages they are used\n\nThe type of the None singleton.\n\nThe type of the None singleton.\n\nThe type of the None singleton.\n\nThe type of the None singleton.\n\nThe type of the None singleton.\n\nResolve a family+style to a concrete font instance from the font registry.\n\nScan a rendered content stream and register resources used on the given page. Currently indexes: - ExtGState invocations: '/GSn gs' - Image XObjects: '/In Do'\n\nRegister a blend group Form XObject and return its resource index.\n\nGraphics style can be added without associating to a page number right away, like when rendering a svg image. The method that adds image to the page will call the add method for the page association.\n\nRegister a soft mask xobject and return its object id\n\nParse a content stream and return discovered resources",
  "headings": [
    {
      "level": "h1",
      "text": "Module fpdf.output",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Functions",
      "id": "header-functions"
    },
    {
      "level": "h2",
      "text": "Classes",
      "id": "header-classes"
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Subclasses",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Subclasses",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Class variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Behavior",
      "id": "behavior"
    },
    {
      "level": "h2",
      "text": "Notes",
      "id": "notes"
    }
  ],
  "code_samples": [
    {
      "code": "def blend_group_to_xobject(\n    group: \"BlendGroup\", resource_catalog: ResourceCatalog\n) -> PDFContentStream:\n    \"\"\"Convert a blend group into a Form XObject with an isolated transparency group.\"\"\"\n    stream = group.render(resource_catalog)\n    xobject = PDFContentStream(contents=stream.encode(\"latin-1\"))\n    xobject._blend_group = group  # type: ignore[attr-defined]\n    xobject._registered = False  # type: ignore[attr-defined]\n    xobject.type = Name(\"XObject\")  # type: ignore[attr-defined]\n    xobject.subtype = Name(\"Form\")  # type: ignore[attr-defined]\n    bbox = group.get_bounding_box()\n    xobject.b_box = PDFArray(bbox)  # type: ignore[attr-defined]\n    xobject.group = \"<</S /Transparency /CS /DeviceRGB /I true>>\"  # type: ignore[attr-defined]\n    return xobject",
      "language": "python"
    },
    {
      "code": "def soft_mask_path_to_xobject(\n    path: PaintSoftMask, resource_catalog: ResourceCatalog\n) -> PDFContentStream:\n    \"\"\"Converts a PaintedSoftMask into a PDF XObject Form suitable for use as a soft mask.\"\"\"\n    xobject = PDFContentStream(contents=path.render(resource_catalog).encode(\"latin-1\"))\n    xobject._path = path  # type: ignore[attr-defined]\n    xobject.type = Name(\"XObject\")  # type: ignore[attr-defined]\n    xobject.subtype = Name(\"Form\")  # type: ignore[attr-defined]\n    xobject.b_box = PDFArray(path.get_bounding_box())  # type: ignore[attr-defined]\n    xobject.group = \"<</S /Transparency /CS /DeviceGray /I true /K false>>\"  # type: ignore[attr-defined]\n    return xobject",
      "language": "python"
    },
    {
      "code": "def stream_content_for_raster_image(\n    info: RasterImageInfo,\n    x: float,\n    y: float,\n    w: float,\n    h: float,\n    keep_aspect_ratio: bool = False,\n    scale: float = 1,\n    pdf_height_to_flip: Optional[float] = None,\n) -> str:\n    if keep_aspect_ratio:\n        x, y, w, h = info.scale_inside_box(x, y, w, h)\n    if pdf_height_to_flip:\n        stream_h = h\n        stream_y = pdf_height_to_flip - h - y\n    else:\n        stream_h = -h\n        stream_y = y + h\n    return (\n        f\"q {w * scale:.2f} 0 0 {stream_h * scale:.2f}\"\n        f\" {x * scale:.2f} {stream_y * scale:.2f} cm\"\n        f\" /I{info['i']} Do Q\"\n    )",
      "language": "python"
    },
    {
      "code": "class AcroForm:\n    def __init__(self, fields: PDFArray, sig_flags: int):\n        self.fields = fields\n        self.sig_flags = sig_flags\n\n    def serialize(\n        self,\n        _security_handler: Optional[\"StandardSecurityHandler\"] = None,\n        _obj_id: Optional[int] = None,\n    ) -> str:\n        obj_dict = build_obj_dict(\n            {key: getattr(self, key) for key in dir(self)},\n            _security_handler=_security_handler,\n            _obj_id=_obj_id,\n        )\n        return pdf_dict(obj_dict, field_join=\" \")",
      "language": "python"
    },
    {
      "code": "def serialize(\n    self,\n    _security_handler: Optional[\"StandardSecurityHandler\"] = None,\n    _obj_id: Optional[int] = None,\n) -> str:\n    obj_dict = build_obj_dict(\n        {key: getattr(self, key) for key in dir(self)},\n        _security_handler=_security_handler,\n        _obj_id=_obj_id,\n    )\n    return pdf_dict(obj_dict, field_join=\" \")",
      "language": "python"
    },
    {
      "code": "class CIDSystemInfo(PDFObject):\n    def __init__(self) -> None:\n        super().__init__()\n        self.registry = PDFString(\"Adobe\", encrypt=True)\n        self.ordering = PDFString(\"UCS\", encrypt=True)\n        self.supplement = 0",
      "language": "python"
    },
    {
      "code": "class ContentWithoutID(ABC):\n\n    @abstractmethod\n    def serialize(\n        self, _security_handler: Optional[\"StandardSecurityHandler\"] = None\n    ) -> str:\n        raise NotImplementedError",
      "language": "python"
    },
    {
      "code": "@abstractmethod\ndef serialize(\n    self, _security_handler: Optional[\"StandardSecurityHandler\"] = None\n) -> str:\n    raise NotImplementedError",
      "language": "python"
    },
    {
      "code": "class OutputIntentDictionary:\n    \"\"\"\n    The optional OutputIntents (PDF 1.4) entry in the document\n    catalog dictionary holds an array of output intent dictionaries,\n    each describing the colour reproduction characteristics of a possible\n    output device.\n\n    Args:\n        subtype (OutputIntentSubType, required): PDFA, PDFX or ISOPDF\n        output_condition_identifier (str, required): see the Name in\n            https://www.color.org/registry.xalter\n        output_condition (str, optional): see the Definition in\n            https://www.color.org/registry.xalter\n        registry_name (str, optional): \"https://www.color.org\"\n        dest_output_profile (PDFICCProfile, required/optional):\n            PDFICCProfile | None # (required if\n            output_condition_identifier does not specify a standard\n            production condition; optional otherwise)\n        info (str, required/optional see dest_output_profile): human\n            readable description of profile\n    \"\"\"\n\n    __slots__ = (  # RAM usage optimization\n        \"type\",\n        \"s\",\n        \"output_condition_identifier\",\n        \"output_condition\",\n        \"registry_name\",\n        \"dest_output_profile\",\n        \"info\",\n    )\n\n    def __init__(\n        self,\n        subtype: \"OutputIntentSubType | str\",\n        output_condition_identifier: Optional[str],\n        output_condition: Optional[str] = None,\n        registry_name: Optional[str] = None,\n        dest_output_profile: Optional[PDFICCProfile] = None,\n        info: Optional[str] = None,\n    ) -> None:\n        self.type = Name(\"OutputIntent\")\n        self.s = Name(OutputIntentSubType.coerce(subtype).value)\n        self.output_condition_identifier = (\n            PDFString(output_condition_identifier)\n            if output_condition_identifier\n            else None\n        )\n        self.output_condition = (\n            PDFString(output_condition) if output_condition else None\n        )\n        self.registry_name = PDFString(registry_name) if registry_name else None\n        self.dest_output_profile = (\n            dest_output_profile\n            if dest_output_profile and isinstance(dest_output_profile, PDFICCProfile)\n            else None\n        )\n        self.info = PDFString(info) if info else None\n\n    def serialize(\n        self,\n        _security_handler: Optional[\"StandardSecurityHandler\"] = None,\n        _obj_id: Optional[int] = None,\n    ) -> str:\n        obj_dict = build_obj_dict(\n            {key: getattr(self, key) for key in dir(self)},\n            _security_handler=_security_handler,\n            _obj_id=_obj_id,\n        )\n        return pdf_dict(obj_dict)",
      "language": "python"
    },
    {
      "code": "class OutputIntentDictionary:\n    \"\"\"\n    The optional OutputIntents (PDF 1.4) entry in the document\n    catalog dictionary holds an array of output intent dictionaries,\n    each describing the colour reproduction characteristics of a possible\n    output device.\n\n    Args:\n        subtype (OutputIntentSubType, required): PDFA, PDFX or ISOPDF\n        output_condition_identifier (str, required): see the Name in\n            https://www.color.org/registry.xalter\n        output_condition (str, optional): see the Definition in\n            https://www.color.org/registry.xalter\n        registry_name (str, optional): \"https://www.color.org\"\n        dest_output_profile (PDFICCProfile, required/optional):\n            PDFICCProfile | None # (required if\n            output_condition_identifier does not specify a standard\n            production condition; optional otherwise)\n        info (str, required/optional see dest_output_profile): human\n            readable description of profile\n    \"\"\"\n\n    __slots__ = (  # RAM usage optimization\n        \"type\",\n        \"s\",\n        \"output_condition_identifier\",\n        \"output_condition\",\n        \"registry_name\",\n        \"dest_output_profile\",\n        \"info\",\n    )\n\n    def __init__(\n        self,\n        subtype: \"OutputIntentSubType | str\",\n        output_condition_identifier: Optional[str],\n        output_condition: Optional[str] = None,\n        registry_name: Optional[str] = None,\n        dest_output_profile: Optional[PDFICCProfile] = None,\n        info: Optional[str] = None,\n    ) -> None:\n        self.type = Name(\"OutputIntent\")\n        self.s = Name(OutputIntentSubType.coerce(subtype).value)\n        self.output_condition_identifier = (\n            PDFString(output_condition_identifier)\n            if output_condition_identifier\n            else None\n        )\n        self.output_condition = (\n            PDFString(output_condition) if output_condition else None\n        )\n        self.registry_name = PDFString(registry_name) if registry_name else None\n        self.dest_output_profile = (\n            dest_output_profile\n            if dest_output_profile and isinstance(dest_output_profile, PDFICCProfile)\n            else None\n        )\n        self.info = PDFString(info) if info else None\n\n    def serialize(\n        self,\n        _security_handler: Optional[\"StandardSecurityHandler\"] = None,\n        _obj_id: Optional[int] = None,\n    ) -> str:\n        obj_dict = build_obj_dict(\n            {key: getattr(self, key) for key in dir(self)},\n            _security_handler=_security_handler,\n            _obj_id=_obj_id,\n        )\n        return pdf_dict(obj_dict)",
      "language": "python"
    },
    {
      "code": "class OutputIntentDictionary:\n    \"\"\"\n    The optional OutputIntents (PDF 1.4) entry in the document\n    catalog dictionary holds an array of output intent dictionaries,\n    each describing the colour reproduction characteristics of a possible\n    output device.\n\n    Args:\n        subtype (OutputIntentSubType, required): PDFA, PDFX or ISOPDF\n        output_condition_identifier (str, required): see the Name in\n            https://www.color.org/registry.xalter\n        output_condition (str, optional): see the Definition in\n            https://www.color.org/registry.xalter\n        registry_name (str, optional): \"https://www.color.org\"\n        dest_output_profile (PDFICCProfile, required/optional):\n            PDFICCProfile | None # (required if\n            output_condition_identifier does not specify a standard\n            production condition; optional otherwise)\n        info (str, required/optional see dest_output_profile): human\n            readable description of profile\n    \"\"\"\n\n    __slots__ = (  # RAM usage optimization\n        \"type\",\n        \"s\",\n        \"output_condition_identifier\",\n        \"output_condition\",\n        \"registry_name\",\n        \"dest_output_profile\",\n        \"info\",\n    )\n\n    def __init__(\n        self,\n        subtype: \"OutputIntentSubType | str\",\n        output_condition_identifier: Optional[str],\n        output_condition: Optional[str] = None,\n        registry_name: Optional[str] = None,\n        dest_output_profile: Optional[PDFICCProfile] = None,\n        info: Optional[str] = None,\n    ) -> None:\n        self.type = Name(\"OutputIntent\")\n        self.s = Name(OutputIntentSubType.coerce(subtype).value)\n        self.output_condition_identifier = (\n            PDFString(output_condition_identifier)\n            if output_condition_identifier\n            else None\n        )\n        self.output_condition = (\n            PDFString(output_condition) if output_condition else None\n        )\n        self.registry_name = PDFString(registry_name) if registry_name else None\n        self.dest_output_profile = (\n            dest_output_profile\n            if dest_output_profile and isinstance(dest_output_profile, PDFICCProfile)\n            else None\n        )\n        self.info = PDFString(info) if info else None\n\n    def serialize(\n        self,\n        _security_handler: Optional[\"StandardSecurityHandler\"] = None,\n        _obj_id: Optional[int] = None,\n    ) -> str:\n        obj_dict = build_obj_dict(\n            {key: getattr(self, key) for key in dir(self)},\n            _security_handler=_security_handler,\n            _obj_id=_obj_id,\n        )\n        return pdf_dict(obj_dict)",
      "language": "python"
    },
    {
      "code": "class OutputIntentDictionary:\n    \"\"\"\n    The optional OutputIntents (PDF 1.4) entry in the document\n    catalog dictionary holds an array of output intent dictionaries,\n    each describing the colour reproduction characteristics of a possible\n    output device.\n\n    Args:\n        subtype (OutputIntentSubType, required): PDFA, PDFX or ISOPDF\n        output_condition_identifier (str, required): see the Name in\n            https://www.color.org/registry.xalter\n        output_condition (str, optional): see the Definition in\n            https://www.color.org/registry.xalter\n        registry_name (str, optional): \"https://www.color.org\"\n        dest_output_profile (PDFICCProfile, required/optional):\n            PDFICCProfile | None # (required if\n            output_condition_identifier does not specify a standard\n            production condition; optional otherwise)\n        info (str, required/optional see dest_output_profile): human\n            readable description of profile\n    \"\"\"\n\n    __slots__ = (  # RAM usage optimization\n        \"type\",\n        \"s\",\n        \"output_condition_identifier\",\n        \"output_condition\",\n        \"registry_name\",\n        \"dest_output_profile\",\n        \"info\",\n    )\n\n    def __init__(\n        self,\n        subtype: \"OutputIntentSubType | str\",\n        output_condition_identifier: Optional[str],\n        output_condition: Optional[str] = None,\n        registry_name: Optional[str] = None,\n        dest_output_profile: Optional[PDFICCProfile] = None,\n        info: Optional[str] = None,\n    ) -> None:\n        self.type = Name(\"OutputIntent\")\n        self.s = Name(OutputIntentSubType.coerce(subtype).value)\n        self.output_condition_identifier = (\n            PDFString(output_condition_identifier)\n            if output_condition_identifier\n            else None\n        )\n        self.output_condition = (\n            PDFString(output_condition) if output_condition else None\n        )\n        self.registry_name = PDFString(registry_name) if registry_name else None\n        self.dest_output_profile = (\n            dest_output_profile\n            if dest_output_profile and isinstance(dest_output_profile, PDFICCProfile)\n            else None\n        )\n        self.info = PDFString(info) if info else None\n\n    def serialize(\n        self,\n        _security_handler: Optional[\"StandardSecurityHandler\"] = None,\n        _obj_id: Optional[int] = None,\n    ) -> str:\n        obj_dict = build_obj_dict(\n            {key: getattr(self, key) for key in dir(self)},\n            _security_handler=_security_handler,\n            _obj_id=_obj_id,\n        )\n        return pdf_dict(obj_dict)",
      "language": "python"
    },
    {
      "code": "class OutputIntentDictionary:\n    \"\"\"\n    The optional OutputIntents (PDF 1.4) entry in the document\n    catalog dictionary holds an array of output intent dictionaries,\n    each describing the colour reproduction characteristics of a possible\n    output device.\n\n    Args:\n        subtype (OutputIntentSubType, required): PDFA, PDFX or ISOPDF\n        output_condition_identifier (str, required): see the Name in\n            https://www.color.org/registry.xalter\n        output_condition (str, optional): see the Definition in\n            https://www.color.org/registry.xalter\n        registry_name (str, optional): \"https://www.color.org\"\n        dest_output_profile (PDFICCProfile, required/optional):\n            PDFICCProfile | None # (required if\n            output_condition_identifier does not specify a standard\n            production condition; optional otherwise)\n        info (str, required/optional see dest_output_profile): human\n            readable description of profile\n    \"\"\"\n\n    __slots__ = (  # RAM usage optimization\n        \"type\",\n        \"s\",\n        \"output_condition_identifier\",\n        \"output_condition\",\n        \"registry_name\",\n        \"dest_output_profile\",\n        \"info\",\n    )\n\n    def __init__(\n        self,\n        subtype: \"OutputIntentSubType | str\",\n        output_condition_identifier: Optional[str],\n        output_condition: Optional[str] = None,\n        registry_name: Optional[str] = None,\n        dest_output_profile: Optional[PDFICCProfile] = None,\n        info: Optional[str] = None,\n    ) -> None:\n        self.type = Name(\"OutputIntent\")\n        self.s = Name(OutputIntentSubType.coerce(subtype).value)\n        self.output_condition_identifier = (\n            PDFString(output_condition_identifier)\n            if output_condition_identifier\n            else None\n        )\n        self.output_condition = (\n            PDFString(output_condition) if output_condition else None\n        )\n        self.registry_name = PDFString(registry_name) if registry_name else None\n        self.dest_output_profile = (\n            dest_output_profile\n            if dest_output_profile and isinstance(dest_output_profile, PDFICCProfile)\n            else None\n        )\n        self.info = PDFString(info) if info else None\n\n    def serialize(\n        self,\n        _security_handler: Optional[\"StandardSecurityHandler\"] = None,\n        _obj_id: Optional[int] = None,\n    ) -> str:\n        obj_dict = build_obj_dict(\n            {key: getattr(self, key) for key in dir(self)},\n            _security_handler=_security_handler,\n            _obj_id=_obj_id,\n        )\n        return pdf_dict(obj_dict)",
      "language": "python"
    },
    {
      "code": "class OutputIntentDictionary:\n    \"\"\"\n    The optional OutputIntents (PDF 1.4) entry in the document\n    catalog dictionary holds an array of output intent dictionaries,\n    each describing the colour reproduction characteristics of a possible\n    output device.\n\n    Args:\n        subtype (OutputIntentSubType, required): PDFA, PDFX or ISOPDF\n        output_condition_identifier (str, required): see the Name in\n            https://www.color.org/registry.xalter\n        output_condition (str, optional): see the Definition in\n            https://www.color.org/registry.xalter\n        registry_name (str, optional): \"https://www.color.org\"\n        dest_output_profile (PDFICCProfile, required/optional):\n            PDFICCProfile | None # (required if\n            output_condition_identifier does not specify a standard\n            production condition; optional otherwise)\n        info (str, required/optional see dest_output_profile): human\n            readable description of profile\n    \"\"\"\n\n    __slots__ = (  # RAM usage optimization\n        \"type\",\n        \"s\",\n        \"output_condition_identifier\",\n        \"output_condition\",\n        \"registry_name\",\n        \"dest_output_profile\",\n        \"info\",\n    )\n\n    def __init__(\n        self,\n        subtype: \"OutputIntentSubType | str\",\n        output_condition_identifier: Optional[str],\n        output_condition: Optional[str] = None,\n        registry_name: Optional[str] = None,\n        dest_output_profile: Optional[PDFICCProfile] = None,\n        info: Optional[str] = None,\n    ) -> None:\n        self.type = Name(\"OutputIntent\")\n        self.s = Name(OutputIntentSubType.coerce(subtype).value)\n        self.output_condition_identifier = (\n            PDFString(output_condition_identifier)\n            if output_condition_identifier\n            else None\n        )\n        self.output_condition = (\n            PDFString(output_condition) if output_condition else None\n        )\n        self.registry_name = PDFString(registry_name) if registry_name else None\n        self.dest_output_profile = (\n            dest_output_profile\n            if dest_output_profile and isinstance(dest_output_profile, PDFICCProfile)\n            else None\n        )\n        self.info = PDFString(info) if info else None\n\n    def serialize(\n        self,\n        _security_handler: Optional[\"StandardSecurityHandler\"] = None,\n        _obj_id: Optional[int] = None,\n    ) -> str:\n        obj_dict = build_obj_dict(\n            {key: getattr(self, key) for key in dir(self)},\n            _security_handler=_security_handler,\n            _obj_id=_obj_id,\n        )\n        return pdf_dict(obj_dict)",
      "language": "python"
    },
    {
      "code": "class OutputIntentDictionary:\n    \"\"\"\n    The optional OutputIntents (PDF 1.4) entry in the document\n    catalog dictionary holds an array of output intent dictionaries,\n    each describing the colour reproduction characteristics of a possible\n    output device.\n\n    Args:\n        subtype (OutputIntentSubType, required): PDFA, PDFX or ISOPDF\n        output_condition_identifier (str, required): see the Name in\n            https://www.color.org/registry.xalter\n        output_condition (str, optional): see the Definition in\n            https://www.color.org/registry.xalter\n        registry_name (str, optional): \"https://www.color.org\"\n        dest_output_profile (PDFICCProfile, required/optional):\n            PDFICCProfile | None # (required if\n            output_condition_identifier does not specify a standard\n            production condition; optional otherwise)\n        info (str, required/optional see dest_output_profile): human\n            readable description of profile\n    \"\"\"\n\n    __slots__ = (  # RAM usage optimization\n        \"type\",\n        \"s\",\n        \"output_condition_identifier\",\n        \"output_condition\",\n        \"registry_name\",\n        \"dest_output_profile\",\n        \"info\",\n    )\n\n    def __init__(\n        self,\n        subtype: \"OutputIntentSubType | str\",\n        output_condition_identifier: Optional[str],\n        output_condition: Optional[str] = None,\n        registry_name: Optional[str] = None,\n        dest_output_profile: Optional[PDFICCProfile] = None,\n        info: Optional[str] = None,\n    ) -> None:\n        self.type = Name(\"OutputIntent\")\n        self.s = Name(OutputIntentSubType.coerce(subtype).value)\n        self.output_condition_identifier = (\n            PDFString(output_condition_identifier)\n            if output_condition_identifier\n            else None\n        )\n        self.output_condition = (\n            PDFString(output_condition) if output_condition else None\n        )\n        self.registry_name = PDFString(registry_name) if registry_name else None\n        self.dest_output_profile = (\n            dest_output_profile\n            if dest_output_profile and isinstance(dest_output_profile, PDFICCProfile)\n            else None\n        )\n        self.info = PDFString(info) if info else None\n\n    def serialize(\n        self,\n        _security_handler: Optional[\"StandardSecurityHandler\"] = None,\n        _obj_id: Optional[int] = None,\n    ) -> str:\n        obj_dict = build_obj_dict(\n            {key: getattr(self, key) for key in dir(self)},\n            _security_handler=_security_handler,\n            _obj_id=_obj_id,\n        )\n        return pdf_dict(obj_dict)",
      "language": "python"
    },
    {
      "code": "class OutputIntentDictionary:\n    \"\"\"\n    The optional OutputIntents (PDF 1.4) entry in the document\n    catalog dictionary holds an array of output intent dictionaries,\n    each describing the colour reproduction characteristics of a possible\n    output device.\n\n    Args:\n        subtype (OutputIntentSubType, required): PDFA, PDFX or ISOPDF\n        output_condition_identifier (str, required): see the Name in\n            https://www.color.org/registry.xalter\n        output_condition (str, optional): see the Definition in\n            https://www.color.org/registry.xalter\n        registry_name (str, optional): \"https://www.color.org\"\n        dest_output_profile (PDFICCProfile, required/optional):\n            PDFICCProfile | None # (required if\n            output_condition_identifier does not specify a standard\n            production condition; optional otherwise)\n        info (str, required/optional see dest_output_profile): human\n            readable description of profile\n    \"\"\"\n\n    __slots__ = (  # RAM usage optimization\n        \"type\",\n        \"s\",\n        \"output_condition_identifier\",\n        \"output_condition\",\n        \"registry_name\",\n        \"dest_output_profile\",\n        \"info\",\n    )\n\n    def __init__(\n        self,\n        subtype: \"OutputIntentSubType | str\",\n        output_condition_identifier: Optional[str],\n        output_condition: Optional[str] = None,\n        registry_name: Optional[str] = None,\n        dest_output_profile: Optional[PDFICCProfile] = None,\n        info: Optional[str] = None,\n    ) -> None:\n        self.type = Name(\"OutputIntent\")\n        self.s = Name(OutputIntentSubType.coerce(subtype).value)\n        self.output_condition_identifier = (\n            PDFString(output_condition_identifier)\n            if output_condition_identifier\n            else None\n        )\n        self.output_condition = (\n            PDFString(output_condition) if output_condition else None\n        )\n        self.registry_name = PDFString(registry_name) if registry_name else None\n        self.dest_output_profile = (\n            dest_output_profile\n            if dest_output_profile and isinstance(dest_output_profile, PDFICCProfile)\n            else None\n        )\n        self.info = PDFString(info) if info else None\n\n    def serialize(\n        self,\n        _security_handler: Optional[\"StandardSecurityHandler\"] = None,\n        _obj_id: Optional[int] = None,\n    ) -> str:\n        obj_dict = build_obj_dict(\n            {key: getattr(self, key) for key in dir(self)},\n            _security_handler=_security_handler,\n            _obj_id=_obj_id,\n        )\n        return pdf_dict(obj_dict)",
      "language": "python"
    },
    {
      "code": "def serialize(\n    self,\n    _security_handler: Optional[\"StandardSecurityHandler\"] = None,\n    _obj_id: Optional[int] = None,\n) -> str:\n    obj_dict = build_obj_dict(\n        {key: getattr(self, key) for key in dir(self)},\n        _security_handler=_security_handler,\n        _obj_id=_obj_id,\n    )\n    return pdf_dict(obj_dict)",
      "language": "python"
    },
    {
      "code": "class OutputProducer:\n    \"Generates the final bytearray representing the PDF document, based on a FPDF instance.\"\n\n    def __init__(self, fpdf: \"FPDF\") -> None:\n        self.fpdf = fpdf\n        self.pdf_objs: list[PDFObject | ContentWithoutID] = []\n        self.iccp_i_to_pdf_i: dict[int, int] = {}\n        self.obj_id: int = (\n            fpdf._resource_catalog.last_reserved_object_id\n        )  # current PDF object number\n        # array of PDF object offsets in self.buffer, used to build the xref table:\n        self.offsets: dict[int, int] = {}\n        self.trace_labels_per_obj_id: dict[int, str] = {}\n        self.sections_size_per_trace_label: dict[str, int] = defaultdict(int)\n        self.buffer: bytearray = bytearray()  # resulting output buffer\n\n    def bufferize(self) -> bytearray:\n        \"\"\"\n        This method alters the target FPDF instance\n        by assigning IDs to all PDF objects,\n        plus a few other properties on PDFPage instances\n        \"\"\"\n        fpdf = self.fpdf\n\n        # 1. setup - Insert all PDF objects\n        #    and assign unique consecutive numeric IDs to all of them\n\n        if fpdf._security_handler is not None:\n            # get the file_id and generate passwords needed to encrypt streams and strings\n            file_id: Optional[str | Literal[-1]] = fpdf.file_id()\n            if file_id == -1:\n                # no custom file id - use default file id so encryption passwords can be generated\n                file_id = fpdf._default_file_id(bytearray(0x00))\n            fpdf._security_handler.generate_passwords(str(file_id))\n\n        pdf_version = fpdf.pdf_version\n        if (\n            fpdf.viewer_preferences\n            and fpdf.viewer_preferences._min_pdf_version > pdf_version\n        ):\n            pdf_version = fpdf.viewer_preferences._min_pdf_version\n        self.pdf_objs.append(PDFHeader(pdf_version))\n        pages_root_obj = self._add_pages_root()\n        catalog_obj = self._add_catalog()\n        page_objs = self._add_pages()\n        sig_annotation_obj = self._add_annotations_as_objects()\n        for embedded_file in fpdf.embedded_files:\n            self._add_pdf_obj(embedded_file, \"embedded_files\")\n            self._add_pdf_obj(embedded_file.file_spec(), \"file_spec\")\n        self._insert_resources(page_objs)\n        struct_tree_root_obj = self._add_structure_tree()\n        outline_dict_obj, outline_items = self._add_document_outline()\n        xmp_metadata_obj = self._add_xmp_metadata()\n        info_obj = None\n        if not fpdf._compliance:\n            info_obj = self._add_info()\n        encryption_obj = self._add_encryption()\n\n        xref = PDFXrefAndTrailer(self)\n        self.pdf_objs.append(xref)\n\n        # 2. Plumbing - Inject all PDF object references required:\n        pages_root_obj.kids = PDFArray(page_objs)\n        self._finalize_catalog(\n            catalog_obj,\n            pages_root_obj=pages_root_obj,\n            first_page_obj=page_objs[0],\n            sig_annotation_obj=sig_annotation_obj,\n            xmp_metadata_obj=xmp_metadata_obj,\n            struct_tree_root_obj=struct_tree_root_obj,\n            outline_dict_obj=outline_dict_obj,\n        )\n        dests: list[DestinationXYZ] = []\n        for page_obj in page_objs:\n            page_obj.parent = pages_root_obj\n            assert isinstance(page_obj.annots, PDFArray)\n            for annot in page_obj.annots:\n                page_dests: list[DestinationXYZ] = []\n                if annot.dest:\n                    # Only add to page_dests if it's a Destination object (not a string/PDFString)\n                    if hasattr(annot.dest, \"page_number\"):\n                        page_dests.append(annot.dest)\n                if annot.a and hasattr(annot.a, \"dest\"):\n                    # Only add to page_dests if it's a Destination object (not a string/PDFString)\n                    if hasattr(annot.a.dest, \"page_number\"):\n                        page_dests.append(annot.a.dest)\n                for dest in page_dests:\n                    if dest.page_number > len(page_objs):\n                        raise ValueError(\n                            f\"Invalid reference to non-existing page {dest.page_number} present on page {page_obj.index()}: \"\n                        )\n                dests.extend(page_dests)\n            if not page_obj.annots:\n                # Avoid serializing an empty PDFArray:\n                page_obj.annots = None\n        for outline_item in outline_items:\n            if outline_item.dest is not None:\n                dests.append(outline_item.dest)\n        # Assigning the .page_ref property of all Destination objects:\n        for dest in dests:\n            dest.page_ref = pdf_ref(\n                page_objs[\n                    dest.page_number - 1\n                ].id  # pyright: ignore[reportUnknownArgumentType]\n            )\n        for struct_elem in fpdf.struct_builder.doc_struct_elem.k:\n            struct_elem.pg = page_objs[struct_elem.page_number() - 1]\n        xref.catalog_obj = catalog_obj\n        xref.info_obj = info_obj\n        xref.encryption_obj = encryption_obj\n\n        # 3. Serializing - Append all PDF objects to the buffer:\n        assert (\n            not self.buffer\n        ), f\"Nothing should have been appended to the .buffer at this stage: {self.buffer}\"\n        assert (\n            not self.offsets\n        ), f\"No offset should have been set at this stage: {len(self.offsets)}\"\n\n        for pdf_obj in self.pdf_objs:\n            if isinstance(pdf_obj, ContentWithoutID):\n                # top header, xref table & trailer:\n                trace_label = None\n            else:\n                self.offsets[pdf_obj.id] = len(self.buffer)\n                trace_label = self.trace_labels_per_obj_id.get(pdf_obj.id)\n            if trace_label:\n                with self._trace_size(trace_label):\n                    self._out(\n                        pdf_obj.serialize(_security_handler=fpdf._security_handler)\n                    )\n            else:\n                self._out(pdf_obj.serialize(_security_handler=fpdf._security_handler))\n        self._log_final_sections_sizes()\n\n        if fpdf._sign_key:\n            self.buffer = sign_content(\n                signer,  # pyright: ignore[reportArgumentType]\n                self.buffer,\n                fpdf._sign_key,\n                fpdf._sign_cert,\n                fpdf._sign_extra_certs,\n                fpdf._sign_hashalgo,\n                fpdf._sign_time,\n            )\n        return self.buffer\n\n    def _out(self, data: bytes | bytearray | str) -> None:\n        \"Append data to the buffer\"\n        if not isinstance(data, bytes):\n            if not isinstance(data, str):\n                data = str(data)\n            data = data.encode(\"latin1\")\n        self.buffer += data + b\"\\n\"\n\n    def _add_pdf_obj(\n        self, pdf_obj: PDFObject, trace_label: Optional[str] = None\n    ) -> int:\n        self.obj_id += 1\n        pdf_obj.id = self.obj_id\n        self.pdf_objs.append(pdf_obj)\n        if trace_label:\n            self.trace_labels_per_obj_id[self.obj_id] = trace_label\n        return self.obj_id\n\n    def _add_pages_root(self) -> PDFPagesRoot:\n        fpdf = self.fpdf\n        pages_root_obj = PDFPagesRoot(\n            count=fpdf.pages_count,\n            media_box=_dimensions_to_mediabox(fpdf.default_page_dimensions),\n        )\n        self._add_pdf_obj(pages_root_obj)\n        return pages_root_obj\n\n    def _iter_pages_in_order(self) -> Iterator[PDFPage]:\n        for page_index in range(1, self.fpdf.pages_count + 1):\n            page_obj = self.fpdf.pages[page_index]\n            # Defensive check:\n            assert (\n                page_obj.index() == page_index\n            ), f\"{page_obj.index()=} != {page_index=}\"\n            yield page_obj\n\n    def _add_pages(self, _slice: slice = slice(0, None)) -> list[PDFPage]:\n        fpdf = self.fpdf\n        page_objs: list[PDFPage] = []\n        for page_obj in list(self._iter_pages_in_order())[_slice]:\n            if fpdf.pdf_version > \"1.3\" and fpdf.allow_images_transparency:\n                page_obj.group = pdf_dict(\n                    {\"/Type\": \"/Group\", \"/S\": \"/Transparency\", \"/CS\": \"/DeviceRGB\"},\n                    field_join=\" \",\n                )\n            if page_obj.dimensions() != fpdf.default_page_dimensions:\n                page_obj.media_box = _dimensions_to_mediabox(page_obj.dimensions())\n            self._add_pdf_obj(page_obj, \"pages\")\n            page_objs.append(page_obj)\n\n            # Extracting the page contents to insert it as a content stream:\n            assert isinstance(page_obj.contents, bytearray)\n            cs_obj = PDFContentStream(\n                contents=page_obj.contents, compress=fpdf.compress\n            )\n            self._add_pdf_obj(cs_obj, \"pages\")\n            page_obj.contents = cs_obj\n\n        return page_objs\n\n    def _add_annotations_as_objects(self) -> Optional[PDFAnnotation]:\n        sig_annotation_obj = None\n        for page_obj in self.fpdf.pages.values():\n            assert isinstance(page_obj.annots, PDFArray)\n            for annot_obj in page_obj.annots:\n                if isinstance(annot_obj, PDFAnnotation):  # distinct from AnnotationDict\n                    self._add_pdf_obj(annot_obj)\n                    if isinstance(annot_obj.v, Signature):\n                        assert (\n                            sig_annotation_obj is None\n                        ), \"A /Sig annotation is present on more than 1 page\"\n                        sig_annotation_obj = annot_obj\n        return sig_annotation_obj\n\n    def _add_fonts(\n        self,\n        image_objects_per_index: dict[int, PDFXObject],\n        gfxstate_objs_per_name: dict[str, PDFExtGState],\n        pattern_objs_per_name: dict[str, \"Pattern\"],\n    ) -> dict[int, PDFFont | PDFType3Font]:\n        font_objs_per_index: dict[int, PDFFont | PDFType3Font] = {}\n        for font in sorted(self.fpdf.fonts.values(), key=lambda font: font.i):\n\n            # type 3 font\n            if isinstance(font, TTFFont) and font.color_font:\n                if font.subset._next > 0xFF:\n                    raise FPDFException(\n                        \"Type 3 fonts with color glyphs are not supported is more than 255 glyphs are rendered. \"\n                        \"set FPDF.render_color_fonts=False or use less color glyphs.\"\n                    )\n                for color_glyph in font.color_font.glyphs:\n                    color_glyph.obj_id = self._add_pdf_obj(\n                        PDFContentStream(\n                            contents=color_glyph.glyph.encode(\"latin-1\"),\n                            compress=self.fpdf.compress,\n                        ),\n                        \"fonts\",\n                    )\n                bfChar: list[str] = []\n\n                for glyph, code_mapped in font.subset.items():\n                    if (\n                        glyph is None\n                        or not isinstance(glyph.unicode, tuple)\n                        or len(glyph.unicode) == 0\n                    ):\n                        continue\n                    bfChar.append(\n                        f'<{code_mapped:02X}> <{\"\".join(chr(code).encode(\"utf-16-be\").hex().upper() for code in glyph.unicode)}>\\n'\n                    )\n\n                to_unicode_obj = PDFContentStream(\n                    (\n                        \"/CIDInit /ProcSet findresource begin\\n\"\n                        \"12 dict begin\\n\"\n                        \"begincmap\\n\"\n                        \"/CIDSystemInfo\\n\"\n                        \"<</Registry (Adobe)\\n\"\n                        \"/Ordering (UCS)\\n\"\n                        \"/Supplement 0\\n\"\n                        \">> def\\n\"\n                        \"/CMapName /Adobe-Identity-UCS def\\n\"\n                        \"/CMapType 2 def\\n\"\n                        \"1 begincodespacerange\\n\"\n                        \"<00> <FF>\\n\"\n                        \"endcodespacerange\\n\"\n                        f\"{len(bfChar)} beginbfchar\\n\"\n                        f\"{''.join(bfChar)}\"\n                        \"endbfchar\\n\"\n                        \"endcmap\\n\"\n                        \"CMapName currentdict /CMap defineresource pop\\n\"\n                        \"end\\n\"\n                        \"end\"\n                    ).encode(\"latin-1\")\n                )\n                self._add_pdf_obj(to_unicode_obj, \"fonts\")\n\n                t3_font_obj = PDFType3Font(font.color_font)\n                t3_font_obj.to_unicode = pdf_ref(to_unicode_obj.id)\n                t3_font_obj.generate_resources(\n                    image_objects_per_index,\n                    gfxstate_objs_per_name,\n                    pattern_objs_per_name,\n                )\n                self._add_pdf_obj(t3_font_obj, \"fonts\")\n                font_objs_per_index[font.i] = t3_font_obj\n                continue\n\n            # Standard font\n            if isinstance(font, CoreFont):\n                encoding = (\n                    \"WinAnsiEncoding\"\n                    if font.name not in (\"Symbol\", \"ZapfDingbats\")\n                    else None\n                )\n                core_font_obj = PDFFont(\n                    subtype=\"Type1\", base_font=font.name, encoding=encoding\n                )\n                self._add_pdf_obj(core_font_obj, \"fonts\")\n                font_objs_per_index[font.i] = core_font_obj\n            elif isinstance(font, TTFFont):\n                fontname = f\"MPDFAA+{font.name}\"\n\n                # 1. get all glyphs in PDF\n                glyph_names = font.subset.get_all_glyph_names()\n\n                if len(font.missing_glyphs) > 0:\n                    msg = \", \".join(\n                        f\"'{chr(x)}' ({chr(x).encode('unicode-escape').decode()})\"\n                        for x in font.missing_glyphs[:10]\n                    )\n                    if len(font.missing_glyphs) > 10:\n                        msg += f\", ... (and {len(font.missing_glyphs) - 10} others)\"\n                    LOGGER.warning(\n                        \"Font %s is missing the following glyphs: %s\", fontname, msg\n                    )\n\n                # 2. make a subset\n                # notdef_outline=True means that keeps the white box for the .notdef glyph\n                # recommended_glyphs=True means that adds the .notdef, .null, CR, and space glyphs\n                options = ftsubset.Options(notdef_outline=True, recommended_glyphs=True)\n                # dropping some tables that currently not used:\n                options.drop_tables += [\n                    \"FFTM\",  # FontForge Timestamp table - cf. https://github.com/py-pdf/fpdf2/issues/600\n                    \"GDEF\",  # Glyph Definition table = various glyph properties used in OpenType layout processing\n                    \"GPOS\",  # Glyph Positioning table = precise control over glyph placement\n                    #          for sophisticated text layout and rendering in each script and language system\n                    \"GSUB\",  # Glyph Substitution table = data for substitution of glyphs for appropriate rendering of scripts\n                    \"MATH\",  # Mathematical typesetting table = specific information necessary for math formula layout\n                    \"hdmx\",  # Horizontal Device Metrics table, stores integer advance widths scaled to particular pixel sizes\n                    #          for OpenType™ fonts with TrueType outlines\n                    \"meta\",  # metadata table\n                    \"sbix\",  # Apple's SBIX table, used for color bitmap glyphs\n                    \"CBDT\",  # Color Bitmap Data Table\n                    \"CBLC\",  # Color Bitmap Location Table\n                    \"EBDT\",  # Embedded Bitmap Data Table\n                    \"EBLC\",  # Embedded Bitmap Location Table\n                    \"EBSC\",  # Embedded Bitmap Scaling Table\n                    \"SVG \",  # SVG table\n                    \"CPAL\",  # Color Palette table\n                    \"COLR\",  # Color table\n                ]\n                subsetter = ftsubset.Subsetter(options)\n                subsetter.populate(glyphs=glyph_names)\n                subsetter.subset(font.ttfont)\n\n                # 3. make codeToGlyph\n                # is a map Character_ID -> Glyph_ID\n                # it's used for associating glyphs to new codes\n                # this basically takes the old code of the character\n                # take the glyph associated with it\n                # and then associate to the new code the glyph associated with the old code\n\n                code_to_glyph: dict[int, int] = {\n                    char_id: font.ttfont.getGlyphID(glyph.glyph_name)\n                    for glyph, char_id in font.subset.items()\n                    if glyph is not None\n                }\n\n                # 4. return the ttfile\n                output = BytesIO()\n                font.ttfont.save(output)\n\n                output.seek(0)\n                ttfontstream = output.read()\n\n                # A composite font - a font composed of other fonts,\n                # organized hierarchically\n                composite_font_obj = PDFFont(\n                    subtype=\"Type0\", base_font=fontname, encoding=\"Identity-H\"\n                )\n                self._add_pdf_obj(composite_font_obj, \"fonts\")\n                font_objs_per_index[font.i] = composite_font_obj\n\n                # A CIDFont whose glyph descriptions are based on\n                # TrueType font technology\n                cid_font_obj = PDFFont(\n                    subtype=\"CIDFontType2\",\n                    base_font=fontname,\n                    d_w=font.desc.missing_width,\n                    w=_tt_font_widths(font),\n                )\n                self._add_pdf_obj(cid_font_obj, \"fonts\")\n                composite_font_obj.descendant_fonts = PDFArray([cid_font_obj])\n\n                # bfChar\n                # This table informs the PDF reader about the unicode\n                # character that each used 16-bit code belongs to. It\n                # allows searching the file and copying text from it.\n                bfChar = []\n\n                def format_code(unicode: int) -> str:\n                    if unicode > 0xFFFF:\n                        # Calculate surrogate pair\n                        code_high = 0xD800 | (unicode - 0x10000) >> 10\n                        code_low = 0xDC00 | (unicode & 0x3FF)\n                        return f\"{code_high:04X}{code_low:04X}\"\n                    return f\"{unicode:04X}\"\n\n                for glyph, code_mapped in font.subset.items():\n                    if (\n                        glyph is None\n                        or not isinstance(glyph.unicode, tuple)\n                        or len(glyph.unicode) == 0\n                    ):\n                        continue\n                    bfChar.append(\n                        f'<{code_mapped:04X}> <{\"\".join(format_code(code) for code in glyph.unicode)}>\\n'\n                    )\n\n                to_unicode_obj = PDFContentStream(\n                    (\n                        \"/CIDInit /ProcSet findresource begin\\n\"\n                        \"12 dict begin\\n\"\n                        \"begincmap\\n\"\n                        \"/CIDSystemInfo\\n\"\n                        \"<</Registry (Adobe)\\n\"\n                        \"/Ordering (UCS)\\n\"\n                        \"/Supplement 0\\n\"\n                        \">> def\\n\"\n                        \"/CMapName /Adobe-Identity-UCS def\\n\"\n                        \"/CMapType 2 def\\n\"\n                        \"1 begincodespacerange\\n\"\n                        \"<0000> <FFFF>\\n\"\n                        \"endcodespacerange\\n\"\n                        f\"{len(bfChar)} beginbfchar\\n\"\n                        f\"{''.join(bfChar)}\"\n                        \"endbfchar\\n\"\n                        \"endcmap\\n\"\n                        \"CMapName currentdict /CMap defineresource pop\\n\"\n                        \"end\\n\"\n                        \"end\"\n                    ).encode(\"latin-1\")\n                )\n                self._add_pdf_obj(to_unicode_obj, \"fonts\")\n                composite_font_obj.to_unicode = to_unicode_obj\n\n                cid_system_info_obj = CIDSystemInfo()\n                self._add_pdf_obj(cid_system_info_obj, \"fonts\")\n                cid_font_obj.c_i_d_system_info = cid_system_info_obj\n\n                font_descriptor_obj = font.desc\n                font_descriptor_obj.font_name = Name(fontname)\n                self._add_pdf_obj(font_descriptor_obj, \"fonts\")\n                cid_font_obj.font_descriptor = font_descriptor_obj\n\n                # Embed CIDToGIDMap\n                # A specification of the mapping from CIDs to glyph indices\n                cid_to_gid_list = [\"\\x00\"] * 256 * 256 * 2\n                for cc, glyph_i in code_to_glyph.items():\n                    cid_to_gid_list[cc * 2] = chr(glyph_i >> 8)\n                    cid_to_gid_list[cc * 2 + 1] = chr(glyph_i & 0xFF)\n                cid_to_gid_map = \"\".join(cid_to_gid_list)\n\n                # manage binary data as latin1 until PEP461-like function is implemented\n                cid_to_gid_map_obj = PDFContentStream(\n                    contents=cid_to_gid_map.encode(\"latin1\"), compress=True\n                )\n                self._add_pdf_obj(cid_to_gid_map_obj, \"fonts\")\n                cid_font_obj.c_i_d_to_g_i_d_map = cid_to_gid_map_obj\n\n                font_file_cs_obj = PDFFontStream(contents=ttfontstream)\n                self._add_pdf_obj(font_file_cs_obj, \"fonts\")\n                font_descriptor_obj.font_file2 = font_file_cs_obj  # type: ignore[attr-defined]\n\n                font.subset.pick.cache_clear()\n                font.subset.get_glyph.cache_clear()\n                font.close()\n\n        return font_objs_per_index\n\n    def _add_images(self) -> dict[int, PDFXObject]:\n        img_objs_per_index: dict[int, PDFXObject] = {}\n        for img in sorted(\n            self.fpdf.image_cache.images.values(), key=lambda img: cast(int, img[\"i\"])\n        ):\n            if cast(int, img[\"usages\"]) > 0:\n                img_objs_per_index[cast(int, img[\"i\"])] = self._add_image(img)\n        return img_objs_per_index\n\n    def _ensure_iccp(self, img_info: dict[str, object]) -> int:\n        \"\"\"\n        Returns the PDF object of the ICC profile indexed iccp_i in the FPDF object.\n        Adds it if not present.\n        \"\"\"\n        iccp_i = cast(int, img_info[\"iccp_i\"])\n        if iccp_i in self.iccp_i_to_pdf_i:\n            return self.iccp_i_to_pdf_i[iccp_i]\n        iccp_content = None\n        for iccp_c, i in self.fpdf.image_cache.icc_profiles.items():\n            if iccp_i == i:\n                iccp_content = iccp_c\n                break\n        assert iccp_content is not None\n        # Note: n should be 4 if the profile ColorSpace is CMYK\n        iccp_obj = PDFICCProfile(\n            contents=iccp_content,\n            n=cast(int, img_info[\"dpn\"]),\n            alternate=cast(str, img_info[\"cs\"]),\n        )\n        iccp_pdf_i = self._add_pdf_obj(iccp_obj, \"iccp\")\n        self.iccp_i_to_pdf_i[iccp_i] = iccp_pdf_i\n        return iccp_pdf_i\n\n    def _add_image(self, info: dict[str, object]) -> PDFXObject:\n        color_space: Name | PDFArray = Name(info[\"cs\"])\n        decode = None\n        iccp_i = info.get(\"iccp_i\")\n        if color_space == \"Indexed\":\n            color_space = PDFArray(\n                [\"/Indexed\", \"/DeviceRGB\", f\"{len(info['pal']) // 3 - 1}\"]  # type: ignore[arg-type]\n            )\n        elif iccp_i is not None:\n            iccp_pdf_i = self._ensure_iccp(info)\n            color_space = PDFArray([\"/ICCBased\", str(iccp_pdf_i), str(\"0\"), \"R\"])\n        elif color_space == \"DeviceCMYK\":\n            if info[\"inverted\"] is True:\n                decode = \"[1 0 1 0 1 0 1 0]\"\n\n        decode_parms = f\"<<{info['dp']} /BitsPerComponent {info['bpc']}>>\"\n        img_obj = PDFXObject(\n            subtype=\"Image\",\n            contents=cast(bytes, info[\"data\"]),\n            width=cast(int, info[\"w\"]),\n            height=cast(int, info[\"h\"]),\n            color_space=color_space,\n            bits_per_component=cast(int, info[\"bpc\"]),\n            img_filter=cast(str, info[\"f\"]),\n            decode=decode,\n            decode_parms=decode_parms,\n        )\n        info[\"obj_id\"] = self._add_pdf_obj(img_obj, \"images\")\n\n        # Soft mask\n        if self.fpdf.allow_images_transparency and \"smask\" in info:\n            dp = f\"/Predictor 15 /Colors 1 /Columns {info['w']}\"\n            img_obj.s_mask = self._add_image(\n                {\n                    \"w\": info[\"w\"],\n                    \"h\": info[\"h\"],\n                    \"cs\": \"DeviceGray\",\n                    \"bpc\": 8,\n                    \"f\": info[\"f\"],\n                    \"dp\": dp,\n                    \"data\": info[\"smask\"],\n                }\n            )\n\n        # Palette\n        if \"/Indexed\" in color_space:\n            assert isinstance(img_obj.color_space, PDFArray)\n            pal_cs_obj = PDFContentStream(\n                contents=cast(bytes, info[\"pal\"]), compress=self.fpdf.compress\n            )\n            self._add_pdf_obj(pal_cs_obj, \"images\")\n            img_obj.color_space.append(pdf_ref(pal_cs_obj.id))\n\n        return img_obj\n\n    def _add_gfxstates(self) -> dict[str, PDFExtGState]:\n        gfxstate_objs_per_name: dict[str, PDFExtGState] = OrderedDict()\n        for state_dict, name in self.fpdf._resource_catalog.graphics_styles.items():\n            gfxstate_obj = PDFExtGState(state_dict)\n            self._add_pdf_obj(gfxstate_obj, \"gfxstate\")\n            gfxstate_objs_per_name[name] = gfxstate_obj\n        return gfxstate_objs_per_name\n\n    def _add_soft_masks(\n        self,\n        gfxstate_objs_per_name: dict[str, PDFExtGState],\n        pattern_objs_per_name: dict[str, \"Pattern\"],\n    ) -> None:\n        \"\"\"Append soft-mask Form XObjects after patterns exist so we can resolve /Pattern ids.\"\"\"\n        for soft_mask in self.fpdf._resource_catalog.soft_mask_xobjects:\n            soft_mask.resources = soft_mask._path.get_resource_dictionary(  # type: ignore[attr-defined]\n                gfxstate_objs_per_name, pattern_objs_per_name\n            )\n            self.pdf_objs.append(soft_mask)\n\n    def _register_form_xobject_placeholders(\n        self, img_objs_per_index: dict[int, PDFXObject]\n    ) -> None:\n        \"\"\"Ensure isolated blend forms are part of the XObject set before other resources rely on them.\"\"\"\n        for index, xobject in self.fpdf._resource_catalog.form_xobjects:\n            if not getattr(xobject, \"_registered\", False):\n                self._add_pdf_obj(xobject, \"images\")\n                xobject._registered = True  # type: ignore[attr-defined]\n            img_objs_per_index.setdefault(index, xobject)  # type: ignore[arg-type]\n\n    def _finalize_form_xobjects(\n        self,\n        img_objs_per_index: dict[int, PDFXObject],\n        gfxstate_objs_per_name: dict[str, PDFExtGState],\n        pattern_objs_per_name: dict[str, Pattern],\n        shading_objs_per_name: dict[str, Shading | MeshShading],\n        font_objs_per_index: dict[int, PDFFont | PDFType3Font],\n    ) -> None:\n        \"\"\"Populate resource dictionaries for isolated blend Form XObjects.\"\"\"\n        for _, xobject in self.fpdf._resource_catalog.form_xobjects:\n            blend_group = getattr(xobject, \"_blend_group\", None)\n            if blend_group is not None:\n                xobject.resources = blend_group.get_resource_dictionary(  # type: ignore[attr-defined]\n                    gfxstate_objs_per_name,\n                    pattern_objs_per_name,\n                    shading_objs_per_name,\n                    font_objs_per_index,\n                    img_objs_per_index,\n                )\n\n    def _add_shadings(self) -> dict[str, Shading | MeshShading]:\n        shading_objs_per_name: dict[str, Shading | MeshShading] = OrderedDict()\n        for shading, name in self.fpdf._resource_catalog.get_items(\n            PDFResourceType.SHADING\n        ):\n            assert isinstance(shading, (Gradient, Shading, MeshShading))\n            for function in shading.get_functions():\n                self._add_pdf_obj(function, \"function\")\n            shading_obj: Shading | MeshShading = shading.get_shading_object()\n            self._add_pdf_obj(shading_obj, \"shading\")\n            shading_objs_per_name[name] = shading_obj\n        return shading_objs_per_name\n\n    def _add_patterns(self) -> dict[str, Pattern]:\n        pattern_objs_per_name: dict[str, Pattern] = OrderedDict()\n        for pattern, name in self.fpdf._resource_catalog.get_items(\n            PDFResourceType.PATTERN\n        ):\n            assert isinstance(pattern, Pattern)\n            self._add_pdf_obj(pattern, \"pattern\")\n            pattern_objs_per_name[name] = pattern\n            if pattern.get_apply_page_ctm():\n                pattern.set_matrix(\n                    pattern.get_matrix()\n                    @ Transform.translation(0, -self.fpdf.h)\n                    .scale(x=1, y=-1)\n                    .scale(self.fpdf.k)\n                )\n\n        return pattern_objs_per_name\n\n    def _insert_resources(self, page_objs: list[PDFPage]) -> None:\n        img_objs_per_index = self._add_images()\n        self._register_form_xobject_placeholders(img_objs_per_index)\n        gfxstate_objs_per_name = self._add_gfxstates()\n        pattern_objs_per_name = self._add_patterns()\n        font_objs_per_index = self._add_fonts(\n            img_objs_per_index, gfxstate_objs_per_name, pattern_objs_per_name\n        )\n        shading_objs_per_name = self._add_shadings()\n        self._finalize_form_xobjects(\n            img_objs_per_index,\n            gfxstate_objs_per_name,\n            pattern_objs_per_name,\n            shading_objs_per_name,\n            font_objs_per_index,\n        )\n        self._add_soft_masks(gfxstate_objs_per_name, pattern_objs_per_name)\n        # Insert /Resources dicts:\n        if self.fpdf.single_resources_object:\n            resources_dict_obj = self._add_resources_dict(\n                font_objs_per_index,\n                img_objs_per_index,\n                gfxstate_objs_per_name,\n                shading_objs_per_name,\n                pattern_objs_per_name,\n            )\n            for page_obj in page_objs:\n                page_obj.resources = resources_dict_obj\n        else:\n            for page_number, page_obj in enumerate(page_objs, start=1):\n                page_font_objs_per_index = {\n                    int(font_id): font_objs_per_index[int(font_id)]  # type: ignore[arg-type]\n                    for font_id in self.fpdf._resource_catalog.get_resources_per_page(\n                        page_number, PDFResourceType.FONT\n                    )\n                }\n                page_img_objs_per_index = {\n                    int(img_id): img_objs_per_index[int(img_id)]  # type: ignore[arg-type]\n                    for img_id in self.fpdf._resource_catalog.get_resources_per_page(\n                        page_number, PDFResourceType.X_OBJECT\n                    )\n                }\n                page_gfxstate_objs_per_name = {\n                    gfx_name: gfx_state\n                    for (gfx_name, gfx_state) in gfxstate_objs_per_name.items()\n                    if gfx_name\n                    in self.fpdf._resource_catalog.get_resources_per_page(\n                        page_number, PDFResourceType.EXT_G_STATE\n                    )\n                }\n                page_shading_objs_per_name = {\n                    str(shading_name): shading_objs_per_name[str(shading_name)]\n                    for shading_name in self.fpdf._resource_catalog.get_resources_per_page(\n                        page_number, PDFResourceType.SHADING\n                    )\n                }\n                page_pattern_objs_per_name = {\n                    str(pattern_name): pattern_objs_per_name[str(pattern_name)]\n                    for pattern_name in self.fpdf._resource_catalog.get_resources_per_page(\n                        page_number, PDFResourceType.PATTERN\n                    )\n                }\n\n                page_obj.resources = self._add_resources_dict(\n                    page_font_objs_per_index,\n                    page_img_objs_per_index,\n                    page_gfxstate_objs_per_name,\n                    page_shading_objs_per_name,\n                    page_pattern_objs_per_name,\n                )\n\n    def _add_resources_dict(\n        self,\n        font_objs_per_index: dict[int, PDFFont | PDFType3Font],\n        img_objs_per_index: dict[int, PDFXObject],\n        gfxstate_objs_per_name: dict[str, PDFExtGState],\n        shading_objs_per_name: dict[str, Shading | MeshShading],\n        pattern_objs_per_name: dict[str, Pattern],\n    ) -> PDFResources:\n        # From section 10.1, \"Procedure sets\", of PDF 1.7 spec:\n        # > Beginning with PDF 1.4, this feature is considered obsolete.\n        # > For compatibility with existing consumer applications,\n        # > PDF producer applications should continue to specify procedure sets\n        # > (preferably, all of those listed in Table 10.1).\n        proc_set = \"[/PDF /Text /ImageB /ImageC /ImageI]\"\n        font, x_object, ext_g_state, shading, pattern = None, None, None, None, None\n\n        if font_objs_per_index:\n            font = pdf_dict(\n                {\n                    f\"/F{index}\": pdf_ref(font_obj.id)\n                    for index, font_obj in sorted(font_objs_per_index.items())\n                }\n            )\n\n        if img_objs_per_index:\n            x_object = pdf_dict(\n                {\n                    f\"/I{index}\": pdf_ref(img_obj.id)\n                    for index, img_obj in sorted(img_objs_per_index.items())\n                }\n            )\n\n        if gfxstate_objs_per_name:\n            ext_g_state = pdf_dict(\n                {\n                    f\"/{name}\": pdf_ref(gfxstate_obj.id)\n                    for name, gfxstate_obj in gfxstate_objs_per_name.items()\n                }\n            )\n        if shading_objs_per_name:\n            shading = pdf_dict(\n                {\n                    f\"/{name}\": pdf_ref(shading_obj.id)\n                    for name, shading_obj in sorted(shading_objs_per_name.items())\n                }\n            )\n\n        if pattern_objs_per_name:\n            pattern = pdf_dict(\n                {\n                    f\"/{name}\": pdf_ref(pattern_obj.id)\n                    for name, pattern_obj in sorted(pattern_objs_per_name.items())\n                }\n            )\n\n        resources_obj = PDFResources(\n            proc_set=proc_set,\n            font=font,\n            x_object=x_object,\n            ext_g_state=ext_g_state,\n            shading=shading,\n            pattern=pattern,\n        )\n        self._add_pdf_obj(resources_obj)\n        return resources_obj\n\n    def _add_structure_tree(self) -> Optional[PDFObject]:\n        \"Builds a Structure Hierarchy, including image alternate descriptions\"\n        if self.fpdf.struct_builder.empty():\n            return None\n        struct_tree_root_obj = None\n        for pdf_obj in self.fpdf.struct_builder:\n            if struct_tree_root_obj is None:\n                struct_tree_root_obj = pdf_obj\n            self._add_pdf_obj(pdf_obj, \"structure_tree\")\n        return struct_tree_root_obj\n\n    def _add_document_outline(\n        self,\n    ) -> tuple[Optional[OutlineDictionary], Sequence[OutlineItemDictionary]]:\n        if not self.fpdf._outline:\n            return None, ()\n        outline_dict_obj: Optional[OutlineDictionary] = None\n        outline_items: list[OutlineItemDictionary] = []\n        for pdf_obj in build_outline_objs(self.fpdf._outline):\n            if isinstance(pdf_obj, OutlineDictionary):\n                outline_dict_obj = pdf_obj\n            else:\n                outline_items.append(pdf_obj)\n            self._add_pdf_obj(pdf_obj, \"document_outline\")\n        return outline_dict_obj, outline_items\n\n    def _add_xmp_metadata(self) -> Optional[PDFXmpMetadata]:\n        # Prefer explicitly provided XMP (user-supplied inner <x:xmpmeta/> without xpacket):\n        xmp_src = self.fpdf.xmp_metadata\n        # If not provided but a PDF/A document is being created, synthesize it:\n        if not xmp_src and self.fpdf._compliance:\n            xmp_src = self._build_xmp_from_info()\n        if not xmp_src:\n            return None\n        xpacket = f'<?xpacket begin=\"{chr(0xFEFF)}\" id=\"W5M0MpCehiHzreSzNTczkc9d\"?>\\n{xmp_src}\\n<?xpacket end=\"w\"?>\\n'\n        pdf_obj = PDFXmpMetadata(xpacket)\n        self._add_pdf_obj(pdf_obj)\n        return pdf_obj\n\n    def _build_xmp_from_info(self) -> str:\n        title = getattr(self.fpdf, \"title\", None) or \"\"\n        subject = getattr(self.fpdf, \"subject\", None) or \"\"\n        author = getattr(self.fpdf, \"author\", None) or \"\"\n        if author and isinstance(author, str):\n            author = [author]\n        keywords = getattr(self.fpdf, \"keywords\", None) or \"\"\n        if keywords and isinstance(keywords, str):\n            keywords = [keywords]\n        creator_tool = getattr(self.fpdf, \"creator\", None) or \"\"\n        producer = getattr(self.fpdf, \"producer\", None) or \"\"\n        cdate = getattr(self.fpdf, \"creation_date\", None)\n        creation_date_utc = None\n        if isinstance(cdate, datetime):\n            creation_date_utc = cdate if cdate.tzinfo else cdate.astimezone()\n            creation_date_utc = creation_date_utc.astimezone(timezone.utc)\n        pdfa = self.fpdf._compliance\n\n        # Escape for XML attributes/PCDATA:\n        def esc(s: str) -> str:\n            \"\"\"Return XML-escaped text suitable for XMP (attributes or text nodes).\"\"\"\n            value = \"\" if s is None else _html_escape(str(s), quote=True)\n            return value.replace(\"'\", \"&apos;\")\n\n        # XMP times are ISO 8601 (e.g., 2025-09-01T12:34:56+02:00):\n        EPOCH = datetime(1969, 12, 31, 19, 0, 0, tzinfo=timezone.utc)\n        now = datetime.now(timezone.utc)\n        if creation_date_utc == EPOCH:\n            xmp_create = EPOCH.isoformat(timespec=\"seconds\")\n            xmp_modify = EPOCH.isoformat(timespec=\"seconds\")\n        else:\n            create_dt = creation_date_utc or now\n            xmp_create = create_dt.isoformat(timespec=\"seconds\")\n            xmp_modify = now.isoformat(timespec=\"seconds\")\n        # Build a single Description that includes everything + pdfaid if requested:\n        parts = [\n            '<x:xmpmeta xmlns:x=\"adobe:ns:meta/\" x:xmptk=\"fpdf2\">',\n            \"  <rdf:RDF\",\n            '    xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"',\n            '    xmlns:dc=\"http://purl.org/dc/elements/1.1/\"',\n            '    xmlns:xmp=\"http://ns.adobe.com/xap/1.0/\"',\n            '    xmlns:pdf=\"http://ns.adobe.com/pdf/1.3/\"',\n            '    xmlns:pdfaid=\"http://www.aiim.org/pdfa/ns/id/\">',\n            '    <rdf:Description rdf:about=\"\"',\n        ]\n        # attributes block (xmp, pdf, pdfaid)\n        if creator_tool:\n            parts.append(f'        xmp:CreatorTool=\"{esc(creator_tool)}\"')\n        if xmp_create:\n            parts.append(f'        xmp:CreateDate=\"{esc(xmp_create)}\"')\n            parts.append(f'        xmp:ModifyDate=\"{esc(xmp_modify)}\"')\n            parts.append(f'        xmp:MetadataDate=\"{esc(xmp_modify)}\"')\n        if producer:\n            parts.append(f'        pdf:Producer=\"{esc(producer)}\"')\n        if keywords:\n            keyword_list = \",\".join(keywords)\n            parts.append(f'        pdf:Keywords=\"{esc(keyword_list)}\"')\n        parts.append(\"      >\")\n        # nested elements (Lang Alt / Seqs)\n        if pdfa:\n            parts.append(f\"      <pdfaid:part>{int(pdfa.part)}</pdfaid:part>\")\n            if pdfa.conformance:\n                parts.append(\n                    f\"      <pdfaid:conformance>{esc(pdfa.conformance)}</pdfaid:conformance>\"\n                )\n            if pdfa.part == 4:\n                parts.append(\"      <pdfaid:rev>2020</pdfaid:rev>\")\n        if title:\n            parts += [\n                \"      <dc:title><rdf:Alt>\",\n                '        <rdf:li xml:lang=\"x-default\">' + esc(title) + \"</rdf:li>\",\n                \"      </rdf:Alt></dc:title>\",\n            ]\n        if subject:\n            parts += [\n                \"      <dc:description><rdf:Alt>\",\n                '        <rdf:li xml:lang=\"x-default\">' + esc(subject) + \"</rdf:li>\",\n                \"      </rdf:Alt></dc:description>\",\n            ]\n        if author:\n            parts.append(\"      <dc:creator><rdf:Seq>\")\n            for a in author:\n                parts.append(f\"        <rdf:li>{esc(a)}</rdf:li>\")\n            parts.append(\"      </rdf:Seq></dc:creator>\")\n        parts += [\n            \"    </rdf:Description>\",\n            \"  </rdf:RDF>\",\n            \"</x:xmpmeta>\",\n        ]\n        return \"\\n\".join(parts)\n\n    def _add_info(self) -> PDFInfo:\n        fpdf = self.fpdf\n        try:\n            creation_date = PDFDate(fpdf.creation_date, with_tz=True, encrypt=True)\n        except Exception as error:\n            raise FPDFException(\n                f\"Could not format date: {fpdf.creation_date}\"\n            ) from error\n        info_obj = PDFInfo(\n            title=fpdf.title,\n            subject=getattr(fpdf, \"subject\", None),\n            author=getattr(fpdf, \"author\", None),\n            keywords=getattr(fpdf, \"keywords\", None),\n            creator=getattr(fpdf, \"creator\", None),\n            producer=getattr(fpdf, \"producer\", None),\n            creation_date=creation_date,\n        )\n        self._add_pdf_obj(info_obj)\n        return info_obj\n\n    def _add_encryption(self) -> Optional[\"EncryptionDictionary\"]:\n        if self.fpdf._security_handler:\n            encryption_handler = self.fpdf._security_handler\n            pdf_obj = encryption_handler.get_encryption_obj()\n            self._add_pdf_obj(pdf_obj)\n            return pdf_obj\n        return None\n\n    def _add_output_intents(self) -> Optional[PDFArray]:\n        \"\"\"should be added in _add_catalog\"\"\"\n        output_intents = self.fpdf.output_intents\n        if not output_intents:\n            return None\n        for output_intent in output_intents:\n            if output_intent.dest_output_profile:\n                self._add_pdf_obj(output_intent.dest_output_profile)\n        return PDFArray(output_intents)\n\n    def _add_catalog(self) -> PDFCatalog:\n        fpdf = self.fpdf\n        catalog_obj = PDFCatalog(\n            lang=getattr(fpdf, \"lang\", None),\n            page_layout=fpdf.page_layout,\n            page_mode=fpdf.page_mode,\n            viewer_preferences=fpdf.viewer_preferences,\n        )\n        catalog_obj.output_intents = self._add_output_intents()\n\n        self._add_pdf_obj(catalog_obj)\n        return catalog_obj\n\n    def _finalize_catalog(\n        self,\n        catalog_obj: PDFCatalog,\n        pages_root_obj: PDFPagesRoot,\n        first_page_obj: PDFPage,\n        sig_annotation_obj: Optional[PDFAnnotation],\n        xmp_metadata_obj: Optional[PDFXmpMetadata],\n        struct_tree_root_obj: Optional[PDFObject],\n        outline_dict_obj: Optional[OutlineDictionary],\n    ) -> None:\n        fpdf = self.fpdf\n        catalog_obj.pages = pages_root_obj\n        catalog_obj.struct_tree_root = struct_tree_root_obj\n        catalog_obj.outlines = outline_dict_obj\n        catalog_obj.metadata = xmp_metadata_obj\n        if sig_annotation_obj:\n            flags = SignatureFlag.SIGNATURES_EXIST + SignatureFlag.APPEND_ONLY\n            catalog_obj.acro_form = AcroForm(\n                fields=PDFArray([sig_annotation_obj]), sig_flags=flags\n            )\n        if fpdf.zoom_mode in ZOOM_CONFIGS:\n            zoom_config = [\n                pdf_ref(first_page_obj.id),\n                *ZOOM_CONFIGS[fpdf.zoom_mode],  # type: ignore[index]\n            ]\n        else:  # zoom_mode is a number, not one of the allowed strings:\n            zoom_config = [\n                pdf_ref(first_page_obj.id),\n                \"/XYZ\",\n                \"null\",\n                \"null\",\n                str(cast(float, fpdf.zoom_mode) / 100),\n            ]\n        catalog_obj.open_action = pdf_list(zoom_config)\n        if struct_tree_root_obj:\n            catalog_obj.mark_info = pdf_dict({\"/Marked\": \"true\"})\n        if fpdf.embedded_files or fpdf.named_destinations:\n            names_dict_entries: dict[str, str] = {}\n\n            if fpdf.embedded_files:\n                file_spec_names = [\n                    f\"{PDFString(embedded_file.basename()).serialize()} {embedded_file.file_spec().ref}\"\n                    for embedded_file in fpdf.embedded_files\n                ]\n                names_dict_entries[\"/EmbeddedFiles\"] = pdf_dict(\n                    {\"/Names\": pdf_list(file_spec_names)}\n                )\n                global_file_specs = [\n                    pdf_ref(ef.file_spec().id)\n                    for ef in self.fpdf.embedded_files\n                    if ef.globally_enclosed()\n                ]\n                if global_file_specs:\n                    catalog_obj.a_f = pdf_list(global_file_specs)\n\n            if fpdf.named_destinations:\n                # Create a list of name/destination pairs for the Dests name tree\n                dests_names: list[str] = []\n                for name, dest in fpdf.named_destinations.items():\n                    # Check if this is a placeholder destination (page 0)\n                    if dest.page_number == 0:\n                        raise FPDFException(\n                            f\"Named destination '{name}' was referenced but never set with set_link(name=...)\"\n                        )\n\n                    # Ensure the destination's page_ref is set\n                    if not hasattr(dest, \"page_ref\") or not dest.page_ref:\n                        assert dest.page_number is not None\n                        page_index = dest.page_number - 1\n                        if 0 <= page_index < len(fpdf.pages):\n                            dest.page_ref = pdf_ref(fpdf.pages[dest.page_number].id)\n\n                    # Add name and destination to the Dests list\n                    dests_names.append(\n                        f\"{PDFString(name, encrypt=True).serialize(_security_handler=fpdf._security_handler, _obj_id=catalog_obj.id)} {dest.serialize()}\"\n                    )\n\n                if dests_names:\n                    names_dict_entries[\"/Dests\"] = pdf_dict(\n                        {\"/Names\": pdf_list(sorted(dests_names))}\n                    )\n\n            catalog_obj.names = pdf_dict(names_dict_entries)\n\n        page_labels = [\n            f\"{i} {pdf_dict(label.serialize())}\"\n            for i, page in enumerate(self._iter_pages_in_order())\n            if (label := page.get_page_label()) is not None\n        ]\n        if page_labels and not fpdf.pages[1].get_page_label():\n            # If page labels are used, an entry for sequence 0 is mandatory\n            page_labels.insert(0, \"0 <<>>\")\n        if page_labels:\n            catalog_obj.page_labels = pdf_dict(\n                {\"/Nums\": PDFArray(page_labels).serialize()}\n            )\n\n    @contextmanager\n    def _trace_size(self, label: str) -> Iterator[None]:\n        prev_size = len(self.buffer)\n        yield\n        self.sections_size_per_trace_label[label] += len(self.buffer) - prev_size\n\n    def _log_final_sections_sizes(self) -> None:\n        LOGGER.debug(\"Final size summary of the biggest document sections:\")\n        for label, section_size in self.sections_size_per_trace_label.items():\n            LOGGER.debug(\"- %s: %s\", label, _sizeof_fmt(section_size))",
      "language": "python"
    },
    {
      "code": "def bufferize(self) -> bytearray:\n    \"\"\"\n    This method alters the target FPDF instance\n    by assigning IDs to all PDF objects,\n    plus a few other properties on PDFPage instances\n    \"\"\"\n    fpdf = self.fpdf\n\n    # 1. setup - Insert all PDF objects\n    #    and assign unique consecutive numeric IDs to all of them\n\n    if fpdf._security_handler is not None:\n        # get the file_id and generate passwords needed to encrypt streams and strings\n        file_id: Optional[str | Literal[-1]] = fpdf.file_id()\n        if file_id == -1:\n            # no custom file id - use default file id so encryption passwords can be generated\n            file_id = fpdf._default_file_id(bytearray(0x00))\n        fpdf._security_handler.generate_passwords(str(file_id))\n\n    pdf_version = fpdf.pdf_version\n    if (\n        fpdf.viewer_preferences\n        and fpdf.viewer_preferences._min_pdf_version > pdf_version\n    ):\n        pdf_version = fpdf.viewer_preferences._min_pdf_version\n    self.pdf_objs.append(PDFHeader(pdf_version))\n    pages_root_obj = self._add_pages_root()\n    catalog_obj = self._add_catalog()\n    page_objs = self._add_pages()\n    sig_annotation_obj = self._add_annotations_as_objects()\n    for embedded_file in fpdf.embedded_files:\n        self._add_pdf_obj(embedded_file, \"embedded_files\")\n        self._add_pdf_obj(embedded_file.file_spec(), \"file_spec\")\n    self._insert_resources(page_objs)\n    struct_tree_root_obj = self._add_structure_tree()\n    outline_dict_obj, outline_items = self._add_document_outline()\n    xmp_metadata_obj = self._add_xmp_metadata()\n    info_obj = None\n    if not fpdf._compliance:\n        info_obj = self._add_info()\n    encryption_obj = self._add_encryption()\n\n    xref = PDFXrefAndTrailer(self)\n    self.pdf_objs.append(xref)\n\n    # 2. Plumbing - Inject all PDF object references required:\n    pages_root_obj.kids = PDFArray(page_objs)\n    self._finalize_catalog(\n        catalog_obj,\n        pages_root_obj=pages_root_obj,\n        first_page_obj=page_objs[0],\n        sig_annotation_obj=sig_annotation_obj,\n        xmp_metadata_obj=xmp_metadata_obj,\n        struct_tree_root_obj=struct_tree_root_obj,\n        outline_dict_obj=outline_dict_obj,\n    )\n    dests: list[DestinationXYZ] = []\n    for page_obj in page_objs:\n        page_obj.parent = pages_root_obj\n        assert isinstance(page_obj.annots, PDFArray)\n        for annot in page_obj.annots:\n            page_dests: list[DestinationXYZ] = []\n            if annot.dest:\n                # Only add to page_dests if it's a Destination object (not a string/PDFString)\n                if hasattr(annot.dest, \"page_number\"):\n                    page_dests.append(annot.dest)\n            if annot.a and hasattr(annot.a, \"dest\"):\n                # Only add to page_dests if it's a Destination object (not a string/PDFString)\n                if hasattr(annot.a.dest, \"page_number\"):\n                    page_dests.append(annot.a.dest)\n            for dest in page_dests:\n                if dest.page_number > len(page_objs):\n                    raise ValueError(\n                        f\"Invalid reference to non-existing page {dest.page_number} present on page {page_obj.index()}: \"\n                    )\n            dests.extend(page_dests)\n        if not page_obj.annots:\n            # Avoid serializing an empty PDFArray:\n            page_obj.annots = None\n    for outline_item in outline_items:\n        if outline_item.dest is not None:\n            dests.append(outline_item.dest)\n    # Assigning the .page_ref property of all Destination objects:\n    for dest in dests:\n        dest.page_ref = pdf_ref(\n            page_objs[\n                dest.page_number - 1\n            ].id  # pyright: ignore[reportUnknownArgumentType]\n        )\n    for struct_elem in fpdf.struct_builder.doc_struct_elem.k:\n        struct_elem.pg = page_objs[struct_elem.page_number() - 1]\n    xref.catalog_obj = catalog_obj\n    xref.info_obj = info_obj\n    xref.encryption_obj = encryption_obj\n\n    # 3. Serializing - Append all PDF objects to the buffer:\n    assert (\n        not self.buffer\n    ), f\"Nothing should have been appended to the .buffer at this stage: {self.buffer}\"\n    assert (\n        not self.offsets\n    ), f\"No offset should have been set at this stage: {len(self.offsets)}\"\n\n    for pdf_obj in self.pdf_objs:\n        if isinstance(pdf_obj, ContentWithoutID):\n            # top header, xref table & trailer:\n            trace_label = None\n        else:\n            self.offsets[pdf_obj.id] = len(self.buffer)\n            trace_label = self.trace_labels_per_obj_id.get(pdf_obj.id)\n        if trace_label:\n            with self._trace_size(trace_label):\n                self._out(\n                    pdf_obj.serialize(_security_handler=fpdf._security_handler)\n                )\n        else:\n            self._out(pdf_obj.serialize(_security_handler=fpdf._security_handler))\n    self._log_final_sections_sizes()\n\n    if fpdf._sign_key:\n        self.buffer = sign_content(\n            signer,  # pyright: ignore[reportArgumentType]\n            self.buffer,\n            fpdf._sign_key,\n            fpdf._sign_cert,\n            fpdf._sign_extra_certs,\n            fpdf._sign_hashalgo,\n            fpdf._sign_time,\n        )\n    return self.buffer",
      "language": "python"
    },
    {
      "code": "class PDFCatalog(PDFObject):\n    def __init__(\n        self,\n        lang: Optional[str] = None,\n        page_layout: Optional[\"PageLayout\"] = None,\n        page_mode: Optional[\"PageMode\"] = None,\n        viewer_preferences: Optional[\"ViewerPreferences\"] = None,\n    ) -> None:\n        super().__init__()\n        self.type = Name(\"Catalog\")\n        self.lang = PDFString(lang) if lang else None\n        self.page_layout = page_layout\n        self.page_mode = page_mode\n        self.viewer_preferences = viewer_preferences\n        self.pages: Optional[PDFPagesRoot] = (\n            None  # Required; shall be an indirect reference\n        )\n        self.acro_form: Optional[AcroForm] = None\n        self.open_action: Optional[str] = None\n        self.mark_info: Optional[str] = None\n        self.metadata: Optional[PDFXmpMetadata] = None\n        self.names: Optional[str] = None\n        self.outlines: Optional[OutlineDictionary] = None\n        self.output_intents: Optional[PDFArray] = None\n        self.struct_tree_root: Optional[PDFObject] = None\n        self.a_f: Optional[str] = None\n        self.page_labels: Optional[str] = None",
      "language": "python"
    },
    {
      "code": "class PDFExtGState(PDFObject):\n    def __init__(self, dict_as_str: str) -> None:\n        super().__init__()\n        self._dict_as_str = dict_as_str\n\n    # method override\n    def serialize(\n        self,\n        obj_dict: Optional[dict[str, Any]] = None,\n        _security_handler: Optional[\"StandardSecurityHandler\"] = None,\n    ) -> str:\n        return f\"{self.id} 0 obj\\n{self._dict_as_str}\\nendobj\"",
      "language": "python"
    },
    {
      "code": "def serialize(\n    self,\n    obj_dict: Optional[dict[str, Any]] = None,\n    _security_handler: Optional[\"StandardSecurityHandler\"] = None,\n) -> str:\n    return f\"{self.id} 0 obj\\n{self._dict_as_str}\\nendobj\"",
      "language": "python"
    },
    {
      "code": "class PDFFont(PDFObject):\n    def __init__(\n        self,\n        subtype: str,\n        base_font: str,\n        encoding: Optional[str] = None,\n        d_w: Optional[float] = None,\n        w: Optional[str] = None,\n    ) -> None:\n        super().__init__()\n        self.type = Name(\"Font\")\n        self.subtype = Name(subtype)\n        self.base_font = Name(base_font)\n        self.encoding = Name(encoding) if encoding else None\n        self.d_w = d_w  # default glyph width\n        self.w = w  # widths list\n        self.descendant_fonts: Optional[PDFArray] = None\n        self.to_unicode: Optional[PDFContentStream] = None\n        self.c_i_d_system_info: Optional[CIDSystemInfo] = None\n        self.font_descriptor: Optional[\"PDFFontDescriptor\"] = None\n        self.c_i_d_to_g_i_d_map: Optional[PDFContentStream] = None",
      "language": "python"
    },
    {
      "code": "class PDFFontStream(PDFContentStream):\n    def __init__(self, contents: bytes) -> None:\n        super().__init__(contents=contents, compress=True)\n        self.length1 = len(contents)",
      "language": "python"
    },
    {
      "code": "class PDFHeader(ContentWithoutID):\n    \"\"\"\n    Emit the PDF file header as required by ISO 32000-1, §7.5.2 “File header”.\n\n    The header consists of:\n      1) A line starting with the literal \"%PDF-\" followed by the file version\n      2) If the file contains binary data an immediate second line that is a comment\n         starting with \"%\" and containing at least four bytes with values ≥ 128 (non-ASCII).\n         This helps file-transfer tools treat the content as binary rather than text.\n    \"\"\"\n\n    def __init__(self, pdf_version: str) -> None:\n        self.pdf_version = pdf_version\n\n    def serialize(\n        self, _security_handler: Optional[\"StandardSecurityHandler\"] = None\n    ) -> str:\n        return f\"%PDF-{self.pdf_version}\\n%éëñ¿\"",
      "language": "python"
    },
    {
      "code": "def serialize(\n    self, _security_handler: Optional[\"StandardSecurityHandler\"] = None\n) -> str:\n    return f\"%PDF-{self.pdf_version}\\n%éëñ¿\"",
      "language": "python"
    },
    {
      "code": "class PDFICCProfile(PDFContentStream):\n    \"\"\"\n    Holds values for ICC Profile Stream\n    Args:\n        contents (str): stream content\n        n (int): [1|3|4], # the numbers for colors 1=Gray, 3=RGB, 4=CMYK\n        alternate (str): ['DeviceGray'|'DeviceRGB'|'DeviceCMYK']\n    \"\"\"\n\n    __slots__ = (  # RAM usage optimization\n        \"_id\",\n        \"_contents\",\n        \"filter\",\n        \"length\",\n        \"n\",\n        \"alternate\",\n    )\n\n    def __init__(\n        self,\n        contents: bytes,\n        n: int,\n        alternate: str,\n    ):\n        super().__init__(contents=contents, compress=True)\n        self.n = n\n        self.alternate = Name(alternate)",
      "language": "python"
    },
    {
      "code": "class PDFICCProfile(PDFContentStream):\n    \"\"\"\n    Holds values for ICC Profile Stream\n    Args:\n        contents (str): stream content\n        n (int): [1|3|4], # the numbers for colors 1=Gray, 3=RGB, 4=CMYK\n        alternate (str): ['DeviceGray'|'DeviceRGB'|'DeviceCMYK']\n    \"\"\"\n\n    __slots__ = (  # RAM usage optimization\n        \"_id\",\n        \"_contents\",\n        \"filter\",\n        \"length\",\n        \"n\",\n        \"alternate\",\n    )\n\n    def __init__(\n        self,\n        contents: bytes,\n        n: int,\n        alternate: str,\n    ):\n        super().__init__(contents=contents, compress=True)\n        self.n = n\n        self.alternate = Name(alternate)",
      "language": "python"
    },
    {
      "code": "class PDFICCProfile(PDFContentStream):\n    \"\"\"\n    Holds values for ICC Profile Stream\n    Args:\n        contents (str): stream content\n        n (int): [1|3|4], # the numbers for colors 1=Gray, 3=RGB, 4=CMYK\n        alternate (str): ['DeviceGray'|'DeviceRGB'|'DeviceCMYK']\n    \"\"\"\n\n    __slots__ = (  # RAM usage optimization\n        \"_id\",\n        \"_contents\",\n        \"filter\",\n        \"length\",\n        \"n\",\n        \"alternate\",\n    )\n\n    def __init__(\n        self,\n        contents: bytes,\n        n: int,\n        alternate: str,\n    ):\n        super().__init__(contents=contents, compress=True)\n        self.n = n\n        self.alternate = Name(alternate)",
      "language": "python"
    },
    {
      "code": "class PDFICCProfile(PDFContentStream):\n    \"\"\"\n    Holds values for ICC Profile Stream\n    Args:\n        contents (str): stream content\n        n (int): [1|3|4], # the numbers for colors 1=Gray, 3=RGB, 4=CMYK\n        alternate (str): ['DeviceGray'|'DeviceRGB'|'DeviceCMYK']\n    \"\"\"\n\n    __slots__ = (  # RAM usage optimization\n        \"_id\",\n        \"_contents\",\n        \"filter\",\n        \"length\",\n        \"n\",\n        \"alternate\",\n    )\n\n    def __init__(\n        self,\n        contents: bytes,\n        n: int,\n        alternate: str,\n    ):\n        super().__init__(contents=contents, compress=True)\n        self.n = n\n        self.alternate = Name(alternate)",
      "language": "python"
    },
    {
      "code": "class PDFICCProfile(PDFContentStream):\n    \"\"\"\n    Holds values for ICC Profile Stream\n    Args:\n        contents (str): stream content\n        n (int): [1|3|4], # the numbers for colors 1=Gray, 3=RGB, 4=CMYK\n        alternate (str): ['DeviceGray'|'DeviceRGB'|'DeviceCMYK']\n    \"\"\"\n\n    __slots__ = (  # RAM usage optimization\n        \"_id\",\n        \"_contents\",\n        \"filter\",\n        \"length\",\n        \"n\",\n        \"alternate\",\n    )\n\n    def __init__(\n        self,\n        contents: bytes,\n        n: int,\n        alternate: str,\n    ):\n        super().__init__(contents=contents, compress=True)\n        self.n = n\n        self.alternate = Name(alternate)",
      "language": "python"
    },
    {
      "code": "class PDFInfo(PDFObject):\n    def __init__(\n        self,\n        title: Optional[str],\n        subject: Optional[str],\n        author: Optional[str],\n        keywords: Optional[str],\n        creator: Optional[str],\n        producer: Optional[str],\n        creation_date: PDFDate,\n    ) -> None:\n        super().__init__()\n        self.title = PDFString(title, encrypt=True) if title else None\n        self.subject = PDFString(subject, encrypt=True) if subject else None\n        if author and isinstance(author, (list, tuple, set)):\n            author = \"; \".join(str(a) for a in author)\n        self.author = PDFString(author, encrypt=True) if author else None\n        if keywords and isinstance(keywords, (list, tuple, set)):\n            keywords = \", \".join(str(keyword) for keyword in keywords)\n        self.keywords = PDFString(keywords, encrypt=True) if keywords else None\n        self.creator = PDFString(creator, encrypt=True) if creator else None\n        self.producer = PDFString(producer, encrypt=True) if producer else None\n        self.creation_date = creation_date",
      "language": "python"
    },
    {
      "code": "class PDFPage(PDFObject):\n    __slots__ = (  # RAM usage optimization\n        \"_id\",\n        \"type\",\n        \"contents\",\n        \"dur\",\n        \"trans\",\n        \"annots\",\n        \"group\",\n        \"media_box\",\n        \"struct_parents\",\n        \"resources\",\n        \"parent\",\n        \"_index\",\n        \"_width_pt\",\n        \"_height_pt\",\n        \"_page_label\",\n        \"_text_substitution_fragments\",\n    )\n\n    def __init__(\n        self,\n        duration: Optional[float],\n        transition: Optional[\"Transition\"],\n        contents: bytearray | PDFContentStream,\n        index: int,\n    ):\n        super().__init__()\n        self.type = Name(\"Page\")\n        self.contents = contents\n        self.dur = duration if duration else None\n        self.trans = transition\n        self.annots: Optional[PDFArray] = PDFArray()  # list of PDFAnnotation\n        self.group: Optional[str] = None\n        self.media_box: Optional[str] = None\n        self.struct_parents: Optional[int] = None\n        self.resources: Optional[PDFResources] = (\n            None  # must always be set before calling .serialize()\n        )\n        self.parent: Optional[PDFPagesRoot] = (\n            None  # must always be set before calling .serialize()\n        )\n        # Useful properties that will not be serialized in the final PDF document:\n        self._index = index\n        self._width_pt: Optional[float] = None\n        self._height_pt: Optional[float] = None\n        self._page_label: Optional[PDFPageLabel] = None\n        self._text_substitution_fragments: list[TotalPagesSubstitutionFragment] = []\n\n    def index(self) -> int:\n        return self._index\n\n    def set_index(self, i: int) -> None:\n        self._index = i\n\n    def dimensions(self) -> tuple[float, float]:\n        \"Return a pair (width, height) in the unit specified to FPDF constructor\"\n        if self._width_pt is None or self._height_pt is None:\n            raise ValueError(\"Page dimensions are null\")\n        return self._width_pt, self._height_pt\n\n    def set_dimensions(self, width_pt: float, height_pt: float) -> None:\n        \"Accepts a pair (width, height) in the unit specified to FPDF constructor\"\n        self._width_pt, self._height_pt = width_pt, height_pt\n\n    def set_page_label(\n        self,\n        previous_page_label: Optional[PDFPageLabel],\n        page_label: Optional[PDFPageLabel],\n    ) -> None:\n        if (\n            previous_page_label\n            and page_label\n            and page_label.get_style() == previous_page_label.get_style()\n            and page_label.get_prefix() == previous_page_label.get_prefix()\n            and not page_label.st\n        ):\n            page_label.st = previous_page_label.get_start() + 1\n\n        if page_label:\n            if page_label.st is None or page_label.st == 0:\n                page_label.st = 1\n\n        if previous_page_label and not page_label:\n            page_label = PDFPageLabel(\n                previous_page_label.get_style(),\n                previous_page_label.get_prefix(),\n                previous_page_label.get_start() + 1,\n            )\n\n        self._page_label = page_label\n\n    def get_page_label(self) -> Optional[PDFPageLabel]:\n        return self._page_label\n\n    def get_label(self) -> str:\n        return str(self.index()) if not self._page_label else str(self._page_label)\n\n    def get_text_substitutions(self) -> Sequence[TotalPagesSubstitutionFragment]:\n        return self._text_substitution_fragments\n\n    def add_text_substitution(self, fragment: TotalPagesSubstitutionFragment) -> None:\n        self._text_substitution_fragments.append(fragment)\n\n    def add_annotation(self, annotation: AnnotationDict | PDFAnnotation) -> None:\n        if self.annots is None:\n            self.annots = PDFArray()\n        self.annots.append(annotation)",
      "language": "python"
    },
    {
      "code": "class PDFPage(PDFObject):\n    __slots__ = (  # RAM usage optimization\n        \"_id\",\n        \"type\",\n        \"contents\",\n        \"dur\",\n        \"trans\",\n        \"annots\",\n        \"group\",\n        \"media_box\",\n        \"struct_parents\",\n        \"resources\",\n        \"parent\",\n        \"_index\",\n        \"_width_pt\",\n        \"_height_pt\",\n        \"_page_label\",\n        \"_text_substitution_fragments\",\n    )\n\n    def __init__(\n        self,\n        duration: Optional[float],\n        transition: Optional[\"Transition\"],\n        contents: bytearray | PDFContentStream,\n        index: int,\n    ):\n        super().__init__()\n        self.type = Name(\"Page\")\n        self.contents = contents\n        self.dur = duration if duration else None\n        self.trans = transition\n        self.annots: Optional[PDFArray] = PDFArray()  # list of PDFAnnotation\n        self.group: Optional[str] = None\n        self.media_box: Optional[str] = None\n        self.struct_parents: Optional[int] = None\n        self.resources: Optional[PDFResources] = (\n            None  # must always be set before calling .serialize()\n        )\n        self.parent: Optional[PDFPagesRoot] = (\n            None  # must always be set before calling .serialize()\n        )\n        # Useful properties that will not be serialized in the final PDF document:\n        self._index = index\n        self._width_pt: Optional[float] = None\n        self._height_pt: Optional[float] = None\n        self._page_label: Optional[PDFPageLabel] = None\n        self._text_substitution_fragments: list[TotalPagesSubstitutionFragment] = []\n\n    def index(self) -> int:\n        return self._index\n\n    def set_index(self, i: int) -> None:\n        self._index = i\n\n    def dimensions(self) -> tuple[float, float]:\n        \"Return a pair (width, height) in the unit specified to FPDF constructor\"\n        if self._width_pt is None or self._height_pt is None:\n            raise ValueError(\"Page dimensions are null\")\n        return self._width_pt, self._height_pt\n\n    def set_dimensions(self, width_pt: float, height_pt: float) -> None:\n        \"Accepts a pair (width, height) in the unit specified to FPDF constructor\"\n        self._width_pt, self._height_pt = width_pt, height_pt\n\n    def set_page_label(\n        self,\n        previous_page_label: Optional[PDFPageLabel],\n        page_label: Optional[PDFPageLabel],\n    ) -> None:\n        if (\n            previous_page_label\n            and page_label\n            and page_label.get_style() == previous_page_label.get_style()\n            and page_label.get_prefix() == previous_page_label.get_prefix()\n            and not page_label.st\n        ):\n            page_label.st = previous_page_label.get_start() + 1\n\n        if page_label:\n            if page_label.st is None or page_label.st == 0:\n                page_label.st = 1\n\n        if previous_page_label and not page_label:\n            page_label = PDFPageLabel(\n                previous_page_label.get_style(),\n                previous_page_label.get_prefix(),\n                previous_page_label.get_start() + 1,\n            )\n\n        self._page_label = page_label\n\n    def get_page_label(self) -> Optional[PDFPageLabel]:\n        return self._page_label\n\n    def get_label(self) -> str:\n        return str(self.index()) if not self._page_label else str(self._page_label)\n\n    def get_text_substitutions(self) -> Sequence[TotalPagesSubstitutionFragment]:\n        return self._text_substitution_fragments\n\n    def add_text_substitution(self, fragment: TotalPagesSubstitutionFragment) -> None:\n        self._text_substitution_fragments.append(fragment)\n\n    def add_annotation(self, annotation: AnnotationDict | PDFAnnotation) -> None:\n        if self.annots is None:\n            self.annots = PDFArray()\n        self.annots.append(annotation)",
      "language": "python"
    },
    {
      "code": "class PDFPage(PDFObject):\n    __slots__ = (  # RAM usage optimization\n        \"_id\",\n        \"type\",\n        \"contents\",\n        \"dur\",\n        \"trans\",\n        \"annots\",\n        \"group\",\n        \"media_box\",\n        \"struct_parents\",\n        \"resources\",\n        \"parent\",\n        \"_index\",\n        \"_width_pt\",\n        \"_height_pt\",\n        \"_page_label\",\n        \"_text_substitution_fragments\",\n    )\n\n    def __init__(\n        self,\n        duration: Optional[float],\n        transition: Optional[\"Transition\"],\n        contents: bytearray | PDFContentStream,\n        index: int,\n    ):\n        super().__init__()\n        self.type = Name(\"Page\")\n        self.contents = contents\n        self.dur = duration if duration else None\n        self.trans = transition\n        self.annots: Optional[PDFArray] = PDFArray()  # list of PDFAnnotation\n        self.group: Optional[str] = None\n        self.media_box: Optional[str] = None\n        self.struct_parents: Optional[int] = None\n        self.resources: Optional[PDFResources] = (\n            None  # must always be set before calling .serialize()\n        )\n        self.parent: Optional[PDFPagesRoot] = (\n            None  # must always be set before calling .serialize()\n        )\n        # Useful properties that will not be serialized in the final PDF document:\n        self._index = index\n        self._width_pt: Optional[float] = None\n        self._height_pt: Optional[float] = None\n        self._page_label: Optional[PDFPageLabel] = None\n        self._text_substitution_fragments: list[TotalPagesSubstitutionFragment] = []\n\n    def index(self) -> int:\n        return self._index\n\n    def set_index(self, i: int) -> None:\n        self._index = i\n\n    def dimensions(self) -> tuple[float, float]:\n        \"Return a pair (width, height) in the unit specified to FPDF constructor\"\n        if self._width_pt is None or self._height_pt is None:\n            raise ValueError(\"Page dimensions are null\")\n        return self._width_pt, self._height_pt\n\n    def set_dimensions(self, width_pt: float, height_pt: float) -> None:\n        \"Accepts a pair (width, height) in the unit specified to FPDF constructor\"\n        self._width_pt, self._height_pt = width_pt, height_pt\n\n    def set_page_label(\n        self,\n        previous_page_label: Optional[PDFPageLabel],\n        page_label: Optional[PDFPageLabel],\n    ) -> None:\n        if (\n            previous_page_label\n            and page_label\n            and page_label.get_style() == previous_page_label.get_style()\n            and page_label.get_prefix() == previous_page_label.get_prefix()\n            and not page_label.st\n        ):\n            page_label.st = previous_page_label.get_start() + 1\n\n        if page_label:\n            if page_label.st is None or page_label.st == 0:\n                page_label.st = 1\n\n        if previous_page_label and not page_label:\n            page_label = PDFPageLabel(\n                previous_page_label.get_style(),\n                previous_page_label.get_prefix(),\n                previous_page_label.get_start() + 1,\n            )\n\n        self._page_label = page_label\n\n    def get_page_label(self) -> Optional[PDFPageLabel]:\n        return self._page_label\n\n    def get_label(self) -> str:\n        return str(self.index()) if not self._page_label else str(self._page_label)\n\n    def get_text_substitutions(self) -> Sequence[TotalPagesSubstitutionFragment]:\n        return self._text_substitution_fragments\n\n    def add_text_substitution(self, fragment: TotalPagesSubstitutionFragment) -> None:\n        self._text_substitution_fragments.append(fragment)\n\n    def add_annotation(self, annotation: AnnotationDict | PDFAnnotation) -> None:\n        if self.annots is None:\n            self.annots = PDFArray()\n        self.annots.append(annotation)",
      "language": "python"
    },
    {
      "code": "class PDFPage(PDFObject):\n    __slots__ = (  # RAM usage optimization\n        \"_id\",\n        \"type\",\n        \"contents\",\n        \"dur\",\n        \"trans\",\n        \"annots\",\n        \"group\",\n        \"media_box\",\n        \"struct_parents\",\n        \"resources\",\n        \"parent\",\n        \"_index\",\n        \"_width_pt\",\n        \"_height_pt\",\n        \"_page_label\",\n        \"_text_substitution_fragments\",\n    )\n\n    def __init__(\n        self,\n        duration: Optional[float],\n        transition: Optional[\"Transition\"],\n        contents: bytearray | PDFContentStream,\n        index: int,\n    ):\n        super().__init__()\n        self.type = Name(\"Page\")\n        self.contents = contents\n        self.dur = duration if duration else None\n        self.trans = transition\n        self.annots: Optional[PDFArray] = PDFArray()  # list of PDFAnnotation\n        self.group: Optional[str] = None\n        self.media_box: Optional[str] = None\n        self.struct_parents: Optional[int] = None\n        self.resources: Optional[PDFResources] = (\n            None  # must always be set before calling .serialize()\n        )\n        self.parent: Optional[PDFPagesRoot] = (\n            None  # must always be set before calling .serialize()\n        )\n        # Useful properties that will not be serialized in the final PDF document:\n        self._index = index\n        self._width_pt: Optional[float] = None\n        self._height_pt: Optional[float] = None\n        self._page_label: Optional[PDFPageLabel] = None\n        self._text_substitution_fragments: list[TotalPagesSubstitutionFragment] = []\n\n    def index(self) -> int:\n        return self._index\n\n    def set_index(self, i: int) -> None:\n        self._index = i\n\n    def dimensions(self) -> tuple[float, float]:\n        \"Return a pair (width, height) in the unit specified to FPDF constructor\"\n        if self._width_pt is None or self._height_pt is None:\n            raise ValueError(\"Page dimensions are null\")\n        return self._width_pt, self._height_pt\n\n    def set_dimensions(self, width_pt: float, height_pt: float) -> None:\n        \"Accepts a pair (width, height) in the unit specified to FPDF constructor\"\n        self._width_pt, self._height_pt = width_pt, height_pt\n\n    def set_page_label(\n        self,\n        previous_page_label: Optional[PDFPageLabel],\n        page_label: Optional[PDFPageLabel],\n    ) -> None:\n        if (\n            previous_page_label\n            and page_label\n            and page_label.get_style() == previous_page_label.get_style()\n            and page_label.get_prefix() == previous_page_label.get_prefix()\n            and not page_label.st\n        ):\n            page_label.st = previous_page_label.get_start() + 1\n\n        if page_label:\n            if page_label.st is None or page_label.st == 0:\n                page_label.st = 1\n\n        if previous_page_label and not page_label:\n            page_label = PDFPageLabel(\n                previous_page_label.get_style(),\n                previous_page_label.get_prefix(),\n                previous_page_label.get_start() + 1,\n            )\n\n        self._page_label = page_label\n\n    def get_page_label(self) -> Optional[PDFPageLabel]:\n        return self._page_label\n\n    def get_label(self) -> str:\n        return str(self.index()) if not self._page_label else str(self._page_label)\n\n    def get_text_substitutions(self) -> Sequence[TotalPagesSubstitutionFragment]:\n        return self._text_substitution_fragments\n\n    def add_text_substitution(self, fragment: TotalPagesSubstitutionFragment) -> None:\n        self._text_substitution_fragments.append(fragment)\n\n    def add_annotation(self, annotation: AnnotationDict | PDFAnnotation) -> None:\n        if self.annots is None:\n            self.annots = PDFArray()\n        self.annots.append(annotation)",
      "language": "python"
    },
    {
      "code": "class PDFPage(PDFObject):\n    __slots__ = (  # RAM usage optimization\n        \"_id\",\n        \"type\",\n        \"contents\",\n        \"dur\",\n        \"trans\",\n        \"annots\",\n        \"group\",\n        \"media_box\",\n        \"struct_parents\",\n        \"resources\",\n        \"parent\",\n        \"_index\",\n        \"_width_pt\",\n        \"_height_pt\",\n        \"_page_label\",\n        \"_text_substitution_fragments\",\n    )\n\n    def __init__(\n        self,\n        duration: Optional[float],\n        transition: Optional[\"Transition\"],\n        contents: bytearray | PDFContentStream,\n        index: int,\n    ):\n        super().__init__()\n        self.type = Name(\"Page\")\n        self.contents = contents\n        self.dur = duration if duration else None\n        self.trans = transition\n        self.annots: Optional[PDFArray] = PDFArray()  # list of PDFAnnotation\n        self.group: Optional[str] = None\n        self.media_box: Optional[str] = None\n        self.struct_parents: Optional[int] = None\n        self.resources: Optional[PDFResources] = (\n            None  # must always be set before calling .serialize()\n        )\n        self.parent: Optional[PDFPagesRoot] = (\n            None  # must always be set before calling .serialize()\n        )\n        # Useful properties that will not be serialized in the final PDF document:\n        self._index = index\n        self._width_pt: Optional[float] = None\n        self._height_pt: Optional[float] = None\n        self._page_label: Optional[PDFPageLabel] = None\n        self._text_substitution_fragments: list[TotalPagesSubstitutionFragment] = []\n\n    def index(self) -> int:\n        return self._index\n\n    def set_index(self, i: int) -> None:\n        self._index = i\n\n    def dimensions(self) -> tuple[float, float]:\n        \"Return a pair (width, height) in the unit specified to FPDF constructor\"\n        if self._width_pt is None or self._height_pt is None:\n            raise ValueError(\"Page dimensions are null\")\n        return self._width_pt, self._height_pt\n\n    def set_dimensions(self, width_pt: float, height_pt: float) -> None:\n        \"Accepts a pair (width, height) in the unit specified to FPDF constructor\"\n        self._width_pt, self._height_pt = width_pt, height_pt\n\n    def set_page_label(\n        self,\n        previous_page_label: Optional[PDFPageLabel],\n        page_label: Optional[PDFPageLabel],\n    ) -> None:\n        if (\n            previous_page_label\n            and page_label\n            and page_label.get_style() == previous_page_label.get_style()\n            and page_label.get_prefix() == previous_page_label.get_prefix()\n            and not page_label.st\n        ):\n            page_label.st = previous_page_label.get_start() + 1\n\n        if page_label:\n            if page_label.st is None or page_label.st == 0:\n                page_label.st = 1\n\n        if previous_page_label and not page_label:\n            page_label = PDFPageLabel(\n                previous_page_label.get_style(),\n                previous_page_label.get_prefix(),\n                previous_page_label.get_start() + 1,\n            )\n\n        self._page_label = page_label\n\n    def get_page_label(self) -> Optional[PDFPageLabel]:\n        return self._page_label\n\n    def get_label(self) -> str:\n        return str(self.index()) if not self._page_label else str(self._page_label)\n\n    def get_text_substitutions(self) -> Sequence[TotalPagesSubstitutionFragment]:\n        return self._text_substitution_fragments\n\n    def add_text_substitution(self, fragment: TotalPagesSubstitutionFragment) -> None:\n        self._text_substitution_fragments.append(fragment)\n\n    def add_annotation(self, annotation: AnnotationDict | PDFAnnotation) -> None:\n        if self.annots is None:\n            self.annots = PDFArray()\n        self.annots.append(annotation)",
      "language": "python"
    },
    {
      "code": "class PDFPage(PDFObject):\n    __slots__ = (  # RAM usage optimization\n        \"_id\",\n        \"type\",\n        \"contents\",\n        \"dur\",\n        \"trans\",\n        \"annots\",\n        \"group\",\n        \"media_box\",\n        \"struct_parents\",\n        \"resources\",\n        \"parent\",\n        \"_index\",\n        \"_width_pt\",\n        \"_height_pt\",\n        \"_page_label\",\n        \"_text_substitution_fragments\",\n    )\n\n    def __init__(\n        self,\n        duration: Optional[float],\n        transition: Optional[\"Transition\"],\n        contents: bytearray | PDFContentStream,\n        index: int,\n    ):\n        super().__init__()\n        self.type = Name(\"Page\")\n        self.contents = contents\n        self.dur = duration if duration else None\n        self.trans = transition\n        self.annots: Optional[PDFArray] = PDFArray()  # list of PDFAnnotation\n        self.group: Optional[str] = None\n        self.media_box: Optional[str] = None\n        self.struct_parents: Optional[int] = None\n        self.resources: Optional[PDFResources] = (\n            None  # must always be set before calling .serialize()\n        )\n        self.parent: Optional[PDFPagesRoot] = (\n            None  # must always be set before calling .serialize()\n        )\n        # Useful properties that will not be serialized in the final PDF document:\n        self._index = index\n        self._width_pt: Optional[float] = None\n        self._height_pt: Optional[float] = None\n        self._page_label: Optional[PDFPageLabel] = None\n        self._text_substitution_fragments: list[TotalPagesSubstitutionFragment] = []\n\n    def index(self) -> int:\n        return self._index\n\n    def set_index(self, i: int) -> None:\n        self._index = i\n\n    def dimensions(self) -> tuple[float, float]:\n        \"Return a pair (width, height) in the unit specified to FPDF constructor\"\n        if self._width_pt is None or self._height_pt is None:\n            raise ValueError(\"Page dimensions are null\")\n        return self._width_pt, self._height_pt\n\n    def set_dimensions(self, width_pt: float, height_pt: float) -> None:\n        \"Accepts a pair (width, height) in the unit specified to FPDF constructor\"\n        self._width_pt, self._height_pt = width_pt, height_pt\n\n    def set_page_label(\n        self,\n        previous_page_label: Optional[PDFPageLabel],\n        page_label: Optional[PDFPageLabel],\n    ) -> None:\n        if (\n            previous_page_label\n            and page_label\n            and page_label.get_style() == previous_page_label.get_style()\n            and page_label.get_prefix() == previous_page_label.get_prefix()\n            and not page_label.st\n        ):\n            page_label.st = previous_page_label.get_start() + 1\n\n        if page_label:\n            if page_label.st is None or page_label.st == 0:\n                page_label.st = 1\n\n        if previous_page_label and not page_label:\n            page_label = PDFPageLabel(\n                previous_page_label.get_style(),\n                previous_page_label.get_prefix(),\n                previous_page_label.get_start() + 1,\n            )\n\n        self._page_label = page_label\n\n    def get_page_label(self) -> Optional[PDFPageLabel]:\n        return self._page_label\n\n    def get_label(self) -> str:\n        return str(self.index()) if not self._page_label else str(self._page_label)\n\n    def get_text_substitutions(self) -> Sequence[TotalPagesSubstitutionFragment]:\n        return self._text_substitution_fragments\n\n    def add_text_substitution(self, fragment: TotalPagesSubstitutionFragment) -> None:\n        self._text_substitution_fragments.append(fragment)\n\n    def add_annotation(self, annotation: AnnotationDict | PDFAnnotation) -> None:\n        if self.annots is None:\n            self.annots = PDFArray()\n        self.annots.append(annotation)",
      "language": "python"
    },
    {
      "code": "class PDFPage(PDFObject):\n    __slots__ = (  # RAM usage optimization\n        \"_id\",\n        \"type\",\n        \"contents\",\n        \"dur\",\n        \"trans\",\n        \"annots\",\n        \"group\",\n        \"media_box\",\n        \"struct_parents\",\n        \"resources\",\n        \"parent\",\n        \"_index\",\n        \"_width_pt\",\n        \"_height_pt\",\n        \"_page_label\",\n        \"_text_substitution_fragments\",\n    )\n\n    def __init__(\n        self,\n        duration: Optional[float],\n        transition: Optional[\"Transition\"],\n        contents: bytearray | PDFContentStream,\n        index: int,\n    ):\n        super().__init__()\n        self.type = Name(\"Page\")\n        self.contents = contents\n        self.dur = duration if duration else None\n        self.trans = transition\n        self.annots: Optional[PDFArray] = PDFArray()  # list of PDFAnnotation\n        self.group: Optional[str] = None\n        self.media_box: Optional[str] = None\n        self.struct_parents: Optional[int] = None\n        self.resources: Optional[PDFResources] = (\n            None  # must always be set before calling .serialize()\n        )\n        self.parent: Optional[PDFPagesRoot] = (\n            None  # must always be set before calling .serialize()\n        )\n        # Useful properties that will not be serialized in the final PDF document:\n        self._index = index\n        self._width_pt: Optional[float] = None\n        self._height_pt: Optional[float] = None\n        self._page_label: Optional[PDFPageLabel] = None\n        self._text_substitution_fragments: list[TotalPagesSubstitutionFragment] = []\n\n    def index(self) -> int:\n        return self._index\n\n    def set_index(self, i: int) -> None:\n        self._index = i\n\n    def dimensions(self) -> tuple[float, float]:\n        \"Return a pair (width, height) in the unit specified to FPDF constructor\"\n        if self._width_pt is None or self._height_pt is None:\n            raise ValueError(\"Page dimensions are null\")\n        return self._width_pt, self._height_pt\n\n    def set_dimensions(self, width_pt: float, height_pt: float) -> None:\n        \"Accepts a pair (width, height) in the unit specified to FPDF constructor\"\n        self._width_pt, self._height_pt = width_pt, height_pt\n\n    def set_page_label(\n        self,\n        previous_page_label: Optional[PDFPageLabel],\n        page_label: Optional[PDFPageLabel],\n    ) -> None:\n        if (\n            previous_page_label\n            and page_label\n            and page_label.get_style() == previous_page_label.get_style()\n            and page_label.get_prefix() == previous_page_label.get_prefix()\n            and not page_label.st\n        ):\n            page_label.st = previous_page_label.get_start() + 1\n\n        if page_label:\n            if page_label.st is None or page_label.st == 0:\n                page_label.st = 1\n\n        if previous_page_label and not page_label:\n            page_label = PDFPageLabel(\n                previous_page_label.get_style(),\n                previous_page_label.get_prefix(),\n                previous_page_label.get_start() + 1,\n            )\n\n        self._page_label = page_label\n\n    def get_page_label(self) -> Optional[PDFPageLabel]:\n        return self._page_label\n\n    def get_label(self) -> str:\n        return str(self.index()) if not self._page_label else str(self._page_label)\n\n    def get_text_substitutions(self) -> Sequence[TotalPagesSubstitutionFragment]:\n        return self._text_substitution_fragments\n\n    def add_text_substitution(self, fragment: TotalPagesSubstitutionFragment) -> None:\n        self._text_substitution_fragments.append(fragment)\n\n    def add_annotation(self, annotation: AnnotationDict | PDFAnnotation) -> None:\n        if self.annots is None:\n            self.annots = PDFArray()\n        self.annots.append(annotation)",
      "language": "python"
    },
    {
      "code": "class PDFPage(PDFObject):\n    __slots__ = (  # RAM usage optimization\n        \"_id\",\n        \"type\",\n        \"contents\",\n        \"dur\",\n        \"trans\",\n        \"annots\",\n        \"group\",\n        \"media_box\",\n        \"struct_parents\",\n        \"resources\",\n        \"parent\",\n        \"_index\",\n        \"_width_pt\",\n        \"_height_pt\",\n        \"_page_label\",\n        \"_text_substitution_fragments\",\n    )\n\n    def __init__(\n        self,\n        duration: Optional[float],\n        transition: Optional[\"Transition\"],\n        contents: bytearray | PDFContentStream,\n        index: int,\n    ):\n        super().__init__()\n        self.type = Name(\"Page\")\n        self.contents = contents\n        self.dur = duration if duration else None\n        self.trans = transition\n        self.annots: Optional[PDFArray] = PDFArray()  # list of PDFAnnotation\n        self.group: Optional[str] = None\n        self.media_box: Optional[str] = None\n        self.struct_parents: Optional[int] = None\n        self.resources: Optional[PDFResources] = (\n            None  # must always be set before calling .serialize()\n        )\n        self.parent: Optional[PDFPagesRoot] = (\n            None  # must always be set before calling .serialize()\n        )\n        # Useful properties that will not be serialized in the final PDF document:\n        self._index = index\n        self._width_pt: Optional[float] = None\n        self._height_pt: Optional[float] = None\n        self._page_label: Optional[PDFPageLabel] = None\n        self._text_substitution_fragments: list[TotalPagesSubstitutionFragment] = []\n\n    def index(self) -> int:\n        return self._index\n\n    def set_index(self, i: int) -> None:\n        self._index = i\n\n    def dimensions(self) -> tuple[float, float]:\n        \"Return a pair (width, height) in the unit specified to FPDF constructor\"\n        if self._width_pt is None or self._height_pt is None:\n            raise ValueError(\"Page dimensions are null\")\n        return self._width_pt, self._height_pt\n\n    def set_dimensions(self, width_pt: float, height_pt: float) -> None:\n        \"Accepts a pair (width, height) in the unit specified to FPDF constructor\"\n        self._width_pt, self._height_pt = width_pt, height_pt\n\n    def set_page_label(\n        self,\n        previous_page_label: Optional[PDFPageLabel],\n        page_label: Optional[PDFPageLabel],\n    ) -> None:\n        if (\n            previous_page_label\n            and page_label\n            and page_label.get_style() == previous_page_label.get_style()\n            and page_label.get_prefix() == previous_page_label.get_prefix()\n            and not page_label.st\n        ):\n            page_label.st = previous_page_label.get_start() + 1\n\n        if page_label:\n            if page_label.st is None or page_label.st == 0:\n                page_label.st = 1\n\n        if previous_page_label and not page_label:\n            page_label = PDFPageLabel(\n                previous_page_label.get_style(),\n                previous_page_label.get_prefix(),\n                previous_page_label.get_start() + 1,\n            )\n\n        self._page_label = page_label\n\n    def get_page_label(self) -> Optional[PDFPageLabel]:\n        return self._page_label\n\n    def get_label(self) -> str:\n        return str(self.index()) if not self._page_label else str(self._page_label)\n\n    def get_text_substitutions(self) -> Sequence[TotalPagesSubstitutionFragment]:\n        return self._text_substitution_fragments\n\n    def add_text_substitution(self, fragment: TotalPagesSubstitutionFragment) -> None:\n        self._text_substitution_fragments.append(fragment)\n\n    def add_annotation(self, annotation: AnnotationDict | PDFAnnotation) -> None:\n        if self.annots is None:\n            self.annots = PDFArray()\n        self.annots.append(annotation)",
      "language": "python"
    },
    {
      "code": "class PDFPage(PDFObject):\n    __slots__ = (  # RAM usage optimization\n        \"_id\",\n        \"type\",\n        \"contents\",\n        \"dur\",\n        \"trans\",\n        \"annots\",\n        \"group\",\n        \"media_box\",\n        \"struct_parents\",\n        \"resources\",\n        \"parent\",\n        \"_index\",\n        \"_width_pt\",\n        \"_height_pt\",\n        \"_page_label\",\n        \"_text_substitution_fragments\",\n    )\n\n    def __init__(\n        self,\n        duration: Optional[float],\n        transition: Optional[\"Transition\"],\n        contents: bytearray | PDFContentStream,\n        index: int,\n    ):\n        super().__init__()\n        self.type = Name(\"Page\")\n        self.contents = contents\n        self.dur = duration if duration else None\n        self.trans = transition\n        self.annots: Optional[PDFArray] = PDFArray()  # list of PDFAnnotation\n        self.group: Optional[str] = None\n        self.media_box: Optional[str] = None\n        self.struct_parents: Optional[int] = None\n        self.resources: Optional[PDFResources] = (\n            None  # must always be set before calling .serialize()\n        )\n        self.parent: Optional[PDFPagesRoot] = (\n            None  # must always be set before calling .serialize()\n        )\n        # Useful properties that will not be serialized in the final PDF document:\n        self._index = index\n        self._width_pt: Optional[float] = None\n        self._height_pt: Optional[float] = None\n        self._page_label: Optional[PDFPageLabel] = None\n        self._text_substitution_fragments: list[TotalPagesSubstitutionFragment] = []\n\n    def index(self) -> int:\n        return self._index\n\n    def set_index(self, i: int) -> None:\n        self._index = i\n\n    def dimensions(self) -> tuple[float, float]:\n        \"Return a pair (width, height) in the unit specified to FPDF constructor\"\n        if self._width_pt is None or self._height_pt is None:\n            raise ValueError(\"Page dimensions are null\")\n        return self._width_pt, self._height_pt\n\n    def set_dimensions(self, width_pt: float, height_pt: float) -> None:\n        \"Accepts a pair (width, height) in the unit specified to FPDF constructor\"\n        self._width_pt, self._height_pt = width_pt, height_pt\n\n    def set_page_label(\n        self,\n        previous_page_label: Optional[PDFPageLabel],\n        page_label: Optional[PDFPageLabel],\n    ) -> None:\n        if (\n            previous_page_label\n            and page_label\n            and page_label.get_style() == previous_page_label.get_style()\n            and page_label.get_prefix() == previous_page_label.get_prefix()\n            and not page_label.st\n        ):\n            page_label.st = previous_page_label.get_start() + 1\n\n        if page_label:\n            if page_label.st is None or page_label.st == 0:\n                page_label.st = 1\n\n        if previous_page_label and not page_label:\n            page_label = PDFPageLabel(\n                previous_page_label.get_style(),\n                previous_page_label.get_prefix(),\n                previous_page_label.get_start() + 1,\n            )\n\n        self._page_label = page_label\n\n    def get_page_label(self) -> Optional[PDFPageLabel]:\n        return self._page_label\n\n    def get_label(self) -> str:\n        return str(self.index()) if not self._page_label else str(self._page_label)\n\n    def get_text_substitutions(self) -> Sequence[TotalPagesSubstitutionFragment]:\n        return self._text_substitution_fragments\n\n    def add_text_substitution(self, fragment: TotalPagesSubstitutionFragment) -> None:\n        self._text_substitution_fragments.append(fragment)\n\n    def add_annotation(self, annotation: AnnotationDict | PDFAnnotation) -> None:\n        if self.annots is None:\n            self.annots = PDFArray()\n        self.annots.append(annotation)",
      "language": "python"
    },
    {
      "code": "class PDFPage(PDFObject):\n    __slots__ = (  # RAM usage optimization\n        \"_id\",\n        \"type\",\n        \"contents\",\n        \"dur\",\n        \"trans\",\n        \"annots\",\n        \"group\",\n        \"media_box\",\n        \"struct_parents\",\n        \"resources\",\n        \"parent\",\n        \"_index\",\n        \"_width_pt\",\n        \"_height_pt\",\n        \"_page_label\",\n        \"_text_substitution_fragments\",\n    )\n\n    def __init__(\n        self,\n        duration: Optional[float],\n        transition: Optional[\"Transition\"],\n        contents: bytearray | PDFContentStream,\n        index: int,\n    ):\n        super().__init__()\n        self.type = Name(\"Page\")\n        self.contents = contents\n        self.dur = duration if duration else None\n        self.trans = transition\n        self.annots: Optional[PDFArray] = PDFArray()  # list of PDFAnnotation\n        self.group: Optional[str] = None\n        self.media_box: Optional[str] = None\n        self.struct_parents: Optional[int] = None\n        self.resources: Optional[PDFResources] = (\n            None  # must always be set before calling .serialize()\n        )\n        self.parent: Optional[PDFPagesRoot] = (\n            None  # must always be set before calling .serialize()\n        )\n        # Useful properties that will not be serialized in the final PDF document:\n        self._index = index\n        self._width_pt: Optional[float] = None\n        self._height_pt: Optional[float] = None\n        self._page_label: Optional[PDFPageLabel] = None\n        self._text_substitution_fragments: list[TotalPagesSubstitutionFragment] = []\n\n    def index(self) -> int:\n        return self._index\n\n    def set_index(self, i: int) -> None:\n        self._index = i\n\n    def dimensions(self) -> tuple[float, float]:\n        \"Return a pair (width, height) in the unit specified to FPDF constructor\"\n        if self._width_pt is None or self._height_pt is None:\n            raise ValueError(\"Page dimensions are null\")\n        return self._width_pt, self._height_pt\n\n    def set_dimensions(self, width_pt: float, height_pt: float) -> None:\n        \"Accepts a pair (width, height) in the unit specified to FPDF constructor\"\n        self._width_pt, self._height_pt = width_pt, height_pt\n\n    def set_page_label(\n        self,\n        previous_page_label: Optional[PDFPageLabel],\n        page_label: Optional[PDFPageLabel],\n    ) -> None:\n        if (\n            previous_page_label\n            and page_label\n            and page_label.get_style() == previous_page_label.get_style()\n            and page_label.get_prefix() == previous_page_label.get_prefix()\n            and not page_label.st\n        ):\n            page_label.st = previous_page_label.get_start() + 1\n\n        if page_label:\n            if page_label.st is None or page_label.st == 0:\n                page_label.st = 1\n\n        if previous_page_label and not page_label:\n            page_label = PDFPageLabel(\n                previous_page_label.get_style(),\n                previous_page_label.get_prefix(),\n                previous_page_label.get_start() + 1,\n            )\n\n        self._page_label = page_label\n\n    def get_page_label(self) -> Optional[PDFPageLabel]:\n        return self._page_label\n\n    def get_label(self) -> str:\n        return str(self.index()) if not self._page_label else str(self._page_label)\n\n    def get_text_substitutions(self) -> Sequence[TotalPagesSubstitutionFragment]:\n        return self._text_substitution_fragments\n\n    def add_text_substitution(self, fragment: TotalPagesSubstitutionFragment) -> None:\n        self._text_substitution_fragments.append(fragment)\n\n    def add_annotation(self, annotation: AnnotationDict | PDFAnnotation) -> None:\n        if self.annots is None:\n            self.annots = PDFArray()\n        self.annots.append(annotation)",
      "language": "python"
    },
    {
      "code": "class PDFPage(PDFObject):\n    __slots__ = (  # RAM usage optimization\n        \"_id\",\n        \"type\",\n        \"contents\",\n        \"dur\",\n        \"trans\",\n        \"annots\",\n        \"group\",\n        \"media_box\",\n        \"struct_parents\",\n        \"resources\",\n        \"parent\",\n        \"_index\",\n        \"_width_pt\",\n        \"_height_pt\",\n        \"_page_label\",\n        \"_text_substitution_fragments\",\n    )\n\n    def __init__(\n        self,\n        duration: Optional[float],\n        transition: Optional[\"Transition\"],\n        contents: bytearray | PDFContentStream,\n        index: int,\n    ):\n        super().__init__()\n        self.type = Name(\"Page\")\n        self.contents = contents\n        self.dur = duration if duration else None\n        self.trans = transition\n        self.annots: Optional[PDFArray] = PDFArray()  # list of PDFAnnotation\n        self.group: Optional[str] = None\n        self.media_box: Optional[str] = None\n        self.struct_parents: Optional[int] = None\n        self.resources: Optional[PDFResources] = (\n            None  # must always be set before calling .serialize()\n        )\n        self.parent: Optional[PDFPagesRoot] = (\n            None  # must always be set before calling .serialize()\n        )\n        # Useful properties that will not be serialized in the final PDF document:\n        self._index = index\n        self._width_pt: Optional[float] = None\n        self._height_pt: Optional[float] = None\n        self._page_label: Optional[PDFPageLabel] = None\n        self._text_substitution_fragments: list[TotalPagesSubstitutionFragment] = []\n\n    def index(self) -> int:\n        return self._index\n\n    def set_index(self, i: int) -> None:\n        self._index = i\n\n    def dimensions(self) -> tuple[float, float]:\n        \"Return a pair (width, height) in the unit specified to FPDF constructor\"\n        if self._width_pt is None or self._height_pt is None:\n            raise ValueError(\"Page dimensions are null\")\n        return self._width_pt, self._height_pt\n\n    def set_dimensions(self, width_pt: float, height_pt: float) -> None:\n        \"Accepts a pair (width, height) in the unit specified to FPDF constructor\"\n        self._width_pt, self._height_pt = width_pt, height_pt\n\n    def set_page_label(\n        self,\n        previous_page_label: Optional[PDFPageLabel],\n        page_label: Optional[PDFPageLabel],\n    ) -> None:\n        if (\n            previous_page_label\n            and page_label\n            and page_label.get_style() == previous_page_label.get_style()\n            and page_label.get_prefix() == previous_page_label.get_prefix()\n            and not page_label.st\n        ):\n            page_label.st = previous_page_label.get_start() + 1\n\n        if page_label:\n            if page_label.st is None or page_label.st == 0:\n                page_label.st = 1\n\n        if previous_page_label and not page_label:\n            page_label = PDFPageLabel(\n                previous_page_label.get_style(),\n                previous_page_label.get_prefix(),\n                previous_page_label.get_start() + 1,\n            )\n\n        self._page_label = page_label\n\n    def get_page_label(self) -> Optional[PDFPageLabel]:\n        return self._page_label\n\n    def get_label(self) -> str:\n        return str(self.index()) if not self._page_label else str(self._page_label)\n\n    def get_text_substitutions(self) -> Sequence[TotalPagesSubstitutionFragment]:\n        return self._text_substitution_fragments\n\n    def add_text_substitution(self, fragment: TotalPagesSubstitutionFragment) -> None:\n        self._text_substitution_fragments.append(fragment)\n\n    def add_annotation(self, annotation: AnnotationDict | PDFAnnotation) -> None:\n        if self.annots is None:\n            self.annots = PDFArray()\n        self.annots.append(annotation)",
      "language": "python"
    },
    {
      "code": "def add_annotation(self, annotation: AnnotationDict | PDFAnnotation) -> None:\n    if self.annots is None:\n        self.annots = PDFArray()\n    self.annots.append(annotation)",
      "language": "python"
    },
    {
      "code": "def add_text_substitution(self, fragment: TotalPagesSubstitutionFragment) -> None:\n    self._text_substitution_fragments.append(fragment)",
      "language": "python"
    },
    {
      "code": "def dimensions(self) -> tuple[float, float]:\n    \"Return a pair (width, height) in the unit specified to FPDF constructor\"\n    if self._width_pt is None or self._height_pt is None:\n        raise ValueError(\"Page dimensions are null\")\n    return self._width_pt, self._height_pt",
      "language": "python"
    },
    {
      "code": "def get_label(self) -> str:\n    return str(self.index()) if not self._page_label else str(self._page_label)",
      "language": "python"
    },
    {
      "code": "def get_page_label(self) -> Optional[PDFPageLabel]:\n    return self._page_label",
      "language": "python"
    },
    {
      "code": "def get_text_substitutions(self) -> Sequence[TotalPagesSubstitutionFragment]:\n    return self._text_substitution_fragments",
      "language": "python"
    },
    {
      "code": "def index(self) -> int:\n    return self._index",
      "language": "python"
    },
    {
      "code": "def set_dimensions(self, width_pt: float, height_pt: float) -> None:\n    \"Accepts a pair (width, height) in the unit specified to FPDF constructor\"\n    self._width_pt, self._height_pt = width_pt, height_pt",
      "language": "python"
    },
    {
      "code": "def set_index(self, i: int) -> None:\n    self._index = i",
      "language": "python"
    },
    {
      "code": "def set_page_label(\n    self,\n    previous_page_label: Optional[PDFPageLabel],\n    page_label: Optional[PDFPageLabel],\n) -> None:\n    if (\n        previous_page_label\n        and page_label\n        and page_label.get_style() == previous_page_label.get_style()\n        and page_label.get_prefix() == previous_page_label.get_prefix()\n        and not page_label.st\n    ):\n        page_label.st = previous_page_label.get_start() + 1\n\n    if page_label:\n        if page_label.st is None or page_label.st == 0:\n            page_label.st = 1\n\n    if previous_page_label and not page_label:\n        page_label = PDFPageLabel(\n            previous_page_label.get_style(),\n            previous_page_label.get_prefix(),\n            previous_page_label.get_start() + 1,\n        )\n\n    self._page_label = page_label",
      "language": "python"
    },
    {
      "code": "class PDFPageLabel:\n    \"\"\"\n    This will be displayed by some PDF readers to identify pages.\n    \"\"\"\n\n    __slots__ = (\"_style\", \"_prefix\", \"st\")  # RAM usage optimization\n\n    def __init__(\n        self,\n        label_style: Optional[PageLabelStyle],\n        label_prefix: Optional[str],\n        label_start: Optional[int],\n    ) -> None:\n        self._style: Optional[PageLabelStyle] = label_style\n        self._prefix: Optional[str] = label_prefix\n        self.st: Optional[int] = label_start\n\n    @property\n    def s(self) -> Optional[Name]:\n        return Name(self._style.value) if self._style else None\n\n    @property\n    def p(self) -> Optional[PDFString]:\n        return PDFString(self._prefix) if self._prefix else None\n\n    def __repr__(self) -> str:\n        return f\"PDFPageLabel({self._style}, {self._prefix}, {self.st})\"\n\n    def __str__(self) -> str:\n        ret = self._prefix if self._prefix else \"\"\n        if self._style:\n            if self._style == PageLabelStyle.NUMBER:\n                ret += str(self.st)\n            elif self._style == PageLabelStyle.UPPER_ROMAN:\n                ret += int2roman(self.st or 1)\n            elif self._style == PageLabelStyle.LOWER_ROMAN:\n                ret += int2roman(self.st or 1).lower()\n            elif self._style == PageLabelStyle.UPPER_LETTER:\n                start = (self.st or 1) - 1\n                ret += int_to_letters(start)\n            elif self._style == PageLabelStyle.LOWER_LETTER:\n                start = (self.st or 1) - 1\n                ret += int_to_letters(start).lower()\n        return ret\n\n    def serialize(self) -> dict[str, Any]:\n        return build_obj_dict({key: getattr(self, key) for key in dir(self)})\n\n    def get_style(self) -> Optional[PageLabelStyle]:\n        return self._style\n\n    def get_prefix(self) -> str:\n        return self._prefix or \"\"\n\n    def get_start(self) -> int:\n        return self.st or 1",
      "language": "python"
    },
    {
      "code": "@property\ndef p(self) -> Optional[PDFString]:\n    return PDFString(self._prefix) if self._prefix else None",
      "language": "python"
    },
    {
      "code": "@property\ndef s(self) -> Optional[Name]:\n    return Name(self._style.value) if self._style else None",
      "language": "python"
    },
    {
      "code": "class PDFPageLabel:\n    \"\"\"\n    This will be displayed by some PDF readers to identify pages.\n    \"\"\"\n\n    __slots__ = (\"_style\", \"_prefix\", \"st\")  # RAM usage optimization\n\n    def __init__(\n        self,\n        label_style: Optional[PageLabelStyle],\n        label_prefix: Optional[str],\n        label_start: Optional[int],\n    ) -> None:\n        self._style: Optional[PageLabelStyle] = label_style\n        self._prefix: Optional[str] = label_prefix\n        self.st: Optional[int] = label_start\n\n    @property\n    def s(self) -> Optional[Name]:\n        return Name(self._style.value) if self._style else None\n\n    @property\n    def p(self) -> Optional[PDFString]:\n        return PDFString(self._prefix) if self._prefix else None\n\n    def __repr__(self) -> str:\n        return f\"PDFPageLabel({self._style}, {self._prefix}, {self.st})\"\n\n    def __str__(self) -> str:\n        ret = self._prefix if self._prefix else \"\"\n        if self._style:\n            if self._style == PageLabelStyle.NUMBER:\n                ret += str(self.st)\n            elif self._style == PageLabelStyle.UPPER_ROMAN:\n                ret += int2roman(self.st or 1)\n            elif self._style == PageLabelStyle.LOWER_ROMAN:\n                ret += int2roman(self.st or 1).lower()\n            elif self._style == PageLabelStyle.UPPER_LETTER:\n                start = (self.st or 1) - 1\n                ret += int_to_letters(start)\n            elif self._style == PageLabelStyle.LOWER_LETTER:\n                start = (self.st or 1) - 1\n                ret += int_to_letters(start).lower()\n        return ret\n\n    def serialize(self) -> dict[str, Any]:\n        return build_obj_dict({key: getattr(self, key) for key in dir(self)})\n\n    def get_style(self) -> Optional[PageLabelStyle]:\n        return self._style\n\n    def get_prefix(self) -> str:\n        return self._prefix or \"\"\n\n    def get_start(self) -> int:\n        return self.st or 1",
      "language": "python"
    },
    {
      "code": "def get_prefix(self) -> str:\n    return self._prefix or \"\"",
      "language": "python"
    },
    {
      "code": "def get_start(self) -> int:\n    return self.st or 1",
      "language": "python"
    },
    {
      "code": "def get_style(self) -> Optional[PageLabelStyle]:\n    return self._style",
      "language": "python"
    },
    {
      "code": "def serialize(self) -> dict[str, Any]:\n    return build_obj_dict({key: getattr(self, key) for key in dir(self)})",
      "language": "python"
    },
    {
      "code": "class PDFPagesRoot(PDFObject):\n    def __init__(self, count: int, media_box: str) -> None:\n        super().__init__()\n        self.type = Name(\"Pages\")\n        self.count = count\n        self.media_box = media_box\n        self.kids: Optional[PDFArray] = (\n            None  # must always be set before calling .serialize()\n        )",
      "language": "python"
    },
    {
      "code": "class PDFResources(PDFObject):\n    def __init__(\n        self,\n        proc_set: Optional[str],\n        font: Optional[str],\n        x_object: Optional[str],\n        ext_g_state: Optional[str],\n        shading: Optional[str],\n        pattern: Optional[str],\n    ) -> None:\n        super().__init__()\n        self.proc_set = proc_set\n        self.font = font\n        self.x_object = x_object\n        self.ext_g_state = ext_g_state\n        self.shading = shading\n        self.pattern = pattern",
      "language": "python"
    },
    {
      "code": "class PDFType3Font(PDFObject):\n    def __init__(self, font3: \"Type3Font\") -> None:\n        super().__init__()\n        self._font3 = font3\n        self.type = Name(\"Font\")\n        self.name = Name(f\"MPDFAA+{font3.base_font.name}\")\n        self.subtype = Name(\"Type3\")\n        self.font_b_box = (\n            f\"[{self._font3.base_font.ttfont['head'].xMin * self._font3.scale:.0f}\"\n            f\" {self._font3.base_font.ttfont['head'].yMin * self._font3.scale:.0f}\"\n            f\" {self._font3.base_font.ttfont['head'].xMax * self._font3.scale:.0f}\"\n            f\" {self._font3.base_font.ttfont['head'].yMax * self._font3.scale:.0f}]\"\n        )\n        self.font_matrix = \"[0.001 0 0 0.001 0 0]\"\n        self.first_char = min(g.unicode for g in font3.glyphs)\n        self.last_char = max(g.unicode for g in font3.glyphs)\n        self.resources: Optional[str] = None\n        self.to_unicode: Optional[str] = None\n\n    @property\n    def char_procs(self) -> str:\n        return pdf_dict(\n            {f\"/{g.glyph_name}\": f\"{g.obj_id} 0 R\" for g in self._font3.glyphs}\n        )\n\n    @property\n    def encoding(self) -> str:\n        return pdf_dict(\n            {\n                Name(\"/Type\"): Name(\"/Encoding\"),\n                Name(\"/Differences\"): self.differences_table(),\n            }\n        )\n\n    @property\n    def widths(self) -> str:\n        sorted_glyphs = sorted(self._font3.glyphs, key=lambda glyph: glyph.unicode)\n        # Find the range of unicode values\n        min_unicode = sorted_glyphs[0].unicode\n        max_unicode = sorted_glyphs[-1].unicode\n\n        # Initialize widths array with zeros\n        widths = [0] * (max_unicode + 1 - min_unicode)\n\n        # Populate the widths array\n        for glyph in sorted_glyphs:\n            widths[glyph.unicode - min_unicode] = round(\n                glyph.glyph_width * self._font3.scale + 0.001\n            )\n        return pdf_list([str(glyph_width) for glyph_width in widths])\n\n    def generate_resources(\n        self,\n        img_objs_per_index: dict[int, \"PDFXObject\"],\n        gfxstate_objs_per_name: dict[str, \"PDFExtGState\"],\n        pattern_objs_per_name: dict[str, \"Pattern\"],\n    ) -> None:\n        resources = \"<<\"\n        objects = \" \".join(\n            f\"/I{img} {img_objs_per_index[img].id} 0 R\"\n            for img in self._font3.images_used\n        )\n        resources += f\"/XObject <<{objects}>>\" if len(objects) > 0 else \"\"\n\n        ext_g_state = \" \".join(\n            f\"/{name} {gfxstate_obj.id} 0 R\"\n            for name, gfxstate_obj in gfxstate_objs_per_name.items()\n            if name in self._font3.graphics_style_used\n        )\n        resources += f\"/ExtGState <<{ext_g_state}>>\" if len(ext_g_state) > 0 else \"\"\n\n        pattern = \" \".join(\n            f\"/{name} {pattern.id} 0 R\"\n            for name, pattern in pattern_objs_per_name.items()\n            if name in self._font3.patterns_used\n        )\n        resources += f\"/Pattern <<{pattern}>>\" if len(pattern) > 0 else \"\"\n\n        resources += \">>\"\n        self.resources = resources\n\n    def differences_table(self) -> str:\n        sorted_glyphs = sorted(self._font3.glyphs, key=lambda glyph: glyph.unicode)\n        return (\n            \"[\"\n            + \"\\n\".join(\n                f\"{glyph.unicode} /{glyph.glyph_name}\" for glyph in sorted_glyphs\n            )\n            + \"]\"\n        )",
      "language": "python"
    },
    {
      "code": "@property\ndef char_procs(self) -> str:\n    return pdf_dict(\n        {f\"/{g.glyph_name}\": f\"{g.obj_id} 0 R\" for g in self._font3.glyphs}\n    )",
      "language": "python"
    },
    {
      "code": "@property\ndef encoding(self) -> str:\n    return pdf_dict(\n        {\n            Name(\"/Type\"): Name(\"/Encoding\"),\n            Name(\"/Differences\"): self.differences_table(),\n        }\n    )",
      "language": "python"
    },
    {
      "code": "@property\ndef widths(self) -> str:\n    sorted_glyphs = sorted(self._font3.glyphs, key=lambda glyph: glyph.unicode)\n    # Find the range of unicode values\n    min_unicode = sorted_glyphs[0].unicode\n    max_unicode = sorted_glyphs[-1].unicode\n\n    # Initialize widths array with zeros\n    widths = [0] * (max_unicode + 1 - min_unicode)\n\n    # Populate the widths array\n    for glyph in sorted_glyphs:\n        widths[glyph.unicode - min_unicode] = round(\n            glyph.glyph_width * self._font3.scale + 0.001\n        )\n    return pdf_list([str(glyph_width) for glyph_width in widths])",
      "language": "python"
    },
    {
      "code": "def differences_table(self) -> str:\n    sorted_glyphs = sorted(self._font3.glyphs, key=lambda glyph: glyph.unicode)\n    return (\n        \"[\"\n        + \"\\n\".join(\n            f\"{glyph.unicode} /{glyph.glyph_name}\" for glyph in sorted_glyphs\n        )\n        + \"]\"\n    )",
      "language": "python"
    },
    {
      "code": "def generate_resources(\n    self,\n    img_objs_per_index: dict[int, \"PDFXObject\"],\n    gfxstate_objs_per_name: dict[str, \"PDFExtGState\"],\n    pattern_objs_per_name: dict[str, \"Pattern\"],\n) -> None:\n    resources = \"<<\"\n    objects = \" \".join(\n        f\"/I{img} {img_objs_per_index[img].id} 0 R\"\n        for img in self._font3.images_used\n    )\n    resources += f\"/XObject <<{objects}>>\" if len(objects) > 0 else \"\"\n\n    ext_g_state = \" \".join(\n        f\"/{name} {gfxstate_obj.id} 0 R\"\n        for name, gfxstate_obj in gfxstate_objs_per_name.items()\n        if name in self._font3.graphics_style_used\n    )\n    resources += f\"/ExtGState <<{ext_g_state}>>\" if len(ext_g_state) > 0 else \"\"\n\n    pattern = \" \".join(\n        f\"/{name} {pattern.id} 0 R\"\n        for name, pattern in pattern_objs_per_name.items()\n        if name in self._font3.patterns_used\n    )\n    resources += f\"/Pattern <<{pattern}>>\" if len(pattern) > 0 else \"\"\n\n    resources += \">>\"\n    self.resources = resources",
      "language": "python"
    },
    {
      "code": "class PDFXObject(PDFContentStream):\n    __slots__ = (  # RAM usage optimization\n        \"_id\",\n        \"_contents\",\n        \"filter\",\n        \"length\",\n        \"type\",\n        \"subtype\",\n        \"width\",\n        \"height\",\n        \"color_space\",\n        \"bits_per_component\",\n        \"decode\",\n        \"decode_parms\",\n        \"s_mask\",\n    )\n\n    def __init__(\n        self,\n        contents: bytes,\n        subtype: str,\n        width: float,\n        height: float,\n        color_space: PDFArray | Name,\n        bits_per_component: int,\n        img_filter: Optional[str] = None,\n        decode: Optional[str] = None,\n        decode_parms: Optional[str] = None,\n    ) -> None:\n        super().__init__(contents=contents)\n        self.type = Name(\"XObject\")\n        self.subtype = Name(subtype)\n        self.width = width\n        self.height = height\n        self.color_space = color_space\n        self.bits_per_component = bits_per_component\n        self.filter = Name(img_filter)\n        self.decode = decode\n        self.decode_parms = decode_parms\n        self.s_mask: Optional[PDFXObject] = None",
      "language": "python"
    },
    {
      "code": "class PDFXObject(PDFContentStream):\n    __slots__ = (  # RAM usage optimization\n        \"_id\",\n        \"_contents\",\n        \"filter\",\n        \"length\",\n        \"type\",\n        \"subtype\",\n        \"width\",\n        \"height\",\n        \"color_space\",\n        \"bits_per_component\",\n        \"decode\",\n        \"decode_parms\",\n        \"s_mask\",\n    )\n\n    def __init__(\n        self,\n        contents: bytes,\n        subtype: str,\n        width: float,\n        height: float,\n        color_space: PDFArray | Name,\n        bits_per_component: int,\n        img_filter: Optional[str] = None,\n        decode: Optional[str] = None,\n        decode_parms: Optional[str] = None,\n    ) -> None:\n        super().__init__(contents=contents)\n        self.type = Name(\"XObject\")\n        self.subtype = Name(subtype)\n        self.width = width\n        self.height = height\n        self.color_space = color_space\n        self.bits_per_component = bits_per_component\n        self.filter = Name(img_filter)\n        self.decode = decode\n        self.decode_parms = decode_parms\n        self.s_mask: Optional[PDFXObject] = None",
      "language": "python"
    },
    {
      "code": "class PDFXObject(PDFContentStream):\n    __slots__ = (  # RAM usage optimization\n        \"_id\",\n        \"_contents\",\n        \"filter\",\n        \"length\",\n        \"type\",\n        \"subtype\",\n        \"width\",\n        \"height\",\n        \"color_space\",\n        \"bits_per_component\",\n        \"decode\",\n        \"decode_parms\",\n        \"s_mask\",\n    )\n\n    def __init__(\n        self,\n        contents: bytes,\n        subtype: str,\n        width: float,\n        height: float,\n        color_space: PDFArray | Name,\n        bits_per_component: int,\n        img_filter: Optional[str] = None,\n        decode: Optional[str] = None,\n        decode_parms: Optional[str] = None,\n    ) -> None:\n        super().__init__(contents=contents)\n        self.type = Name(\"XObject\")\n        self.subtype = Name(subtype)\n        self.width = width\n        self.height = height\n        self.color_space = color_space\n        self.bits_per_component = bits_per_component\n        self.filter = Name(img_filter)\n        self.decode = decode\n        self.decode_parms = decode_parms\n        self.s_mask: Optional[PDFXObject] = None",
      "language": "python"
    },
    {
      "code": "class PDFXObject(PDFContentStream):\n    __slots__ = (  # RAM usage optimization\n        \"_id\",\n        \"_contents\",\n        \"filter\",\n        \"length\",\n        \"type\",\n        \"subtype\",\n        \"width\",\n        \"height\",\n        \"color_space\",\n        \"bits_per_component\",\n        \"decode\",\n        \"decode_parms\",\n        \"s_mask\",\n    )\n\n    def __init__(\n        self,\n        contents: bytes,\n        subtype: str,\n        width: float,\n        height: float,\n        color_space: PDFArray | Name,\n        bits_per_component: int,\n        img_filter: Optional[str] = None,\n        decode: Optional[str] = None,\n        decode_parms: Optional[str] = None,\n    ) -> None:\n        super().__init__(contents=contents)\n        self.type = Name(\"XObject\")\n        self.subtype = Name(subtype)\n        self.width = width\n        self.height = height\n        self.color_space = color_space\n        self.bits_per_component = bits_per_component\n        self.filter = Name(img_filter)\n        self.decode = decode\n        self.decode_parms = decode_parms\n        self.s_mask: Optional[PDFXObject] = None",
      "language": "python"
    },
    {
      "code": "class PDFXObject(PDFContentStream):\n    __slots__ = (  # RAM usage optimization\n        \"_id\",\n        \"_contents\",\n        \"filter\",\n        \"length\",\n        \"type\",\n        \"subtype\",\n        \"width\",\n        \"height\",\n        \"color_space\",\n        \"bits_per_component\",\n        \"decode\",\n        \"decode_parms\",\n        \"s_mask\",\n    )\n\n    def __init__(\n        self,\n        contents: bytes,\n        subtype: str,\n        width: float,\n        height: float,\n        color_space: PDFArray | Name,\n        bits_per_component: int,\n        img_filter: Optional[str] = None,\n        decode: Optional[str] = None,\n        decode_parms: Optional[str] = None,\n    ) -> None:\n        super().__init__(contents=contents)\n        self.type = Name(\"XObject\")\n        self.subtype = Name(subtype)\n        self.width = width\n        self.height = height\n        self.color_space = color_space\n        self.bits_per_component = bits_per_component\n        self.filter = Name(img_filter)\n        self.decode = decode\n        self.decode_parms = decode_parms\n        self.s_mask: Optional[PDFXObject] = None",
      "language": "python"
    },
    {
      "code": "class PDFXObject(PDFContentStream):\n    __slots__ = (  # RAM usage optimization\n        \"_id\",\n        \"_contents\",\n        \"filter\",\n        \"length\",\n        \"type\",\n        \"subtype\",\n        \"width\",\n        \"height\",\n        \"color_space\",\n        \"bits_per_component\",\n        \"decode\",\n        \"decode_parms\",\n        \"s_mask\",\n    )\n\n    def __init__(\n        self,\n        contents: bytes,\n        subtype: str,\n        width: float,\n        height: float,\n        color_space: PDFArray | Name,\n        bits_per_component: int,\n        img_filter: Optional[str] = None,\n        decode: Optional[str] = None,\n        decode_parms: Optional[str] = None,\n    ) -> None:\n        super().__init__(contents=contents)\n        self.type = Name(\"XObject\")\n        self.subtype = Name(subtype)\n        self.width = width\n        self.height = height\n        self.color_space = color_space\n        self.bits_per_component = bits_per_component\n        self.filter = Name(img_filter)\n        self.decode = decode\n        self.decode_parms = decode_parms\n        self.s_mask: Optional[PDFXObject] = None",
      "language": "python"
    },
    {
      "code": "class PDFXObject(PDFContentStream):\n    __slots__ = (  # RAM usage optimization\n        \"_id\",\n        \"_contents\",\n        \"filter\",\n        \"length\",\n        \"type\",\n        \"subtype\",\n        \"width\",\n        \"height\",\n        \"color_space\",\n        \"bits_per_component\",\n        \"decode\",\n        \"decode_parms\",\n        \"s_mask\",\n    )\n\n    def __init__(\n        self,\n        contents: bytes,\n        subtype: str,\n        width: float,\n        height: float,\n        color_space: PDFArray | Name,\n        bits_per_component: int,\n        img_filter: Optional[str] = None,\n        decode: Optional[str] = None,\n        decode_parms: Optional[str] = None,\n    ) -> None:\n        super().__init__(contents=contents)\n        self.type = Name(\"XObject\")\n        self.subtype = Name(subtype)\n        self.width = width\n        self.height = height\n        self.color_space = color_space\n        self.bits_per_component = bits_per_component\n        self.filter = Name(img_filter)\n        self.decode = decode\n        self.decode_parms = decode_parms\n        self.s_mask: Optional[PDFXObject] = None",
      "language": "python"
    },
    {
      "code": "class PDFXObject(PDFContentStream):\n    __slots__ = (  # RAM usage optimization\n        \"_id\",\n        \"_contents\",\n        \"filter\",\n        \"length\",\n        \"type\",\n        \"subtype\",\n        \"width\",\n        \"height\",\n        \"color_space\",\n        \"bits_per_component\",\n        \"decode\",\n        \"decode_parms\",\n        \"s_mask\",\n    )\n\n    def __init__(\n        self,\n        contents: bytes,\n        subtype: str,\n        width: float,\n        height: float,\n        color_space: PDFArray | Name,\n        bits_per_component: int,\n        img_filter: Optional[str] = None,\n        decode: Optional[str] = None,\n        decode_parms: Optional[str] = None,\n    ) -> None:\n        super().__init__(contents=contents)\n        self.type = Name(\"XObject\")\n        self.subtype = Name(subtype)\n        self.width = width\n        self.height = height\n        self.color_space = color_space\n        self.bits_per_component = bits_per_component\n        self.filter = Name(img_filter)\n        self.decode = decode\n        self.decode_parms = decode_parms\n        self.s_mask: Optional[PDFXObject] = None",
      "language": "python"
    },
    {
      "code": "class PDFXObject(PDFContentStream):\n    __slots__ = (  # RAM usage optimization\n        \"_id\",\n        \"_contents\",\n        \"filter\",\n        \"length\",\n        \"type\",\n        \"subtype\",\n        \"width\",\n        \"height\",\n        \"color_space\",\n        \"bits_per_component\",\n        \"decode\",\n        \"decode_parms\",\n        \"s_mask\",\n    )\n\n    def __init__(\n        self,\n        contents: bytes,\n        subtype: str,\n        width: float,\n        height: float,\n        color_space: PDFArray | Name,\n        bits_per_component: int,\n        img_filter: Optional[str] = None,\n        decode: Optional[str] = None,\n        decode_parms: Optional[str] = None,\n    ) -> None:\n        super().__init__(contents=contents)\n        self.type = Name(\"XObject\")\n        self.subtype = Name(subtype)\n        self.width = width\n        self.height = height\n        self.color_space = color_space\n        self.bits_per_component = bits_per_component\n        self.filter = Name(img_filter)\n        self.decode = decode\n        self.decode_parms = decode_parms\n        self.s_mask: Optional[PDFXObject] = None",
      "language": "python"
    },
    {
      "code": "class PDFXObject(PDFContentStream):\n    __slots__ = (  # RAM usage optimization\n        \"_id\",\n        \"_contents\",\n        \"filter\",\n        \"length\",\n        \"type\",\n        \"subtype\",\n        \"width\",\n        \"height\",\n        \"color_space\",\n        \"bits_per_component\",\n        \"decode\",\n        \"decode_parms\",\n        \"s_mask\",\n    )\n\n    def __init__(\n        self,\n        contents: bytes,\n        subtype: str,\n        width: float,\n        height: float,\n        color_space: PDFArray | Name,\n        bits_per_component: int,\n        img_filter: Optional[str] = None,\n        decode: Optional[str] = None,\n        decode_parms: Optional[str] = None,\n    ) -> None:\n        super().__init__(contents=contents)\n        self.type = Name(\"XObject\")\n        self.subtype = Name(subtype)\n        self.width = width\n        self.height = height\n        self.color_space = color_space\n        self.bits_per_component = bits_per_component\n        self.filter = Name(img_filter)\n        self.decode = decode\n        self.decode_parms = decode_parms\n        self.s_mask: Optional[PDFXObject] = None",
      "language": "python"
    },
    {
      "code": "class PDFXObject(PDFContentStream):\n    __slots__ = (  # RAM usage optimization\n        \"_id\",\n        \"_contents\",\n        \"filter\",\n        \"length\",\n        \"type\",\n        \"subtype\",\n        \"width\",\n        \"height\",\n        \"color_space\",\n        \"bits_per_component\",\n        \"decode\",\n        \"decode_parms\",\n        \"s_mask\",\n    )\n\n    def __init__(\n        self,\n        contents: bytes,\n        subtype: str,\n        width: float,\n        height: float,\n        color_space: PDFArray | Name,\n        bits_per_component: int,\n        img_filter: Optional[str] = None,\n        decode: Optional[str] = None,\n        decode_parms: Optional[str] = None,\n    ) -> None:\n        super().__init__(contents=contents)\n        self.type = Name(\"XObject\")\n        self.subtype = Name(subtype)\n        self.width = width\n        self.height = height\n        self.color_space = color_space\n        self.bits_per_component = bits_per_component\n        self.filter = Name(img_filter)\n        self.decode = decode\n        self.decode_parms = decode_parms\n        self.s_mask: Optional[PDFXObject] = None",
      "language": "python"
    },
    {
      "code": "class PDFXObject(PDFContentStream):\n    __slots__ = (  # RAM usage optimization\n        \"_id\",\n        \"_contents\",\n        \"filter\",\n        \"length\",\n        \"type\",\n        \"subtype\",\n        \"width\",\n        \"height\",\n        \"color_space\",\n        \"bits_per_component\",\n        \"decode\",\n        \"decode_parms\",\n        \"s_mask\",\n    )\n\n    def __init__(\n        self,\n        contents: bytes,\n        subtype: str,\n        width: float,\n        height: float,\n        color_space: PDFArray | Name,\n        bits_per_component: int,\n        img_filter: Optional[str] = None,\n        decode: Optional[str] = None,\n        decode_parms: Optional[str] = None,\n    ) -> None:\n        super().__init__(contents=contents)\n        self.type = Name(\"XObject\")\n        self.subtype = Name(subtype)\n        self.width = width\n        self.height = height\n        self.color_space = color_space\n        self.bits_per_component = bits_per_component\n        self.filter = Name(img_filter)\n        self.decode = decode\n        self.decode_parms = decode_parms\n        self.s_mask: Optional[PDFXObject] = None",
      "language": "python"
    },
    {
      "code": "class PDFXmpMetadata(PDFContentStream):\n    def __init__(self, contents: str) -> None:\n        super().__init__(contents=contents.encode(\"utf-8\"))\n        self.type = Name(\"Metadata\")\n        self.subtype = Name(\"XML\")",
      "language": "python"
    },
    {
      "code": "class PDFXrefAndTrailer(ContentWithoutID):\n    \"Cross-reference table & file trailer\"\n\n    def __init__(self, output_builder: \"OutputProducer\") -> None:\n        self.output_builder = output_builder\n        self.count = output_builder.obj_id + 1\n        # Must be set before the call to serialize():\n        self.catalog_obj: Optional[PDFCatalog] = None\n        self.info_obj: Optional[PDFInfo] = None\n        self.encryption_obj: Optional[\"EncryptionDictionary\"] = None\n\n    def serialize(\n        self, _security_handler: Optional[\"StandardSecurityHandler\"] = None\n    ) -> str:\n        if self.catalog_obj is None:\n            raise FPDFException(\"Invalid state for XREF production.\")\n        builder = self.output_builder\n        startxref = str(len(builder.buffer))\n        out: list[str] = []\n        out.append(\"xref\")\n        out.append(f\"0 {self.count}\")\n        out.append(\"0000000000 65535 f \")\n        for obj_id in range(1, self.count):\n            out.append(f\"{builder.offsets[obj_id]:010} 00000 n \")\n        out.append(\"trailer\")\n        out.append(\"<<\")\n        out.append(f\"/Size {self.count}\")\n        out.append(f\"/Root {pdf_ref(self.catalog_obj.id)}\")\n        if self.info_obj:\n            out.append(f\"/Info {pdf_ref(self.info_obj.id)}\")\n        fpdf = builder.fpdf\n        if self.encryption_obj:\n            out.append(f\"/Encrypt {pdf_ref(self.encryption_obj.id)}\")\n            assert fpdf._security_handler is not None\n            file_id: Optional[str | Literal[-1]] = fpdf._security_handler.file_id\n        else:\n            file_id = fpdf.file_id()\n            if file_id == -1:\n                file_id = fpdf._default_file_id(builder.buffer)\n        if file_id is not None:\n            out.append(f\"/ID [{file_id}]\")\n        out.append(\">>\")\n        out.append(\"startxref\")\n        out.append(startxref)\n        out.append(\"%%EOF\")\n        return \"\\n\".join(out)",
      "language": "python"
    },
    {
      "code": "def serialize(\n    self, _security_handler: Optional[\"StandardSecurityHandler\"] = None\n) -> str:\n    if self.catalog_obj is None:\n        raise FPDFException(\"Invalid state for XREF production.\")\n    builder = self.output_builder\n    startxref = str(len(builder.buffer))\n    out: list[str] = []\n    out.append(\"xref\")\n    out.append(f\"0 {self.count}\")\n    out.append(\"0000000000 65535 f \")\n    for obj_id in range(1, self.count):\n        out.append(f\"{builder.offsets[obj_id]:010} 00000 n \")\n    out.append(\"trailer\")\n    out.append(\"<<\")\n    out.append(f\"/Size {self.count}\")\n    out.append(f\"/Root {pdf_ref(self.catalog_obj.id)}\")\n    if self.info_obj:\n        out.append(f\"/Info {pdf_ref(self.info_obj.id)}\")\n    fpdf = builder.fpdf\n    if self.encryption_obj:\n        out.append(f\"/Encrypt {pdf_ref(self.encryption_obj.id)}\")\n        assert fpdf._security_handler is not None\n        file_id: Optional[str | Literal[-1]] = fpdf._security_handler.file_id\n    else:\n        file_id = fpdf.file_id()\n        if file_id == -1:\n            file_id = fpdf._default_file_id(builder.buffer)\n    if file_id is not None:\n        out.append(f\"/ID [{file_id}]\")\n    out.append(\">>\")\n    out.append(\"startxref\")\n    out.append(startxref)\n    out.append(\"%%EOF\")\n    return \"\\n\".join(out)",
      "language": "python"
    },
    {
      "code": "class ResourceCatalog:\n    \"Manage the indexing of resources and association to the pages they are used\"\n\n    GS_REGEX = re.compile(r\"/(GS\\d+) gs\")\n    IMG_REGEX = re.compile(r\"/I(\\d+) Do\")\n    PATTERN_FILL_REGEX = re.compile(r\"/(P\\d+)\\s+scn\")\n    PATTERN_STROKE_REGEX = re.compile(r\"/(P\\d+)\\s+SCN\")\n    FONT_REGEX = re.compile(r\"/F(\\d+)\\s+[-+]?\\d+(?:\\.\\d+)?\\s+Tf\")\n\n    def __init__(self) -> None:\n        self.resources: dict[PDFResourceType, dict[ResourceTypes, str]] = defaultdict(\n            dict\n        )\n        self.resources_per_page: dict[\n            tuple[int, PDFResourceType], set[ResourceTypes]\n        ] = defaultdict(set)\n        self.graphics_styles: dict[str, Name] = OrderedDict()\n        self.soft_mask_xobjects: list[PDFContentStream] = []\n        self.form_xobjects: list[tuple[int, PDFContentStream]] = []\n        self.last_reserved_object_id: int = 0\n        self.font_registry: dict[str, CoreFont | TTFFont] = {}\n        self.next_xobject_index: int = 1\n\n    def add(\n        self,\n        resource_type: PDFResourceType,\n        resource: ResourceTypes,\n        page_number: Optional[int],\n    ) -> Optional[str]:\n        if resource_type in (PDFResourceType.PATTERN, PDFResourceType.SHADING):\n            registry = self.resources[resource_type]\n            prefix = self._get_prefix(resource_type)\n\n            if resource not in registry:\n                registry[resource] = f\"{prefix}{len(registry) + 1}\"\n            if page_number is not None:\n                self.resources_per_page[(page_number, resource_type)].add(\n                    registry[resource]\n                )\n            return str(registry[resource])\n\n        if (\n            resource_type == PDFResourceType.X_OBJECT\n            and isinstance(resource, int)\n            and resource >= self.next_xobject_index\n        ):\n            self.next_xobject_index = resource + 1\n\n        if TYPE_CHECKING:\n            assert page_number is not None\n        self.resources_per_page[(page_number, resource_type)].add(resource)\n        return None\n\n    def register_graphics_style(self, style: \"GraphicsStyle\") -> Optional[Name]:\n        \"\"\"\n        Graphics style can be added without associating to a page number right away,\n        like when rendering a svg image.\n        The method that adds image to the page will call the add method for the page association.\n        \"\"\"\n        style_dict: Optional[Raw] = style.serialize()\n        if style_dict is None:  # empty style does not need an entry\n            return None\n        style_str = str(style_dict)\n\n        if style_str not in self.graphics_styles:\n            name = Name(\n                f\"{self._get_prefix(PDFResourceType.EXT_G_STATE)}{len(self.graphics_styles)}\"\n            )\n            self.graphics_styles[style_str] = name\n\n        return self.graphics_styles[style_str]\n\n    def register_soft_mask(self, soft_mask: PaintSoftMask) -> int:\n        \"\"\"Register a soft mask xobject and return its object id\"\"\"\n        self.last_reserved_object_id += 1\n        xobject = soft_mask_path_to_xobject(soft_mask, self)\n        xobject.id = self.last_reserved_object_id\n        self.soft_mask_xobjects.append(xobject)\n        return xobject.id\n\n    def register_blend_form(self, blend_group: \"BlendGroup\") -> int:\n        \"\"\"Register a blend group Form XObject and return its resource index.\"\"\"\n        xobject = blend_group_to_xobject(blend_group, self)\n        index = self.next_xobject_index\n        self.next_xobject_index += 1\n        self.form_xobjects.append((index, xobject))\n        return index\n\n    def scan_stream(self, rendered: str) -> set[tuple[PDFResourceType, str]]:\n        \"\"\"Parse a content stream and return discovered resources\"\"\"\n        found: set[tuple[PDFResourceType, str]] = set()\n\n        for m in self.GS_REGEX.finditer(rendered):\n            found.add((PDFResourceType.EXT_G_STATE, m.group(1)))\n\n        for m in self.IMG_REGEX.finditer(rendered):\n            found.add((PDFResourceType.X_OBJECT, m.group(1)))\n\n        for m in self.PATTERN_FILL_REGEX.finditer(rendered):\n            found.add((PDFResourceType.PATTERN, m.group(1)))\n\n        for m in self.PATTERN_STROKE_REGEX.finditer(rendered):\n            found.add((PDFResourceType.PATTERN, m.group(1)))\n\n        for m in self.FONT_REGEX.finditer(rendered):\n            found.add((PDFResourceType.FONT, m.group(1)))\n\n        return found\n\n    def index_stream_resources(self, rendered: str, page_number: int) -> None:\n        \"\"\"\n        Scan a rendered content stream and register resources used on the given page.\n        Currently indexes:\n          - ExtGState invocations: '/GSn gs'\n          - Image XObjects: '/In Do'\n        \"\"\"\n        for resource_type, resource in self.scan_stream(rendered):\n            if resource_type == PDFResourceType.PATTERN:\n                self.resources_per_page[(page_number, PDFResourceType.PATTERN)].add(\n                    resource\n                )\n            else:\n                self.add(resource_type, resource, page_number)\n\n    def get_items(\n        self, resource_type: PDFResourceType\n    ) -> ItemsView[ResourceTypes, str]:\n        return self.resources[resource_type].items()\n\n    def get_resources_per_page(\n        self, page_number: int, resource_type: PDFResourceType\n    ) -> set[ResourceTypes]:\n        return self.resources_per_page[(page_number, resource_type)]\n\n    def get_used_resources(self, resource_type: PDFResourceType) -> set[ResourceTypes]:\n        unique: set[ResourceTypes] = set()\n        for (_, rtype), resource in self.resources_per_page.items():\n            if rtype == resource_type:\n                unique.update(resource)\n        return unique\n\n    @classmethod\n    def _get_prefix(cls, resource_type: PDFResourceType) -> str:\n        if resource_type == PDFResourceType.EXT_G_STATE:\n            return \"GS\"\n        if resource_type == PDFResourceType.PATTERN:\n            return \"P\"\n        if resource_type == PDFResourceType.SHADING:\n            return \"Sh\"\n        raise ValueError(f\"No prefix for resource type {resource_type}\")\n\n    def get_font_from_family(\n        self, font_family: str, font_style: str = \"\"\n    ) -> CoreFont | TTFFont:\n        \"\"\"\n        Resolve a family+style to a concrete font instance from the font registry.\n        Behavior:\n          - Exact match (family.lower() + style.upper()) in registry: return it\n          - If `family` names a core font: add CoreFont to registry (if missing) and return it\n          - If `family` is an alias/generic: translate to a core font, add to registry (if missing), and return it\n          - Otherwise: raise KeyError\n\n        Notes:\n          - For Symbol/ZapfDingbats, style is forced to \"\" (they don't support B/I).\n        \"\"\"\n        if not font_family:\n            raise KeyError(\"Empty font family\")\n\n        style = \"\".join(sorted(font_style.upper()))\n\n        alias = {\n            # sans\n            \"sans-serif\": \"helvetica\",\n            \"sans serif\": \"helvetica\",\n            \"arial\": \"helvetica\",\n            \"verdana\": \"helvetica\",\n            \"tahoma\": \"helvetica\",\n            \"segoe ui\": \"helvetica\",\n            # serif\n            \"serif\": \"times\",\n            \"times\": \"times\",\n            \"times new roman\": \"times\",\n            \"georgia\": \"times\",\n            \"cambria\": \"times\",\n            \"garamond\": \"times\",\n            # mono\n            \"monospace\": \"courier\",\n            \"courier\": \"courier\",\n            \"courier new\": \"courier\",\n            \"consolas\": \"courier\",\n            \"monaco\": \"courier\",\n            # symbol\n            \"symbol\": \"symbol\",\n            \"zapfdingbats\": \"zapfdingbats\",\n            \"zapf dingbats\": \"zapfdingbats\",\n        }\n\n        for candidate in font_family.strip().strip(\"'\\\"\").split(\",\"):\n            family = candidate.strip().strip(\"'\\\"\").lower()\n\n            # 1) Exact match\n            fontkey = f\"{family}{style}\"\n            if fontkey in self.font_registry:\n                return self.font_registry[fontkey]\n\n            # 2) Core-family direct hit?\n            if family in CORE_FONTS:\n                core_style = \"\" if family in {\"symbol\", \"zapfdingbats\"} else style\n                key = f\"{family}{core_style}\"\n                if key not in self.font_registry:\n                    i = len(self.font_registry) + 1\n                    self.font_registry[key] = CoreFont(i, key, core_style)\n                return self.font_registry[key]\n\n            # 3) Alias / generic mapping to core font\n            mapped = alias.get(family)\n            if mapped:\n                core_style = \"\" if mapped in {\"symbol\", \"zapfdingbats\"} else style\n                key = f\"{mapped}{core_style}\"\n                if key not in self.font_registry:\n                    i = len(self.font_registry) + 1\n                    self.font_registry[key] = CoreFont(i, key, core_style)\n                return self.font_registry[key]\n\n        # 4) Fail: do not return anything\n        raise KeyError(f\"No suitable font for family={font_family!r}, style={style!r}\")",
      "language": "python"
    },
    {
      "code": "def add(\n    self,\n    resource_type: PDFResourceType,\n    resource: ResourceTypes,\n    page_number: Optional[int],\n) -> Optional[str]:\n    if resource_type in (PDFResourceType.PATTERN, PDFResourceType.SHADING):\n        registry = self.resources[resource_type]\n        prefix = self._get_prefix(resource_type)\n\n        if resource not in registry:\n            registry[resource] = f\"{prefix}{len(registry) + 1}\"\n        if page_number is not None:\n            self.resources_per_page[(page_number, resource_type)].add(\n                registry[resource]\n            )\n        return str(registry[resource])\n\n    if (\n        resource_type == PDFResourceType.X_OBJECT\n        and isinstance(resource, int)\n        and resource >= self.next_xobject_index\n    ):\n        self.next_xobject_index = resource + 1\n\n    if TYPE_CHECKING:\n        assert page_number is not None\n    self.resources_per_page[(page_number, resource_type)].add(resource)\n    return None",
      "language": "python"
    },
    {
      "code": "def get_font_from_family(\n    self, font_family: str, font_style: str = \"\"\n) -> CoreFont | TTFFont:\n    \"\"\"\n    Resolve a family+style to a concrete font instance from the font registry.\n    Behavior:\n      - Exact match (family.lower() + style.upper()) in registry: return it\n      - If `family` names a core font: add CoreFont to registry (if missing) and return it\n      - If `family` is an alias/generic: translate to a core font, add to registry (if missing), and return it\n      - Otherwise: raise KeyError\n\n    Notes:\n      - For Symbol/ZapfDingbats, style is forced to \"\" (they don't support B/I).\n    \"\"\"\n    if not font_family:\n        raise KeyError(\"Empty font family\")\n\n    style = \"\".join(sorted(font_style.upper()))\n\n    alias = {\n        # sans\n        \"sans-serif\": \"helvetica\",\n        \"sans serif\": \"helvetica\",\n        \"arial\": \"helvetica\",\n        \"verdana\": \"helvetica\",\n        \"tahoma\": \"helvetica\",\n        \"segoe ui\": \"helvetica\",\n        # serif\n        \"serif\": \"times\",\n        \"times\": \"times\",\n        \"times new roman\": \"times\",\n        \"georgia\": \"times\",\n        \"cambria\": \"times\",\n        \"garamond\": \"times\",\n        # mono\n        \"monospace\": \"courier\",\n        \"courier\": \"courier\",\n        \"courier new\": \"courier\",\n        \"consolas\": \"courier\",\n        \"monaco\": \"courier\",\n        # symbol\n        \"symbol\": \"symbol\",\n        \"zapfdingbats\": \"zapfdingbats\",\n        \"zapf dingbats\": \"zapfdingbats\",\n    }\n\n    for candidate in font_family.strip().strip(\"'\\\"\").split(\",\"):\n        family = candidate.strip().strip(\"'\\\"\").lower()\n\n        # 1) Exact match\n        fontkey = f\"{family}{style}\"\n        if fontkey in self.font_registry:\n            return self.font_registry[fontkey]\n\n        # 2) Core-family direct hit?\n        if family in CORE_FONTS:\n            core_style = \"\" if family in {\"symbol\", \"zapfdingbats\"} else style\n            key = f\"{family}{core_style}\"\n            if key not in self.font_registry:\n                i = len(self.font_registry) + 1\n                self.font_registry[key] = CoreFont(i, key, core_style)\n            return self.font_registry[key]\n\n        # 3) Alias / generic mapping to core font\n        mapped = alias.get(family)\n        if mapped:\n            core_style = \"\" if mapped in {\"symbol\", \"zapfdingbats\"} else style\n            key = f\"{mapped}{core_style}\"\n            if key not in self.font_registry:\n                i = len(self.font_registry) + 1\n                self.font_registry[key] = CoreFont(i, key, core_style)\n            return self.font_registry[key]\n\n    # 4) Fail: do not return anything\n    raise KeyError(f\"No suitable font for family={font_family!r}, style={style!r}\")",
      "language": "python"
    },
    {
      "code": "def get_items(\n    self, resource_type: PDFResourceType\n) -> ItemsView[ResourceTypes, str]:\n    return self.resources[resource_type].items()",
      "language": "python"
    },
    {
      "code": "def get_resources_per_page(\n    self, page_number: int, resource_type: PDFResourceType\n) -> set[ResourceTypes]:\n    return self.resources_per_page[(page_number, resource_type)]",
      "language": "python"
    },
    {
      "code": "def get_used_resources(self, resource_type: PDFResourceType) -> set[ResourceTypes]:\n    unique: set[ResourceTypes] = set()\n    for (_, rtype), resource in self.resources_per_page.items():\n        if rtype == resource_type:\n            unique.update(resource)\n    return unique",
      "language": "python"
    },
    {
      "code": "def index_stream_resources(self, rendered: str, page_number: int) -> None:\n    \"\"\"\n    Scan a rendered content stream and register resources used on the given page.\n    Currently indexes:\n      - ExtGState invocations: '/GSn gs'\n      - Image XObjects: '/In Do'\n    \"\"\"\n    for resource_type, resource in self.scan_stream(rendered):\n        if resource_type == PDFResourceType.PATTERN:\n            self.resources_per_page[(page_number, PDFResourceType.PATTERN)].add(\n                resource\n            )\n        else:\n            self.add(resource_type, resource, page_number)",
      "language": "python"
    },
    {
      "code": "def register_blend_form(self, blend_group: \"BlendGroup\") -> int:\n    \"\"\"Register a blend group Form XObject and return its resource index.\"\"\"\n    xobject = blend_group_to_xobject(blend_group, self)\n    index = self.next_xobject_index\n    self.next_xobject_index += 1\n    self.form_xobjects.append((index, xobject))\n    return index",
      "language": "python"
    },
    {
      "code": "def register_graphics_style(self, style: \"GraphicsStyle\") -> Optional[Name]:\n    \"\"\"\n    Graphics style can be added without associating to a page number right away,\n    like when rendering a svg image.\n    The method that adds image to the page will call the add method for the page association.\n    \"\"\"\n    style_dict: Optional[Raw] = style.serialize()\n    if style_dict is None:  # empty style does not need an entry\n        return None\n    style_str = str(style_dict)\n\n    if style_str not in self.graphics_styles:\n        name = Name(\n            f\"{self._get_prefix(PDFResourceType.EXT_G_STATE)}{len(self.graphics_styles)}\"\n        )\n        self.graphics_styles[style_str] = name\n\n    return self.graphics_styles[style_str]",
      "language": "python"
    },
    {
      "code": "def register_soft_mask(self, soft_mask: PaintSoftMask) -> int:\n    \"\"\"Register a soft mask xobject and return its object id\"\"\"\n    self.last_reserved_object_id += 1\n    xobject = soft_mask_path_to_xobject(soft_mask, self)\n    xobject.id = self.last_reserved_object_id\n    self.soft_mask_xobjects.append(xobject)\n    return xobject.id",
      "language": "python"
    },
    {
      "code": "def scan_stream(self, rendered: str) -> set[tuple[PDFResourceType, str]]:\n    \"\"\"Parse a content stream and return discovered resources\"\"\"\n    found: set[tuple[PDFResourceType, str]] = set()\n\n    for m in self.GS_REGEX.finditer(rendered):\n        found.add((PDFResourceType.EXT_G_STATE, m.group(1)))\n\n    for m in self.IMG_REGEX.finditer(rendered):\n        found.add((PDFResourceType.X_OBJECT, m.group(1)))\n\n    for m in self.PATTERN_FILL_REGEX.finditer(rendered):\n        found.add((PDFResourceType.PATTERN, m.group(1)))\n\n    for m in self.PATTERN_STROKE_REGEX.finditer(rendered):\n        found.add((PDFResourceType.PATTERN, m.group(1)))\n\n    for m in self.FONT_REGEX.finditer(rendered):\n        found.add((PDFResourceType.FONT, m.group(1)))\n\n    return found",
      "language": "python"
    }
  ],
  "patterns": [],
  "links": [
    "https://py-pdf.github.io/fpdf2/fpdf/output.html",
    "https://py-pdf.github.io/fpdf2/fpdf/syntax.html",
    "https://py-pdf.github.io/fpdf2/fpdf/drawing.html",
    "https://py-pdf.github.io/fpdf2/fpdf/image_datastructures.html",
    "https://py-pdf.github.io/fpdf2/fpdf/linearization.html",
    "https://py-pdf.github.io/fpdf2/fpdf/annotations.html",
    "https://py-pdf.github.io/fpdf2/fpdf/line_break.html",
    "https://py-pdf.github.io/fpdf2/fpdf/enums.html",
    "https://py-pdf.github.io/fpdf2/fpdf/fonts.html",
    "https://py-pdf.github.io/fpdf2/fpdf/pattern.html",
    "https://py-pdf.github.io/fpdf2/fpdf/index.html"
  ]
}