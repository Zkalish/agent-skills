{
  "url": "https://py-pdf.github.io/fpdf2/fpdf/image_parsing.html",
  "title": "Module fpdf.image_parsing",
  "content": "returns the byte offset and length of the CCITT payload in the original TIFF data\n\nReset the encoding table and coding state to initial conditions.\n\nChecks the validity of an ICC profile\n\nThis method is used to load external resources, such as images. It is automatically called when resource added to document by FPDF.image(). It always return a BytesIO buffer.\n\nConvert the list of result codes into a continuous byte stream, with codes packed as per the code bit-width. The bit-width starts at 9 bits and expands as needed.\n\nRead an image and load it into memory.\n\nFor raster images: following this call, the image is inserted in image_cache.images, and following calls to FPDF.image() will re-use the same cached values, without re-reading the image.\n\nFor vector images: the data is loaded and the metadata extracted.\n\nReturns: A tuple, consisting of 3 values: the name, the image data, and an instance of a subclass of ImageInfo.\n\nConvert the open PIL.Image imgdata to compressed CCITT Group4 data.\n\nImageSettings(compression_level: int = -1)\n\nThe type of the None singleton.\n\ntemporary change the attribute of an object using a context manager",
  "headings": [
    {
      "level": "h1",
      "text": "Module fpdf.image_parsing",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Functions",
      "id": "header-functions"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Classes",
      "id": "header-classes"
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    }
  ],
  "code_samples": [
    {
      "code": "def ccitt_payload_location_from_pil(img: \"PILImage\") -> tuple[int, int]:\n    \"\"\"\n    returns the byte offset and length of the CCITT payload in the original TIFF data\n    \"\"\"\n    # assert(img.info[\"compression\"] == \"group4\")\n\n    # Read the TIFF tags to find the offset(s) of the compressed data strips.\n    strip_offsets = img.tag_v2[TiffImagePlugin.STRIPOFFSETS]  # type: ignore[attr-defined]\n    strip_bytes = img.tag_v2[TiffImagePlugin.STRIPBYTECOUNTS]  # type: ignore[attr-defined]\n\n    # PIL always seems to create a single strip even for very large TIFFs when\n    # it saves images, so assume we only have to read a single strip.\n    # A test ~10 GPixel image was still encoded as a single strip. Just to be\n    # safe check throw an error if there is more than one offset.\n    if (\n        len(strip_offsets) != 1  # pyright: ignore[reportUnknownArgumentType]\n        or len(strip_bytes) != 1  # pyright: ignore[reportUnknownArgumentType]\n    ):  # pyright: ignore[reportUnknownArgumentType]\n        raise NotImplementedError(\n            \"Transcoding multiple strips not supported by the PDF format\"\n        )\n\n    (offset,), (length,) = (  # pyright: ignore[reportUnknownVariableType]\n        strip_offsets,\n        strip_bytes,\n    )  # pyright: ignore[reportUnknownVariableType]\n\n    return offset, length  # pyright: ignore[reportUnknownVariableType]",
      "language": "python"
    },
    {
      "code": "def clear_table() -> tuple[dict[bytes, int], int, int, int]:\n    \"\"\"\n    Reset the encoding table and coding state to initial conditions.\n\n    \"\"\"\n\n    table = {bytes([i]): i for i in range(256)}\n    next_code = LZW_EOD_MARKER + 1\n    bits_per_code = LZW_INITIAL_BITS_PER_CODE\n    max_code_value = (1 << bits_per_code) - 1\n    return table, next_code, bits_per_code, max_code_value",
      "language": "python"
    },
    {
      "code": "def get_img_info(\n    filename: Union[str, BinaryIO, Path],\n    img: Union[\"PILImage\", bytes, BinaryIO, Path, str, None] = None,\n    image_filter: ImageFilter = \"AUTO\",\n    dims: Optional[tuple[float, float]] = None,\n) -> RasterImageInfo:\n    \"\"\"\n    Args:\n        filename: in a format that can be passed to load_image\n        img: optional `bytes`, `BytesIO` or `PIL.Image.Image` instance\n        image_filter (str): one of the SUPPORTED_IMAGE_FILTERS\n    \"\"\"\n    if Image is None:\n        raise EnvironmentError(\"Pillow not available - fpdf2 cannot insert images\")\n\n    is_pil_img = True\n    keep_bytes_io_open = False\n    # Flag to check whether a cmyk image is jpeg or not, if set to True the decode array\n    # is inverted in output.py\n    jpeg_inverted = False\n    img_raw_data: Optional[BinaryIO] = None\n    if not img or isinstance(img, (Path, str)):\n        img_raw_data = load_image(filename)\n        img = Image.open(img_raw_data)\n        is_pil_img = False\n    elif not _is_pil_image(img):\n        keep_bytes_io_open = isinstance(img, BytesIO)\n        if isinstance(img, bytes):\n            img_raw_data = BytesIO(img)\n        else:\n            img_raw_data = img  # type: ignore[assignment]\n        assert img_raw_data is not None\n        img = Image.open(img_raw_data)\n        is_pil_img = False\n    assert _is_pil_image(img)\n\n    img_altered = False\n    if dims:\n        img = img.resize(dims, resample=RESAMPLE)  # type: ignore[arg-type]\n        img_altered = True\n\n    if image_filter == \"AUTO\":\n        # Very simple logic for now:\n        if img.format == \"JPEG\":\n            image_filter = \"DCTDecode\"\n        elif img.mode == \"1\" and PIL_features.check(\"libtiff\"):\n            # The 2nd condition prevents from running in a bug sometimes,\n            # cf. test_transcode_monochrome_and_libtiff_support_custom_tags()\n            image_filter = \"CCITTFaxDecode\"\n        else:\n            image_filter = \"FlateDecode\"\n\n    if img.mode in (\"P\", \"PA\") and image_filter != \"FlateDecode\":\n        img = img.convert(\"RGBA\")\n\n    if img.mode not in (\"1\", \"L\", \"LA\", \"RGB\", \"RGBA\", \"P\", \"PA\", \"CMYK\"):\n        img = img.convert(\"RGBA\")\n        img_altered = True\n\n    if img.mode in (\"P\", \"RGBA\") and image_filter == \"LZWDecode\":\n        img = img.convert(\"RGB\")\n    elif img.mode in (\"LA\") and image_filter == \"LZWDecode\":\n        img = img.convert(\"L\")\n\n    w, h = img.size\n    info = RasterImageInfo()\n\n    iccp = None\n    if \"icc_profile\" in img.info:\n        if is_iccp_valid(img.info[\"icc_profile\"], filename):\n            iccp = img.info[\"icc_profile\"]\n\n    if img_raw_data is not None and not img_altered:\n        # if we can use the original image bytes directly we do (JPEG and group4 TIFF only):\n        if img.format == \"JPEG\" and image_filter == \"DCTDecode\":\n            if img.mode in (\"RGB\", \"RGBA\"):\n                dpn, bpc, colspace = 3, 8, \"DeviceRGB\"\n            elif img.mode == \"CMYK\":\n                dpn, bpc, colspace = 4, 8, \"DeviceCMYK\"\n                jpeg_inverted = True\n            elif img.mode == \"L\":\n                dpn, bpc, colspace = 1, 8, \"DeviceGray\"\n            else:\n                raise ValueError(f\"Unsupported image mode: {img.mode}\")\n            img_raw_data.seek(0)\n            info.update(\n                {\n                    \"data\": img_raw_data.read(),\n                    \"w\": w,\n                    \"h\": h,\n                    \"cs\": colspace,\n                    \"iccp\": iccp,\n                    \"dpn\": dpn,\n                    \"bpc\": bpc,\n                    \"f\": image_filter,\n                    \"inverted\": jpeg_inverted,\n                    \"dp\": f\"/Predictor 15 /Colors {dpn} /Columns {w}\",\n                }\n            )\n            return info\n        # We can directly copy the data out of a CCITT Group 4 encoded TIFF, if it\n        # only contains a single strip\n        if (\n            img.format == \"TIFF\"\n            and image_filter == \"CCITTFaxDecode\"\n            and img.info[\"compression\"] == \"group4\"\n            and len(img.tag_v2[TiffImagePlugin.STRIPOFFSETS]) == 1  # type: ignore[attr-defined]\n            and len(img.tag_v2[TiffImagePlugin.STRIPBYTECOUNTS]) == 1  # type: ignore[attr-defined]\n        ):\n            photo = img.tag_v2[TiffImagePlugin.PHOTOMETRIC_INTERPRETATION]  # type: ignore[attr-defined]\n            inverted = False\n            if photo == 0:\n                inverted = True\n            elif photo != 1:\n                raise ValueError(\n                    f\"unsupported photometric interpretation for g4 tiff: {photo}\"\n                )\n            offset, length = ccitt_payload_location_from_pil(img)\n            img_raw_data.seek(offset)\n            ccittrawdata: bytes | bytearray = img_raw_data.read(length)\n            fillorder = img.tag_v2.get(TiffImagePlugin.FILLORDER)  # type: ignore[attr-defined]\n            if fillorder is None or fillorder == 1:\n                # no FillOrder or msb-to-lsb: nothing to do\n                pass\n            elif fillorder == 2:\n                # lsb-to-msb: reverse bits of each byte\n                ccittrawdata = bytearray(ccittrawdata)\n                for i, n in enumerate(ccittrawdata):\n                    ccittrawdata[i] = TIFFBitRevTable[n]\n                ccittrawdata = bytes(ccittrawdata)\n            else:\n                raise ValueError(f\"unsupported FillOrder: {fillorder}\")\n            dpn, bpc, colspace = 1, 1, \"DeviceGray\"\n            info.update(\n                {\n                    \"data\": ccittrawdata,\n                    \"w\": w,\n                    \"h\": h,\n                    \"iccp\": None,\n                    \"dpn\": dpn,\n                    \"cs\": colspace,\n                    \"bpc\": bpc,\n                    \"f\": image_filter,\n                    \"inverted\": jpeg_inverted,\n                    \"dp\": f\"/BlackIs1 {str(not inverted).lower()} /Columns {w} /K -1 /Rows {h}\",\n                }\n            )\n            return info\n\n    # garbage collection\n    img_raw_data = None\n\n    if img.mode == \"1\":\n        dpn, bpc, colspace = 1, 1, \"DeviceGray\"\n        info[\"data\"] = _to_data(img, image_filter)\n    elif img.mode == \"L\":\n        dpn, bpc, colspace = 1, 8, \"DeviceGray\"\n        info[\"data\"] = _to_data(img, image_filter)\n    elif img.mode == \"LA\":\n        dpn, bpc, colspace = 1, 8, \"DeviceGray\"\n        alpha_channel = slice(1, None, 2)\n        info[\"data\"] = _to_data(img, image_filter, remove_slice=alpha_channel)\n        if _has_alpha(img) and image_filter not in (\n            \"DCTDecode\",\n            \"JPXDecode\",\n        ):\n            info[\"smask\"] = _to_data(img, image_filter, select_slice=alpha_channel)\n    elif img.mode == \"P\":\n        dpn, bpc, colspace = 1, 8, \"Indexed\"\n        info[\"data\"] = _to_data(img, image_filter)\n        info[\"pal\"] = img.palette.palette if img.palette is not None else None\n\n        # check if the P image has transparency\n        if img.info.get(\"transparency\", None) is not None and image_filter not in (\n            \"DCTDecode\",\n            \"JPXDecode\",\n        ):\n            # convert to RGBA to get the alpha channel for creating the smask\n            info[\"smask\"] = _to_data(\n                img.convert(\"RGBA\"), image_filter, select_slice=slice(3, None, 4)\n            )\n    elif img.mode == \"PA\":\n        dpn, bpc, colspace = 1, 8, \"Indexed\"\n        info[\"pal\"] = img.palette.palette if img.palette is not None else None\n        alpha_channel = slice(1, None, 2)\n        info[\"data\"] = _to_data(img, image_filter, remove_slice=alpha_channel)\n        if _has_alpha(img) and image_filter not in (\n            \"DCTDecode\",\n            \"JPXDecode\",\n        ):\n            info[\"smask\"] = _to_data(img, image_filter, select_slice=alpha_channel)\n    elif img.mode == \"CMYK\":\n        dpn, bpc, colspace = 4, 8, \"DeviceCMYK\"\n        info[\"data\"] = _to_data(img, image_filter)\n    elif img.mode == \"RGB\":\n        dpn, bpc, colspace = 3, 8, \"DeviceRGB\"\n        info[\"data\"] = _to_data(img, image_filter)\n    else:  # RGBA image\n        dpn, bpc, colspace = 3, 8, \"DeviceRGB\"\n        alpha_channel = slice(3, None, 4)\n        info[\"data\"] = _to_data(img, image_filter, remove_slice=alpha_channel)\n        if _has_alpha(img) and image_filter not in (\n            \"DCTDecode\",\n            \"JPXDecode\",\n        ):\n            info[\"smask\"] = _to_data(img, image_filter, select_slice=alpha_channel)\n\n    dp = f\"/Predictor 15 /Colors {dpn} /Columns {w}\"\n\n    if img.mode == \"1\":\n        dp = f\"/BlackIs1 true /Columns {w} /K -1 /Rows {h}\"\n\n    if not is_pil_img:\n        if keep_bytes_io_open:\n            setattr(img, \"fp\", None)\n        else:\n            img.close()\n\n    info.update(\n        {\n            \"w\": w,\n            \"h\": h,\n            \"cs\": colspace,\n            \"iccp\": iccp,\n            \"bpc\": bpc,\n            \"dpn\": dpn,\n            \"f\": image_filter,\n            \"inverted\": jpeg_inverted,\n            \"dp\": dp,\n        }\n    )\n    return info",
      "language": "python"
    },
    {
      "code": "def get_svg_info(\n    filename: str, img: BinaryIO, image_cache: ImageCache\n) -> tuple[str, SVGObject, VectorImageInfo]:\n    img.seek(0)\n    svg_data = img.read()\n    svg = SVGObject(svg_data, image_cache=image_cache)\n    if svg.viewbox:\n        _, _, w, h = svg.viewbox\n    else:\n        w = h = 0.0\n    if svg.width:\n        w = svg.width\n    if svg.height:\n        h = svg.height\n    info = VectorImageInfo(data=svg, w=w, h=h)\n    return filename, svg, info",
      "language": "python"
    },
    {
      "code": "@no_type_check\ndef is_iccp_valid(iccp: bytes, filename: str | Path) -> bool:\n    \"Checks the validity of an ICC profile\"\n    try:\n        profile: \"ImageCmsProfile\" = ImageCms.getOpenProfile(BytesIO(iccp))\n    except ImageCms.PyCMSError:\n        LOGGER.info(\"Invalid ICC Profile in file %s\", filename)\n        return False\n    color_space = str(profile.profile.xcolor_space).strip()\n    if color_space not in (\"GRAY\", \"RGB\"):\n        LOGGER.info(\n            \"Unsupported color space %s in ICC Profile of file %s - cf. issue #711\",\n            color_space,\n            filename,\n        )\n        return False\n    return True",
      "language": "python"
    },
    {
      "code": "def load_image(filename: str | Path | BinaryIO) -> BinaryIO:\n    \"\"\"\n    This method is used to load external resources, such as images.\n    It is automatically called when resource added to document by `fpdf.fpdf.FPDF.image()`.\n    It always return a BytesIO buffer.\n    \"\"\"\n    # if a file-like object is passed in, use it directly or copy it into a BytesIO buffer\n    if isinstance(filename, (BytesIO, io.BufferedIOBase, BinaryIO)):\n        return filename\n    if hasattr(filename, \"read\") and not isinstance(filename, (str, Path)):\n        # Copy other file-like objects into a BytesIO so downstream code can seek/read freely\n        return BytesIO(filename.read())\n    if isinstance(filename, Path):\n        filename = str(filename)\n    # by default loading from network is allowed for all images\n    if filename.startswith((\"http://\", \"https://\")):\n        # disabling bandit & semgrep rules as permitted schemes are whitelisted:\n        # nosemgrep: python.lang.security.audit.dynamic-urllib-use-detected.dynamic-urllib-use-detected\n        with urlopen(filename) as url_file:  # nosec B310\n            return BytesIO(url_file.read())\n    elif filename.startswith(\"data:\"):\n        return _decode_base64_image(filename)\n    with open(filename, \"rb\") as local_file:\n        return BytesIO(local_file.read())",
      "language": "python"
    },
    {
      "code": "def pack_codes_into_bytes(codes: Iterable[int]) -> bytes:\n    \"\"\"\n    Convert the list of result codes into a continuous byte stream, with codes packed as per the code bit-width.\n    The bit-width starts at 9 bits and expands as needed.\n\n    \"\"\"\n\n    (\n        _,\n        next_code,\n        bits_per_code,\n        max_code_value,\n    ) = clear_table()\n    buffer = 0\n    bits_in_buffer = 0\n    output = bytearray()\n\n    if numpy is not None:\n        # Using numpy improves the performance significantly there\n        # _cf._ https://github.com/py-pdf/fpdf2/issues/1380\n        codes = numpy.array(codes, dtype=numpy.uint32)\n    for code in codes:\n        buffer = (buffer << bits_per_code) | code\n        bits_in_buffer += bits_per_code\n\n        while bits_in_buffer >= 8:\n            bits_in_buffer -= 8\n            output.append((buffer >> bits_in_buffer) & 0xFF)\n\n        if code == LZW_CLEAR_TABLE_MARKER:\n            _, next_code, bits_per_code, max_code_value = clear_table()\n        elif code != LZW_EOD_MARKER:\n            next_code += 1\n            if next_code > max_code_value and bits_per_code < LZW_MAX_BITS_PER_CODE:\n                bits_per_code += 1\n                max_code_value = (1 << bits_per_code) - 1\n\n    if bits_in_buffer > 0:\n        output.append((buffer << (8 - bits_in_buffer)) & 0xFF)\n\n    return bytes(output)",
      "language": "python"
    },
    {
      "code": "def preload_image(\n    image_cache: ImageCache,\n    name: ImageType,\n    dims: Optional[tuple[float, float]] = None,\n) -> tuple[\n    str,\n    Union[SVGObject, \"PILImage\", bytes, BinaryIO, Path, None],\n    RasterImageInfo | VectorImageInfo,\n]:\n    \"\"\"\n    Read an image and load it into memory.\n\n    For raster images: following this call, the image is inserted in `image_cache.images`,\n    and following calls to `fpdf.fpdf.FPDF.image()` will re-use the same cached values, without re-reading the image.\n\n    For vector images: the data is loaded and the metadata extracted.\n\n    Args:\n        image_cache: an `ImageCache` instance, usually the `.image_cache` attribute of a `FPDF` instance.\n        name: either a string representing a file path to an image, an URL to an image,\n            an io.BytesIO, or a instance of `PIL.Image.Image`.\n        dims (tuple[int, int]): optional dimensions as a tuple (width, height) to resize the image\n            (raster only) before storing it in the PDF.\n\n    Returns: A tuple, consisting of 3 values: the name, the image data,\n        and an instance of a subclass of `ImageInfo`.\n    \"\"\"\n    # Identify and load SVG data:\n    if isinstance(name, (str, Path)) and str(name).endswith(\".svg\"):\n        try:\n            return get_svg_info(\n                str(name), load_image(str(name)), image_cache=image_cache\n            )\n        except Exception as error:\n            raise ValueError(f\"Could not parse file: {name}\") from error\n    if isinstance(name, bytes) and _is_svg(name.strip()):\n        return get_svg_info(\"vector_image\", io.BytesIO(name), image_cache=image_cache)\n    if isinstance(name, io.BytesIO) and _is_svg(name.getvalue().strip()):\n        return get_svg_info(\"vector_image\", name, image_cache=image_cache)\n\n    # Load raster data.\n    img: Union[\"PILImage\", bytes, BinaryIO, Path, None]\n    raster_name: str\n    if isinstance(name, str):\n        raster_name, img = name, None\n    elif _is_pil_image(name):\n        bytes_ = name.tobytes()\n        img_hash = hashlib.new(\"md5\", usedforsecurity=False)  # nosec B324\n        img_hash.update(bytes_)\n        raster_name, img = img_hash.hexdigest(), name\n    elif isinstance(name, (bytes, io.BytesIO)):\n        bytes_ = name.getvalue() if isinstance(name, io.BytesIO) else name\n        bytes_ = bytes_.strip()\n        img_hash = hashlib.new(\"md5\", usedforsecurity=False)  # nosec B324\n        img_hash.update(bytes_)\n        raster_name, img = img_hash.hexdigest(), name\n    else:\n        raster_name, img = str(name), None\n    info: RasterImageInfo | VectorImageInfo | None = image_cache.images.get(raster_name)\n    if info is not None:\n        info[\"usages\"] = info[\"usages\"] + 1  # type: ignore[operator]\n    else:\n        info = get_img_info(\n            raster_name,\n            img,\n            image_cache.image_filter,\n            dims,\n        )\n        info[\"i\"] = len(image_cache.images) + 1\n        info[\"usages\"] = 1\n        info[\"iccp_i\"] = None\n        iccp = info.get(\"iccp\")\n        if iccp is not None:\n            LOGGER.debug(\n                \"ICC profile found for image %s - It will be inserted in the PDF document\",\n                raster_name,\n            )\n            if iccp in image_cache.icc_profiles:\n                info[\"iccp_i\"] = image_cache.icc_profiles[iccp]  # type: ignore[index]\n            else:\n                iccp_i = len(image_cache.icc_profiles)\n                image_cache.icc_profiles[iccp] = iccp_i  # type: ignore[index]\n                info[\"iccp_i\"] = iccp_i\n            info[\"iccp\"] = None\n        image_cache.images[raster_name] = info\n    return raster_name, img, info",
      "language": "python"
    },
    {
      "code": "def transcode_monochrome(img: \"PILImage\") -> bytes:\n    \"\"\"\n    Convert the open PIL.Image imgdata to compressed CCITT Group4 data.\n\n    \"\"\"\n    # Convert the image to Group 4 in memory. If libtiff is not installed and\n    # Pillow is not compiled against it, .save() will raise an exception.\n    newimgio = BytesIO()\n\n    # we create a whole new PIL image or otherwise it might happen with some\n    # input images, that libtiff fails an assert and the whole process is\n    # killed by a SIGABRT:\n    img2 = Image.frombytes(img.mode, img.size, img.tobytes())\n\n    # Since version 8.3.0 Pillow limits strips to 64 KB. Since PDF only\n    # supports single strip CCITT Group4 payloads, we have to coerce it back\n    # into putting everything into a single strip. Thanks to Andrew Murray for\n    # the hack.\n    #\n    # Since version 8.4.0 Pillow allows us to modify the strip size explicitly\n    tmp_strip_size = (img.size[0] + 7) // 8 * img.size[1]\n    if hasattr(TiffImagePlugin, \"STRIP_SIZE\"):\n        # we are using Pillow 8.4.0 or later\n        with temp_attr(TiffImagePlugin, \"STRIP_SIZE\", tmp_strip_size):\n            img2.save(newimgio, format=\"TIFF\", compression=\"group4\")\n    else:\n        # only needed for Pillow 8.3.x but works for versions before that as\n        # well\n        pillow__getitem__ = TiffImagePlugin.ImageFileDirectory_v2.__getitem__\n\n        def __getitem__(self: Any, tag: int) -> object:\n            overrides = {\n                TiffImagePlugin.ROWSPERSTRIP: img.size[1],\n                TiffImagePlugin.STRIPBYTECOUNTS: [tmp_strip_size],\n                TiffImagePlugin.STRIPOFFSETS: [0],\n            }\n            return overrides.get(tag, pillow__getitem__(self, tag))\n\n        with temp_attr(\n            TiffImagePlugin.ImageFileDirectory_v2, \"__getitem__\", __getitem__\n        ):\n            img2.save(newimgio, format=\"TIFF\", compression=\"group4\")\n\n    # Open new image in memory\n    newimgio.seek(0)\n    newimg = Image.open(newimgio)\n\n    offset, length = ccitt_payload_location_from_pil(newimg)\n\n    newimgio.seek(offset)\n    return newimgio.read(length)",
      "language": "python"
    },
    {
      "code": "@dataclass\nclass ImageSettings:\n    # Passed to zlib.compress() - In range 0-9 - Default is currently equivalent to 6:\n    compression_level: int = -1",
      "language": "python"
    },
    {
      "code": "class temp_attr:\n    \"\"\"\n    temporary change the attribute of an object using a context manager\n    \"\"\"\n\n    def __init__(self, obj: Any, field: str, value: Any):\n        self.obj = obj\n        self.field = field\n        self.value = value\n        self.exists = False\n        self.old_value: Any = None\n\n    def __enter__(self) -> None:\n        if hasattr(self.obj, self.field):\n            self.exists = True\n            self.old_value = getattr(self.obj, self.field)\n        setattr(self.obj, self.field, self.value)\n\n    def __exit__(self, exctype: Any, excinst: Any, exctb: Any) -> None:\n        if self.exists:\n            setattr(self.obj, self.field, self.old_value)\n        else:\n            delattr(self.obj, self.field)",
      "language": "python"
    }
  ],
  "patterns": [],
  "links": [
    "https://py-pdf.github.io/fpdf2/fpdf/image_datastructures.html",
    "https://py-pdf.github.io/fpdf2/fpdf/svg.html",
    "https://py-pdf.github.io/fpdf2/fpdf/fpdf.html",
    "https://py-pdf.github.io/fpdf2/fpdf/index.html",
    "https://py-pdf.github.io/fpdf2/fpdf/image_parsing.html"
  ]
}