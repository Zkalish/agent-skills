{
  "url": "https://py-pdf.github.io/fpdf2/fpdf/font_type_3.html",
  "title": "Module fpdf.font_type_3",
  "content": "This module provides support for embedding and rendering various color font formats in PDF documents using Type 3 fonts. It defines classes and utilities to handle different color font technologies, including:\n\nSupport for CBDT+CBLC bitmap color fonts.\n\nSupport for COLRv0 and COLRv1 OpenType color vector fonts. https://learn.microsoft.com/en-us/typography/opentype/spec/colr\n\nCOLRv0 is a sequence of glyphs layers with color specification and they are built one on top of the other.\n\nCOLRv1 allows for more complex color glyphs by including gradients, transformations, and composite operations.\n\nThis class handles both versions of the COLR table by using the drawing API to render the glyphs as vector graphics.\n\nGet the FPDF BlendMode for a given CompositeMode.\n\nDraw a COLRv1 Paint object into the given GraphicsContext. This is an implementation of the COLR version 1 rendering algorithm: https://learn.microsoft.com/en-us/typography/opentype/spec/colr#colr-version-1-rendering-algorithm\n\nCreates a surface representing the whole glyph area for actions that require painting an infinite surface and clipping to a geometry path\n\nBase class for protocol classes.\n\nProtocol classes are defined as::\n\nSuch classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing).\n\nSee PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as::\n\nThe type of the None singleton.\n\nThe type of the None singleton.\n\nBase class for protocol classes.\n\nProtocol classes are defined as::\n\nSuch classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing).\n\nSee PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as::\n\nThe type of the None singleton.\n\nSupport for SBIX bitmap color fonts.\n\nSupport for SVG OpenType vector color fonts.",
  "headings": [
    {
      "level": "h1",
      "text": "Module fpdf.font_type_3",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Functions",
      "id": "header-functions"
    },
    {
      "level": "h2",
      "text": "Classes",
      "id": "header-classes"
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Static methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Class variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Class variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Subclasses",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Static methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    }
  ],
  "code_samples": [
    {
      "code": "def get_color_font_object(\n    fpdf: \"FPDF\", base_font: \"TTFFont\", palette_index: int = 0\n) -> Union[Type3Font, None]:\n    if \"CBDT\" in base_font.ttfont:\n        LOGGER.debug(\"Font %s is a CBLC+CBDT color font\", base_font.name)\n        return CBDTColorFont(fpdf, base_font)\n    if \"EBDT\" in base_font.ttfont:\n        raise NotImplementedError(\n            f\"{base_font.name} - EBLC+EBDT color font is not supported yet\"\n        )\n    if \"COLR\" in base_font.ttfont:\n        if base_font.ttfont[\"COLR\"].version == 0:\n            LOGGER.debug(\"Font %s is a COLRv0 color font\", base_font.name)\n        else:\n            LOGGER.debug(\"Font %s is a COLRv1 color font\", base_font.name)\n        return COLRFont(fpdf, base_font, palette_index)\n    if \"SVG \" in base_font.ttfont:\n        LOGGER.debug(\"Font %s is a SVG color font\", base_font.name)\n        return SVGColorFont(fpdf, base_font)\n    if \"sbix\" in base_font.ttfont:\n        LOGGER.debug(\"Font %s is a SBIX color font\", base_font.name)\n        return SBIXColorFont(fpdf, base_font)\n    return None",
      "language": "python"
    },
    {
      "code": "class CBDTColorFont(Type3Font):\n    \"\"\"Support for CBDT+CBLC bitmap color fonts.\"\"\"\n\n    # Only looking at the first strike - Need to look all strikes available on the CBLC table first?\n    def glyph_exists(self, glyph_name: str) -> bool:\n        return glyph_name in self.base_font.ttfont[\"CBDT\"].strikeData[0]\n\n    def load_glyph_image(self, glyph: Type3FontGlyph) -> None:\n        ppem = self.base_font.ttfont[\"CBLC\"].strikes[0].bitmapSizeTable.ppemX\n        g = self.base_font.ttfont[\"CBDT\"].strikeData[0][glyph.glyph_name]\n        glyph_bitmap = g.data[9:]\n        metrics = g.metrics\n        if isinstance(metrics, SmallGlyphMetrics):\n            x_min = round(metrics.BearingX * self.upem / ppem)\n            y_min = round((metrics.BearingY - metrics.height) * self.upem / ppem)\n            x_max = round(metrics.width * self.upem / ppem)\n            y_max = round(metrics.BearingY * self.upem / ppem)\n        elif isinstance(metrics, BigGlyphMetrics):\n            x_min = round(metrics.horiBearingX * self.upem / ppem)\n            y_min = round((metrics.horiBearingY - metrics.height) * self.upem / ppem)\n            x_max = round(metrics.width * self.upem / ppem)\n            y_max = round(metrics.horiBearingY * self.upem / ppem)\n        else:  # fallback scenario: use font bounding box\n            x_min = self.base_font.ttfont[\"head\"].xMin\n            y_min = self.base_font.ttfont[\"head\"].yMin\n            x_max = self.base_font.ttfont[\"head\"].xMax\n            y_max = self.base_font.ttfont[\"head\"].yMax\n\n        bio = BytesIO(glyph_bitmap)\n        bio.seek(0)\n        _, _, info = self.fpdf.preload_glyph_image(glyph_image_bytes=bio)\n        w = round(self.base_font.ttfont[\"hmtx\"].metrics[glyph.glyph_name][0] + 0.001)\n        glyph.glyph = (\n            f\"{round(w * self.scale)} 0 d0\\n\"\n            \"q\\n\"\n            f\"{(x_max - x_min)* self.scale} 0 0 {(-y_min + y_max)*self.scale} {x_min*self.scale} {y_min*self.scale} cm\\n\"\n            f\"/I{info['i']} Do\\nQ\"\n        )\n        self.images_used.add(info[\"i\"])  # type: ignore[arg-type]\n        glyph.glyph_width = w",
      "language": "python"
    },
    {
      "code": "def glyph_exists(self, glyph_name: str) -> bool:\n    return glyph_name in self.base_font.ttfont[\"CBDT\"].strikeData[0]",
      "language": "python"
    },
    {
      "code": "def load_glyph_image(self, glyph: Type3FontGlyph) -> None:\n    ppem = self.base_font.ttfont[\"CBLC\"].strikes[0].bitmapSizeTable.ppemX\n    g = self.base_font.ttfont[\"CBDT\"].strikeData[0][glyph.glyph_name]\n    glyph_bitmap = g.data[9:]\n    metrics = g.metrics\n    if isinstance(metrics, SmallGlyphMetrics):\n        x_min = round(metrics.BearingX * self.upem / ppem)\n        y_min = round((metrics.BearingY - metrics.height) * self.upem / ppem)\n        x_max = round(metrics.width * self.upem / ppem)\n        y_max = round(metrics.BearingY * self.upem / ppem)\n    elif isinstance(metrics, BigGlyphMetrics):\n        x_min = round(metrics.horiBearingX * self.upem / ppem)\n        y_min = round((metrics.horiBearingY - metrics.height) * self.upem / ppem)\n        x_max = round(metrics.width * self.upem / ppem)\n        y_max = round(metrics.horiBearingY * self.upem / ppem)\n    else:  # fallback scenario: use font bounding box\n        x_min = self.base_font.ttfont[\"head\"].xMin\n        y_min = self.base_font.ttfont[\"head\"].yMin\n        x_max = self.base_font.ttfont[\"head\"].xMax\n        y_max = self.base_font.ttfont[\"head\"].yMax\n\n    bio = BytesIO(glyph_bitmap)\n    bio.seek(0)\n    _, _, info = self.fpdf.preload_glyph_image(glyph_image_bytes=bio)\n    w = round(self.base_font.ttfont[\"hmtx\"].metrics[glyph.glyph_name][0] + 0.001)\n    glyph.glyph = (\n        f\"{round(w * self.scale)} 0 d0\\n\"\n        \"q\\n\"\n        f\"{(x_max - x_min)* self.scale} 0 0 {(-y_min + y_max)*self.scale} {x_min*self.scale} {y_min*self.scale} cm\\n\"\n        f\"/I{info['i']} Do\\nQ\"\n    )\n    self.images_used.add(info[\"i\"])  # type: ignore[arg-type]\n    glyph.glyph_width = w",
      "language": "python"
    },
    {
      "code": "class COLRFont(Type3Font):\n    \"\"\"\n    Support for COLRv0 and COLRv1 OpenType color vector fonts.\n    https://learn.microsoft.com/en-us/typography/opentype/spec/colr\n\n    COLRv0 is a sequence of glyphs layers with color specification\n    and they are built one on top of the other.\n\n    COLRv1 allows for more complex color glyphs by including gradients,\n    transformations, and composite operations.\n\n    This class handles both versions of the COLR table by using the\n    drawing API to render the glyphs as vector graphics.\n    \"\"\"\n\n    def __init__(\n        self, fpdf: \"FPDF\", base_font: \"TTFFont\", palette_index: int = 0\n    ) -> None:\n        super().__init__(fpdf, base_font)\n        colr_table: table_C_O_L_R_ = self.base_font.ttfont[\"COLR\"]\n        self.colrv0_glyphs: dict[str, tuple[ColrV0Layer]] = {}\n        self.colrv1_glyphs: dict[str, ColrV1Paint] = {}\n        self.version = colr_table.version\n        self.colrv1_clip_boxes = {}\n        self.colr_var_instancer = None\n        self.colr_var_index_map = None\n        if colr_table.version == 0:\n            self.colrv0_glyphs = colr_table.ColorLayers\n        else:\n            try:\n                self.colrv0_glyphs = (\n                    colr_table._decompileColorLayersV0(colr_table.table) or {}\n                )\n            except (KeyError, AttributeError, TypeError, ValueError):\n                self.colrv0_glyphs = {}\n            colr_table_v1 = colr_table.table\n            var_store = getattr(colr_table_v1, \"VarStore\", None)\n            if var_store is not None:\n                axis_tags = []\n                if \"fvar\" in self.base_font.ttfont:\n                    axis_tags = [\n                        axis.axisTag for axis in self.base_font.ttfont[\"fvar\"].axes\n                    ]\n                self.colr_var_instancer = VarStoreInstancer(var_store, axis_tags)\n                self.colr_var_instancer.setLocation({tag: 0.0 for tag in axis_tags})\n                var_index_map = getattr(colr_table_v1, \"VarIndexMap\", None)\n                if var_index_map is not None:\n                    self.colr_var_index_map = var_index_map.mapping\n            self.colrv1_glyphs = {\n                glyph.BaseGlyph: glyph\n                for glyph in colr_table_v1.BaseGlyphList.BaseGlyphPaintRecord\n            }\n            clip_list = getattr(colr_table_v1, \"ClipList\", None)\n            if clip_list is not None:\n                for glyph_name, clip in getattr(clip_list, \"clips\", {}).items():\n                    resolved = self._resolve_clip_box(clip)\n                    if resolved is not None:\n                        self.colrv1_clip_boxes[glyph_name] = resolved\n        self.palette = None\n        if \"CPAL\" in self.base_font.ttfont:\n            num_palettes = len(self.base_font.ttfont[\"CPAL\"].palettes)\n            # Validate palette index\n            if palette_index >= num_palettes:\n                LOGGER.warning(\n                    \"Palette index %s is out of range. This font has %s palettes. Using palette 0.\",\n                    palette_index,\n                    num_palettes,\n                )\n                palette_index = 0\n            palette = self.base_font.ttfont[\"CPAL\"].palettes[palette_index]\n            self.palette = [\n                (\n                    color.red / 255,\n                    color.green / 255,\n                    color.blue / 255,\n                    color.alpha / 255,\n                )\n                for color in palette\n            ]\n\n    def metric_bbox(self) -> BoundingBox:\n        return BoundingBox(\n            self.base_font.ttfont[\"head\"].xMin,\n            self.base_font.ttfont[\"head\"].yMin,\n            self.base_font.ttfont[\"head\"].xMax,\n            self.base_font.ttfont[\"head\"].yMax,\n        )\n\n    def glyph_exists(self, glyph_name: str) -> bool:\n        return glyph_name in self.colrv0_glyphs or glyph_name in self.colrv1_glyphs\n\n    def load_glyph_image(self, glyph: Type3FontGlyph) -> None:\n        w = round(self.base_font.ttfont[\"hmtx\"].metrics[glyph.glyph_name][0] + 0.001)\n        if glyph.glyph_name in self.colrv0_glyphs:\n            glyph_layers = self.colrv0_glyphs[glyph.glyph_name]\n            img = self.draw_glyph_colrv0(glyph_layers)\n        else:\n            if self.version < 1 or glyph.glyph_name not in self.colrv1_glyphs:\n                raise NotImplementedError(\n                    f\"No COLRv0 layers and no COLRv1 paint found for '{glyph.glyph_name}'.\"\n                )\n            img = self.draw_glyph_colrv1(glyph.glyph_name)\n        img.transform = Transform.scaling(self.scale, -self.scale)\n        output_stream = self.fpdf.draw_vector_glyph(img, self)\n        glyph.glyph = f\"{round(w * self.scale)} 0 d0\\n\" \"q\\n\" f\"{output_stream}\\n\" \"Q\"\n        glyph.glyph_width = w\n\n    def get_color(self, color_index: int, alpha: float = 1) -> DeviceRGB:\n        if self.palette is None:  # should never happen\n            return DeviceRGB(0, 0, 0, 1)\n        if color_index == 0xFFFF:\n            # Palette entry 0xFFFF requests the application text foreground color.\n            text_color = getattr(self.fpdf, \"text_color\", DeviceGray(0))\n            if isinstance(text_color, DeviceRGB):\n                r, g, b = text_color.r, text_color.g, text_color.b\n                a = 1.0 if text_color.a is None else text_color.a\n            elif isinstance(text_color, DeviceGray):\n                r = g = b = text_color.g\n                a = 1.0 if text_color.a is None else text_color.a\n            elif isinstance(text_color, DeviceCMYK):\n                c, m, y, k = text_color.c, text_color.m, text_color.y, text_color.k\n                r = 1.0 - min(1.0, c + k)\n                g = 1.0 - min(1.0, m + k)\n                b = 1.0 - min(1.0, y + k)\n                a = 1.0 if text_color.a is None else text_color.a\n            else:\n                r = g = b = 0.0\n                a = 1.0\n        else:\n            r, g, b, a = self.palette[color_index]\n        a *= alpha\n        return DeviceRGB(r, g, b, a)\n\n    def draw_glyph_colrv0(self, layers: Sequence[ColrV0Layer]) -> GraphicsContext:\n        gc = GraphicsContext()\n        for layer in layers:\n            path = PaintedPath()\n            glyph_set = self.base_font.ttfont.getGlyphSet()\n            pen = GlyphPathPen(path, glyphSet=glyph_set)\n            glyph = glyph_set[layer.name]\n            glyph.draw(pen)\n            path.style.fill_color = self.get_color(layer.colorID)\n            path.style.stroke_color = self.get_color(layer.colorID)\n            gc.add_item(item=path, clone=False)\n        return gc\n\n    def draw_glyph_colrv1(self, glyph_name: str) -> GraphicsContext:\n        gc = GraphicsContext()\n        clip_path = self._build_clip_path(glyph_name)\n        if clip_path is not None:\n            gc.clipping_path = clip_path\n        glyph = self.colrv1_glyphs[glyph_name]\n        self.draw_colrv1_paint(\n            paint=glyph.Paint,\n            parent=gc,\n            target_path=None,\n            ctm=Transform.identity(),\n            visited_glyphs=set(glyph_name),\n        )\n        return gc\n\n    # pylint: disable=too-many-return-statements\n    def draw_colrv1_paint(\n        self,\n        paint: Paint,\n        parent: GraphicsContext,\n        target_path: Optional[PaintedPath] = None,\n        ctm: Optional[Transform] = None,\n        visited_glyphs: Optional[set[str]] = None,\n    ) -> tuple[GraphicsContext, Optional[PaintedPath]]:\n        \"\"\"\n        Draw a COLRv1 Paint object into the given GraphicsContext.\n        This is an implementation of the COLR version 1 rendering algorithm:\n        https://learn.microsoft.com/en-us/typography/opentype/spec/colr#colr-version-1-rendering-algorithm\n        \"\"\"\n        paint = self._unwrap_paint(paint)\n        ctm = ctm or Transform.identity()\n\n        if visited_glyphs is None:\n            visited_glyphs = set()\n\n        if paint.Format == PaintFormat.PaintColrLayers:\n            layer_list = self.base_font.ttfont[\"COLR\"].table.LayerList\n            group = GraphicsContext()\n            for layer in range(\n                paint.FirstLayerIndex, paint.FirstLayerIndex + paint.NumLayers\n            ):\n                self.draw_colrv1_paint(\n                    paint=layer_list.Paint[layer],\n                    parent=group,\n                    ctm=ctm,\n                    visited_glyphs=visited_glyphs,\n                )\n            parent.add_item(item=group, clone=False)\n            return parent, target_path\n\n        if paint.Format in (\n            PaintFormat.PaintSolid,\n            PaintFormat.PaintVarSolid,\n        ):\n            target_path = target_path or self.get_paint_surface()\n            target_path.style.fill_color = self.get_color(\n                color_index=paint.PaletteIndex, alpha=paint.Alpha\n            )\n            target_path.style.stroke_color = None\n            target_path.style.paint_rule = PathPaintRule.FILL_NONZERO\n            return parent, target_path\n\n        if paint.Format == PaintFormat.PaintLinearGradient:\n            stops: list[tuple[float, DeviceRGB]] = [\n                (stop.StopOffset, self.get_color(stop.PaletteIndex, stop.Alpha))\n                for stop in paint.ColorLine.ColorStop\n            ]\n            if paint.ColorLine.Extend == 2:  # REFLECT\n                spread_method = GradientSpreadMethod.REFLECT\n            elif paint.ColorLine.Extend == 1:  # REPEAT\n                spread_method = GradientSpreadMethod.REPEAT\n            else:  # PAD\n                spread_method = GradientSpreadMethod.PAD\n            linear_gradient = shape_linear_gradient(\n                paint.x0,\n                paint.y0,\n                paint.x1,\n                paint.y1,\n                stops,\n            )\n            target_path = target_path or self.get_paint_surface()\n            target_path.style.fill_color = GradientPaint(\n                gradient=linear_gradient,\n                units=GradientUnits.USER_SPACE_ON_USE,\n                gradient_transform=ctm,\n                apply_page_ctm=False,\n                spread_method=spread_method,\n            )\n            target_path.style.stroke_color = None\n            target_path.style.paint_rule = PathPaintRule.FILL_NONZERO\n            return parent, target_path\n\n        if paint.Format == PaintFormat.PaintRadialGradient:\n            raw = [\n                (cs.StopOffset, self.get_color(cs.PaletteIndex, cs.Alpha))\n                for cs in paint.ColorLine.ColorStop\n            ]\n            t_min, t_max, norm_stops = _normalize_color_line(raw)\n            c0: tuple[float, float] = (paint.x0, paint.y0)\n            r0: float = paint.r0\n            c1: tuple[float, float] = (paint.x1, paint.y1)\n            r1: float = paint.r1\n            fx, fy = _lerp_pt(c0, c1, t_min)\n            cx, cy = _lerp_pt(c0, c1, t_max)\n            fr = max(_lerp(r0, r1, t_min), 0.0)\n            r = max(_lerp(r0, r1, t_max), 1e-6)\n            if paint.ColorLine.Extend == 2:  # REFLECT\n                spread_method = GradientSpreadMethod.REFLECT\n            elif paint.ColorLine.Extend == 1:  # REPEAT\n                spread_method = GradientSpreadMethod.REPEAT\n            else:  # PAD\n                spread_method = GradientSpreadMethod.PAD\n            radial_gradient = shape_radial_gradient(\n                cx=cx,\n                cy=cy,\n                r=r,\n                fx=fx,\n                fy=fy,\n                fr=fr,\n                stops=norm_stops,\n            )\n            target_path = target_path or self.get_paint_surface()\n            target_path.style.fill_color = GradientPaint(\n                gradient=radial_gradient,\n                units=GradientUnits.USER_SPACE_ON_USE,\n                gradient_transform=ctm,\n                apply_page_ctm=False,\n                spread_method=spread_method,\n            )\n            target_path.style.stroke_color = None\n            target_path.style.paint_rule = PathPaintRule.FILL_NONZERO\n            return parent, target_path\n\n        if paint.Format == PaintFormat.PaintSweepGradient:  # 8\n            stops = [\n                (cs.StopOffset, self.get_color(cs.PaletteIndex, cs.Alpha))\n                for cs in paint.ColorLine.ColorStop\n            ]\n\n            if paint.ColorLine.Extend == 2:  # REFLECT\n                spread_method = GradientSpreadMethod.REFLECT\n            elif paint.ColorLine.Extend == 1:  # REPEAT\n                spread_method = GradientSpreadMethod.REPEAT\n            else:\n                spread_method = GradientSpreadMethod.PAD\n\n            cx = paint.centerX\n            cy = paint.centerY\n\n            # COLRv1 defines sweep angles clockwise from the positive X axis.\n            # We build gradients in glyph space, which later undergoes a Y-axis flip\n            # when emitted to PDF coordinates. To compensate, convert the COLR angles\n            # directly to mathematical radians (counter-clockwise); the subsequent flip\n            # restores the expected clockwise visual direction.\n            start_angle, end_angle = self._sweep_angles(\n                paint.startAngle, paint.endAngle\n            )\n\n            # Build a lazy sweep gradient object (bbox-resolved at emit time)\n            sweep_gradient = SweepGradient(\n                cx=cx,\n                cy=cy,\n                start_angle=start_angle,\n                end_angle=end_angle,\n                stops=stops,\n                spread_method=spread_method,\n                segments=None,\n                inner_radius_factor=0.002,\n            )\n\n            target_path = target_path or self.get_paint_surface()\n            target_path.style.fill_color = GradientPaint(\n                gradient=sweep_gradient,\n                units=GradientUnits.USER_SPACE_ON_USE,\n                gradient_transform=ctm,\n                apply_page_ctm=False,\n                spread_method=spread_method,\n            )\n            target_path.style.stroke_color = None\n            target_path.style.paint_rule = PathPaintRule.FILL_NONZERO\n            return parent, target_path\n\n        if paint.Format == PaintFormat.PaintGlyph:  # 10\n            glyph_set = self.base_font.ttfont.getGlyphSet()\n            clipping_path = ClippingPath()\n            glyph_set[paint.Glyph].draw(GlyphPathPen(clipping_path, glyphSet=glyph_set))\n            clipping_path.transform = (\n                clipping_path.transform or Transform.identity()\n            ) @ ctm\n\n            if getattr(paint, \"Paint\", None) is None:\n                return parent, None\n\n            group = GraphicsContext()\n            group.clipping_path = clipping_path\n\n            group, surface_path = self.draw_colrv1_paint(\n                paint=paint.Paint,\n                parent=group,\n                ctm=Transform.identity(),\n                visited_glyphs=visited_glyphs,\n            )\n            if surface_path is not None:\n                group.add_item(item=surface_path, clone=False)\n            parent.add_item(item=group, clone=False)\n            return parent, None\n\n        if paint.Format == PaintFormat.PaintColrGlyph:\n            ref: str = getattr(paint, \"Glyph\", None) or getattr(paint, \"GlyphID\", None)  # type: ignore[assignment]\n            if isinstance(ref, int):\n                ref_name = self.base_font.ttfont.getGlyphName(ref)\n            else:\n                ref_name = ref\n            if ref_name in visited_glyphs:\n                LOGGER.warning(\"Skipping recursive COLR glyph reference '%s'\", ref_name)\n                return parent, target_path  # nothing to draw\n            rec = self.colrv1_glyphs.get(ref_name)\n            if rec is None or getattr(rec, \"Paint\", None) is None:\n                return parent, target_path  # nothing to draw\n\n            visited_glyphs.add(ref_name)\n            try:\n                group = GraphicsContext()\n                clip_path = self._build_clip_path(ref_name)\n                if clip_path is not None:\n                    group.clipping_path = clip_path\n                self.draw_colrv1_paint(\n                    paint=rec.Paint,\n                    parent=group,\n                    ctm=ctm,\n                    visited_glyphs=visited_glyphs,\n                )\n                parent.add_item(item=group, clone=False)\n            finally:\n                visited_glyphs.remove(ref_name)\n            return parent, target_path\n\n        if paint.Format in (\n            PaintFormat.PaintTransform,  # 12\n            PaintFormat.PaintVarTransform,  # 13\n            PaintFormat.PaintTranslate,  # 14\n            PaintFormat.PaintVarTranslate,  # 15\n            PaintFormat.PaintScale,  # 16\n            PaintFormat.PaintVarScale,  # 17\n            PaintFormat.PaintScaleAroundCenter,  # 18\n            PaintFormat.PaintVarScaleAroundCenter,  # 19\n            PaintFormat.PaintScaleUniform,  # 20\n            PaintFormat.PaintVarScaleUniform,  # 21\n            PaintFormat.PaintScaleUniformAroundCenter,  # 22\n            PaintFormat.PaintVarScaleUniformAroundCenter,  # 23\n            PaintFormat.PaintRotate,  # 24\n            PaintFormat.PaintVarRotate,  # 25\n            PaintFormat.PaintRotateAroundCenter,  # 26\n            PaintFormat.PaintVarRotateAroundCenter,  # 27\n            PaintFormat.PaintSkew,  # 28\n            PaintFormat.PaintVarSkew,  # 29\n            PaintFormat.PaintSkewAroundCenter,  # 30\n            PaintFormat.PaintVarSkewAroundCenter,  # 31\n        ):\n            transform = self._transform_from_paint(paint)\n            new_ctm = ctm @ transform\n            return self.draw_colrv1_paint(\n                paint=paint.Paint,\n                parent=parent,\n                target_path=target_path,\n                ctm=new_ctm,\n                visited_glyphs=visited_glyphs,\n            )\n\n        if paint.Format in (\n            PaintFormat.PaintVarLinearGradient,  # 5\n            PaintFormat.PaintVarRadialGradient,  # 7\n            PaintFormat.PaintVarSweepGradient,\n        ):  # 9\n            raise NotImplementedError(\"Variable fonts are not yet supported.\")\n\n        if paint.Format == PaintFormat.PaintComposite:  # 32\n            backdrop_node = GraphicsContext()\n            _, backdrop_path = self.draw_colrv1_paint(\n                paint=paint.BackdropPaint,\n                parent=backdrop_node,\n                ctm=ctm,\n                visited_glyphs=visited_glyphs,\n            )\n            if backdrop_path is not None:\n                backdrop_node.add_item(item=backdrop_path, clone=False)\n\n            source_node = GraphicsContext()\n            _, source_path = self.draw_colrv1_paint(\n                paint=paint.SourcePaint,\n                parent=source_node,\n                ctm=ctm,\n                visited_glyphs=visited_glyphs,\n            )\n            if source_path is not None:\n                source_node.add_item(item=source_path, clone=False)\n\n            composite_type, composite_mode = self.get_composite_mode(\n                paint.CompositeMode\n            )\n            if composite_type == \"Blend\":\n                if TYPE_CHECKING:\n                    assert isinstance(composite_mode, BlendMode)\n                parent.add_item(\n                    item=PaintBlendComposite(\n                        backdrop=backdrop_node,\n                        source=source_node,\n                        blend_mode=composite_mode,\n                    ),\n                    clone=False,\n                )\n            elif composite_type == \"Compositing\":\n                if TYPE_CHECKING:\n                    assert isinstance(composite_mode, CompositeMode)\n                composite_node = PaintComposite(\n                    backdrop=backdrop_node,\n                    source=source_node,\n                    operation=composite_mode,  # pyright: ignore[reportArgumentType]\n                )\n                parent.add_item(item=composite_node, clone=False)\n            else:\n                raise ValueError(\"Composite operation not supported - {composite_type}\")\n            return parent, None\n\n        raise NotImplementedError(f\"Unknown PaintFormat: {paint.Format}\")\n\n    @classmethod\n    def _sweep_angles(cls, start_deg: float, end_deg: float) -> tuple[float, float]:\n        start_norm = math.fmod(start_deg, 360.0)\n        if start_norm < 0.0:\n            start_norm += 360.0\n        span_deg = math.fmod(end_deg - start_deg, 360.0)\n        if span_deg <= 0.0:\n            span_deg += 360.0\n        start_rad = math.radians(start_norm)\n        end_rad = start_rad + math.radians(span_deg)\n        return start_rad, end_rad\n\n    @classmethod\n    def _transform_from_paint(cls, paint: Paint) -> Transform:\n        paint_format = paint.Format\n        if paint_format in (PaintFormat.PaintTransform, PaintFormat.PaintVarTransform):\n            transform = paint.Transform\n            return Transform(\n                transform.xx,\n                transform.yx,\n                transform.xy,\n                transform.yy,\n                transform.dx,\n                transform.dy,\n            )\n        if paint_format in (PaintFormat.PaintTranslate, PaintFormat.PaintVarTranslate):\n            return Transform.translation(paint.dx, paint.dy)\n        if paint_format in (PaintFormat.PaintScale, PaintFormat.PaintVarScale):\n            return Transform.scaling(paint.scaleX, paint.scaleY)\n        if paint_format in (\n            PaintFormat.PaintScaleAroundCenter,\n            PaintFormat.PaintVarScaleAroundCenter,\n        ):\n            return Transform.scaling(paint.scaleX, paint.scaleY).about(\n                paint.centerX, paint.centerY\n            )\n        if paint_format in (\n            PaintFormat.PaintScaleUniform,\n            PaintFormat.PaintVarScaleUniform,\n        ):\n            return Transform.scaling(paint.scale, paint.scale)\n        if paint_format in (\n            PaintFormat.PaintScaleUniformAroundCenter,\n            PaintFormat.PaintVarScaleUniformAroundCenter,\n        ):\n            return Transform.scaling(paint.scale, paint.scale).about(\n                paint.centerX, paint.centerY\n            )\n        if paint_format in (PaintFormat.PaintRotate, PaintFormat.PaintVarRotate):\n            return Transform.rotation_d(paint.angle)\n        if paint_format in (\n            PaintFormat.PaintRotateAroundCenter,\n            PaintFormat.PaintVarRotateAroundCenter,\n        ):\n            return Transform.rotation_d(paint.angle).about(paint.centerX, paint.centerY)\n        if paint_format in (PaintFormat.PaintSkew, PaintFormat.PaintVarSkew):\n            return Transform.skewing_d(-paint.xSkewAngle, paint.ySkewAngle)\n        if paint_format in (\n            PaintFormat.PaintSkewAroundCenter,\n            PaintFormat.PaintVarSkewAroundCenter,\n        ):\n            return Transform.skewing_d(-paint.xSkewAngle, paint.ySkewAngle).about(\n                paint.centerX, paint.centerY\n            )\n        raise NotImplementedError(f\"Transform not implemented for {format}\")\n\n    def get_paint_surface(self) -> PaintedPath:\n        \"\"\"\n        Creates a surface representing the whole glyph area for actions that require\n        painting an infinite surface and clipping to a geometry path\n        \"\"\"\n        paint_surface = PaintedPath()\n        surface_bbox = self.metric_bbox()\n        paint_surface.rectangle(\n            x=surface_bbox.x0,\n            y=surface_bbox.y0,\n            w=surface_bbox.width,\n            h=surface_bbox.height,\n        )\n        return paint_surface\n\n    @classmethod\n    def get_composite_mode(\n        cls, composite_mode: CompositeMode\n    ) -> (\n        tuple[Literal[\"Compositing\"], CompositingOperation]\n        | tuple[Literal[\"Blend\"], BlendMode]\n    ):\n        \"\"\"Get the FPDF BlendMode for a given CompositeMode.\"\"\"\n\n        map_compositing_operation = {\n            CompositeMode.SRC: CompositingOperation.SOURCE,\n            CompositeMode.DEST: CompositingOperation.DESTINATION,\n            CompositeMode.CLEAR: CompositingOperation.CLEAR,\n            CompositeMode.SRC_OVER: CompositingOperation.SOURCE_OVER,\n            CompositeMode.DEST_OVER: CompositingOperation.DESTINATION_OVER,\n            CompositeMode.SRC_IN: CompositingOperation.SOURCE_IN,\n            CompositeMode.DEST_IN: CompositingOperation.DESTINATION_IN,\n            CompositeMode.SRC_OUT: CompositingOperation.SOURCE_OUT,\n            CompositeMode.DEST_OUT: CompositingOperation.DESTINATION_OUT,\n            CompositeMode.SRC_ATOP: CompositingOperation.SOURCE_ATOP,\n            CompositeMode.DEST_ATOP: CompositingOperation.DESTINATION_ATOP,\n            CompositeMode.XOR: CompositingOperation.XOR,\n        }\n\n        compositing_operation = map_compositing_operation.get(composite_mode, None)\n        if compositing_operation is not None:\n            return (\"Compositing\", compositing_operation)\n\n        map_blend_mode = {\n            CompositeMode.PLUS: BlendMode.SCREEN,  # approximation\n            CompositeMode.SCREEN: BlendMode.SCREEN,\n            CompositeMode.OVERLAY: BlendMode.OVERLAY,\n            CompositeMode.DARKEN: BlendMode.DARKEN,\n            CompositeMode.LIGHTEN: BlendMode.LIGHTEN,\n            CompositeMode.COLOR_DODGE: BlendMode.COLOR_DODGE,\n            CompositeMode.COLOR_BURN: BlendMode.COLOR_BURN,\n            CompositeMode.HARD_LIGHT: BlendMode.HARD_LIGHT,\n            CompositeMode.SOFT_LIGHT: BlendMode.SOFT_LIGHT,\n            CompositeMode.DIFFERENCE: BlendMode.DIFFERENCE,\n            CompositeMode.EXCLUSION: BlendMode.EXCLUSION,\n            CompositeMode.MULTIPLY: BlendMode.MULTIPLY,\n            CompositeMode.HSL_HUE: BlendMode.HUE,\n            CompositeMode.HSL_SATURATION: BlendMode.SATURATION,\n            CompositeMode.HSL_COLOR: BlendMode.COLOR,\n            CompositeMode.HSL_LUMINOSITY: BlendMode.LUMINOSITY,\n        }\n        blend_mode = map_blend_mode.get(composite_mode, None)\n        if blend_mode is not None:\n            return (\"Blend\", blend_mode)\n\n        raise NotImplementedError(f\"Unknown composite mode: {composite_mode}\")\n\n    def _unwrap_paint(self, paint: Paint) -> Union[Paint, \"VarTableWrapper\"]:\n        mapped_format = PAINT_VAR_MAPPING.get(paint.Format)\n        if mapped_format is None or self.colr_var_instancer is None:\n            return paint\n        return VarTableWrapper(\n            paint,\n            self.colr_var_instancer,\n            self.colr_var_index_map,\n            format_override=mapped_format,\n        )\n\n    def _build_clip_path(self, glyph_name: str) -> Optional[ClippingPath]:\n        clip_box = self.colrv1_clip_boxes.get(glyph_name)\n        if clip_box is None:\n            return None\n        x_min, y_min, x_max, y_max = clip_box\n        clip_path = ClippingPath()\n        clip_path.move_to(x_min, y_min)\n        clip_path.rectangle(x_min, y_min, x_max - x_min, y_max - y_min)\n        return clip_path\n\n    def _resolve_clip_box(\n        self, clip: Any\n    ) -> Optional[tuple[float, float, float, float]]:\n        if clip is None:\n            return None\n        if (\n            getattr(clip, \"Format\", None) == ClipBoxFormat.Variable\n            and self.colr_var_instancer is not None\n        ):\n            clip = VarTableWrapper(\n                clip,\n                self.colr_var_instancer,\n                self.colr_var_index_map,\n            )\n        if hasattr(clip, \"xMin\") and hasattr(clip, \"xMax\"):\n            return (clip.xMin, clip.yMin, clip.xMax, clip.yMax)\n        LOGGER.debug(\"Unsupported COLRv1 clip format for clip box\")\n        return None",
      "language": "python"
    },
    {
      "code": "def draw_colrv1_paint(\n    self,\n    paint: Paint,\n    parent: GraphicsContext,\n    target_path: Optional[PaintedPath] = None,\n    ctm: Optional[Transform] = None,\n    visited_glyphs: Optional[set[str]] = None,\n) -> tuple[GraphicsContext, Optional[PaintedPath]]:\n    \"\"\"\n    Draw a COLRv1 Paint object into the given GraphicsContext.\n    This is an implementation of the COLR version 1 rendering algorithm:\n    https://learn.microsoft.com/en-us/typography/opentype/spec/colr#colr-version-1-rendering-algorithm\n    \"\"\"\n    paint = self._unwrap_paint(paint)\n    ctm = ctm or Transform.identity()\n\n    if visited_glyphs is None:\n        visited_glyphs = set()\n\n    if paint.Format == PaintFormat.PaintColrLayers:\n        layer_list = self.base_font.ttfont[\"COLR\"].table.LayerList\n        group = GraphicsContext()\n        for layer in range(\n            paint.FirstLayerIndex, paint.FirstLayerIndex + paint.NumLayers\n        ):\n            self.draw_colrv1_paint(\n                paint=layer_list.Paint[layer],\n                parent=group,\n                ctm=ctm,\n                visited_glyphs=visited_glyphs,\n            )\n        parent.add_item(item=group, clone=False)\n        return parent, target_path\n\n    if paint.Format in (\n        PaintFormat.PaintSolid,\n        PaintFormat.PaintVarSolid,\n    ):\n        target_path = target_path or self.get_paint_surface()\n        target_path.style.fill_color = self.get_color(\n            color_index=paint.PaletteIndex, alpha=paint.Alpha\n        )\n        target_path.style.stroke_color = None\n        target_path.style.paint_rule = PathPaintRule.FILL_NONZERO\n        return parent, target_path\n\n    if paint.Format == PaintFormat.PaintLinearGradient:\n        stops: list[tuple[float, DeviceRGB]] = [\n            (stop.StopOffset, self.get_color(stop.PaletteIndex, stop.Alpha))\n            for stop in paint.ColorLine.ColorStop\n        ]\n        if paint.ColorLine.Extend == 2:  # REFLECT\n            spread_method = GradientSpreadMethod.REFLECT\n        elif paint.ColorLine.Extend == 1:  # REPEAT\n            spread_method = GradientSpreadMethod.REPEAT\n        else:  # PAD\n            spread_method = GradientSpreadMethod.PAD\n        linear_gradient = shape_linear_gradient(\n            paint.x0,\n            paint.y0,\n            paint.x1,\n            paint.y1,\n            stops,\n        )\n        target_path = target_path or self.get_paint_surface()\n        target_path.style.fill_color = GradientPaint(\n            gradient=linear_gradient,\n            units=GradientUnits.USER_SPACE_ON_USE,\n            gradient_transform=ctm,\n            apply_page_ctm=False,\n            spread_method=spread_method,\n        )\n        target_path.style.stroke_color = None\n        target_path.style.paint_rule = PathPaintRule.FILL_NONZERO\n        return parent, target_path\n\n    if paint.Format == PaintFormat.PaintRadialGradient:\n        raw = [\n            (cs.StopOffset, self.get_color(cs.PaletteIndex, cs.Alpha))\n            for cs in paint.ColorLine.ColorStop\n        ]\n        t_min, t_max, norm_stops = _normalize_color_line(raw)\n        c0: tuple[float, float] = (paint.x0, paint.y0)\n        r0: float = paint.r0\n        c1: tuple[float, float] = (paint.x1, paint.y1)\n        r1: float = paint.r1\n        fx, fy = _lerp_pt(c0, c1, t_min)\n        cx, cy = _lerp_pt(c0, c1, t_max)\n        fr = max(_lerp(r0, r1, t_min), 0.0)\n        r = max(_lerp(r0, r1, t_max), 1e-6)\n        if paint.ColorLine.Extend == 2:  # REFLECT\n            spread_method = GradientSpreadMethod.REFLECT\n        elif paint.ColorLine.Extend == 1:  # REPEAT\n            spread_method = GradientSpreadMethod.REPEAT\n        else:  # PAD\n            spread_method = GradientSpreadMethod.PAD\n        radial_gradient = shape_radial_gradient(\n            cx=cx,\n            cy=cy,\n            r=r,\n            fx=fx,\n            fy=fy,\n            fr=fr,\n            stops=norm_stops,\n        )\n        target_path = target_path or self.get_paint_surface()\n        target_path.style.fill_color = GradientPaint(\n            gradient=radial_gradient,\n            units=GradientUnits.USER_SPACE_ON_USE,\n            gradient_transform=ctm,\n            apply_page_ctm=False,\n            spread_method=spread_method,\n        )\n        target_path.style.stroke_color = None\n        target_path.style.paint_rule = PathPaintRule.FILL_NONZERO\n        return parent, target_path\n\n    if paint.Format == PaintFormat.PaintSweepGradient:  # 8\n        stops = [\n            (cs.StopOffset, self.get_color(cs.PaletteIndex, cs.Alpha))\n            for cs in paint.ColorLine.ColorStop\n        ]\n\n        if paint.ColorLine.Extend == 2:  # REFLECT\n            spread_method = GradientSpreadMethod.REFLECT\n        elif paint.ColorLine.Extend == 1:  # REPEAT\n            spread_method = GradientSpreadMethod.REPEAT\n        else:\n            spread_method = GradientSpreadMethod.PAD\n\n        cx = paint.centerX\n        cy = paint.centerY\n\n        # COLRv1 defines sweep angles clockwise from the positive X axis.\n        # We build gradients in glyph space, which later undergoes a Y-axis flip\n        # when emitted to PDF coordinates. To compensate, convert the COLR angles\n        # directly to mathematical radians (counter-clockwise); the subsequent flip\n        # restores the expected clockwise visual direction.\n        start_angle, end_angle = self._sweep_angles(\n            paint.startAngle, paint.endAngle\n        )\n\n        # Build a lazy sweep gradient object (bbox-resolved at emit time)\n        sweep_gradient = SweepGradient(\n            cx=cx,\n            cy=cy,\n            start_angle=start_angle,\n            end_angle=end_angle,\n            stops=stops,\n            spread_method=spread_method,\n            segments=None,\n            inner_radius_factor=0.002,\n        )\n\n        target_path = target_path or self.get_paint_surface()\n        target_path.style.fill_color = GradientPaint(\n            gradient=sweep_gradient,\n            units=GradientUnits.USER_SPACE_ON_USE,\n            gradient_transform=ctm,\n            apply_page_ctm=False,\n            spread_method=spread_method,\n        )\n        target_path.style.stroke_color = None\n        target_path.style.paint_rule = PathPaintRule.FILL_NONZERO\n        return parent, target_path\n\n    if paint.Format == PaintFormat.PaintGlyph:  # 10\n        glyph_set = self.base_font.ttfont.getGlyphSet()\n        clipping_path = ClippingPath()\n        glyph_set[paint.Glyph].draw(GlyphPathPen(clipping_path, glyphSet=glyph_set))\n        clipping_path.transform = (\n            clipping_path.transform or Transform.identity()\n        ) @ ctm\n\n        if getattr(paint, \"Paint\", None) is None:\n            return parent, None\n\n        group = GraphicsContext()\n        group.clipping_path = clipping_path\n\n        group, surface_path = self.draw_colrv1_paint(\n            paint=paint.Paint,\n            parent=group,\n            ctm=Transform.identity(),\n            visited_glyphs=visited_glyphs,\n        )\n        if surface_path is not None:\n            group.add_item(item=surface_path, clone=False)\n        parent.add_item(item=group, clone=False)\n        return parent, None\n\n    if paint.Format == PaintFormat.PaintColrGlyph:\n        ref: str = getattr(paint, \"Glyph\", None) or getattr(paint, \"GlyphID\", None)  # type: ignore[assignment]\n        if isinstance(ref, int):\n            ref_name = self.base_font.ttfont.getGlyphName(ref)\n        else:\n            ref_name = ref\n        if ref_name in visited_glyphs:\n            LOGGER.warning(\"Skipping recursive COLR glyph reference '%s'\", ref_name)\n            return parent, target_path  # nothing to draw\n        rec = self.colrv1_glyphs.get(ref_name)\n        if rec is None or getattr(rec, \"Paint\", None) is None:\n            return parent, target_path  # nothing to draw\n\n        visited_glyphs.add(ref_name)\n        try:\n            group = GraphicsContext()\n            clip_path = self._build_clip_path(ref_name)\n            if clip_path is not None:\n                group.clipping_path = clip_path\n            self.draw_colrv1_paint(\n                paint=rec.Paint,\n                parent=group,\n                ctm=ctm,\n                visited_glyphs=visited_glyphs,\n            )\n            parent.add_item(item=group, clone=False)\n        finally:\n            visited_glyphs.remove(ref_name)\n        return parent, target_path\n\n    if paint.Format in (\n        PaintFormat.PaintTransform,  # 12\n        PaintFormat.PaintVarTransform,  # 13\n        PaintFormat.PaintTranslate,  # 14\n        PaintFormat.PaintVarTranslate,  # 15\n        PaintFormat.PaintScale,  # 16\n        PaintFormat.PaintVarScale,  # 17\n        PaintFormat.PaintScaleAroundCenter,  # 18\n        PaintFormat.PaintVarScaleAroundCenter,  # 19\n        PaintFormat.PaintScaleUniform,  # 20\n        PaintFormat.PaintVarScaleUniform,  # 21\n        PaintFormat.PaintScaleUniformAroundCenter,  # 22\n        PaintFormat.PaintVarScaleUniformAroundCenter,  # 23\n        PaintFormat.PaintRotate,  # 24\n        PaintFormat.PaintVarRotate,  # 25\n        PaintFormat.PaintRotateAroundCenter,  # 26\n        PaintFormat.PaintVarRotateAroundCenter,  # 27\n        PaintFormat.PaintSkew,  # 28\n        PaintFormat.PaintVarSkew,  # 29\n        PaintFormat.PaintSkewAroundCenter,  # 30\n        PaintFormat.PaintVarSkewAroundCenter,  # 31\n    ):\n        transform = self._transform_from_paint(paint)\n        new_ctm = ctm @ transform\n        return self.draw_colrv1_paint(\n            paint=paint.Paint,\n            parent=parent,\n            target_path=target_path,\n            ctm=new_ctm,\n            visited_glyphs=visited_glyphs,\n        )\n\n    if paint.Format in (\n        PaintFormat.PaintVarLinearGradient,  # 5\n        PaintFormat.PaintVarRadialGradient,  # 7\n        PaintFormat.PaintVarSweepGradient,\n    ):  # 9\n        raise NotImplementedError(\"Variable fonts are not yet supported.\")\n\n    if paint.Format == PaintFormat.PaintComposite:  # 32\n        backdrop_node = GraphicsContext()\n        _, backdrop_path = self.draw_colrv1_paint(\n            paint=paint.BackdropPaint,\n            parent=backdrop_node,\n            ctm=ctm,\n            visited_glyphs=visited_glyphs,\n        )\n        if backdrop_path is not None:\n            backdrop_node.add_item(item=backdrop_path, clone=False)\n\n        source_node = GraphicsContext()\n        _, source_path = self.draw_colrv1_paint(\n            paint=paint.SourcePaint,\n            parent=source_node,\n            ctm=ctm,\n            visited_glyphs=visited_glyphs,\n        )\n        if source_path is not None:\n            source_node.add_item(item=source_path, clone=False)\n\n        composite_type, composite_mode = self.get_composite_mode(\n            paint.CompositeMode\n        )\n        if composite_type == \"Blend\":\n            if TYPE_CHECKING:\n                assert isinstance(composite_mode, BlendMode)\n            parent.add_item(\n                item=PaintBlendComposite(\n                    backdrop=backdrop_node,\n                    source=source_node,\n                    blend_mode=composite_mode,\n                ),\n                clone=False,\n            )\n        elif composite_type == \"Compositing\":\n            if TYPE_CHECKING:\n                assert isinstance(composite_mode, CompositeMode)\n            composite_node = PaintComposite(\n                backdrop=backdrop_node,\n                source=source_node,\n                operation=composite_mode,  # pyright: ignore[reportArgumentType]\n            )\n            parent.add_item(item=composite_node, clone=False)\n        else:\n            raise ValueError(\"Composite operation not supported - {composite_type}\")\n        return parent, None\n\n    raise NotImplementedError(f\"Unknown PaintFormat: {paint.Format}\")",
      "language": "python"
    },
    {
      "code": "def draw_glyph_colrv0(self, layers: Sequence[ColrV0Layer]) -> GraphicsContext:\n    gc = GraphicsContext()\n    for layer in layers:\n        path = PaintedPath()\n        glyph_set = self.base_font.ttfont.getGlyphSet()\n        pen = GlyphPathPen(path, glyphSet=glyph_set)\n        glyph = glyph_set[layer.name]\n        glyph.draw(pen)\n        path.style.fill_color = self.get_color(layer.colorID)\n        path.style.stroke_color = self.get_color(layer.colorID)\n        gc.add_item(item=path, clone=False)\n    return gc",
      "language": "python"
    },
    {
      "code": "def draw_glyph_colrv1(self, glyph_name: str) -> GraphicsContext:\n    gc = GraphicsContext()\n    clip_path = self._build_clip_path(glyph_name)\n    if clip_path is not None:\n        gc.clipping_path = clip_path\n    glyph = self.colrv1_glyphs[glyph_name]\n    self.draw_colrv1_paint(\n        paint=glyph.Paint,\n        parent=gc,\n        target_path=None,\n        ctm=Transform.identity(),\n        visited_glyphs=set(glyph_name),\n    )\n    return gc",
      "language": "python"
    },
    {
      "code": "def get_color(self, color_index: int, alpha: float = 1) -> DeviceRGB:\n    if self.palette is None:  # should never happen\n        return DeviceRGB(0, 0, 0, 1)\n    if color_index == 0xFFFF:\n        # Palette entry 0xFFFF requests the application text foreground color.\n        text_color = getattr(self.fpdf, \"text_color\", DeviceGray(0))\n        if isinstance(text_color, DeviceRGB):\n            r, g, b = text_color.r, text_color.g, text_color.b\n            a = 1.0 if text_color.a is None else text_color.a\n        elif isinstance(text_color, DeviceGray):\n            r = g = b = text_color.g\n            a = 1.0 if text_color.a is None else text_color.a\n        elif isinstance(text_color, DeviceCMYK):\n            c, m, y, k = text_color.c, text_color.m, text_color.y, text_color.k\n            r = 1.0 - min(1.0, c + k)\n            g = 1.0 - min(1.0, m + k)\n            b = 1.0 - min(1.0, y + k)\n            a = 1.0 if text_color.a is None else text_color.a\n        else:\n            r = g = b = 0.0\n            a = 1.0\n    else:\n        r, g, b, a = self.palette[color_index]\n    a *= alpha\n    return DeviceRGB(r, g, b, a)",
      "language": "python"
    },
    {
      "code": "def get_paint_surface(self) -> PaintedPath:\n    \"\"\"\n    Creates a surface representing the whole glyph area for actions that require\n    painting an infinite surface and clipping to a geometry path\n    \"\"\"\n    paint_surface = PaintedPath()\n    surface_bbox = self.metric_bbox()\n    paint_surface.rectangle(\n        x=surface_bbox.x0,\n        y=surface_bbox.y0,\n        w=surface_bbox.width,\n        h=surface_bbox.height,\n    )\n    return paint_surface",
      "language": "python"
    },
    {
      "code": "def glyph_exists(self, glyph_name: str) -> bool:\n    return glyph_name in self.colrv0_glyphs or glyph_name in self.colrv1_glyphs",
      "language": "python"
    },
    {
      "code": "def load_glyph_image(self, glyph: Type3FontGlyph) -> None:\n    w = round(self.base_font.ttfont[\"hmtx\"].metrics[glyph.glyph_name][0] + 0.001)\n    if glyph.glyph_name in self.colrv0_glyphs:\n        glyph_layers = self.colrv0_glyphs[glyph.glyph_name]\n        img = self.draw_glyph_colrv0(glyph_layers)\n    else:\n        if self.version < 1 or glyph.glyph_name not in self.colrv1_glyphs:\n            raise NotImplementedError(\n                f\"No COLRv0 layers and no COLRv1 paint found for '{glyph.glyph_name}'.\"\n            )\n        img = self.draw_glyph_colrv1(glyph.glyph_name)\n    img.transform = Transform.scaling(self.scale, -self.scale)\n    output_stream = self.fpdf.draw_vector_glyph(img, self)\n    glyph.glyph = f\"{round(w * self.scale)} 0 d0\\n\" \"q\\n\" f\"{output_stream}\\n\" \"Q\"\n    glyph.glyph_width = w",
      "language": "python"
    },
    {
      "code": "def metric_bbox(self) -> BoundingBox:\n    return BoundingBox(\n        self.base_font.ttfont[\"head\"].xMin,\n        self.base_font.ttfont[\"head\"].yMin,\n        self.base_font.ttfont[\"head\"].xMax,\n        self.base_font.ttfont[\"head\"].yMax,\n    )",
      "language": "python"
    },
    {
      "code": "class ColrV0Layer(Protocol):\n    name: str\n    colorID: int",
      "language": "python"
    },
    {
      "code": "class Proto(Protocol):\n    def meth(self) -> int:\n        ...",
      "language": "php"
    },
    {
      "code": "class C:\n    def meth(self) -> int:\n        return 0\n\ndef func(x: Proto) -> int:\n    return x.meth()\n\nfunc(C())  # Passes static type check",
      "language": "swift"
    },
    {
      "code": "class GenProto[T](Protocol):\n    def meth(self) -> T:\n        ...",
      "language": "php"
    },
    {
      "code": "class ColrV1Paint(Protocol):\n    Paint: Paint",
      "language": "python"
    },
    {
      "code": "class Proto(Protocol):\n    def meth(self) -> int:\n        ...",
      "language": "php"
    },
    {
      "code": "class C:\n    def meth(self) -> int:\n        return 0\n\ndef func(x: Proto) -> int:\n    return x.meth()\n\nfunc(C())  # Passes static type check",
      "language": "swift"
    },
    {
      "code": "class GenProto[T](Protocol):\n    def meth(self) -> T:\n        ...",
      "language": "php"
    },
    {
      "code": "class SBIXColorFont(Type3Font):\n    \"\"\"Support for SBIX bitmap color fonts.\"\"\"\n\n    def glyph_exists(self, glyph_name: str) -> bool:\n        glyph = (\n            self.base_font.ttfont[\"sbix\"]\n            .strikes[self.get_strike_index()]\n            .glyphs.get(glyph_name)\n        )\n        return glyph is not None and glyph.graphicType is not None\n\n    def get_strike_index(self) -> int:\n        target_ppem = self.get_target_ppem(self.base_font.biggest_size_pt)\n        ppem_list: list[int] = [\n            ppem\n            for ppem in self.base_font.ttfont[\"sbix\"].strikes.keys()\n            if ppem >= target_ppem\n        ]\n        if not ppem_list:\n            return max(list(self.base_font.ttfont[\"sbix\"].strikes.keys()))  # type: ignore[no-any-return]\n        return min(ppem_list)\n\n    def load_glyph_image(self, glyph: Type3FontGlyph) -> None:\n        ppem = self.get_strike_index()\n        sbix_glyph = (\n            self.base_font.ttfont[\"sbix\"].strikes[ppem].glyphs.get(glyph.glyph_name)\n        )\n        if sbix_glyph.graphicType == \"dupe\":\n            raise NotImplementedError(\n                f\"{glyph.glyph_name}: Dupe SBIX graphic type not implemented.\"\n            )\n            # waiting for an example to test\n            # dupe_char = font.getBestCmap()[glyph.imageData]\n            # return self.get_color_glyph(dupe_char)\n\n        if sbix_glyph.graphicType not in (\"jpg \", \"png \", \"tiff\"):  # pdf or mask\n            raise NotImplementedError(\n                f\" {glyph.glyph_name}: Invalid SBIX graphic type {sbix_glyph.graphicType}.\"\n            )\n\n        bio = BytesIO(sbix_glyph.imageData)\n        bio.seek(0)\n        _, _, info = self.fpdf.preload_glyph_image(glyph_image_bytes=bio)\n        w = round(self.base_font.ttfont[\"hmtx\"].metrics[glyph.glyph_name][0] + 0.001)\n        glyf_metrics = self.base_font.ttfont[\"glyf\"].get(glyph.glyph_name)\n        assert glyf_metrics is not None\n        x_min = glyf_metrics.xMin + sbix_glyph.originOffsetX\n        x_max = glyf_metrics.xMax + sbix_glyph.originOffsetX\n        y_min = glyf_metrics.yMin + sbix_glyph.originOffsetY\n        y_max = glyf_metrics.yMax + sbix_glyph.originOffsetY\n\n        glyph.glyph = (\n            f\"{round(w * self.scale)} 0 d0\\n\"\n            \"q\\n\"\n            f\"{(x_max - x_min) * self.scale} 0 0 {(-y_min + y_max) * self.scale} {x_min * self.scale} {y_min * self.scale} cm\\n\"\n            f\"/I{info['i']} Do\\nQ\"\n        )\n        self.images_used.add(info[\"i\"])  # type: ignore[arg-type]\n        glyph.glyph_width = w",
      "language": "python"
    },
    {
      "code": "def get_strike_index(self) -> int:\n    target_ppem = self.get_target_ppem(self.base_font.biggest_size_pt)\n    ppem_list: list[int] = [\n        ppem\n        for ppem in self.base_font.ttfont[\"sbix\"].strikes.keys()\n        if ppem >= target_ppem\n    ]\n    if not ppem_list:\n        return max(list(self.base_font.ttfont[\"sbix\"].strikes.keys()))  # type: ignore[no-any-return]\n    return min(ppem_list)",
      "language": "python"
    },
    {
      "code": "def glyph_exists(self, glyph_name: str) -> bool:\n    glyph = (\n        self.base_font.ttfont[\"sbix\"]\n        .strikes[self.get_strike_index()]\n        .glyphs.get(glyph_name)\n    )\n    return glyph is not None and glyph.graphicType is not None",
      "language": "python"
    },
    {
      "code": "def load_glyph_image(self, glyph: Type3FontGlyph) -> None:\n    ppem = self.get_strike_index()\n    sbix_glyph = (\n        self.base_font.ttfont[\"sbix\"].strikes[ppem].glyphs.get(glyph.glyph_name)\n    )\n    if sbix_glyph.graphicType == \"dupe\":\n        raise NotImplementedError(\n            f\"{glyph.glyph_name}: Dupe SBIX graphic type not implemented.\"\n        )\n        # waiting for an example to test\n        # dupe_char = font.getBestCmap()[glyph.imageData]\n        # return self.get_color_glyph(dupe_char)\n\n    if sbix_glyph.graphicType not in (\"jpg \", \"png \", \"tiff\"):  # pdf or mask\n        raise NotImplementedError(\n            f\" {glyph.glyph_name}: Invalid SBIX graphic type {sbix_glyph.graphicType}.\"\n        )\n\n    bio = BytesIO(sbix_glyph.imageData)\n    bio.seek(0)\n    _, _, info = self.fpdf.preload_glyph_image(glyph_image_bytes=bio)\n    w = round(self.base_font.ttfont[\"hmtx\"].metrics[glyph.glyph_name][0] + 0.001)\n    glyf_metrics = self.base_font.ttfont[\"glyf\"].get(glyph.glyph_name)\n    assert glyf_metrics is not None\n    x_min = glyf_metrics.xMin + sbix_glyph.originOffsetX\n    x_max = glyf_metrics.xMax + sbix_glyph.originOffsetX\n    y_min = glyf_metrics.yMin + sbix_glyph.originOffsetY\n    y_max = glyf_metrics.yMax + sbix_glyph.originOffsetY\n\n    glyph.glyph = (\n        f\"{round(w * self.scale)} 0 d0\\n\"\n        \"q\\n\"\n        f\"{(x_max - x_min) * self.scale} 0 0 {(-y_min + y_max) * self.scale} {x_min * self.scale} {y_min * self.scale} cm\\n\"\n        f\"/I{info['i']} Do\\nQ\"\n    )\n    self.images_used.add(info[\"i\"])  # type: ignore[arg-type]\n    glyph.glyph_width = w",
      "language": "python"
    },
    {
      "code": "class SVGColorFont(Type3Font):\n    \"\"\"Support for SVG OpenType vector color fonts.\"\"\"\n\n    def glyph_exists(self, glyph_name: str) -> bool:\n        glyph_id = self.base_font.ttfont.getGlyphID(glyph_name)\n        return any(\n            svg_doc.startGlyphID <= glyph_id <= svg_doc.endGlyphID\n            for svg_doc in self.base_font.ttfont[\"SVG \"].docList\n        )\n\n    def load_glyph_image(self, glyph: Type3FontGlyph) -> None:\n        glyph_id = self.base_font.ttfont.getGlyphID(glyph.glyph_name)\n        glyph_svg_data = None\n        for svg_doc in self.base_font.ttfont[\"SVG \"].docList:\n            if svg_doc.startGlyphID <= glyph_id <= svg_doc.endGlyphID:\n                glyph_svg_data = svg_doc.data.encode(\"utf-8\")\n                break\n        if not glyph_svg_data:\n            raise ValueError(\n                f\"Glyph {glyph.glyph_name} (ID: {glyph_id}) not found in SVG font.\"\n            )\n        bio = BytesIO(glyph_svg_data)\n        bio.seek(0)\n        _, img, _ = self.fpdf.preload_glyph_image(glyph_image_bytes=bio)\n        if TYPE_CHECKING:\n            assert isinstance(img, SVGObject)\n        w = round(self.base_font.ttfont[\"hmtx\"].metrics[glyph.glyph_name][0] + 0.001)\n        img.base_group.transform = Transform.scaling(self.scale, self.scale)\n        output_stream = self.fpdf.draw_vector_glyph(img.base_group, self)\n        glyph.glyph = f\"{round(w * self.scale)} 0 d0\\n\" \"q\\n\" f\"{output_stream}\\n\" \"Q\"\n        glyph.glyph_width = w",
      "language": "python"
    },
    {
      "code": "def glyph_exists(self, glyph_name: str) -> bool:\n    glyph_id = self.base_font.ttfont.getGlyphID(glyph_name)\n    return any(\n        svg_doc.startGlyphID <= glyph_id <= svg_doc.endGlyphID\n        for svg_doc in self.base_font.ttfont[\"SVG \"].docList\n    )",
      "language": "python"
    },
    {
      "code": "def load_glyph_image(self, glyph: Type3FontGlyph) -> None:\n    glyph_id = self.base_font.ttfont.getGlyphID(glyph.glyph_name)\n    glyph_svg_data = None\n    for svg_doc in self.base_font.ttfont[\"SVG \"].docList:\n        if svg_doc.startGlyphID <= glyph_id <= svg_doc.endGlyphID:\n            glyph_svg_data = svg_doc.data.encode(\"utf-8\")\n            break\n    if not glyph_svg_data:\n        raise ValueError(\n            f\"Glyph {glyph.glyph_name} (ID: {glyph_id}) not found in SVG font.\"\n        )\n    bio = BytesIO(glyph_svg_data)\n    bio.seek(0)\n    _, img, _ = self.fpdf.preload_glyph_image(glyph_image_bytes=bio)\n    if TYPE_CHECKING:\n        assert isinstance(img, SVGObject)\n    w = round(self.base_font.ttfont[\"hmtx\"].metrics[glyph.glyph_name][0] + 0.001)\n    img.base_group.transform = Transform.scaling(self.scale, self.scale)\n    output_stream = self.fpdf.draw_vector_glyph(img.base_group, self)\n    glyph.glyph = f\"{round(w * self.scale)} 0 d0\\n\" \"q\\n\" f\"{output_stream}\\n\" \"Q\"\n    glyph.glyph_width = w",
      "language": "python"
    },
    {
      "code": "class Type3Font:\n\n    def __init__(self, fpdf: \"FPDF\", base_font: \"TTFFont\"):\n        self.i: int = 1\n        self.type: str = \"type3\"\n        self.fpdf: \"FPDF\" = fpdf\n        self.base_font: \"TTFFont\" = base_font\n        self.upem: int = self.base_font.ttfont[\"head\"].unitsPerEm\n        self.scale: float = 1000 / self.upem  # pyright: ignore[reportUnknownMemberType]\n        self.images_used: set[int] = set()\n        self.graphics_style_used: set[str] = set()\n        self.patterns_used: set[str] = set()\n        self.glyphs: list[Type3FontGlyph] = []\n\n    def get_notdef_glyph(self, glyph_id: int) -> Type3FontGlyph:\n        notdef = Type3FontGlyph()\n        notdef.glyph_id = glyph_id\n        notdef.unicode = glyph_id\n        notdef.glyph_name = \".notdef\"\n        notdef.glyph_width = self.base_font.ttfont[\"hmtx\"].metrics[\".notdef\"][0]\n        notdef.glyph = f\"{round(notdef.glyph_width * self.scale + 0.001)} 0 d0\"\n        return notdef\n\n    def get_space_glyph(self, glyph_id: int) -> Type3FontGlyph:\n        space = Type3FontGlyph()\n        space.glyph_id = glyph_id\n        space.unicode = 0x20\n        space.glyph_name = \"space\"\n        w = (\n            self.base_font.ttfont[\"hmtx\"].metrics[\"space\"][0]\n            if \"space\" in self.base_font.ttfont[\"hmtx\"].metrics\n            else self.base_font.ttfont[\"hmtx\"].metrics[\".notdef\"][0]\n        )\n        space.glyph_width = round(w + 0.001)\n        space.glyph = f\"{round(space.glyph_width * self.scale + 0.001)} 0 d0\"\n        return space\n\n    def load_glyphs(self) -> None:\n        WHITES = {\n            0x0009,\n            0x000A,\n            0x000C,\n            0x000D,\n            0x0020,\n            0x00A0,\n            0x1680,\n            0x2000,\n            0x2001,\n            0x2002,\n            0x2003,\n            0x2004,\n            0x2005,\n            0x2006,\n            0x2007,\n            0x2008,\n            0x2009,\n            0x200A,\n            0x202F,\n            0x205F,\n            0x3000,\n        }\n        for glyph, char_id in self.base_font.subset.items():\n            if glyph is None:\n                continue\n            if glyph.unicode in WHITES or glyph.glyph_name in (\"space\", \"uni00A0\"):\n                self.glyphs.append(self.get_space_glyph(char_id))\n                continue\n            if not self.glyph_exists(glyph.glyph_name):\n                if self.glyph_exists(\".notdef\"):\n                    self.add_glyph(\".notdef\", char_id)\n                    continue\n                self.glyphs.append(self.get_notdef_glyph(char_id))\n                continue\n            self.add_glyph(glyph.glyph_name, char_id)\n\n    def add_glyph(self, glyph_name: str, char_id: int) -> None:\n        g = Type3FontGlyph()\n        g.glyph_id = char_id\n        g.unicode = char_id\n        g.glyph_name = glyph_name\n        self.load_glyph_image(g)\n        self.glyphs.append(g)\n\n    @classmethod\n    def get_target_ppem(cls, font_size_pt: float) -> float:\n        # Calculating the target ppem:\n        # https://learn.microsoft.com/en-us/typography/opentype/spec/ttch01#display-device-characteristics\n        # ppem = point_size * dpi / 72\n        # The default PDF dpi resolution is 72 dpi - and we have the 72 dpi hardcoded on our scale factor,\n        # so we can simplify the calculation.\n        return font_size_pt\n\n    def load_glyph_image(self, glyph: Type3FontGlyph) -> None:\n        raise NotImplementedError(\"Method must be implemented on child class\")\n\n    def glyph_exists(self, glyph_name: str) -> bool:\n        raise NotImplementedError(\"Method must be implemented on child class\")",
      "language": "python"
    },
    {
      "code": "def add_glyph(self, glyph_name: str, char_id: int) -> None:\n    g = Type3FontGlyph()\n    g.glyph_id = char_id\n    g.unicode = char_id\n    g.glyph_name = glyph_name\n    self.load_glyph_image(g)\n    self.glyphs.append(g)",
      "language": "python"
    },
    {
      "code": "def get_notdef_glyph(self, glyph_id: int) -> Type3FontGlyph:\n    notdef = Type3FontGlyph()\n    notdef.glyph_id = glyph_id\n    notdef.unicode = glyph_id\n    notdef.glyph_name = \".notdef\"\n    notdef.glyph_width = self.base_font.ttfont[\"hmtx\"].metrics[\".notdef\"][0]\n    notdef.glyph = f\"{round(notdef.glyph_width * self.scale + 0.001)} 0 d0\"\n    return notdef",
      "language": "python"
    },
    {
      "code": "def get_space_glyph(self, glyph_id: int) -> Type3FontGlyph:\n    space = Type3FontGlyph()\n    space.glyph_id = glyph_id\n    space.unicode = 0x20\n    space.glyph_name = \"space\"\n    w = (\n        self.base_font.ttfont[\"hmtx\"].metrics[\"space\"][0]\n        if \"space\" in self.base_font.ttfont[\"hmtx\"].metrics\n        else self.base_font.ttfont[\"hmtx\"].metrics[\".notdef\"][0]\n    )\n    space.glyph_width = round(w + 0.001)\n    space.glyph = f\"{round(space.glyph_width * self.scale + 0.001)} 0 d0\"\n    return space",
      "language": "python"
    },
    {
      "code": "def glyph_exists(self, glyph_name: str) -> bool:\n    raise NotImplementedError(\"Method must be implemented on child class\")",
      "language": "python"
    },
    {
      "code": "def load_glyph_image(self, glyph: Type3FontGlyph) -> None:\n    raise NotImplementedError(\"Method must be implemented on child class\")",
      "language": "python"
    },
    {
      "code": "def load_glyphs(self) -> None:\n    WHITES = {\n        0x0009,\n        0x000A,\n        0x000C,\n        0x000D,\n        0x0020,\n        0x00A0,\n        0x1680,\n        0x2000,\n        0x2001,\n        0x2002,\n        0x2003,\n        0x2004,\n        0x2005,\n        0x2006,\n        0x2007,\n        0x2008,\n        0x2009,\n        0x200A,\n        0x202F,\n        0x205F,\n        0x3000,\n    }\n    for glyph, char_id in self.base_font.subset.items():\n        if glyph is None:\n            continue\n        if glyph.unicode in WHITES or glyph.glyph_name in (\"space\", \"uni00A0\"):\n            self.glyphs.append(self.get_space_glyph(char_id))\n            continue\n        if not self.glyph_exists(glyph.glyph_name):\n            if self.glyph_exists(\".notdef\"):\n                self.add_glyph(\".notdef\", char_id)\n                continue\n            self.glyphs.append(self.get_notdef_glyph(char_id))\n            continue\n        self.add_glyph(glyph.glyph_name, char_id)",
      "language": "python"
    },
    {
      "code": "class Type3FontGlyph:\n    # RAM usage optimization:\n    __slots__ = (\n        \"obj_id\",\n        \"glyph_id\",\n        \"unicode\",\n        \"glyph_name\",\n        \"glyph_width\",\n        \"glyph\",\n        \"_glyph_bounds\",\n    )\n    obj_id: int\n    glyph_id: int\n    unicode: int\n    glyph_name: str\n    glyph_width: int\n    glyph: str\n    _glyph_bounds: tuple[int, int, int, int]\n\n    def __init__(self) -> None:\n        pass\n\n    def __hash__(self) -> int:\n        return self.glyph_id",
      "language": "python"
    },
    {
      "code": "class Type3FontGlyph:\n    # RAM usage optimization:\n    __slots__ = (\n        \"obj_id\",\n        \"glyph_id\",\n        \"unicode\",\n        \"glyph_name\",\n        \"glyph_width\",\n        \"glyph\",\n        \"_glyph_bounds\",\n    )\n    obj_id: int\n    glyph_id: int\n    unicode: int\n    glyph_name: str\n    glyph_width: int\n    glyph: str\n    _glyph_bounds: tuple[int, int, int, int]\n\n    def __init__(self) -> None:\n        pass\n\n    def __hash__(self) -> int:\n        return self.glyph_id",
      "language": "python"
    },
    {
      "code": "class Type3FontGlyph:\n    # RAM usage optimization:\n    __slots__ = (\n        \"obj_id\",\n        \"glyph_id\",\n        \"unicode\",\n        \"glyph_name\",\n        \"glyph_width\",\n        \"glyph\",\n        \"_glyph_bounds\",\n    )\n    obj_id: int\n    glyph_id: int\n    unicode: int\n    glyph_name: str\n    glyph_width: int\n    glyph: str\n    _glyph_bounds: tuple[int, int, int, int]\n\n    def __init__(self) -> None:\n        pass\n\n    def __hash__(self) -> int:\n        return self.glyph_id",
      "language": "python"
    },
    {
      "code": "class Type3FontGlyph:\n    # RAM usage optimization:\n    __slots__ = (\n        \"obj_id\",\n        \"glyph_id\",\n        \"unicode\",\n        \"glyph_name\",\n        \"glyph_width\",\n        \"glyph\",\n        \"_glyph_bounds\",\n    )\n    obj_id: int\n    glyph_id: int\n    unicode: int\n    glyph_name: str\n    glyph_width: int\n    glyph: str\n    _glyph_bounds: tuple[int, int, int, int]\n\n    def __init__(self) -> None:\n        pass\n\n    def __hash__(self) -> int:\n        return self.glyph_id",
      "language": "python"
    },
    {
      "code": "class Type3FontGlyph:\n    # RAM usage optimization:\n    __slots__ = (\n        \"obj_id\",\n        \"glyph_id\",\n        \"unicode\",\n        \"glyph_name\",\n        \"glyph_width\",\n        \"glyph\",\n        \"_glyph_bounds\",\n    )\n    obj_id: int\n    glyph_id: int\n    unicode: int\n    glyph_name: str\n    glyph_width: int\n    glyph: str\n    _glyph_bounds: tuple[int, int, int, int]\n\n    def __init__(self) -> None:\n        pass\n\n    def __hash__(self) -> int:\n        return self.glyph_id",
      "language": "python"
    },
    {
      "code": "class Type3FontGlyph:\n    # RAM usage optimization:\n    __slots__ = (\n        \"obj_id\",\n        \"glyph_id\",\n        \"unicode\",\n        \"glyph_name\",\n        \"glyph_width\",\n        \"glyph\",\n        \"_glyph_bounds\",\n    )\n    obj_id: int\n    glyph_id: int\n    unicode: int\n    glyph_name: str\n    glyph_width: int\n    glyph: str\n    _glyph_bounds: tuple[int, int, int, int]\n\n    def __init__(self) -> None:\n        pass\n\n    def __hash__(self) -> int:\n        return self.glyph_id",
      "language": "python"
    },
    {
      "code": "class Type3FontGlyph:\n    # RAM usage optimization:\n    __slots__ = (\n        \"obj_id\",\n        \"glyph_id\",\n        \"unicode\",\n        \"glyph_name\",\n        \"glyph_width\",\n        \"glyph\",\n        \"_glyph_bounds\",\n    )\n    obj_id: int\n    glyph_id: int\n    unicode: int\n    glyph_name: str\n    glyph_width: int\n    glyph: str\n    _glyph_bounds: tuple[int, int, int, int]\n\n    def __init__(self) -> None:\n        pass\n\n    def __hash__(self) -> int:\n        return self.glyph_id",
      "language": "python"
    },
    {
      "code": "class VarTableWrapper:\n    def __init__(\n        self,\n        wrapped: Any,\n        instancer: VarStoreInstancer,\n        var_index_map: Any = None,\n        format_override: Optional[int] = None,\n    ) -> None:\n        assert not isinstance(wrapped, VarTableWrapper)\n        self._wrapped = wrapped\n        self._instancer = instancer\n        self._var_index_map = var_index_map\n        self._format_override = format_override\n        self._var_attrs = {\n            attr: idx for idx, attr in enumerate(wrapped.getVariableAttrs())\n        }\n\n    def __repr__(self) -> str:\n        return f\"VarTableWrapper({self._wrapped!r})\"\n\n    def _get_var_index_for_attr(self, attr_name: str) -> Any:\n        offset = self._var_attrs.get(attr_name)\n        if offset is None:\n            return None\n        base_index = self._wrapped.VarIndexBase\n        if base_index == 0xFFFFFFFF:\n            return base_index\n        var_idx = base_index + offset\n        if self._var_index_map is not None:\n            try:\n                var_idx = self._var_index_map[var_idx]\n            except IndexError:\n                pass\n        return var_idx\n\n    def _get_delta_for_attr(self, attr_name: str, var_idx: Any) -> Any:\n        delta = self._instancer[var_idx]\n        converter = self._wrapped.getConverterByName(attr_name)\n        if hasattr(converter, \"fromInt\"):\n            delta = converter.fromInt(delta)\n        return delta\n\n    def __getattr__(self, attr_name: str) -> Any:\n        if attr_name == \"Format\" and self._format_override is not None:\n            return self._format_override\n\n        value = getattr(self._wrapped, attr_name)\n\n        var_idx = self._get_var_index_for_attr(attr_name)\n        if var_idx is not None:\n            if var_idx < 0xFFFFFFFF:\n                value += self._get_delta_for_attr(attr_name, var_idx)\n        elif isinstance(value, (VarAffine2x3, VarColorLine)):\n            value = VarTableWrapper(value, self._instancer, self._var_index_map)\n        elif (\n            isinstance(value, (list, UserList))\n            and value\n            and isinstance(value[0], VarColorStop)\n        ):\n            value = [\n                VarTableWrapper(item, self._instancer, self._var_index_map)\n                for item in value\n            ]\n\n        return value",
      "language": "python"
    }
  ],
  "patterns": [
    {
      "description": "Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -> int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing). For example:: class C: def meth(self) -> int: return 0 def func(x: Proto) -> int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto[T](Protocol): def meth(self) -> T: ...",
      "code": "class Proto(Protocol):\n    def meth(self) -> int:\n        ..."
    },
    {
      "description": "For example::",
      "code": "class C:\n    def meth(self) -> int:\n        return 0\n\ndef func(x: Proto) -> int:\n    return x.meth()\n\nfunc(C())  # Passes static type check"
    },
    {
      "description": "Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -> int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing). For example:: class C: def meth(self) -> int: return 0 def func(x: Proto) -> int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto[T](Protocol): def meth(self) -> T: ...",
      "code": "class Proto(Protocol):\n    def meth(self) -> int:\n        ..."
    },
    {
      "description": "For example::",
      "code": "class C:\n    def meth(self) -> int:\n        return 0\n\ndef func(x: Proto) -> int:\n    return x.meth()\n\nfunc(C())  # Passes static type check"
    }
  ],
  "links": [
    "https://py-pdf.github.io/fpdf2/fpdf/font_type_3.html",
    "https://py-pdf.github.io/fpdf2/fpdf/enums.html",
    "https://py-pdf.github.io/fpdf2/fpdf/drawing.html",
    "https://py-pdf.github.io/fpdf2/fpdf/drawing_primitives.html",
    "https://py-pdf.github.io/fpdf2/fpdf/index.html"
  ]
}