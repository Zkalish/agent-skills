{
  "url": "https://py-pdf.github.io/fpdf2/fpdf/fonts.html",
  "title": "Module fpdf.fonts",
  "content": "Font-related classes & constants. Includes the definition of the character widths of all PDF standard fonts.\n\nThe contents of this module are internal to fpdf2, and not part of the public API. They may change at any time without prior warning or any deprecation period, in non-backward-compatible ways.\n\nUsage documentation at: https://py-pdf.github.io/fpdf2/Unicode.html\n\nRepresent basic font styling properties. This is a subset of GraphicsStateMixin properties.\n\nCreate a combined FontFace with all the supplied features of the two styles. When both the default and override styles provide a feature, prefer the override style. Override specified FontFace style features Override this FontFace's values with the values of other. Values of other that are None in this FontFace will be kept unchanged.\n\nReturn a new object replacing specified fields with new values.\n\nThis is especially useful for frozen classes. Example usage::\n\n@dataclass(frozen=True) class C: x: int y: int\n\nc = C(1, 2) c1 = replace(c, x=3) assert c1.x == 3 and c1.y == 2\n\nThis represents one glyph on the font Unicode is a tuple because ligatures or character substitution can map a sequence of unicode characters to a single glyph\n\nInherited from: PDFObject.content_stream\n\nSubclasses can override this method to indicate the presence of a content stream\n\nInherited from: PDFObject.serialize\n\nSerialize the PDF object as an obj<</>>endobj text block\n\nHolds a mapping of used characters and their position in the font's subset\n\nCharacters that must be mapped on their actual unicode must be part of the identities list during object instantiation. These non-negative values should only appear once in the list. pick() can be used to get the characters corresponding position in the subset. If it's not yet part of the object, a new position is acquired automatically. This implementation always tries to return the lowest possible representation.\n\nThis method invokes Harfbuzz to perform text shaping of the input string\n\nThis method will invoke harfbuzz for text shaping, include the mapping code of the glyphs on the subset and map input characters to the cluster codes\n\nWhen texts are shaped, the length of a string is not always the sum of all individual character widths This method will invoke harfbuzz to perform the text shaping and return the sum of \"x_advance\" and \"x_offset\" for each glyph. This method works for \"left to right\" or \"right to left\" texts.\n\nSubclass of FontFace that allows to specify vertical & horizontal spacing\n\nInherited from: FontFace.combine\n\nCreate a combined FontFace with all the supplied features of the two styles. When both the default and override styles provide a feature, prefer the â€¦\n\nCreate a new TextStyle instance, with new values for some attributes. Same as dataclasses.replace()",
  "headings": [
    {
      "level": "h1",
      "text": "Module fpdf.fonts",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Classes",
      "id": "header-classes"
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Subclasses",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Static methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Subclasses",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Static methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    }
  ],
  "code_samples": [
    {
      "code": "class CoreFont:\n    # RAM usage optimization:\n    __slots__ = (\n        \"i\",\n        \"type\",\n        \"name\",\n        \"sp\",\n        \"ss\",\n        \"up\",\n        \"ut\",\n        \"cw\",\n        \"fontkey\",\n        \"emphasis\",\n    )\n\n    def __init__(self, i: int, fontkey: str, style: str) -> None:\n        self.i = i\n        self.type = \"core\"\n        self.name = CORE_FONTS[fontkey]\n        self.sp = 250  # strikethrough horizontal position\n        self.ss = 50  # strikethrough size (height)\n        self.up = -100  # underline horizontal position\n        self.ut = 50  # underline height\n        self.cw = CORE_FONTS_CHARWIDTHS[fontkey]\n        self.fontkey = fontkey\n        self.emphasis = TextEmphasis.coerce(style)\n\n    def get_text_width(\n        self, text: str, font_size_pt: float, _: Optional[dict[str, Any]]\n    ) -> tuple[int, float]:\n        return (len(text), sum(self.cw[c] for c in text) * font_size_pt * 0.001)\n\n    # Disabling this check - method kept as is to have same method/signature on CoreConf and TTFFont:\n    # pylint: disable=no-self-use\n    def encode_text(self, text: str) -> str:\n        return f\"({escape_parens(text)}) Tj\"\n\n    def __repr__(self) -> str:\n        return f\"CoreFont(i={self.i}, fontkey={self.fontkey})\"",
      "language": "python"
    },
    {
      "code": "class CoreFont:\n    # RAM usage optimization:\n    __slots__ = (\n        \"i\",\n        \"type\",\n        \"name\",\n        \"sp\",\n        \"ss\",\n        \"up\",\n        \"ut\",\n        \"cw\",\n        \"fontkey\",\n        \"emphasis\",\n    )\n\n    def __init__(self, i: int, fontkey: str, style: str) -> None:\n        self.i = i\n        self.type = \"core\"\n        self.name = CORE_FONTS[fontkey]\n        self.sp = 250  # strikethrough horizontal position\n        self.ss = 50  # strikethrough size (height)\n        self.up = -100  # underline horizontal position\n        self.ut = 50  # underline height\n        self.cw = CORE_FONTS_CHARWIDTHS[fontkey]\n        self.fontkey = fontkey\n        self.emphasis = TextEmphasis.coerce(style)\n\n    def get_text_width(\n        self, text: str, font_size_pt: float, _: Optional[dict[str, Any]]\n    ) -> tuple[int, float]:\n        return (len(text), sum(self.cw[c] for c in text) * font_size_pt * 0.001)\n\n    # Disabling this check - method kept as is to have same method/signature on CoreConf and TTFFont:\n    # pylint: disable=no-self-use\n    def encode_text(self, text: str) -> str:\n        return f\"({escape_parens(text)}) Tj\"\n\n    def __repr__(self) -> str:\n        return f\"CoreFont(i={self.i}, fontkey={self.fontkey})\"",
      "language": "python"
    },
    {
      "code": "class CoreFont:\n    # RAM usage optimization:\n    __slots__ = (\n        \"i\",\n        \"type\",\n        \"name\",\n        \"sp\",\n        \"ss\",\n        \"up\",\n        \"ut\",\n        \"cw\",\n        \"fontkey\",\n        \"emphasis\",\n    )\n\n    def __init__(self, i: int, fontkey: str, style: str) -> None:\n        self.i = i\n        self.type = \"core\"\n        self.name = CORE_FONTS[fontkey]\n        self.sp = 250  # strikethrough horizontal position\n        self.ss = 50  # strikethrough size (height)\n        self.up = -100  # underline horizontal position\n        self.ut = 50  # underline height\n        self.cw = CORE_FONTS_CHARWIDTHS[fontkey]\n        self.fontkey = fontkey\n        self.emphasis = TextEmphasis.coerce(style)\n\n    def get_text_width(\n        self, text: str, font_size_pt: float, _: Optional[dict[str, Any]]\n    ) -> tuple[int, float]:\n        return (len(text), sum(self.cw[c] for c in text) * font_size_pt * 0.001)\n\n    # Disabling this check - method kept as is to have same method/signature on CoreConf and TTFFont:\n    # pylint: disable=no-self-use\n    def encode_text(self, text: str) -> str:\n        return f\"({escape_parens(text)}) Tj\"\n\n    def __repr__(self) -> str:\n        return f\"CoreFont(i={self.i}, fontkey={self.fontkey})\"",
      "language": "python"
    },
    {
      "code": "class CoreFont:\n    # RAM usage optimization:\n    __slots__ = (\n        \"i\",\n        \"type\",\n        \"name\",\n        \"sp\",\n        \"ss\",\n        \"up\",\n        \"ut\",\n        \"cw\",\n        \"fontkey\",\n        \"emphasis\",\n    )\n\n    def __init__(self, i: int, fontkey: str, style: str) -> None:\n        self.i = i\n        self.type = \"core\"\n        self.name = CORE_FONTS[fontkey]\n        self.sp = 250  # strikethrough horizontal position\n        self.ss = 50  # strikethrough size (height)\n        self.up = -100  # underline horizontal position\n        self.ut = 50  # underline height\n        self.cw = CORE_FONTS_CHARWIDTHS[fontkey]\n        self.fontkey = fontkey\n        self.emphasis = TextEmphasis.coerce(style)\n\n    def get_text_width(\n        self, text: str, font_size_pt: float, _: Optional[dict[str, Any]]\n    ) -> tuple[int, float]:\n        return (len(text), sum(self.cw[c] for c in text) * font_size_pt * 0.001)\n\n    # Disabling this check - method kept as is to have same method/signature on CoreConf and TTFFont:\n    # pylint: disable=no-self-use\n    def encode_text(self, text: str) -> str:\n        return f\"({escape_parens(text)}) Tj\"\n\n    def __repr__(self) -> str:\n        return f\"CoreFont(i={self.i}, fontkey={self.fontkey})\"",
      "language": "python"
    },
    {
      "code": "class CoreFont:\n    # RAM usage optimization:\n    __slots__ = (\n        \"i\",\n        \"type\",\n        \"name\",\n        \"sp\",\n        \"ss\",\n        \"up\",\n        \"ut\",\n        \"cw\",\n        \"fontkey\",\n        \"emphasis\",\n    )\n\n    def __init__(self, i: int, fontkey: str, style: str) -> None:\n        self.i = i\n        self.type = \"core\"\n        self.name = CORE_FONTS[fontkey]\n        self.sp = 250  # strikethrough horizontal position\n        self.ss = 50  # strikethrough size (height)\n        self.up = -100  # underline horizontal position\n        self.ut = 50  # underline height\n        self.cw = CORE_FONTS_CHARWIDTHS[fontkey]\n        self.fontkey = fontkey\n        self.emphasis = TextEmphasis.coerce(style)\n\n    def get_text_width(\n        self, text: str, font_size_pt: float, _: Optional[dict[str, Any]]\n    ) -> tuple[int, float]:\n        return (len(text), sum(self.cw[c] for c in text) * font_size_pt * 0.001)\n\n    # Disabling this check - method kept as is to have same method/signature on CoreConf and TTFFont:\n    # pylint: disable=no-self-use\n    def encode_text(self, text: str) -> str:\n        return f\"({escape_parens(text)}) Tj\"\n\n    def __repr__(self) -> str:\n        return f\"CoreFont(i={self.i}, fontkey={self.fontkey})\"",
      "language": "python"
    },
    {
      "code": "class CoreFont:\n    # RAM usage optimization:\n    __slots__ = (\n        \"i\",\n        \"type\",\n        \"name\",\n        \"sp\",\n        \"ss\",\n        \"up\",\n        \"ut\",\n        \"cw\",\n        \"fontkey\",\n        \"emphasis\",\n    )\n\n    def __init__(self, i: int, fontkey: str, style: str) -> None:\n        self.i = i\n        self.type = \"core\"\n        self.name = CORE_FONTS[fontkey]\n        self.sp = 250  # strikethrough horizontal position\n        self.ss = 50  # strikethrough size (height)\n        self.up = -100  # underline horizontal position\n        self.ut = 50  # underline height\n        self.cw = CORE_FONTS_CHARWIDTHS[fontkey]\n        self.fontkey = fontkey\n        self.emphasis = TextEmphasis.coerce(style)\n\n    def get_text_width(\n        self, text: str, font_size_pt: float, _: Optional[dict[str, Any]]\n    ) -> tuple[int, float]:\n        return (len(text), sum(self.cw[c] for c in text) * font_size_pt * 0.001)\n\n    # Disabling this check - method kept as is to have same method/signature on CoreConf and TTFFont:\n    # pylint: disable=no-self-use\n    def encode_text(self, text: str) -> str:\n        return f\"({escape_parens(text)}) Tj\"\n\n    def __repr__(self) -> str:\n        return f\"CoreFont(i={self.i}, fontkey={self.fontkey})\"",
      "language": "python"
    },
    {
      "code": "class CoreFont:\n    # RAM usage optimization:\n    __slots__ = (\n        \"i\",\n        \"type\",\n        \"name\",\n        \"sp\",\n        \"ss\",\n        \"up\",\n        \"ut\",\n        \"cw\",\n        \"fontkey\",\n        \"emphasis\",\n    )\n\n    def __init__(self, i: int, fontkey: str, style: str) -> None:\n        self.i = i\n        self.type = \"core\"\n        self.name = CORE_FONTS[fontkey]\n        self.sp = 250  # strikethrough horizontal position\n        self.ss = 50  # strikethrough size (height)\n        self.up = -100  # underline horizontal position\n        self.ut = 50  # underline height\n        self.cw = CORE_FONTS_CHARWIDTHS[fontkey]\n        self.fontkey = fontkey\n        self.emphasis = TextEmphasis.coerce(style)\n\n    def get_text_width(\n        self, text: str, font_size_pt: float, _: Optional[dict[str, Any]]\n    ) -> tuple[int, float]:\n        return (len(text), sum(self.cw[c] for c in text) * font_size_pt * 0.001)\n\n    # Disabling this check - method kept as is to have same method/signature on CoreConf and TTFFont:\n    # pylint: disable=no-self-use\n    def encode_text(self, text: str) -> str:\n        return f\"({escape_parens(text)}) Tj\"\n\n    def __repr__(self) -> str:\n        return f\"CoreFont(i={self.i}, fontkey={self.fontkey})\"",
      "language": "python"
    },
    {
      "code": "class CoreFont:\n    # RAM usage optimization:\n    __slots__ = (\n        \"i\",\n        \"type\",\n        \"name\",\n        \"sp\",\n        \"ss\",\n        \"up\",\n        \"ut\",\n        \"cw\",\n        \"fontkey\",\n        \"emphasis\",\n    )\n\n    def __init__(self, i: int, fontkey: str, style: str) -> None:\n        self.i = i\n        self.type = \"core\"\n        self.name = CORE_FONTS[fontkey]\n        self.sp = 250  # strikethrough horizontal position\n        self.ss = 50  # strikethrough size (height)\n        self.up = -100  # underline horizontal position\n        self.ut = 50  # underline height\n        self.cw = CORE_FONTS_CHARWIDTHS[fontkey]\n        self.fontkey = fontkey\n        self.emphasis = TextEmphasis.coerce(style)\n\n    def get_text_width(\n        self, text: str, font_size_pt: float, _: Optional[dict[str, Any]]\n    ) -> tuple[int, float]:\n        return (len(text), sum(self.cw[c] for c in text) * font_size_pt * 0.001)\n\n    # Disabling this check - method kept as is to have same method/signature on CoreConf and TTFFont:\n    # pylint: disable=no-self-use\n    def encode_text(self, text: str) -> str:\n        return f\"({escape_parens(text)}) Tj\"\n\n    def __repr__(self) -> str:\n        return f\"CoreFont(i={self.i}, fontkey={self.fontkey})\"",
      "language": "python"
    },
    {
      "code": "class CoreFont:\n    # RAM usage optimization:\n    __slots__ = (\n        \"i\",\n        \"type\",\n        \"name\",\n        \"sp\",\n        \"ss\",\n        \"up\",\n        \"ut\",\n        \"cw\",\n        \"fontkey\",\n        \"emphasis\",\n    )\n\n    def __init__(self, i: int, fontkey: str, style: str) -> None:\n        self.i = i\n        self.type = \"core\"\n        self.name = CORE_FONTS[fontkey]\n        self.sp = 250  # strikethrough horizontal position\n        self.ss = 50  # strikethrough size (height)\n        self.up = -100  # underline horizontal position\n        self.ut = 50  # underline height\n        self.cw = CORE_FONTS_CHARWIDTHS[fontkey]\n        self.fontkey = fontkey\n        self.emphasis = TextEmphasis.coerce(style)\n\n    def get_text_width(\n        self, text: str, font_size_pt: float, _: Optional[dict[str, Any]]\n    ) -> tuple[int, float]:\n        return (len(text), sum(self.cw[c] for c in text) * font_size_pt * 0.001)\n\n    # Disabling this check - method kept as is to have same method/signature on CoreConf and TTFFont:\n    # pylint: disable=no-self-use\n    def encode_text(self, text: str) -> str:\n        return f\"({escape_parens(text)}) Tj\"\n\n    def __repr__(self) -> str:\n        return f\"CoreFont(i={self.i}, fontkey={self.fontkey})\"",
      "language": "python"
    },
    {
      "code": "class CoreFont:\n    # RAM usage optimization:\n    __slots__ = (\n        \"i\",\n        \"type\",\n        \"name\",\n        \"sp\",\n        \"ss\",\n        \"up\",\n        \"ut\",\n        \"cw\",\n        \"fontkey\",\n        \"emphasis\",\n    )\n\n    def __init__(self, i: int, fontkey: str, style: str) -> None:\n        self.i = i\n        self.type = \"core\"\n        self.name = CORE_FONTS[fontkey]\n        self.sp = 250  # strikethrough horizontal position\n        self.ss = 50  # strikethrough size (height)\n        self.up = -100  # underline horizontal position\n        self.ut = 50  # underline height\n        self.cw = CORE_FONTS_CHARWIDTHS[fontkey]\n        self.fontkey = fontkey\n        self.emphasis = TextEmphasis.coerce(style)\n\n    def get_text_width(\n        self, text: str, font_size_pt: float, _: Optional[dict[str, Any]]\n    ) -> tuple[int, float]:\n        return (len(text), sum(self.cw[c] for c in text) * font_size_pt * 0.001)\n\n    # Disabling this check - method kept as is to have same method/signature on CoreConf and TTFFont:\n    # pylint: disable=no-self-use\n    def encode_text(self, text: str) -> str:\n        return f\"({escape_parens(text)}) Tj\"\n\n    def __repr__(self) -> str:\n        return f\"CoreFont(i={self.i}, fontkey={self.fontkey})\"",
      "language": "python"
    },
    {
      "code": "class CoreFont:\n    # RAM usage optimization:\n    __slots__ = (\n        \"i\",\n        \"type\",\n        \"name\",\n        \"sp\",\n        \"ss\",\n        \"up\",\n        \"ut\",\n        \"cw\",\n        \"fontkey\",\n        \"emphasis\",\n    )\n\n    def __init__(self, i: int, fontkey: str, style: str) -> None:\n        self.i = i\n        self.type = \"core\"\n        self.name = CORE_FONTS[fontkey]\n        self.sp = 250  # strikethrough horizontal position\n        self.ss = 50  # strikethrough size (height)\n        self.up = -100  # underline horizontal position\n        self.ut = 50  # underline height\n        self.cw = CORE_FONTS_CHARWIDTHS[fontkey]\n        self.fontkey = fontkey\n        self.emphasis = TextEmphasis.coerce(style)\n\n    def get_text_width(\n        self, text: str, font_size_pt: float, _: Optional[dict[str, Any]]\n    ) -> tuple[int, float]:\n        return (len(text), sum(self.cw[c] for c in text) * font_size_pt * 0.001)\n\n    # Disabling this check - method kept as is to have same method/signature on CoreConf and TTFFont:\n    # pylint: disable=no-self-use\n    def encode_text(self, text: str) -> str:\n        return f\"({escape_parens(text)}) Tj\"\n\n    def __repr__(self) -> str:\n        return f\"CoreFont(i={self.i}, fontkey={self.fontkey})\"",
      "language": "python"
    },
    {
      "code": "def encode_text(self, text: str) -> str:\n    return f\"({escape_parens(text)}) Tj\"",
      "language": "python"
    },
    {
      "code": "def get_text_width(\n    self, text: str, font_size_pt: float, _: Optional[dict[str, Any]]\n) -> tuple[int, float]:\n    return (len(text), sum(self.cw[c] for c in text) * font_size_pt * 0.001)",
      "language": "python"
    },
    {
      "code": "@dataclass\nclass FontFace:\n    \"\"\"\n    Represent basic font styling properties.\n    This is a subset of `fpdf.graphics_state.GraphicsStateMixin` properties.\n    \"\"\"\n\n    __slots__ = (  # RAM usage optimization\n        \"family\",\n        \"emphasis\",\n        \"size_pt\",\n        \"color\",\n        \"fill_color\",\n    )\n    family: Optional[str]\n    emphasis: Optional[TextEmphasis]  # None means \"no override\"\n    #                                   Whereas \"\" means \"no emphasis\"\n    #                                   This can be a combination: B | U\n    size_pt: Optional[float]\n    # Colors are single number grey scales or (red, green, blue) tuples:\n    color: Optional[Union[DeviceGray, DeviceRGB, DeviceCMYK]]\n    fill_color: Optional[Union[DeviceGray, DeviceRGB, DeviceCMYK]]\n\n    def __init__(\n        self,\n        family: Optional[str] = None,\n        emphasis: Optional[TextEmphasis | str | int] = None,\n        size_pt: Optional[float] = None,\n        color: Optional[\n            DeviceRGB | DeviceGray | DeviceCMYK | str | float | Sequence[float]\n        ] = None,\n        fill_color: Optional[\n            DeviceRGB | DeviceGray | DeviceCMYK | str | float | Sequence[float]\n        ] = None,\n    ):\n        self.family = family\n        self.emphasis = None if emphasis is None else TextEmphasis.coerce(emphasis)\n        self.size_pt = size_pt\n        self.color = None if color is None else convert_to_device_color(color)\n        self.fill_color = (\n            None if fill_color is None else convert_to_device_color(fill_color)\n        )\n\n    replace = replace\n    \"\"\"\n    Create a new FontFace instance, with new values for some attributes.\n    Same as `dataclasses.replace()`\n    \"\"\"\n\n    @staticmethod\n    def _override(current_value: Any, override_value: Any) -> Any:\n        \"\"\"Override the current value if an override value is provided\"\"\"\n        return current_value if override_value is None else override_value\n\n    @staticmethod\n    def combine(\n        default_style: Optional[\"FontFace\"], override_style: Optional[\"FontFace\"]\n    ) -> Optional[\"FontFace\"]:\n        \"\"\"\n        Create a combined FontFace with all the supplied features of the two styles. When both\n        the default and override styles provide a feature, prefer the override style.\n        Override specified FontFace style features\n        Override this FontFace's values with the values of `other`.\n        Values of `other` that are None in this FontFace will be kept unchanged.\n        \"\"\"\n        if override_style is None:\n            return default_style\n        if default_style is None:\n            return override_style\n        if not isinstance(override_style, FontFace):\n            raise TypeError(f\"Cannot combine FontFace with {type(override_style)}\")\n        if not isinstance(default_style, FontFace):\n            raise TypeError(f\"Cannot combine FontFace with {type(default_style)}\")\n        return FontFace(\n            family=FontFace._override(default_style.family, override_style.family),\n            emphasis=FontFace._override(\n                default_style.emphasis,\n                override_style.emphasis,\n            ),\n            size_pt=FontFace._override(default_style.size_pt, override_style.size_pt),\n            color=FontFace._override(default_style.color, override_style.color),\n            fill_color=FontFace._override(\n                default_style.fill_color, override_style.fill_color\n            ),\n        )",
      "language": "python"
    },
    {
      "code": "@staticmethod\ndef combine(\n    default_style: Optional[\"FontFace\"], override_style: Optional[\"FontFace\"]\n) -> Optional[\"FontFace\"]:\n    \"\"\"\n    Create a combined FontFace with all the supplied features of the two styles. When both\n    the default and override styles provide a feature, prefer the override style.\n    Override specified FontFace style features\n    Override this FontFace's values with the values of `other`.\n    Values of `other` that are None in this FontFace will be kept unchanged.\n    \"\"\"\n    if override_style is None:\n        return default_style\n    if default_style is None:\n        return override_style\n    if not isinstance(override_style, FontFace):\n        raise TypeError(f\"Cannot combine FontFace with {type(override_style)}\")\n    if not isinstance(default_style, FontFace):\n        raise TypeError(f\"Cannot combine FontFace with {type(default_style)}\")\n    return FontFace(\n        family=FontFace._override(default_style.family, override_style.family),\n        emphasis=FontFace._override(\n            default_style.emphasis,\n            override_style.emphasis,\n        ),\n        size_pt=FontFace._override(default_style.size_pt, override_style.size_pt),\n        color=FontFace._override(default_style.color, override_style.color),\n        fill_color=FontFace._override(\n            default_style.fill_color, override_style.fill_color\n        ),\n    )",
      "language": "python"
    },
    {
      "code": "@dataclass\nclass FontFace:\n    \"\"\"\n    Represent basic font styling properties.\n    This is a subset of `fpdf.graphics_state.GraphicsStateMixin` properties.\n    \"\"\"\n\n    __slots__ = (  # RAM usage optimization\n        \"family\",\n        \"emphasis\",\n        \"size_pt\",\n        \"color\",\n        \"fill_color\",\n    )\n    family: Optional[str]\n    emphasis: Optional[TextEmphasis]  # None means \"no override\"\n    #                                   Whereas \"\" means \"no emphasis\"\n    #                                   This can be a combination: B | U\n    size_pt: Optional[float]\n    # Colors are single number grey scales or (red, green, blue) tuples:\n    color: Optional[Union[DeviceGray, DeviceRGB, DeviceCMYK]]\n    fill_color: Optional[Union[DeviceGray, DeviceRGB, DeviceCMYK]]\n\n    def __init__(\n        self,\n        family: Optional[str] = None,\n        emphasis: Optional[TextEmphasis | str | int] = None,\n        size_pt: Optional[float] = None,\n        color: Optional[\n            DeviceRGB | DeviceGray | DeviceCMYK | str | float | Sequence[float]\n        ] = None,\n        fill_color: Optional[\n            DeviceRGB | DeviceGray | DeviceCMYK | str | float | Sequence[float]\n        ] = None,\n    ):\n        self.family = family\n        self.emphasis = None if emphasis is None else TextEmphasis.coerce(emphasis)\n        self.size_pt = size_pt\n        self.color = None if color is None else convert_to_device_color(color)\n        self.fill_color = (\n            None if fill_color is None else convert_to_device_color(fill_color)\n        )\n\n    replace = replace\n    \"\"\"\n    Create a new FontFace instance, with new values for some attributes.\n    Same as `dataclasses.replace()`\n    \"\"\"\n\n    @staticmethod\n    def _override(current_value: Any, override_value: Any) -> Any:\n        \"\"\"Override the current value if an override value is provided\"\"\"\n        return current_value if override_value is None else override_value\n\n    @staticmethod\n    def combine(\n        default_style: Optional[\"FontFace\"], override_style: Optional[\"FontFace\"]\n    ) -> Optional[\"FontFace\"]:\n        \"\"\"\n        Create a combined FontFace with all the supplied features of the two styles. When both\n        the default and override styles provide a feature, prefer the override style.\n        Override specified FontFace style features\n        Override this FontFace's values with the values of `other`.\n        Values of `other` that are None in this FontFace will be kept unchanged.\n        \"\"\"\n        if override_style is None:\n            return default_style\n        if default_style is None:\n            return override_style\n        if not isinstance(override_style, FontFace):\n            raise TypeError(f\"Cannot combine FontFace with {type(override_style)}\")\n        if not isinstance(default_style, FontFace):\n            raise TypeError(f\"Cannot combine FontFace with {type(default_style)}\")\n        return FontFace(\n            family=FontFace._override(default_style.family, override_style.family),\n            emphasis=FontFace._override(\n                default_style.emphasis,\n                override_style.emphasis,\n            ),\n            size_pt=FontFace._override(default_style.size_pt, override_style.size_pt),\n            color=FontFace._override(default_style.color, override_style.color),\n            fill_color=FontFace._override(\n                default_style.fill_color, override_style.fill_color\n            ),\n        )",
      "language": "python"
    },
    {
      "code": "@dataclass\nclass FontFace:\n    \"\"\"\n    Represent basic font styling properties.\n    This is a subset of `fpdf.graphics_state.GraphicsStateMixin` properties.\n    \"\"\"\n\n    __slots__ = (  # RAM usage optimization\n        \"family\",\n        \"emphasis\",\n        \"size_pt\",\n        \"color\",\n        \"fill_color\",\n    )\n    family: Optional[str]\n    emphasis: Optional[TextEmphasis]  # None means \"no override\"\n    #                                   Whereas \"\" means \"no emphasis\"\n    #                                   This can be a combination: B | U\n    size_pt: Optional[float]\n    # Colors are single number grey scales or (red, green, blue) tuples:\n    color: Optional[Union[DeviceGray, DeviceRGB, DeviceCMYK]]\n    fill_color: Optional[Union[DeviceGray, DeviceRGB, DeviceCMYK]]\n\n    def __init__(\n        self,\n        family: Optional[str] = None,\n        emphasis: Optional[TextEmphasis | str | int] = None,\n        size_pt: Optional[float] = None,\n        color: Optional[\n            DeviceRGB | DeviceGray | DeviceCMYK | str | float | Sequence[float]\n        ] = None,\n        fill_color: Optional[\n            DeviceRGB | DeviceGray | DeviceCMYK | str | float | Sequence[float]\n        ] = None,\n    ):\n        self.family = family\n        self.emphasis = None if emphasis is None else TextEmphasis.coerce(emphasis)\n        self.size_pt = size_pt\n        self.color = None if color is None else convert_to_device_color(color)\n        self.fill_color = (\n            None if fill_color is None else convert_to_device_color(fill_color)\n        )\n\n    replace = replace\n    \"\"\"\n    Create a new FontFace instance, with new values for some attributes.\n    Same as `dataclasses.replace()`\n    \"\"\"\n\n    @staticmethod\n    def _override(current_value: Any, override_value: Any) -> Any:\n        \"\"\"Override the current value if an override value is provided\"\"\"\n        return current_value if override_value is None else override_value\n\n    @staticmethod\n    def combine(\n        default_style: Optional[\"FontFace\"], override_style: Optional[\"FontFace\"]\n    ) -> Optional[\"FontFace\"]:\n        \"\"\"\n        Create a combined FontFace with all the supplied features of the two styles. When both\n        the default and override styles provide a feature, prefer the override style.\n        Override specified FontFace style features\n        Override this FontFace's values with the values of `other`.\n        Values of `other` that are None in this FontFace will be kept unchanged.\n        \"\"\"\n        if override_style is None:\n            return default_style\n        if default_style is None:\n            return override_style\n        if not isinstance(override_style, FontFace):\n            raise TypeError(f\"Cannot combine FontFace with {type(override_style)}\")\n        if not isinstance(default_style, FontFace):\n            raise TypeError(f\"Cannot combine FontFace with {type(default_style)}\")\n        return FontFace(\n            family=FontFace._override(default_style.family, override_style.family),\n            emphasis=FontFace._override(\n                default_style.emphasis,\n                override_style.emphasis,\n            ),\n            size_pt=FontFace._override(default_style.size_pt, override_style.size_pt),\n            color=FontFace._override(default_style.color, override_style.color),\n            fill_color=FontFace._override(\n                default_style.fill_color, override_style.fill_color\n            ),\n        )",
      "language": "python"
    },
    {
      "code": "@dataclass\nclass FontFace:\n    \"\"\"\n    Represent basic font styling properties.\n    This is a subset of `fpdf.graphics_state.GraphicsStateMixin` properties.\n    \"\"\"\n\n    __slots__ = (  # RAM usage optimization\n        \"family\",\n        \"emphasis\",\n        \"size_pt\",\n        \"color\",\n        \"fill_color\",\n    )\n    family: Optional[str]\n    emphasis: Optional[TextEmphasis]  # None means \"no override\"\n    #                                   Whereas \"\" means \"no emphasis\"\n    #                                   This can be a combination: B | U\n    size_pt: Optional[float]\n    # Colors are single number grey scales or (red, green, blue) tuples:\n    color: Optional[Union[DeviceGray, DeviceRGB, DeviceCMYK]]\n    fill_color: Optional[Union[DeviceGray, DeviceRGB, DeviceCMYK]]\n\n    def __init__(\n        self,\n        family: Optional[str] = None,\n        emphasis: Optional[TextEmphasis | str | int] = None,\n        size_pt: Optional[float] = None,\n        color: Optional[\n            DeviceRGB | DeviceGray | DeviceCMYK | str | float | Sequence[float]\n        ] = None,\n        fill_color: Optional[\n            DeviceRGB | DeviceGray | DeviceCMYK | str | float | Sequence[float]\n        ] = None,\n    ):\n        self.family = family\n        self.emphasis = None if emphasis is None else TextEmphasis.coerce(emphasis)\n        self.size_pt = size_pt\n        self.color = None if color is None else convert_to_device_color(color)\n        self.fill_color = (\n            None if fill_color is None else convert_to_device_color(fill_color)\n        )\n\n    replace = replace\n    \"\"\"\n    Create a new FontFace instance, with new values for some attributes.\n    Same as `dataclasses.replace()`\n    \"\"\"\n\n    @staticmethod\n    def _override(current_value: Any, override_value: Any) -> Any:\n        \"\"\"Override the current value if an override value is provided\"\"\"\n        return current_value if override_value is None else override_value\n\n    @staticmethod\n    def combine(\n        default_style: Optional[\"FontFace\"], override_style: Optional[\"FontFace\"]\n    ) -> Optional[\"FontFace\"]:\n        \"\"\"\n        Create a combined FontFace with all the supplied features of the two styles. When both\n        the default and override styles provide a feature, prefer the override style.\n        Override specified FontFace style features\n        Override this FontFace's values with the values of `other`.\n        Values of `other` that are None in this FontFace will be kept unchanged.\n        \"\"\"\n        if override_style is None:\n            return default_style\n        if default_style is None:\n            return override_style\n        if not isinstance(override_style, FontFace):\n            raise TypeError(f\"Cannot combine FontFace with {type(override_style)}\")\n        if not isinstance(default_style, FontFace):\n            raise TypeError(f\"Cannot combine FontFace with {type(default_style)}\")\n        return FontFace(\n            family=FontFace._override(default_style.family, override_style.family),\n            emphasis=FontFace._override(\n                default_style.emphasis,\n                override_style.emphasis,\n            ),\n            size_pt=FontFace._override(default_style.size_pt, override_style.size_pt),\n            color=FontFace._override(default_style.color, override_style.color),\n            fill_color=FontFace._override(\n                default_style.fill_color, override_style.fill_color\n            ),\n        )",
      "language": "python"
    },
    {
      "code": "@dataclass\nclass FontFace:\n    \"\"\"\n    Represent basic font styling properties.\n    This is a subset of `fpdf.graphics_state.GraphicsStateMixin` properties.\n    \"\"\"\n\n    __slots__ = (  # RAM usage optimization\n        \"family\",\n        \"emphasis\",\n        \"size_pt\",\n        \"color\",\n        \"fill_color\",\n    )\n    family: Optional[str]\n    emphasis: Optional[TextEmphasis]  # None means \"no override\"\n    #                                   Whereas \"\" means \"no emphasis\"\n    #                                   This can be a combination: B | U\n    size_pt: Optional[float]\n    # Colors are single number grey scales or (red, green, blue) tuples:\n    color: Optional[Union[DeviceGray, DeviceRGB, DeviceCMYK]]\n    fill_color: Optional[Union[DeviceGray, DeviceRGB, DeviceCMYK]]\n\n    def __init__(\n        self,\n        family: Optional[str] = None,\n        emphasis: Optional[TextEmphasis | str | int] = None,\n        size_pt: Optional[float] = None,\n        color: Optional[\n            DeviceRGB | DeviceGray | DeviceCMYK | str | float | Sequence[float]\n        ] = None,\n        fill_color: Optional[\n            DeviceRGB | DeviceGray | DeviceCMYK | str | float | Sequence[float]\n        ] = None,\n    ):\n        self.family = family\n        self.emphasis = None if emphasis is None else TextEmphasis.coerce(emphasis)\n        self.size_pt = size_pt\n        self.color = None if color is None else convert_to_device_color(color)\n        self.fill_color = (\n            None if fill_color is None else convert_to_device_color(fill_color)\n        )\n\n    replace = replace\n    \"\"\"\n    Create a new FontFace instance, with new values for some attributes.\n    Same as `dataclasses.replace()`\n    \"\"\"\n\n    @staticmethod\n    def _override(current_value: Any, override_value: Any) -> Any:\n        \"\"\"Override the current value if an override value is provided\"\"\"\n        return current_value if override_value is None else override_value\n\n    @staticmethod\n    def combine(\n        default_style: Optional[\"FontFace\"], override_style: Optional[\"FontFace\"]\n    ) -> Optional[\"FontFace\"]:\n        \"\"\"\n        Create a combined FontFace with all the supplied features of the two styles. When both\n        the default and override styles provide a feature, prefer the override style.\n        Override specified FontFace style features\n        Override this FontFace's values with the values of `other`.\n        Values of `other` that are None in this FontFace will be kept unchanged.\n        \"\"\"\n        if override_style is None:\n            return default_style\n        if default_style is None:\n            return override_style\n        if not isinstance(override_style, FontFace):\n            raise TypeError(f\"Cannot combine FontFace with {type(override_style)}\")\n        if not isinstance(default_style, FontFace):\n            raise TypeError(f\"Cannot combine FontFace with {type(default_style)}\")\n        return FontFace(\n            family=FontFace._override(default_style.family, override_style.family),\n            emphasis=FontFace._override(\n                default_style.emphasis,\n                override_style.emphasis,\n            ),\n            size_pt=FontFace._override(default_style.size_pt, override_style.size_pt),\n            color=FontFace._override(default_style.color, override_style.color),\n            fill_color=FontFace._override(\n                default_style.fill_color, override_style.fill_color\n            ),\n        )",
      "language": "python"
    },
    {
      "code": "@dataclass\nclass FontFace:\n    \"\"\"\n    Represent basic font styling properties.\n    This is a subset of `fpdf.graphics_state.GraphicsStateMixin` properties.\n    \"\"\"\n\n    __slots__ = (  # RAM usage optimization\n        \"family\",\n        \"emphasis\",\n        \"size_pt\",\n        \"color\",\n        \"fill_color\",\n    )\n    family: Optional[str]\n    emphasis: Optional[TextEmphasis]  # None means \"no override\"\n    #                                   Whereas \"\" means \"no emphasis\"\n    #                                   This can be a combination: B | U\n    size_pt: Optional[float]\n    # Colors are single number grey scales or (red, green, blue) tuples:\n    color: Optional[Union[DeviceGray, DeviceRGB, DeviceCMYK]]\n    fill_color: Optional[Union[DeviceGray, DeviceRGB, DeviceCMYK]]\n\n    def __init__(\n        self,\n        family: Optional[str] = None,\n        emphasis: Optional[TextEmphasis | str | int] = None,\n        size_pt: Optional[float] = None,\n        color: Optional[\n            DeviceRGB | DeviceGray | DeviceCMYK | str | float | Sequence[float]\n        ] = None,\n        fill_color: Optional[\n            DeviceRGB | DeviceGray | DeviceCMYK | str | float | Sequence[float]\n        ] = None,\n    ):\n        self.family = family\n        self.emphasis = None if emphasis is None else TextEmphasis.coerce(emphasis)\n        self.size_pt = size_pt\n        self.color = None if color is None else convert_to_device_color(color)\n        self.fill_color = (\n            None if fill_color is None else convert_to_device_color(fill_color)\n        )\n\n    replace = replace\n    \"\"\"\n    Create a new FontFace instance, with new values for some attributes.\n    Same as `dataclasses.replace()`\n    \"\"\"\n\n    @staticmethod\n    def _override(current_value: Any, override_value: Any) -> Any:\n        \"\"\"Override the current value if an override value is provided\"\"\"\n        return current_value if override_value is None else override_value\n\n    @staticmethod\n    def combine(\n        default_style: Optional[\"FontFace\"], override_style: Optional[\"FontFace\"]\n    ) -> Optional[\"FontFace\"]:\n        \"\"\"\n        Create a combined FontFace with all the supplied features of the two styles. When both\n        the default and override styles provide a feature, prefer the override style.\n        Override specified FontFace style features\n        Override this FontFace's values with the values of `other`.\n        Values of `other` that are None in this FontFace will be kept unchanged.\n        \"\"\"\n        if override_style is None:\n            return default_style\n        if default_style is None:\n            return override_style\n        if not isinstance(override_style, FontFace):\n            raise TypeError(f\"Cannot combine FontFace with {type(override_style)}\")\n        if not isinstance(default_style, FontFace):\n            raise TypeError(f\"Cannot combine FontFace with {type(default_style)}\")\n        return FontFace(\n            family=FontFace._override(default_style.family, override_style.family),\n            emphasis=FontFace._override(\n                default_style.emphasis,\n                override_style.emphasis,\n            ),\n            size_pt=FontFace._override(default_style.size_pt, override_style.size_pt),\n            color=FontFace._override(default_style.color, override_style.color),\n            fill_color=FontFace._override(\n                default_style.fill_color, override_style.fill_color\n            ),\n        )",
      "language": "python"
    },
    {
      "code": "def replace(obj, /, **changes):\n    \"\"\"Return a new object replacing specified fields with new values.\n\n    This is especially useful for frozen classes.  Example usage::\n\n      @dataclass(frozen=True)\n      class C:\n          x: int\n          y: int\n\n      c = C(1, 2)\n      c1 = replace(c, x=3)\n      assert c1.x == 3 and c1.y == 2\n    \"\"\"\n    if not _is_dataclass_instance(obj):\n        raise TypeError(\"replace() should be called on dataclass instances\")\n    return _replace(obj, **changes)",
      "language": "python"
    },
    {
      "code": "@dataclass(order=True)\nclass Glyph:\n    \"\"\"\n    This represents one glyph on the font\n    Unicode is a tuple because ligatures or character substitution\n    can map a sequence of unicode characters to a single glyph\n    \"\"\"\n\n    # RAM usage optimization:\n    __slots__ = (\"glyph_id\", \"unicode\", \"glyph_name\", \"glyph_width\")\n    glyph_id: int\n    unicode: int | tuple[int, ...]\n    glyph_name: str\n    glyph_width: int\n\n    def __hash__(self) -> int:\n        return self.glyph_id",
      "language": "python"
    },
    {
      "code": "@dataclass(order=True)\nclass Glyph:\n    \"\"\"\n    This represents one glyph on the font\n    Unicode is a tuple because ligatures or character substitution\n    can map a sequence of unicode characters to a single glyph\n    \"\"\"\n\n    # RAM usage optimization:\n    __slots__ = (\"glyph_id\", \"unicode\", \"glyph_name\", \"glyph_width\")\n    glyph_id: int\n    unicode: int | tuple[int, ...]\n    glyph_name: str\n    glyph_width: int\n\n    def __hash__(self) -> int:\n        return self.glyph_id",
      "language": "python"
    },
    {
      "code": "@dataclass(order=True)\nclass Glyph:\n    \"\"\"\n    This represents one glyph on the font\n    Unicode is a tuple because ligatures or character substitution\n    can map a sequence of unicode characters to a single glyph\n    \"\"\"\n\n    # RAM usage optimization:\n    __slots__ = (\"glyph_id\", \"unicode\", \"glyph_name\", \"glyph_width\")\n    glyph_id: int\n    unicode: int | tuple[int, ...]\n    glyph_name: str\n    glyph_width: int\n\n    def __hash__(self) -> int:\n        return self.glyph_id",
      "language": "python"
    },
    {
      "code": "@dataclass(order=True)\nclass Glyph:\n    \"\"\"\n    This represents one glyph on the font\n    Unicode is a tuple because ligatures or character substitution\n    can map a sequence of unicode characters to a single glyph\n    \"\"\"\n\n    # RAM usage optimization:\n    __slots__ = (\"glyph_id\", \"unicode\", \"glyph_name\", \"glyph_width\")\n    glyph_id: int\n    unicode: int | tuple[int, ...]\n    glyph_name: str\n    glyph_width: int\n\n    def __hash__(self) -> int:\n        return self.glyph_id",
      "language": "python"
    },
    {
      "code": "@dataclass(order=True)\nclass Glyph:\n    \"\"\"\n    This represents one glyph on the font\n    Unicode is a tuple because ligatures or character substitution\n    can map a sequence of unicode characters to a single glyph\n    \"\"\"\n\n    # RAM usage optimization:\n    __slots__ = (\"glyph_id\", \"unicode\", \"glyph_name\", \"glyph_width\")\n    glyph_id: int\n    unicode: int | tuple[int, ...]\n    glyph_name: str\n    glyph_width: int\n\n    def __hash__(self) -> int:\n        return self.glyph_id",
      "language": "python"
    },
    {
      "code": "class PDFFontDescriptor(PDFObject):\n    def __init__(\n        self,\n        ascent: float,\n        descent: float,\n        cap_height: float,\n        flags: FontDescriptorFlags,\n        font_b_box: str,\n        italic_angle: int,\n        stem_v: float,\n        missing_width: float,\n    ):\n        super().__init__()\n        self.type = Name(\"FontDescriptor\")\n        self.ascent = ascent\n        self.descent = descent\n        self.cap_height = cap_height\n        self.flags = flags\n        self.font_b_box = font_b_box\n        self.italic_angle = italic_angle\n        self.stem_v = stem_v\n        self.missing_width = missing_width\n        self.font_name: Optional[str] = None",
      "language": "python"
    },
    {
      "code": "class SubsetMap:\n    \"\"\"\n    Holds a mapping of used characters and their position in the font's subset\n\n    Characters that must be mapped on their actual unicode must be part of the\n    `identities` list during object instantiation. These non-negative values should\n    only appear once in the list. `pick()` can be used to get the characters\n    corresponding position in the subset. If it's not yet part of the object, a new\n    position is acquired automatically. This implementation always tries to return\n    the lowest possible representation.\n    \"\"\"\n\n    def __init__(self, font: TTFFont) -> None:\n        super().__init__()\n        self.font = font\n        self._next: int = 0\n\n        # 0x00 \".notdef\" and 0x20 \"space\" are reserved\n        self._reserved = [0x00, 0x20]\n\n        # Maps Glyph instances to character IDs (integers):\n        self._char_id_per_glyph: dict[Optional[Glyph], int] = {}\n        for x in self._reserved:\n            glyph = self.get_glyph(unicode=x)\n            if glyph:\n                self._char_id_per_glyph[glyph] = int(x)\n\n    def __repr__(self) -> str:\n        return (\n            f\"SubsetMap(font={self.font}, _next={self._next},\"\n            f\" _reserved={self._reserved}, _char_id_per_glyph={self._char_id_per_glyph})\"\n        )\n\n    def __len__(self) -> int:\n        return len(self._char_id_per_glyph)\n\n    def items(self) -> Iterator[tuple[Optional[Glyph], int]]:\n        for glyph, char_id in self._char_id_per_glyph.items():\n            yield glyph, char_id\n\n    # pylint: disable=method-cache-max-size-none\n    @cache\n    def pick(self, unicode: int) -> Optional[int]:\n        glyph = self.get_glyph(unicode=unicode)\n        if glyph is None and unicode not in self.font.missing_glyphs:\n            self.font.missing_glyphs.append(unicode)\n        return self.pick_glyph(glyph)\n\n    def pick_glyph(self, glyph: Optional[Glyph]) -> Optional[int]:\n        char_id = self._char_id_per_glyph.get(glyph, None)\n        if glyph is not None and char_id is None:\n            while self._next in self._reserved:\n                self._next += 1\n                if self._next > self._reserved[0]:\n                    del self._reserved[0]\n            char_id = self._next\n            self._char_id_per_glyph[glyph] = char_id\n            self._next += 1\n        return char_id\n\n    # pylint: disable=method-cache-max-size-none\n    @cache\n    def get_glyph(\n        self,\n        glyph: Optional[int] = None,\n        unicode: Optional[int | tuple[int, ...]] = None,\n        glyph_name: Optional[str] = None,\n        glyph_width: Optional[int] = None,\n    ) -> Optional[Glyph]:\n        if (\n            glyph\n            and unicode is not None\n            and glyph_name is not None\n            and glyph_width is not None\n        ):\n            return Glyph(glyph, unicode, glyph_name, glyph_width)\n        if unicode is None or not isinstance(unicode, int):\n            return None\n        glyph_id = self.font.glyph_ids.get(unicode)\n        if isinstance(unicode, int) and glyph_id is not None:\n            return Glyph(\n                glyph_id,\n                (unicode,),\n                self.font.cmap[unicode],\n                int(self.font.cw[unicode]),\n            )\n        if unicode == 0x00:\n            glyph_id = next(iter(self.font.cmap))\n            return Glyph(glyph_id, (0x00,), \".notdef\", 0)\n        if unicode == 0x20:\n            glyph_id = next(iter(self.font.cmap))\n            return Glyph(glyph_id, (0x20,), \"space\", int(self.font.cw[0x20]))\n        return None\n\n    def get_all_glyph_names(self) -> Sequence[str]:\n        return [\n            glyph.glyph_name for glyph in self._char_id_per_glyph if glyph is not None\n        ]",
      "language": "python"
    },
    {
      "code": "def get_all_glyph_names(self) -> Sequence[str]:\n    return [\n        glyph.glyph_name for glyph in self._char_id_per_glyph if glyph is not None\n    ]",
      "language": "python"
    },
    {
      "code": "@cache\ndef get_glyph(\n    self,\n    glyph: Optional[int] = None,\n    unicode: Optional[int | tuple[int, ...]] = None,\n    glyph_name: Optional[str] = None,\n    glyph_width: Optional[int] = None,\n) -> Optional[Glyph]:\n    if (\n        glyph\n        and unicode is not None\n        and glyph_name is not None\n        and glyph_width is not None\n    ):\n        return Glyph(glyph, unicode, glyph_name, glyph_width)\n    if unicode is None or not isinstance(unicode, int):\n        return None\n    glyph_id = self.font.glyph_ids.get(unicode)\n    if isinstance(unicode, int) and glyph_id is not None:\n        return Glyph(\n            glyph_id,\n            (unicode,),\n            self.font.cmap[unicode],\n            int(self.font.cw[unicode]),\n        )\n    if unicode == 0x00:\n        glyph_id = next(iter(self.font.cmap))\n        return Glyph(glyph_id, (0x00,), \".notdef\", 0)\n    if unicode == 0x20:\n        glyph_id = next(iter(self.font.cmap))\n        return Glyph(glyph_id, (0x20,), \"space\", int(self.font.cw[0x20]))\n    return None",
      "language": "python"
    },
    {
      "code": "def items(self) -> Iterator[tuple[Optional[Glyph], int]]:\n    for glyph, char_id in self._char_id_per_glyph.items():\n        yield glyph, char_id",
      "language": "python"
    },
    {
      "code": "@cache\ndef pick(self, unicode: int) -> Optional[int]:\n    glyph = self.get_glyph(unicode=unicode)\n    if glyph is None and unicode not in self.font.missing_glyphs:\n        self.font.missing_glyphs.append(unicode)\n    return self.pick_glyph(glyph)",
      "language": "python"
    },
    {
      "code": "def pick_glyph(self, glyph: Optional[Glyph]) -> Optional[int]:\n    char_id = self._char_id_per_glyph.get(glyph, None)\n    if glyph is not None and char_id is None:\n        while self._next in self._reserved:\n            self._next += 1\n            if self._next > self._reserved[0]:\n                del self._reserved[0]\n        char_id = self._next\n        self._char_id_per_glyph[glyph] = char_id\n        self._next += 1\n    return char_id",
      "language": "python"
    },
    {
      "code": "class TTFFont:\n    __slots__ = (  # RAM usage optimization\n        \"i\",\n        \"type\",\n        \"name\",\n        \"desc\",\n        \"glyph_ids\",\n        \"_hbfont\",\n        \"sp\",\n        \"ss\",\n        \"up\",\n        \"ut\",\n        \"cw\",\n        \"ttffile\",\n        \"fontkey\",\n        \"emphasis\",\n        \"scale\",\n        \"subset\",\n        \"cmap\",\n        \"ttfont\",\n        \"missing_glyphs\",\n        \"biggest_size_pt\",\n        \"color_font\",\n        \"unicode_range\",\n        \"palette_index\",\n        \"is_compressed\",\n    )\n\n    def __init__(\n        self,\n        fpdf: \"FPDF\",\n        font_file_path: Path,\n        fontkey: str,\n        style: str,\n        unicode_range: Optional[set[int]] = None,\n        axes_dict: Optional[dict[str, float]] = None,\n        palette_index: Optional[int] = None,\n    ):\n        self.i = len(fpdf.fonts) + 1\n        self.type = \"TTF\"\n        self.ttffile = font_file_path\n        self.is_compressed = str(self.ttffile).lower().endswith((\".woff\", \".woff2\"))\n        self._hbfont: Optional[\"HarfBuzzFont\"] = None\n        self.fontkey = fontkey\n        self.biggest_size_pt: float = 0\n\n        # recalcTimestamp=False means that it doesn't modify the \"modified\" timestamp in head table\n        # if we leave recalcTimestamp=True the tests will break every time\n        try:\n            self.ttfont = ttLib.TTFont(\n                self.ttffile, recalcTimestamp=False, fontNumber=0, lazy=True\n            )\n        except (\n            ImportError,\n            RuntimeError,\n        ) as exc:  # pragma: no cover - defensive messaging\n            # If the user passed a WOFF2 file but brotli is not installed, fontTools\n            # raises an ImportError/RuntimeError during parsing. Provide a clearer hint\n            # only for that specific situation. Allow other exceptions (e.g. FileNotFoundError,\n            # OSError, parsing errors) to propagate normally so they aren't masked here.\n            fname_str = str(self.ttffile).lower()\n            if fname_str.endswith(\".woff2\"):\n                raise RuntimeError(\n                    \"Could not open WOFF2 font. WOFF2 support requires an external Brotli \"\n                    \"library (install 'brotli' or 'brotlicffi'). Original error: \"\n                    f\"{exc!s}\"\n                ) from exc\n            raise\n\n        if axes_dict is not None:\n            if \"fvar\" not in self.ttfont:\n                raise AttributeError(f\"{self.ttffile} is not a variable font\")\n\n            instancer.instantiateVariableFont(\n                self.ttfont,\n                axes_dict,\n                inplace=True,\n                static=True,\n            )\n        if self.is_compressed:\n            # Normalize to SFNT output for embedding and HarfBuzz.\n            self.ttfont.flavor = None\n        upem: float = float(self.ttfont[\"head\"].unitsPerEm)\n        self.scale: float = 1000 / upem\n\n        # check if the font is a TrueType and missing a .notdef glyph\n        # if it is missing, provide a fallback glyph\n        if (\n            \"glyf\" in self.ttfont\n            and \".notdef\"\n            not in self.ttfont[\"glyf\"]  # pyright: ignore[reportOperatorIssue]\n        ):\n            LOGGER.warning(\n                (\n                    \"TrueType Font '%s' is missing the '.notdef' glyph. \"\n                    \"Fallback glyph will be provided.\"\n                ),\n                self.fontkey,\n            )\n            # draw a diagonal cross .notdef glyph\n            xMin, xMax, yMin, yMax = (\n                self.ttfont[\"head\"].xMin,\n                self.ttfont[\"head\"].xMax,\n                self.ttfont[\"head\"].yMin,\n                self.ttfont[\"head\"].yMax,\n            )\n            pen = TTGlyphPen(self.ttfont[\"glyf\"])  # pyright: ignore[reportArgumentType]\n            pen.moveTo((xMin, yMin))\n            pen.lineTo((xMax, yMin))\n            pen.lineTo((xMax, yMax))\n            pen.lineTo((xMin, yMax))\n            pen.closePath()\n            pen.moveTo((xMin, yMin))\n            pen.lineTo((xMax, yMax))\n            pen.closePath()\n            pen.moveTo((xMax, yMin))\n            pen.lineTo((xMin, yMax))\n            pen.closePath()\n\n            self.ttfont[\"glyf\"][  # pyright: ignore[reportIndexIssue]\n                \".notdef\"\n            ] = pen.glyph()\n            self.ttfont[\"hmtx\"][\".notdef\"] = (  # pyright: ignore[reportIndexIssue]\n                xMax - xMin,\n                yMax - yMin,\n            )\n\n        default_width: float = round(\n            self.scale * self.ttfont[\"hmtx\"].metrics[\".notdef\"][0]\n        )\n\n        os2_table = self.ttfont[\"OS/2\"]\n        post_table = self.ttfont[\"post\"]\n\n        try:\n            cap_height = os2_table.sCapHeight\n        except AttributeError:\n            cap_height = self.ttfont[\"hhea\"].ascent\n\n        # entry for the PDF font descriptor specifying various characteristics of the font\n        flags = FontDescriptorFlags.SYMBOLIC\n        if post_table.isFixedPitch:\n            flags |= FontDescriptorFlags.FIXED_PITCH\n        if post_table.italicAngle != 0:\n            flags |= FontDescriptorFlags.ITALIC\n        if os2_table.usWeightClass >= 600:\n            flags |= FontDescriptorFlags.FORCE_BOLD\n\n        self.desc = PDFFontDescriptor(\n            ascent=round(self.ttfont[\"hhea\"].ascent * self.scale),\n            descent=round(self.ttfont[\"hhea\"].descent * self.scale),\n            cap_height=round(cap_height * self.scale),\n            flags=flags,\n            font_b_box=(\n                f\"[{self.ttfont['head'].xMin * self.scale:.0f} {self.ttfont['head'].yMin * self.scale:.0f}\"\n                f\" {self.ttfont['head'].xMax * self.scale:.0f} {self.ttfont['head'].yMax * self.scale:.0f}]\"\n            ),\n            italic_angle=int(post_table.italicAngle),\n            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),\n            missing_width=default_width,\n        )\n\n        # a map unicode_char -> char_width\n        self.cw: dict[int, float] = defaultdict(lambda: default_width)\n\n        # fonttools cmap = unicode char to glyph name\n        # saving only the keys we have a tuple with\n        # the unicode characters available on the font\n        self.cmap: dict[int, str] = self.ttfont.getBestCmap()\n        if not self.cmap:\n            raise NotImplementedError(\n                \"Font not supported as it does not have a unicode cmap table - cf. issue #1396\"\n            )\n\n        if unicode_range is not None and len(unicode_range) != 0:\n            self.cmap = {\n                codepoint: glyph_id\n                for codepoint, glyph_id in self.cmap.items()  # pyright: ignore[reportUnknownVariableType]\n                if codepoint in unicode_range\n            }\n\n        # saving a list of glyph ids to char to allow\n        # subset by unicode (regular) and by glyph\n        # (shaped with harfbuz)\n        self.glyph_ids = {}\n\n        for char in self.cmap:  # pyright: ignore[]\n            # take glyph associated to char\n            glyph = self.cmap[char]\n\n            # take width associated to glyph\n            w = self.ttfont[\"hmtx\"].metrics[glyph][0]\n\n            # probably this check could be deleted\n            if w == 65535:\n                w = 0\n\n            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP\n\n            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)\n\n        self.missing_glyphs: list[int] = []\n\n        self.name = re.sub(\"[ ()]\", \"\", self.ttfont[\"name\"].getBestFullName())\n        self.up = round(post_table.underlinePosition * self.scale)\n        self.ut = round(post_table.underlineThickness * self.scale)\n        self.sp = round(os2_table.yStrikeoutPosition * self.scale)\n        self.ss = round(os2_table.yStrikeoutSize * self.scale)\n        self.emphasis = TextEmphasis.coerce(style)\n        self.subset = SubsetMap(self)\n        self.palette_index = palette_index if palette_index is not None else 0\n        self.color_font = (\n            get_color_font_object(fpdf, self, self.palette_index)\n            if fpdf.render_color_fonts\n            else None\n        )\n\n    # pylint: disable=no-member\n    @property\n    def hbfont(self) -> \"HarfBuzzFont\":\n        if not self._hbfont:\n            if self.is_compressed:\n                # HarfBuzz cannot load compressed WOFF/WOFF2 files directly, so we\n                # re-serialize the fontTools TTFont to a raw SFNT byte buffer.\n                buf = BytesIO()\n                self.ttfont.save(buf)\n                buf.seek(0)\n                ttfont_bytes = buf.read()\n\n                # Try to create a HarfBuzz blob from bytes; if not available, write a\n                # temporary file as a last resort.\n                try:\n                    blob = hb.Blob.from_bytes(ttfont_bytes)\n                    face = hb.Face(blob)\n                except (AttributeError, RuntimeError):\n                    import tempfile, os  # pylint: disable=import-outside-toplevel\n\n                    tmp_name = None\n                    try:\n                        with tempfile.NamedTemporaryFile(\n                            suffix=\".ttf\", delete=False\n                        ) as tmp:\n                            tmp_name = tmp.name\n                            tmp.write(ttfont_bytes)\n                            tmp.flush()\n                        face = hb.Face(hb.Blob.from_file_path(tmp_name))\n                    finally:\n                        if tmp_name:\n                            try:\n                                os.unlink(tmp_name)\n                            except OSError as cleanup_error:\n                                # Log warning about failed cleanup - orphaned temp file may cause disk issues\n                                LOGGER.warning(\n                                    \"Failed to clean up temporary font file '%s': %s. This may leave an orphaned file on disk.\",\n                                    tmp_name,\n                                    cleanup_error,\n                                )\n\n                self._hbfont = HarfBuzzFont(face)\n            else:\n                # For regular TTF/OTF fonts, load directly from file path (faster)\n                self._hbfont = HarfBuzzFont(\n                    hb.Face(hb.Blob.from_file_path(self.ttffile))\n                )\n\n        return self._hbfont\n\n    def __repr__(self) -> str:\n        return f\"TTFFont(i={self.i}, fontkey={self.fontkey})\"\n\n    def __deepcopy__(self: \"TTFFont\", memo: dict[int, Any]) -> \"TTFFont\":\n        \"\"\"\n        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes\n        but instead share references to immutable objects\n        between the original FPDF instance and the FPDFRecorder instances\n        to avoid performances issues as spotted in issue #1444.\n        \"\"\"\n        copy = TTFFont.__new__(TTFFont)\n        # Immutable attributes:\n        copy.i = self.i\n        copy.type = \"TTF\"\n        copy.ttffile = self.ttffile\n        copy.fontkey = self.fontkey\n        copy.scale = self.scale\n        copy.name = self.name\n        copy.up = self.up\n        copy.ut = self.ut\n        copy.sp = self.sp\n        copy.ss = self.ss\n        copy.emphasis = self.emphasis\n        copy.is_compressed = self.is_compressed\n        # Attributes shared, to improve FPDFRecorder performances:\n        copy.ttfont = self.ttfont\n        copy.cmap = self.cmap\n        copy.desc = self.desc\n        # Attributes deepcopied:\n        copy.cw = deepcopy(self.cw, memo)\n        copy.glyph_ids = deepcopy(self.glyph_ids, memo)\n        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)\n        copy.subset = deepcopy(self.subset, memo)\n        copy.biggest_size_pt = self.biggest_size_pt\n        copy._hbfont = self._hbfont\n        copy.color_font = self.color_font\n        copy.palette_index = self.palette_index\n        return copy\n\n    def close(self) -> None:\n        self.ttfont.close()\n        self._hbfont = None\n\n    def escape_text(self, text: str) -> str:\n        if self.color_font:\n            encoded = text.encode(\"latin-1\", errors=\"replace\")\n            return escape_parens(encoded.decode(\"latin-1\", errors=\"ignore\"))\n        return escape_parens(text.encode(\"utf-16-be\").decode(\"latin-1\"))\n\n    def get_text_width(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[int, float]:\n        if font_size_pt > self.biggest_size_pt:\n            self.biggest_size_pt = font_size_pt\n        if text_shaping_params:\n            return self.shaped_text_width(text, font_size_pt, text_shaping_params)\n        return (len(text), sum(self.cw[ord(c)] for c in text) * font_size_pt * 0.001)\n\n    def shaped_text_width(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[int, float]:\n        \"\"\"\n        When texts are shaped, the length of a string is not always the sum of all individual character widths\n        This method will invoke harfbuzz to perform the text shaping and return the sum of \"x_advance\"\n        and \"x_offset\" for each glyph. This method works for \"left to right\" or \"right to left\" texts.\n        \"\"\"\n        _, glyph_positions = self.perform_harfbuzz_shaping(\n            text, font_size_pt, text_shaping_params\n        )\n\n        # If there is nothing to render (harfbuzz returns None), we return 0 text width\n        if glyph_positions is None:\n            return (0, 0)\n\n        text_width: float = 0\n        for pos in glyph_positions:\n            text_width += (\n                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001\n            )\n        return (len(glyph_positions), text_width)\n\n    # Disabling this check - looks like cython confuses pylint:\n    # pylint: disable=no-member\n    def perform_harfbuzz_shaping(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[Sequence[\"HBGlyphInfo\"], Sequence[\"HBGlyphPosition\"]]:\n        \"\"\"\n        This method invokes Harfbuzz to perform text shaping of the input string\n        \"\"\"\n        self.hbfont.ptem = font_size_pt\n        if TYPE_CHECKING:\n            buf: HBBuffer\n        buf = hb.Buffer()\n        buf.cluster_level = 1\n        buf.add_str(\"\".join(text))\n        buf.guess_segment_properties()\n        features = (\n            text_shaping_params[\"features\"] if text_shaping_params is not None else {}\n        )\n        if text_shaping_params is None:\n            text_shaping_params = {}\n        if (\n            \"fragment_direction\" in text_shaping_params\n            and text_shaping_params[\"fragment_direction\"] is not None\n        ):\n            buf.direction = text_shaping_params[\"fragment_direction\"].value\n        if (\n            \"script\" in text_shaping_params\n            and text_shaping_params[\"script\"] is not None\n        ):\n            buf.script = text_shaping_params[\"script\"]\n        if (\n            \"language\" in text_shaping_params\n            and text_shaping_params[\"language\"] is not None\n        ):\n            buf.language = text_shaping_params[\"language\"]\n        hb.shape(self.hbfont, buf, features)\n        return buf.glyph_infos, buf.glyph_positions\n\n    def encode_text(self, text: str) -> str:\n        txt_mapped = \"\"\n        for char in text:\n            uni = ord(char)\n            # Instead of adding the actual character to the stream its code is\n            # mapped to a position in the font's subset\n            mapped_char: Optional[int] = self.subset.pick(uni)\n            if mapped_char is not None:\n                txt_mapped += chr(mapped_char)\n        return f\"({self.escape_text(txt_mapped)}) Tj\"\n\n    def shape_text(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> Sequence[dict[str, Any]]:\n        \"\"\"\n        This method will invoke harfbuzz for text shaping, include the mapping code\n        of the glyphs on the subset and map input characters to the cluster codes\n        \"\"\"\n        if len(text) == 0:\n            return []\n        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(\n            text, font_size_pt, text_shaping_params\n        )\n        text_info = []\n\n        # Find cluster gaps\n        # Ex: text = \"ABCD\"\n        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph\n        # (ligature or substitution) - the glyph should have both unicodes and it should be translated\n        # properly on the CID to GID mapping\n        #\n        def get_cluster_from_text_index(cluster_list: Sequence[int], index: int) -> int:\n            pos = bisect_left(cluster_list, index)\n            if pos == 0:\n                return cluster_list[0]\n            if pos == len(cluster_list) or cluster_list[pos] != index:\n                return cluster_list[pos - 1]\n            return cluster_list[pos]\n\n        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))\n        cluster_mapping: dict[int, list[int]] = {}\n        for i in range(len(text)):\n            cl = get_cluster_from_text_index(cluster_list, i)\n            if cl in cluster_mapping:\n                cluster_mapping[cl].append(i)\n            else:\n                cluster_mapping[cl] = [i]\n\n        for cluster_seq, gi in enumerate(glyph_infos):\n            unicode = []\n            if gi.cluster in cluster_mapping:\n                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]\n                cluster_mapping.pop(gi.cluster)\n\n            gname = self.ttfont.getGlyphName(gi.codepoint)\n            gwidth = round(self.scale * self.ttfont[\"hmtx\"].metrics[gname][0])\n            glyph = self.subset.get_glyph(\n                glyph=gi.codepoint,\n                unicode=tuple(unicode),\n                glyph_name=gname,\n                glyph_width=gwidth,\n            )\n            if glyph is None:\n                continue\n            force_positioning = False\n            if (\n                gwidth != glyph_positions[cluster_seq].x_advance\n                or glyph_positions[cluster_seq].x_offset != 0\n                or glyph_positions[cluster_seq].y_offset != 0\n                or glyph_positions[cluster_seq].y_advance != 0\n            ):\n                force_positioning = True\n            text_info.append(\n                {\n                    \"mapped_char\": self.subset.pick_glyph(glyph),\n                    \"x_advance\": glyph_positions[cluster_seq].x_advance,\n                    \"y_advance\": glyph_positions[cluster_seq].y_advance,\n                    \"x_offset\": glyph_positions[cluster_seq].x_offset,\n                    \"y_offset\": glyph_positions[cluster_seq].y_offset,\n                    \"force_positioning\": force_positioning,\n                }\n            )\n        return text_info",
      "language": "python"
    },
    {
      "code": "class TTFFont:\n    __slots__ = (  # RAM usage optimization\n        \"i\",\n        \"type\",\n        \"name\",\n        \"desc\",\n        \"glyph_ids\",\n        \"_hbfont\",\n        \"sp\",\n        \"ss\",\n        \"up\",\n        \"ut\",\n        \"cw\",\n        \"ttffile\",\n        \"fontkey\",\n        \"emphasis\",\n        \"scale\",\n        \"subset\",\n        \"cmap\",\n        \"ttfont\",\n        \"missing_glyphs\",\n        \"biggest_size_pt\",\n        \"color_font\",\n        \"unicode_range\",\n        \"palette_index\",\n        \"is_compressed\",\n    )\n\n    def __init__(\n        self,\n        fpdf: \"FPDF\",\n        font_file_path: Path,\n        fontkey: str,\n        style: str,\n        unicode_range: Optional[set[int]] = None,\n        axes_dict: Optional[dict[str, float]] = None,\n        palette_index: Optional[int] = None,\n    ):\n        self.i = len(fpdf.fonts) + 1\n        self.type = \"TTF\"\n        self.ttffile = font_file_path\n        self.is_compressed = str(self.ttffile).lower().endswith((\".woff\", \".woff2\"))\n        self._hbfont: Optional[\"HarfBuzzFont\"] = None\n        self.fontkey = fontkey\n        self.biggest_size_pt: float = 0\n\n        # recalcTimestamp=False means that it doesn't modify the \"modified\" timestamp in head table\n        # if we leave recalcTimestamp=True the tests will break every time\n        try:\n            self.ttfont = ttLib.TTFont(\n                self.ttffile, recalcTimestamp=False, fontNumber=0, lazy=True\n            )\n        except (\n            ImportError,\n            RuntimeError,\n        ) as exc:  # pragma: no cover - defensive messaging\n            # If the user passed a WOFF2 file but brotli is not installed, fontTools\n            # raises an ImportError/RuntimeError during parsing. Provide a clearer hint\n            # only for that specific situation. Allow other exceptions (e.g. FileNotFoundError,\n            # OSError, parsing errors) to propagate normally so they aren't masked here.\n            fname_str = str(self.ttffile).lower()\n            if fname_str.endswith(\".woff2\"):\n                raise RuntimeError(\n                    \"Could not open WOFF2 font. WOFF2 support requires an external Brotli \"\n                    \"library (install 'brotli' or 'brotlicffi'). Original error: \"\n                    f\"{exc!s}\"\n                ) from exc\n            raise\n\n        if axes_dict is not None:\n            if \"fvar\" not in self.ttfont:\n                raise AttributeError(f\"{self.ttffile} is not a variable font\")\n\n            instancer.instantiateVariableFont(\n                self.ttfont,\n                axes_dict,\n                inplace=True,\n                static=True,\n            )\n        if self.is_compressed:\n            # Normalize to SFNT output for embedding and HarfBuzz.\n            self.ttfont.flavor = None\n        upem: float = float(self.ttfont[\"head\"].unitsPerEm)\n        self.scale: float = 1000 / upem\n\n        # check if the font is a TrueType and missing a .notdef glyph\n        # if it is missing, provide a fallback glyph\n        if (\n            \"glyf\" in self.ttfont\n            and \".notdef\"\n            not in self.ttfont[\"glyf\"]  # pyright: ignore[reportOperatorIssue]\n        ):\n            LOGGER.warning(\n                (\n                    \"TrueType Font '%s' is missing the '.notdef' glyph. \"\n                    \"Fallback glyph will be provided.\"\n                ),\n                self.fontkey,\n            )\n            # draw a diagonal cross .notdef glyph\n            xMin, xMax, yMin, yMax = (\n                self.ttfont[\"head\"].xMin,\n                self.ttfont[\"head\"].xMax,\n                self.ttfont[\"head\"].yMin,\n                self.ttfont[\"head\"].yMax,\n            )\n            pen = TTGlyphPen(self.ttfont[\"glyf\"])  # pyright: ignore[reportArgumentType]\n            pen.moveTo((xMin, yMin))\n            pen.lineTo((xMax, yMin))\n            pen.lineTo((xMax, yMax))\n            pen.lineTo((xMin, yMax))\n            pen.closePath()\n            pen.moveTo((xMin, yMin))\n            pen.lineTo((xMax, yMax))\n            pen.closePath()\n            pen.moveTo((xMax, yMin))\n            pen.lineTo((xMin, yMax))\n            pen.closePath()\n\n            self.ttfont[\"glyf\"][  # pyright: ignore[reportIndexIssue]\n                \".notdef\"\n            ] = pen.glyph()\n            self.ttfont[\"hmtx\"][\".notdef\"] = (  # pyright: ignore[reportIndexIssue]\n                xMax - xMin,\n                yMax - yMin,\n            )\n\n        default_width: float = round(\n            self.scale * self.ttfont[\"hmtx\"].metrics[\".notdef\"][0]\n        )\n\n        os2_table = self.ttfont[\"OS/2\"]\n        post_table = self.ttfont[\"post\"]\n\n        try:\n            cap_height = os2_table.sCapHeight\n        except AttributeError:\n            cap_height = self.ttfont[\"hhea\"].ascent\n\n        # entry for the PDF font descriptor specifying various characteristics of the font\n        flags = FontDescriptorFlags.SYMBOLIC\n        if post_table.isFixedPitch:\n            flags |= FontDescriptorFlags.FIXED_PITCH\n        if post_table.italicAngle != 0:\n            flags |= FontDescriptorFlags.ITALIC\n        if os2_table.usWeightClass >= 600:\n            flags |= FontDescriptorFlags.FORCE_BOLD\n\n        self.desc = PDFFontDescriptor(\n            ascent=round(self.ttfont[\"hhea\"].ascent * self.scale),\n            descent=round(self.ttfont[\"hhea\"].descent * self.scale),\n            cap_height=round(cap_height * self.scale),\n            flags=flags,\n            font_b_box=(\n                f\"[{self.ttfont['head'].xMin * self.scale:.0f} {self.ttfont['head'].yMin * self.scale:.0f}\"\n                f\" {self.ttfont['head'].xMax * self.scale:.0f} {self.ttfont['head'].yMax * self.scale:.0f}]\"\n            ),\n            italic_angle=int(post_table.italicAngle),\n            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),\n            missing_width=default_width,\n        )\n\n        # a map unicode_char -> char_width\n        self.cw: dict[int, float] = defaultdict(lambda: default_width)\n\n        # fonttools cmap = unicode char to glyph name\n        # saving only the keys we have a tuple with\n        # the unicode characters available on the font\n        self.cmap: dict[int, str] = self.ttfont.getBestCmap()\n        if not self.cmap:\n            raise NotImplementedError(\n                \"Font not supported as it does not have a unicode cmap table - cf. issue #1396\"\n            )\n\n        if unicode_range is not None and len(unicode_range) != 0:\n            self.cmap = {\n                codepoint: glyph_id\n                for codepoint, glyph_id in self.cmap.items()  # pyright: ignore[reportUnknownVariableType]\n                if codepoint in unicode_range\n            }\n\n        # saving a list of glyph ids to char to allow\n        # subset by unicode (regular) and by glyph\n        # (shaped with harfbuz)\n        self.glyph_ids = {}\n\n        for char in self.cmap:  # pyright: ignore[]\n            # take glyph associated to char\n            glyph = self.cmap[char]\n\n            # take width associated to glyph\n            w = self.ttfont[\"hmtx\"].metrics[glyph][0]\n\n            # probably this check could be deleted\n            if w == 65535:\n                w = 0\n\n            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP\n\n            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)\n\n        self.missing_glyphs: list[int] = []\n\n        self.name = re.sub(\"[ ()]\", \"\", self.ttfont[\"name\"].getBestFullName())\n        self.up = round(post_table.underlinePosition * self.scale)\n        self.ut = round(post_table.underlineThickness * self.scale)\n        self.sp = round(os2_table.yStrikeoutPosition * self.scale)\n        self.ss = round(os2_table.yStrikeoutSize * self.scale)\n        self.emphasis = TextEmphasis.coerce(style)\n        self.subset = SubsetMap(self)\n        self.palette_index = palette_index if palette_index is not None else 0\n        self.color_font = (\n            get_color_font_object(fpdf, self, self.palette_index)\n            if fpdf.render_color_fonts\n            else None\n        )\n\n    # pylint: disable=no-member\n    @property\n    def hbfont(self) -> \"HarfBuzzFont\":\n        if not self._hbfont:\n            if self.is_compressed:\n                # HarfBuzz cannot load compressed WOFF/WOFF2 files directly, so we\n                # re-serialize the fontTools TTFont to a raw SFNT byte buffer.\n                buf = BytesIO()\n                self.ttfont.save(buf)\n                buf.seek(0)\n                ttfont_bytes = buf.read()\n\n                # Try to create a HarfBuzz blob from bytes; if not available, write a\n                # temporary file as a last resort.\n                try:\n                    blob = hb.Blob.from_bytes(ttfont_bytes)\n                    face = hb.Face(blob)\n                except (AttributeError, RuntimeError):\n                    import tempfile, os  # pylint: disable=import-outside-toplevel\n\n                    tmp_name = None\n                    try:\n                        with tempfile.NamedTemporaryFile(\n                            suffix=\".ttf\", delete=False\n                        ) as tmp:\n                            tmp_name = tmp.name\n                            tmp.write(ttfont_bytes)\n                            tmp.flush()\n                        face = hb.Face(hb.Blob.from_file_path(tmp_name))\n                    finally:\n                        if tmp_name:\n                            try:\n                                os.unlink(tmp_name)\n                            except OSError as cleanup_error:\n                                # Log warning about failed cleanup - orphaned temp file may cause disk issues\n                                LOGGER.warning(\n                                    \"Failed to clean up temporary font file '%s': %s. This may leave an orphaned file on disk.\",\n                                    tmp_name,\n                                    cleanup_error,\n                                )\n\n                self._hbfont = HarfBuzzFont(face)\n            else:\n                # For regular TTF/OTF fonts, load directly from file path (faster)\n                self._hbfont = HarfBuzzFont(\n                    hb.Face(hb.Blob.from_file_path(self.ttffile))\n                )\n\n        return self._hbfont\n\n    def __repr__(self) -> str:\n        return f\"TTFFont(i={self.i}, fontkey={self.fontkey})\"\n\n    def __deepcopy__(self: \"TTFFont\", memo: dict[int, Any]) -> \"TTFFont\":\n        \"\"\"\n        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes\n        but instead share references to immutable objects\n        between the original FPDF instance and the FPDFRecorder instances\n        to avoid performances issues as spotted in issue #1444.\n        \"\"\"\n        copy = TTFFont.__new__(TTFFont)\n        # Immutable attributes:\n        copy.i = self.i\n        copy.type = \"TTF\"\n        copy.ttffile = self.ttffile\n        copy.fontkey = self.fontkey\n        copy.scale = self.scale\n        copy.name = self.name\n        copy.up = self.up\n        copy.ut = self.ut\n        copy.sp = self.sp\n        copy.ss = self.ss\n        copy.emphasis = self.emphasis\n        copy.is_compressed = self.is_compressed\n        # Attributes shared, to improve FPDFRecorder performances:\n        copy.ttfont = self.ttfont\n        copy.cmap = self.cmap\n        copy.desc = self.desc\n        # Attributes deepcopied:\n        copy.cw = deepcopy(self.cw, memo)\n        copy.glyph_ids = deepcopy(self.glyph_ids, memo)\n        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)\n        copy.subset = deepcopy(self.subset, memo)\n        copy.biggest_size_pt = self.biggest_size_pt\n        copy._hbfont = self._hbfont\n        copy.color_font = self.color_font\n        copy.palette_index = self.palette_index\n        return copy\n\n    def close(self) -> None:\n        self.ttfont.close()\n        self._hbfont = None\n\n    def escape_text(self, text: str) -> str:\n        if self.color_font:\n            encoded = text.encode(\"latin-1\", errors=\"replace\")\n            return escape_parens(encoded.decode(\"latin-1\", errors=\"ignore\"))\n        return escape_parens(text.encode(\"utf-16-be\").decode(\"latin-1\"))\n\n    def get_text_width(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[int, float]:\n        if font_size_pt > self.biggest_size_pt:\n            self.biggest_size_pt = font_size_pt\n        if text_shaping_params:\n            return self.shaped_text_width(text, font_size_pt, text_shaping_params)\n        return (len(text), sum(self.cw[ord(c)] for c in text) * font_size_pt * 0.001)\n\n    def shaped_text_width(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[int, float]:\n        \"\"\"\n        When texts are shaped, the length of a string is not always the sum of all individual character widths\n        This method will invoke harfbuzz to perform the text shaping and return the sum of \"x_advance\"\n        and \"x_offset\" for each glyph. This method works for \"left to right\" or \"right to left\" texts.\n        \"\"\"\n        _, glyph_positions = self.perform_harfbuzz_shaping(\n            text, font_size_pt, text_shaping_params\n        )\n\n        # If there is nothing to render (harfbuzz returns None), we return 0 text width\n        if glyph_positions is None:\n            return (0, 0)\n\n        text_width: float = 0\n        for pos in glyph_positions:\n            text_width += (\n                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001\n            )\n        return (len(glyph_positions), text_width)\n\n    # Disabling this check - looks like cython confuses pylint:\n    # pylint: disable=no-member\n    def perform_harfbuzz_shaping(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[Sequence[\"HBGlyphInfo\"], Sequence[\"HBGlyphPosition\"]]:\n        \"\"\"\n        This method invokes Harfbuzz to perform text shaping of the input string\n        \"\"\"\n        self.hbfont.ptem = font_size_pt\n        if TYPE_CHECKING:\n            buf: HBBuffer\n        buf = hb.Buffer()\n        buf.cluster_level = 1\n        buf.add_str(\"\".join(text))\n        buf.guess_segment_properties()\n        features = (\n            text_shaping_params[\"features\"] if text_shaping_params is not None else {}\n        )\n        if text_shaping_params is None:\n            text_shaping_params = {}\n        if (\n            \"fragment_direction\" in text_shaping_params\n            and text_shaping_params[\"fragment_direction\"] is not None\n        ):\n            buf.direction = text_shaping_params[\"fragment_direction\"].value\n        if (\n            \"script\" in text_shaping_params\n            and text_shaping_params[\"script\"] is not None\n        ):\n            buf.script = text_shaping_params[\"script\"]\n        if (\n            \"language\" in text_shaping_params\n            and text_shaping_params[\"language\"] is not None\n        ):\n            buf.language = text_shaping_params[\"language\"]\n        hb.shape(self.hbfont, buf, features)\n        return buf.glyph_infos, buf.glyph_positions\n\n    def encode_text(self, text: str) -> str:\n        txt_mapped = \"\"\n        for char in text:\n            uni = ord(char)\n            # Instead of adding the actual character to the stream its code is\n            # mapped to a position in the font's subset\n            mapped_char: Optional[int] = self.subset.pick(uni)\n            if mapped_char is not None:\n                txt_mapped += chr(mapped_char)\n        return f\"({self.escape_text(txt_mapped)}) Tj\"\n\n    def shape_text(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> Sequence[dict[str, Any]]:\n        \"\"\"\n        This method will invoke harfbuzz for text shaping, include the mapping code\n        of the glyphs on the subset and map input characters to the cluster codes\n        \"\"\"\n        if len(text) == 0:\n            return []\n        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(\n            text, font_size_pt, text_shaping_params\n        )\n        text_info = []\n\n        # Find cluster gaps\n        # Ex: text = \"ABCD\"\n        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph\n        # (ligature or substitution) - the glyph should have both unicodes and it should be translated\n        # properly on the CID to GID mapping\n        #\n        def get_cluster_from_text_index(cluster_list: Sequence[int], index: int) -> int:\n            pos = bisect_left(cluster_list, index)\n            if pos == 0:\n                return cluster_list[0]\n            if pos == len(cluster_list) or cluster_list[pos] != index:\n                return cluster_list[pos - 1]\n            return cluster_list[pos]\n\n        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))\n        cluster_mapping: dict[int, list[int]] = {}\n        for i in range(len(text)):\n            cl = get_cluster_from_text_index(cluster_list, i)\n            if cl in cluster_mapping:\n                cluster_mapping[cl].append(i)\n            else:\n                cluster_mapping[cl] = [i]\n\n        for cluster_seq, gi in enumerate(glyph_infos):\n            unicode = []\n            if gi.cluster in cluster_mapping:\n                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]\n                cluster_mapping.pop(gi.cluster)\n\n            gname = self.ttfont.getGlyphName(gi.codepoint)\n            gwidth = round(self.scale * self.ttfont[\"hmtx\"].metrics[gname][0])\n            glyph = self.subset.get_glyph(\n                glyph=gi.codepoint,\n                unicode=tuple(unicode),\n                glyph_name=gname,\n                glyph_width=gwidth,\n            )\n            if glyph is None:\n                continue\n            force_positioning = False\n            if (\n                gwidth != glyph_positions[cluster_seq].x_advance\n                or glyph_positions[cluster_seq].x_offset != 0\n                or glyph_positions[cluster_seq].y_offset != 0\n                or glyph_positions[cluster_seq].y_advance != 0\n            ):\n                force_positioning = True\n            text_info.append(\n                {\n                    \"mapped_char\": self.subset.pick_glyph(glyph),\n                    \"x_advance\": glyph_positions[cluster_seq].x_advance,\n                    \"y_advance\": glyph_positions[cluster_seq].y_advance,\n                    \"x_offset\": glyph_positions[cluster_seq].x_offset,\n                    \"y_offset\": glyph_positions[cluster_seq].y_offset,\n                    \"force_positioning\": force_positioning,\n                }\n            )\n        return text_info",
      "language": "python"
    },
    {
      "code": "class TTFFont:\n    __slots__ = (  # RAM usage optimization\n        \"i\",\n        \"type\",\n        \"name\",\n        \"desc\",\n        \"glyph_ids\",\n        \"_hbfont\",\n        \"sp\",\n        \"ss\",\n        \"up\",\n        \"ut\",\n        \"cw\",\n        \"ttffile\",\n        \"fontkey\",\n        \"emphasis\",\n        \"scale\",\n        \"subset\",\n        \"cmap\",\n        \"ttfont\",\n        \"missing_glyphs\",\n        \"biggest_size_pt\",\n        \"color_font\",\n        \"unicode_range\",\n        \"palette_index\",\n        \"is_compressed\",\n    )\n\n    def __init__(\n        self,\n        fpdf: \"FPDF\",\n        font_file_path: Path,\n        fontkey: str,\n        style: str,\n        unicode_range: Optional[set[int]] = None,\n        axes_dict: Optional[dict[str, float]] = None,\n        palette_index: Optional[int] = None,\n    ):\n        self.i = len(fpdf.fonts) + 1\n        self.type = \"TTF\"\n        self.ttffile = font_file_path\n        self.is_compressed = str(self.ttffile).lower().endswith((\".woff\", \".woff2\"))\n        self._hbfont: Optional[\"HarfBuzzFont\"] = None\n        self.fontkey = fontkey\n        self.biggest_size_pt: float = 0\n\n        # recalcTimestamp=False means that it doesn't modify the \"modified\" timestamp in head table\n        # if we leave recalcTimestamp=True the tests will break every time\n        try:\n            self.ttfont = ttLib.TTFont(\n                self.ttffile, recalcTimestamp=False, fontNumber=0, lazy=True\n            )\n        except (\n            ImportError,\n            RuntimeError,\n        ) as exc:  # pragma: no cover - defensive messaging\n            # If the user passed a WOFF2 file but brotli is not installed, fontTools\n            # raises an ImportError/RuntimeError during parsing. Provide a clearer hint\n            # only for that specific situation. Allow other exceptions (e.g. FileNotFoundError,\n            # OSError, parsing errors) to propagate normally so they aren't masked here.\n            fname_str = str(self.ttffile).lower()\n            if fname_str.endswith(\".woff2\"):\n                raise RuntimeError(\n                    \"Could not open WOFF2 font. WOFF2 support requires an external Brotli \"\n                    \"library (install 'brotli' or 'brotlicffi'). Original error: \"\n                    f\"{exc!s}\"\n                ) from exc\n            raise\n\n        if axes_dict is not None:\n            if \"fvar\" not in self.ttfont:\n                raise AttributeError(f\"{self.ttffile} is not a variable font\")\n\n            instancer.instantiateVariableFont(\n                self.ttfont,\n                axes_dict,\n                inplace=True,\n                static=True,\n            )\n        if self.is_compressed:\n            # Normalize to SFNT output for embedding and HarfBuzz.\n            self.ttfont.flavor = None\n        upem: float = float(self.ttfont[\"head\"].unitsPerEm)\n        self.scale: float = 1000 / upem\n\n        # check if the font is a TrueType and missing a .notdef glyph\n        # if it is missing, provide a fallback glyph\n        if (\n            \"glyf\" in self.ttfont\n            and \".notdef\"\n            not in self.ttfont[\"glyf\"]  # pyright: ignore[reportOperatorIssue]\n        ):\n            LOGGER.warning(\n                (\n                    \"TrueType Font '%s' is missing the '.notdef' glyph. \"\n                    \"Fallback glyph will be provided.\"\n                ),\n                self.fontkey,\n            )\n            # draw a diagonal cross .notdef glyph\n            xMin, xMax, yMin, yMax = (\n                self.ttfont[\"head\"].xMin,\n                self.ttfont[\"head\"].xMax,\n                self.ttfont[\"head\"].yMin,\n                self.ttfont[\"head\"].yMax,\n            )\n            pen = TTGlyphPen(self.ttfont[\"glyf\"])  # pyright: ignore[reportArgumentType]\n            pen.moveTo((xMin, yMin))\n            pen.lineTo((xMax, yMin))\n            pen.lineTo((xMax, yMax))\n            pen.lineTo((xMin, yMax))\n            pen.closePath()\n            pen.moveTo((xMin, yMin))\n            pen.lineTo((xMax, yMax))\n            pen.closePath()\n            pen.moveTo((xMax, yMin))\n            pen.lineTo((xMin, yMax))\n            pen.closePath()\n\n            self.ttfont[\"glyf\"][  # pyright: ignore[reportIndexIssue]\n                \".notdef\"\n            ] = pen.glyph()\n            self.ttfont[\"hmtx\"][\".notdef\"] = (  # pyright: ignore[reportIndexIssue]\n                xMax - xMin,\n                yMax - yMin,\n            )\n\n        default_width: float = round(\n            self.scale * self.ttfont[\"hmtx\"].metrics[\".notdef\"][0]\n        )\n\n        os2_table = self.ttfont[\"OS/2\"]\n        post_table = self.ttfont[\"post\"]\n\n        try:\n            cap_height = os2_table.sCapHeight\n        except AttributeError:\n            cap_height = self.ttfont[\"hhea\"].ascent\n\n        # entry for the PDF font descriptor specifying various characteristics of the font\n        flags = FontDescriptorFlags.SYMBOLIC\n        if post_table.isFixedPitch:\n            flags |= FontDescriptorFlags.FIXED_PITCH\n        if post_table.italicAngle != 0:\n            flags |= FontDescriptorFlags.ITALIC\n        if os2_table.usWeightClass >= 600:\n            flags |= FontDescriptorFlags.FORCE_BOLD\n\n        self.desc = PDFFontDescriptor(\n            ascent=round(self.ttfont[\"hhea\"].ascent * self.scale),\n            descent=round(self.ttfont[\"hhea\"].descent * self.scale),\n            cap_height=round(cap_height * self.scale),\n            flags=flags,\n            font_b_box=(\n                f\"[{self.ttfont['head'].xMin * self.scale:.0f} {self.ttfont['head'].yMin * self.scale:.0f}\"\n                f\" {self.ttfont['head'].xMax * self.scale:.0f} {self.ttfont['head'].yMax * self.scale:.0f}]\"\n            ),\n            italic_angle=int(post_table.italicAngle),\n            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),\n            missing_width=default_width,\n        )\n\n        # a map unicode_char -> char_width\n        self.cw: dict[int, float] = defaultdict(lambda: default_width)\n\n        # fonttools cmap = unicode char to glyph name\n        # saving only the keys we have a tuple with\n        # the unicode characters available on the font\n        self.cmap: dict[int, str] = self.ttfont.getBestCmap()\n        if not self.cmap:\n            raise NotImplementedError(\n                \"Font not supported as it does not have a unicode cmap table - cf. issue #1396\"\n            )\n\n        if unicode_range is not None and len(unicode_range) != 0:\n            self.cmap = {\n                codepoint: glyph_id\n                for codepoint, glyph_id in self.cmap.items()  # pyright: ignore[reportUnknownVariableType]\n                if codepoint in unicode_range\n            }\n\n        # saving a list of glyph ids to char to allow\n        # subset by unicode (regular) and by glyph\n        # (shaped with harfbuz)\n        self.glyph_ids = {}\n\n        for char in self.cmap:  # pyright: ignore[]\n            # take glyph associated to char\n            glyph = self.cmap[char]\n\n            # take width associated to glyph\n            w = self.ttfont[\"hmtx\"].metrics[glyph][0]\n\n            # probably this check could be deleted\n            if w == 65535:\n                w = 0\n\n            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP\n\n            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)\n\n        self.missing_glyphs: list[int] = []\n\n        self.name = re.sub(\"[ ()]\", \"\", self.ttfont[\"name\"].getBestFullName())\n        self.up = round(post_table.underlinePosition * self.scale)\n        self.ut = round(post_table.underlineThickness * self.scale)\n        self.sp = round(os2_table.yStrikeoutPosition * self.scale)\n        self.ss = round(os2_table.yStrikeoutSize * self.scale)\n        self.emphasis = TextEmphasis.coerce(style)\n        self.subset = SubsetMap(self)\n        self.palette_index = palette_index if palette_index is not None else 0\n        self.color_font = (\n            get_color_font_object(fpdf, self, self.palette_index)\n            if fpdf.render_color_fonts\n            else None\n        )\n\n    # pylint: disable=no-member\n    @property\n    def hbfont(self) -> \"HarfBuzzFont\":\n        if not self._hbfont:\n            if self.is_compressed:\n                # HarfBuzz cannot load compressed WOFF/WOFF2 files directly, so we\n                # re-serialize the fontTools TTFont to a raw SFNT byte buffer.\n                buf = BytesIO()\n                self.ttfont.save(buf)\n                buf.seek(0)\n                ttfont_bytes = buf.read()\n\n                # Try to create a HarfBuzz blob from bytes; if not available, write a\n                # temporary file as a last resort.\n                try:\n                    blob = hb.Blob.from_bytes(ttfont_bytes)\n                    face = hb.Face(blob)\n                except (AttributeError, RuntimeError):\n                    import tempfile, os  # pylint: disable=import-outside-toplevel\n\n                    tmp_name = None\n                    try:\n                        with tempfile.NamedTemporaryFile(\n                            suffix=\".ttf\", delete=False\n                        ) as tmp:\n                            tmp_name = tmp.name\n                            tmp.write(ttfont_bytes)\n                            tmp.flush()\n                        face = hb.Face(hb.Blob.from_file_path(tmp_name))\n                    finally:\n                        if tmp_name:\n                            try:\n                                os.unlink(tmp_name)\n                            except OSError as cleanup_error:\n                                # Log warning about failed cleanup - orphaned temp file may cause disk issues\n                                LOGGER.warning(\n                                    \"Failed to clean up temporary font file '%s': %s. This may leave an orphaned file on disk.\",\n                                    tmp_name,\n                                    cleanup_error,\n                                )\n\n                self._hbfont = HarfBuzzFont(face)\n            else:\n                # For regular TTF/OTF fonts, load directly from file path (faster)\n                self._hbfont = HarfBuzzFont(\n                    hb.Face(hb.Blob.from_file_path(self.ttffile))\n                )\n\n        return self._hbfont\n\n    def __repr__(self) -> str:\n        return f\"TTFFont(i={self.i}, fontkey={self.fontkey})\"\n\n    def __deepcopy__(self: \"TTFFont\", memo: dict[int, Any]) -> \"TTFFont\":\n        \"\"\"\n        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes\n        but instead share references to immutable objects\n        between the original FPDF instance and the FPDFRecorder instances\n        to avoid performances issues as spotted in issue #1444.\n        \"\"\"\n        copy = TTFFont.__new__(TTFFont)\n        # Immutable attributes:\n        copy.i = self.i\n        copy.type = \"TTF\"\n        copy.ttffile = self.ttffile\n        copy.fontkey = self.fontkey\n        copy.scale = self.scale\n        copy.name = self.name\n        copy.up = self.up\n        copy.ut = self.ut\n        copy.sp = self.sp\n        copy.ss = self.ss\n        copy.emphasis = self.emphasis\n        copy.is_compressed = self.is_compressed\n        # Attributes shared, to improve FPDFRecorder performances:\n        copy.ttfont = self.ttfont\n        copy.cmap = self.cmap\n        copy.desc = self.desc\n        # Attributes deepcopied:\n        copy.cw = deepcopy(self.cw, memo)\n        copy.glyph_ids = deepcopy(self.glyph_ids, memo)\n        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)\n        copy.subset = deepcopy(self.subset, memo)\n        copy.biggest_size_pt = self.biggest_size_pt\n        copy._hbfont = self._hbfont\n        copy.color_font = self.color_font\n        copy.palette_index = self.palette_index\n        return copy\n\n    def close(self) -> None:\n        self.ttfont.close()\n        self._hbfont = None\n\n    def escape_text(self, text: str) -> str:\n        if self.color_font:\n            encoded = text.encode(\"latin-1\", errors=\"replace\")\n            return escape_parens(encoded.decode(\"latin-1\", errors=\"ignore\"))\n        return escape_parens(text.encode(\"utf-16-be\").decode(\"latin-1\"))\n\n    def get_text_width(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[int, float]:\n        if font_size_pt > self.biggest_size_pt:\n            self.biggest_size_pt = font_size_pt\n        if text_shaping_params:\n            return self.shaped_text_width(text, font_size_pt, text_shaping_params)\n        return (len(text), sum(self.cw[ord(c)] for c in text) * font_size_pt * 0.001)\n\n    def shaped_text_width(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[int, float]:\n        \"\"\"\n        When texts are shaped, the length of a string is not always the sum of all individual character widths\n        This method will invoke harfbuzz to perform the text shaping and return the sum of \"x_advance\"\n        and \"x_offset\" for each glyph. This method works for \"left to right\" or \"right to left\" texts.\n        \"\"\"\n        _, glyph_positions = self.perform_harfbuzz_shaping(\n            text, font_size_pt, text_shaping_params\n        )\n\n        # If there is nothing to render (harfbuzz returns None), we return 0 text width\n        if glyph_positions is None:\n            return (0, 0)\n\n        text_width: float = 0\n        for pos in glyph_positions:\n            text_width += (\n                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001\n            )\n        return (len(glyph_positions), text_width)\n\n    # Disabling this check - looks like cython confuses pylint:\n    # pylint: disable=no-member\n    def perform_harfbuzz_shaping(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[Sequence[\"HBGlyphInfo\"], Sequence[\"HBGlyphPosition\"]]:\n        \"\"\"\n        This method invokes Harfbuzz to perform text shaping of the input string\n        \"\"\"\n        self.hbfont.ptem = font_size_pt\n        if TYPE_CHECKING:\n            buf: HBBuffer\n        buf = hb.Buffer()\n        buf.cluster_level = 1\n        buf.add_str(\"\".join(text))\n        buf.guess_segment_properties()\n        features = (\n            text_shaping_params[\"features\"] if text_shaping_params is not None else {}\n        )\n        if text_shaping_params is None:\n            text_shaping_params = {}\n        if (\n            \"fragment_direction\" in text_shaping_params\n            and text_shaping_params[\"fragment_direction\"] is not None\n        ):\n            buf.direction = text_shaping_params[\"fragment_direction\"].value\n        if (\n            \"script\" in text_shaping_params\n            and text_shaping_params[\"script\"] is not None\n        ):\n            buf.script = text_shaping_params[\"script\"]\n        if (\n            \"language\" in text_shaping_params\n            and text_shaping_params[\"language\"] is not None\n        ):\n            buf.language = text_shaping_params[\"language\"]\n        hb.shape(self.hbfont, buf, features)\n        return buf.glyph_infos, buf.glyph_positions\n\n    def encode_text(self, text: str) -> str:\n        txt_mapped = \"\"\n        for char in text:\n            uni = ord(char)\n            # Instead of adding the actual character to the stream its code is\n            # mapped to a position in the font's subset\n            mapped_char: Optional[int] = self.subset.pick(uni)\n            if mapped_char is not None:\n                txt_mapped += chr(mapped_char)\n        return f\"({self.escape_text(txt_mapped)}) Tj\"\n\n    def shape_text(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> Sequence[dict[str, Any]]:\n        \"\"\"\n        This method will invoke harfbuzz for text shaping, include the mapping code\n        of the glyphs on the subset and map input characters to the cluster codes\n        \"\"\"\n        if len(text) == 0:\n            return []\n        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(\n            text, font_size_pt, text_shaping_params\n        )\n        text_info = []\n\n        # Find cluster gaps\n        # Ex: text = \"ABCD\"\n        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph\n        # (ligature or substitution) - the glyph should have both unicodes and it should be translated\n        # properly on the CID to GID mapping\n        #\n        def get_cluster_from_text_index(cluster_list: Sequence[int], index: int) -> int:\n            pos = bisect_left(cluster_list, index)\n            if pos == 0:\n                return cluster_list[0]\n            if pos == len(cluster_list) or cluster_list[pos] != index:\n                return cluster_list[pos - 1]\n            return cluster_list[pos]\n\n        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))\n        cluster_mapping: dict[int, list[int]] = {}\n        for i in range(len(text)):\n            cl = get_cluster_from_text_index(cluster_list, i)\n            if cl in cluster_mapping:\n                cluster_mapping[cl].append(i)\n            else:\n                cluster_mapping[cl] = [i]\n\n        for cluster_seq, gi in enumerate(glyph_infos):\n            unicode = []\n            if gi.cluster in cluster_mapping:\n                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]\n                cluster_mapping.pop(gi.cluster)\n\n            gname = self.ttfont.getGlyphName(gi.codepoint)\n            gwidth = round(self.scale * self.ttfont[\"hmtx\"].metrics[gname][0])\n            glyph = self.subset.get_glyph(\n                glyph=gi.codepoint,\n                unicode=tuple(unicode),\n                glyph_name=gname,\n                glyph_width=gwidth,\n            )\n            if glyph is None:\n                continue\n            force_positioning = False\n            if (\n                gwidth != glyph_positions[cluster_seq].x_advance\n                or glyph_positions[cluster_seq].x_offset != 0\n                or glyph_positions[cluster_seq].y_offset != 0\n                or glyph_positions[cluster_seq].y_advance != 0\n            ):\n                force_positioning = True\n            text_info.append(\n                {\n                    \"mapped_char\": self.subset.pick_glyph(glyph),\n                    \"x_advance\": glyph_positions[cluster_seq].x_advance,\n                    \"y_advance\": glyph_positions[cluster_seq].y_advance,\n                    \"x_offset\": glyph_positions[cluster_seq].x_offset,\n                    \"y_offset\": glyph_positions[cluster_seq].y_offset,\n                    \"force_positioning\": force_positioning,\n                }\n            )\n        return text_info",
      "language": "python"
    },
    {
      "code": "class TTFFont:\n    __slots__ = (  # RAM usage optimization\n        \"i\",\n        \"type\",\n        \"name\",\n        \"desc\",\n        \"glyph_ids\",\n        \"_hbfont\",\n        \"sp\",\n        \"ss\",\n        \"up\",\n        \"ut\",\n        \"cw\",\n        \"ttffile\",\n        \"fontkey\",\n        \"emphasis\",\n        \"scale\",\n        \"subset\",\n        \"cmap\",\n        \"ttfont\",\n        \"missing_glyphs\",\n        \"biggest_size_pt\",\n        \"color_font\",\n        \"unicode_range\",\n        \"palette_index\",\n        \"is_compressed\",\n    )\n\n    def __init__(\n        self,\n        fpdf: \"FPDF\",\n        font_file_path: Path,\n        fontkey: str,\n        style: str,\n        unicode_range: Optional[set[int]] = None,\n        axes_dict: Optional[dict[str, float]] = None,\n        palette_index: Optional[int] = None,\n    ):\n        self.i = len(fpdf.fonts) + 1\n        self.type = \"TTF\"\n        self.ttffile = font_file_path\n        self.is_compressed = str(self.ttffile).lower().endswith((\".woff\", \".woff2\"))\n        self._hbfont: Optional[\"HarfBuzzFont\"] = None\n        self.fontkey = fontkey\n        self.biggest_size_pt: float = 0\n\n        # recalcTimestamp=False means that it doesn't modify the \"modified\" timestamp in head table\n        # if we leave recalcTimestamp=True the tests will break every time\n        try:\n            self.ttfont = ttLib.TTFont(\n                self.ttffile, recalcTimestamp=False, fontNumber=0, lazy=True\n            )\n        except (\n            ImportError,\n            RuntimeError,\n        ) as exc:  # pragma: no cover - defensive messaging\n            # If the user passed a WOFF2 file but brotli is not installed, fontTools\n            # raises an ImportError/RuntimeError during parsing. Provide a clearer hint\n            # only for that specific situation. Allow other exceptions (e.g. FileNotFoundError,\n            # OSError, parsing errors) to propagate normally so they aren't masked here.\n            fname_str = str(self.ttffile).lower()\n            if fname_str.endswith(\".woff2\"):\n                raise RuntimeError(\n                    \"Could not open WOFF2 font. WOFF2 support requires an external Brotli \"\n                    \"library (install 'brotli' or 'brotlicffi'). Original error: \"\n                    f\"{exc!s}\"\n                ) from exc\n            raise\n\n        if axes_dict is not None:\n            if \"fvar\" not in self.ttfont:\n                raise AttributeError(f\"{self.ttffile} is not a variable font\")\n\n            instancer.instantiateVariableFont(\n                self.ttfont,\n                axes_dict,\n                inplace=True,\n                static=True,\n            )\n        if self.is_compressed:\n            # Normalize to SFNT output for embedding and HarfBuzz.\n            self.ttfont.flavor = None\n        upem: float = float(self.ttfont[\"head\"].unitsPerEm)\n        self.scale: float = 1000 / upem\n\n        # check if the font is a TrueType and missing a .notdef glyph\n        # if it is missing, provide a fallback glyph\n        if (\n            \"glyf\" in self.ttfont\n            and \".notdef\"\n            not in self.ttfont[\"glyf\"]  # pyright: ignore[reportOperatorIssue]\n        ):\n            LOGGER.warning(\n                (\n                    \"TrueType Font '%s' is missing the '.notdef' glyph. \"\n                    \"Fallback glyph will be provided.\"\n                ),\n                self.fontkey,\n            )\n            # draw a diagonal cross .notdef glyph\n            xMin, xMax, yMin, yMax = (\n                self.ttfont[\"head\"].xMin,\n                self.ttfont[\"head\"].xMax,\n                self.ttfont[\"head\"].yMin,\n                self.ttfont[\"head\"].yMax,\n            )\n            pen = TTGlyphPen(self.ttfont[\"glyf\"])  # pyright: ignore[reportArgumentType]\n            pen.moveTo((xMin, yMin))\n            pen.lineTo((xMax, yMin))\n            pen.lineTo((xMax, yMax))\n            pen.lineTo((xMin, yMax))\n            pen.closePath()\n            pen.moveTo((xMin, yMin))\n            pen.lineTo((xMax, yMax))\n            pen.closePath()\n            pen.moveTo((xMax, yMin))\n            pen.lineTo((xMin, yMax))\n            pen.closePath()\n\n            self.ttfont[\"glyf\"][  # pyright: ignore[reportIndexIssue]\n                \".notdef\"\n            ] = pen.glyph()\n            self.ttfont[\"hmtx\"][\".notdef\"] = (  # pyright: ignore[reportIndexIssue]\n                xMax - xMin,\n                yMax - yMin,\n            )\n\n        default_width: float = round(\n            self.scale * self.ttfont[\"hmtx\"].metrics[\".notdef\"][0]\n        )\n\n        os2_table = self.ttfont[\"OS/2\"]\n        post_table = self.ttfont[\"post\"]\n\n        try:\n            cap_height = os2_table.sCapHeight\n        except AttributeError:\n            cap_height = self.ttfont[\"hhea\"].ascent\n\n        # entry for the PDF font descriptor specifying various characteristics of the font\n        flags = FontDescriptorFlags.SYMBOLIC\n        if post_table.isFixedPitch:\n            flags |= FontDescriptorFlags.FIXED_PITCH\n        if post_table.italicAngle != 0:\n            flags |= FontDescriptorFlags.ITALIC\n        if os2_table.usWeightClass >= 600:\n            flags |= FontDescriptorFlags.FORCE_BOLD\n\n        self.desc = PDFFontDescriptor(\n            ascent=round(self.ttfont[\"hhea\"].ascent * self.scale),\n            descent=round(self.ttfont[\"hhea\"].descent * self.scale),\n            cap_height=round(cap_height * self.scale),\n            flags=flags,\n            font_b_box=(\n                f\"[{self.ttfont['head'].xMin * self.scale:.0f} {self.ttfont['head'].yMin * self.scale:.0f}\"\n                f\" {self.ttfont['head'].xMax * self.scale:.0f} {self.ttfont['head'].yMax * self.scale:.0f}]\"\n            ),\n            italic_angle=int(post_table.italicAngle),\n            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),\n            missing_width=default_width,\n        )\n\n        # a map unicode_char -> char_width\n        self.cw: dict[int, float] = defaultdict(lambda: default_width)\n\n        # fonttools cmap = unicode char to glyph name\n        # saving only the keys we have a tuple with\n        # the unicode characters available on the font\n        self.cmap: dict[int, str] = self.ttfont.getBestCmap()\n        if not self.cmap:\n            raise NotImplementedError(\n                \"Font not supported as it does not have a unicode cmap table - cf. issue #1396\"\n            )\n\n        if unicode_range is not None and len(unicode_range) != 0:\n            self.cmap = {\n                codepoint: glyph_id\n                for codepoint, glyph_id in self.cmap.items()  # pyright: ignore[reportUnknownVariableType]\n                if codepoint in unicode_range\n            }\n\n        # saving a list of glyph ids to char to allow\n        # subset by unicode (regular) and by glyph\n        # (shaped with harfbuz)\n        self.glyph_ids = {}\n\n        for char in self.cmap:  # pyright: ignore[]\n            # take glyph associated to char\n            glyph = self.cmap[char]\n\n            # take width associated to glyph\n            w = self.ttfont[\"hmtx\"].metrics[glyph][0]\n\n            # probably this check could be deleted\n            if w == 65535:\n                w = 0\n\n            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP\n\n            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)\n\n        self.missing_glyphs: list[int] = []\n\n        self.name = re.sub(\"[ ()]\", \"\", self.ttfont[\"name\"].getBestFullName())\n        self.up = round(post_table.underlinePosition * self.scale)\n        self.ut = round(post_table.underlineThickness * self.scale)\n        self.sp = round(os2_table.yStrikeoutPosition * self.scale)\n        self.ss = round(os2_table.yStrikeoutSize * self.scale)\n        self.emphasis = TextEmphasis.coerce(style)\n        self.subset = SubsetMap(self)\n        self.palette_index = palette_index if palette_index is not None else 0\n        self.color_font = (\n            get_color_font_object(fpdf, self, self.palette_index)\n            if fpdf.render_color_fonts\n            else None\n        )\n\n    # pylint: disable=no-member\n    @property\n    def hbfont(self) -> \"HarfBuzzFont\":\n        if not self._hbfont:\n            if self.is_compressed:\n                # HarfBuzz cannot load compressed WOFF/WOFF2 files directly, so we\n                # re-serialize the fontTools TTFont to a raw SFNT byte buffer.\n                buf = BytesIO()\n                self.ttfont.save(buf)\n                buf.seek(0)\n                ttfont_bytes = buf.read()\n\n                # Try to create a HarfBuzz blob from bytes; if not available, write a\n                # temporary file as a last resort.\n                try:\n                    blob = hb.Blob.from_bytes(ttfont_bytes)\n                    face = hb.Face(blob)\n                except (AttributeError, RuntimeError):\n                    import tempfile, os  # pylint: disable=import-outside-toplevel\n\n                    tmp_name = None\n                    try:\n                        with tempfile.NamedTemporaryFile(\n                            suffix=\".ttf\", delete=False\n                        ) as tmp:\n                            tmp_name = tmp.name\n                            tmp.write(ttfont_bytes)\n                            tmp.flush()\n                        face = hb.Face(hb.Blob.from_file_path(tmp_name))\n                    finally:\n                        if tmp_name:\n                            try:\n                                os.unlink(tmp_name)\n                            except OSError as cleanup_error:\n                                # Log warning about failed cleanup - orphaned temp file may cause disk issues\n                                LOGGER.warning(\n                                    \"Failed to clean up temporary font file '%s': %s. This may leave an orphaned file on disk.\",\n                                    tmp_name,\n                                    cleanup_error,\n                                )\n\n                self._hbfont = HarfBuzzFont(face)\n            else:\n                # For regular TTF/OTF fonts, load directly from file path (faster)\n                self._hbfont = HarfBuzzFont(\n                    hb.Face(hb.Blob.from_file_path(self.ttffile))\n                )\n\n        return self._hbfont\n\n    def __repr__(self) -> str:\n        return f\"TTFFont(i={self.i}, fontkey={self.fontkey})\"\n\n    def __deepcopy__(self: \"TTFFont\", memo: dict[int, Any]) -> \"TTFFont\":\n        \"\"\"\n        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes\n        but instead share references to immutable objects\n        between the original FPDF instance and the FPDFRecorder instances\n        to avoid performances issues as spotted in issue #1444.\n        \"\"\"\n        copy = TTFFont.__new__(TTFFont)\n        # Immutable attributes:\n        copy.i = self.i\n        copy.type = \"TTF\"\n        copy.ttffile = self.ttffile\n        copy.fontkey = self.fontkey\n        copy.scale = self.scale\n        copy.name = self.name\n        copy.up = self.up\n        copy.ut = self.ut\n        copy.sp = self.sp\n        copy.ss = self.ss\n        copy.emphasis = self.emphasis\n        copy.is_compressed = self.is_compressed\n        # Attributes shared, to improve FPDFRecorder performances:\n        copy.ttfont = self.ttfont\n        copy.cmap = self.cmap\n        copy.desc = self.desc\n        # Attributes deepcopied:\n        copy.cw = deepcopy(self.cw, memo)\n        copy.glyph_ids = deepcopy(self.glyph_ids, memo)\n        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)\n        copy.subset = deepcopy(self.subset, memo)\n        copy.biggest_size_pt = self.biggest_size_pt\n        copy._hbfont = self._hbfont\n        copy.color_font = self.color_font\n        copy.palette_index = self.palette_index\n        return copy\n\n    def close(self) -> None:\n        self.ttfont.close()\n        self._hbfont = None\n\n    def escape_text(self, text: str) -> str:\n        if self.color_font:\n            encoded = text.encode(\"latin-1\", errors=\"replace\")\n            return escape_parens(encoded.decode(\"latin-1\", errors=\"ignore\"))\n        return escape_parens(text.encode(\"utf-16-be\").decode(\"latin-1\"))\n\n    def get_text_width(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[int, float]:\n        if font_size_pt > self.biggest_size_pt:\n            self.biggest_size_pt = font_size_pt\n        if text_shaping_params:\n            return self.shaped_text_width(text, font_size_pt, text_shaping_params)\n        return (len(text), sum(self.cw[ord(c)] for c in text) * font_size_pt * 0.001)\n\n    def shaped_text_width(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[int, float]:\n        \"\"\"\n        When texts are shaped, the length of a string is not always the sum of all individual character widths\n        This method will invoke harfbuzz to perform the text shaping and return the sum of \"x_advance\"\n        and \"x_offset\" for each glyph. This method works for \"left to right\" or \"right to left\" texts.\n        \"\"\"\n        _, glyph_positions = self.perform_harfbuzz_shaping(\n            text, font_size_pt, text_shaping_params\n        )\n\n        # If there is nothing to render (harfbuzz returns None), we return 0 text width\n        if glyph_positions is None:\n            return (0, 0)\n\n        text_width: float = 0\n        for pos in glyph_positions:\n            text_width += (\n                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001\n            )\n        return (len(glyph_positions), text_width)\n\n    # Disabling this check - looks like cython confuses pylint:\n    # pylint: disable=no-member\n    def perform_harfbuzz_shaping(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[Sequence[\"HBGlyphInfo\"], Sequence[\"HBGlyphPosition\"]]:\n        \"\"\"\n        This method invokes Harfbuzz to perform text shaping of the input string\n        \"\"\"\n        self.hbfont.ptem = font_size_pt\n        if TYPE_CHECKING:\n            buf: HBBuffer\n        buf = hb.Buffer()\n        buf.cluster_level = 1\n        buf.add_str(\"\".join(text))\n        buf.guess_segment_properties()\n        features = (\n            text_shaping_params[\"features\"] if text_shaping_params is not None else {}\n        )\n        if text_shaping_params is None:\n            text_shaping_params = {}\n        if (\n            \"fragment_direction\" in text_shaping_params\n            and text_shaping_params[\"fragment_direction\"] is not None\n        ):\n            buf.direction = text_shaping_params[\"fragment_direction\"].value\n        if (\n            \"script\" in text_shaping_params\n            and text_shaping_params[\"script\"] is not None\n        ):\n            buf.script = text_shaping_params[\"script\"]\n        if (\n            \"language\" in text_shaping_params\n            and text_shaping_params[\"language\"] is not None\n        ):\n            buf.language = text_shaping_params[\"language\"]\n        hb.shape(self.hbfont, buf, features)\n        return buf.glyph_infos, buf.glyph_positions\n\n    def encode_text(self, text: str) -> str:\n        txt_mapped = \"\"\n        for char in text:\n            uni = ord(char)\n            # Instead of adding the actual character to the stream its code is\n            # mapped to a position in the font's subset\n            mapped_char: Optional[int] = self.subset.pick(uni)\n            if mapped_char is not None:\n                txt_mapped += chr(mapped_char)\n        return f\"({self.escape_text(txt_mapped)}) Tj\"\n\n    def shape_text(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> Sequence[dict[str, Any]]:\n        \"\"\"\n        This method will invoke harfbuzz for text shaping, include the mapping code\n        of the glyphs on the subset and map input characters to the cluster codes\n        \"\"\"\n        if len(text) == 0:\n            return []\n        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(\n            text, font_size_pt, text_shaping_params\n        )\n        text_info = []\n\n        # Find cluster gaps\n        # Ex: text = \"ABCD\"\n        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph\n        # (ligature or substitution) - the glyph should have both unicodes and it should be translated\n        # properly on the CID to GID mapping\n        #\n        def get_cluster_from_text_index(cluster_list: Sequence[int], index: int) -> int:\n            pos = bisect_left(cluster_list, index)\n            if pos == 0:\n                return cluster_list[0]\n            if pos == len(cluster_list) or cluster_list[pos] != index:\n                return cluster_list[pos - 1]\n            return cluster_list[pos]\n\n        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))\n        cluster_mapping: dict[int, list[int]] = {}\n        for i in range(len(text)):\n            cl = get_cluster_from_text_index(cluster_list, i)\n            if cl in cluster_mapping:\n                cluster_mapping[cl].append(i)\n            else:\n                cluster_mapping[cl] = [i]\n\n        for cluster_seq, gi in enumerate(glyph_infos):\n            unicode = []\n            if gi.cluster in cluster_mapping:\n                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]\n                cluster_mapping.pop(gi.cluster)\n\n            gname = self.ttfont.getGlyphName(gi.codepoint)\n            gwidth = round(self.scale * self.ttfont[\"hmtx\"].metrics[gname][0])\n            glyph = self.subset.get_glyph(\n                glyph=gi.codepoint,\n                unicode=tuple(unicode),\n                glyph_name=gname,\n                glyph_width=gwidth,\n            )\n            if glyph is None:\n                continue\n            force_positioning = False\n            if (\n                gwidth != glyph_positions[cluster_seq].x_advance\n                or glyph_positions[cluster_seq].x_offset != 0\n                or glyph_positions[cluster_seq].y_offset != 0\n                or glyph_positions[cluster_seq].y_advance != 0\n            ):\n                force_positioning = True\n            text_info.append(\n                {\n                    \"mapped_char\": self.subset.pick_glyph(glyph),\n                    \"x_advance\": glyph_positions[cluster_seq].x_advance,\n                    \"y_advance\": glyph_positions[cluster_seq].y_advance,\n                    \"x_offset\": glyph_positions[cluster_seq].x_offset,\n                    \"y_offset\": glyph_positions[cluster_seq].y_offset,\n                    \"force_positioning\": force_positioning,\n                }\n            )\n        return text_info",
      "language": "python"
    },
    {
      "code": "class TTFFont:\n    __slots__ = (  # RAM usage optimization\n        \"i\",\n        \"type\",\n        \"name\",\n        \"desc\",\n        \"glyph_ids\",\n        \"_hbfont\",\n        \"sp\",\n        \"ss\",\n        \"up\",\n        \"ut\",\n        \"cw\",\n        \"ttffile\",\n        \"fontkey\",\n        \"emphasis\",\n        \"scale\",\n        \"subset\",\n        \"cmap\",\n        \"ttfont\",\n        \"missing_glyphs\",\n        \"biggest_size_pt\",\n        \"color_font\",\n        \"unicode_range\",\n        \"palette_index\",\n        \"is_compressed\",\n    )\n\n    def __init__(\n        self,\n        fpdf: \"FPDF\",\n        font_file_path: Path,\n        fontkey: str,\n        style: str,\n        unicode_range: Optional[set[int]] = None,\n        axes_dict: Optional[dict[str, float]] = None,\n        palette_index: Optional[int] = None,\n    ):\n        self.i = len(fpdf.fonts) + 1\n        self.type = \"TTF\"\n        self.ttffile = font_file_path\n        self.is_compressed = str(self.ttffile).lower().endswith((\".woff\", \".woff2\"))\n        self._hbfont: Optional[\"HarfBuzzFont\"] = None\n        self.fontkey = fontkey\n        self.biggest_size_pt: float = 0\n\n        # recalcTimestamp=False means that it doesn't modify the \"modified\" timestamp in head table\n        # if we leave recalcTimestamp=True the tests will break every time\n        try:\n            self.ttfont = ttLib.TTFont(\n                self.ttffile, recalcTimestamp=False, fontNumber=0, lazy=True\n            )\n        except (\n            ImportError,\n            RuntimeError,\n        ) as exc:  # pragma: no cover - defensive messaging\n            # If the user passed a WOFF2 file but brotli is not installed, fontTools\n            # raises an ImportError/RuntimeError during parsing. Provide a clearer hint\n            # only for that specific situation. Allow other exceptions (e.g. FileNotFoundError,\n            # OSError, parsing errors) to propagate normally so they aren't masked here.\n            fname_str = str(self.ttffile).lower()\n            if fname_str.endswith(\".woff2\"):\n                raise RuntimeError(\n                    \"Could not open WOFF2 font. WOFF2 support requires an external Brotli \"\n                    \"library (install 'brotli' or 'brotlicffi'). Original error: \"\n                    f\"{exc!s}\"\n                ) from exc\n            raise\n\n        if axes_dict is not None:\n            if \"fvar\" not in self.ttfont:\n                raise AttributeError(f\"{self.ttffile} is not a variable font\")\n\n            instancer.instantiateVariableFont(\n                self.ttfont,\n                axes_dict,\n                inplace=True,\n                static=True,\n            )\n        if self.is_compressed:\n            # Normalize to SFNT output for embedding and HarfBuzz.\n            self.ttfont.flavor = None\n        upem: float = float(self.ttfont[\"head\"].unitsPerEm)\n        self.scale: float = 1000 / upem\n\n        # check if the font is a TrueType and missing a .notdef glyph\n        # if it is missing, provide a fallback glyph\n        if (\n            \"glyf\" in self.ttfont\n            and \".notdef\"\n            not in self.ttfont[\"glyf\"]  # pyright: ignore[reportOperatorIssue]\n        ):\n            LOGGER.warning(\n                (\n                    \"TrueType Font '%s' is missing the '.notdef' glyph. \"\n                    \"Fallback glyph will be provided.\"\n                ),\n                self.fontkey,\n            )\n            # draw a diagonal cross .notdef glyph\n            xMin, xMax, yMin, yMax = (\n                self.ttfont[\"head\"].xMin,\n                self.ttfont[\"head\"].xMax,\n                self.ttfont[\"head\"].yMin,\n                self.ttfont[\"head\"].yMax,\n            )\n            pen = TTGlyphPen(self.ttfont[\"glyf\"])  # pyright: ignore[reportArgumentType]\n            pen.moveTo((xMin, yMin))\n            pen.lineTo((xMax, yMin))\n            pen.lineTo((xMax, yMax))\n            pen.lineTo((xMin, yMax))\n            pen.closePath()\n            pen.moveTo((xMin, yMin))\n            pen.lineTo((xMax, yMax))\n            pen.closePath()\n            pen.moveTo((xMax, yMin))\n            pen.lineTo((xMin, yMax))\n            pen.closePath()\n\n            self.ttfont[\"glyf\"][  # pyright: ignore[reportIndexIssue]\n                \".notdef\"\n            ] = pen.glyph()\n            self.ttfont[\"hmtx\"][\".notdef\"] = (  # pyright: ignore[reportIndexIssue]\n                xMax - xMin,\n                yMax - yMin,\n            )\n\n        default_width: float = round(\n            self.scale * self.ttfont[\"hmtx\"].metrics[\".notdef\"][0]\n        )\n\n        os2_table = self.ttfont[\"OS/2\"]\n        post_table = self.ttfont[\"post\"]\n\n        try:\n            cap_height = os2_table.sCapHeight\n        except AttributeError:\n            cap_height = self.ttfont[\"hhea\"].ascent\n\n        # entry for the PDF font descriptor specifying various characteristics of the font\n        flags = FontDescriptorFlags.SYMBOLIC\n        if post_table.isFixedPitch:\n            flags |= FontDescriptorFlags.FIXED_PITCH\n        if post_table.italicAngle != 0:\n            flags |= FontDescriptorFlags.ITALIC\n        if os2_table.usWeightClass >= 600:\n            flags |= FontDescriptorFlags.FORCE_BOLD\n\n        self.desc = PDFFontDescriptor(\n            ascent=round(self.ttfont[\"hhea\"].ascent * self.scale),\n            descent=round(self.ttfont[\"hhea\"].descent * self.scale),\n            cap_height=round(cap_height * self.scale),\n            flags=flags,\n            font_b_box=(\n                f\"[{self.ttfont['head'].xMin * self.scale:.0f} {self.ttfont['head'].yMin * self.scale:.0f}\"\n                f\" {self.ttfont['head'].xMax * self.scale:.0f} {self.ttfont['head'].yMax * self.scale:.0f}]\"\n            ),\n            italic_angle=int(post_table.italicAngle),\n            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),\n            missing_width=default_width,\n        )\n\n        # a map unicode_char -> char_width\n        self.cw: dict[int, float] = defaultdict(lambda: default_width)\n\n        # fonttools cmap = unicode char to glyph name\n        # saving only the keys we have a tuple with\n        # the unicode characters available on the font\n        self.cmap: dict[int, str] = self.ttfont.getBestCmap()\n        if not self.cmap:\n            raise NotImplementedError(\n                \"Font not supported as it does not have a unicode cmap table - cf. issue #1396\"\n            )\n\n        if unicode_range is not None and len(unicode_range) != 0:\n            self.cmap = {\n                codepoint: glyph_id\n                for codepoint, glyph_id in self.cmap.items()  # pyright: ignore[reportUnknownVariableType]\n                if codepoint in unicode_range\n            }\n\n        # saving a list of glyph ids to char to allow\n        # subset by unicode (regular) and by glyph\n        # (shaped with harfbuz)\n        self.glyph_ids = {}\n\n        for char in self.cmap:  # pyright: ignore[]\n            # take glyph associated to char\n            glyph = self.cmap[char]\n\n            # take width associated to glyph\n            w = self.ttfont[\"hmtx\"].metrics[glyph][0]\n\n            # probably this check could be deleted\n            if w == 65535:\n                w = 0\n\n            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP\n\n            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)\n\n        self.missing_glyphs: list[int] = []\n\n        self.name = re.sub(\"[ ()]\", \"\", self.ttfont[\"name\"].getBestFullName())\n        self.up = round(post_table.underlinePosition * self.scale)\n        self.ut = round(post_table.underlineThickness * self.scale)\n        self.sp = round(os2_table.yStrikeoutPosition * self.scale)\n        self.ss = round(os2_table.yStrikeoutSize * self.scale)\n        self.emphasis = TextEmphasis.coerce(style)\n        self.subset = SubsetMap(self)\n        self.palette_index = palette_index if palette_index is not None else 0\n        self.color_font = (\n            get_color_font_object(fpdf, self, self.palette_index)\n            if fpdf.render_color_fonts\n            else None\n        )\n\n    # pylint: disable=no-member\n    @property\n    def hbfont(self) -> \"HarfBuzzFont\":\n        if not self._hbfont:\n            if self.is_compressed:\n                # HarfBuzz cannot load compressed WOFF/WOFF2 files directly, so we\n                # re-serialize the fontTools TTFont to a raw SFNT byte buffer.\n                buf = BytesIO()\n                self.ttfont.save(buf)\n                buf.seek(0)\n                ttfont_bytes = buf.read()\n\n                # Try to create a HarfBuzz blob from bytes; if not available, write a\n                # temporary file as a last resort.\n                try:\n                    blob = hb.Blob.from_bytes(ttfont_bytes)\n                    face = hb.Face(blob)\n                except (AttributeError, RuntimeError):\n                    import tempfile, os  # pylint: disable=import-outside-toplevel\n\n                    tmp_name = None\n                    try:\n                        with tempfile.NamedTemporaryFile(\n                            suffix=\".ttf\", delete=False\n                        ) as tmp:\n                            tmp_name = tmp.name\n                            tmp.write(ttfont_bytes)\n                            tmp.flush()\n                        face = hb.Face(hb.Blob.from_file_path(tmp_name))\n                    finally:\n                        if tmp_name:\n                            try:\n                                os.unlink(tmp_name)\n                            except OSError as cleanup_error:\n                                # Log warning about failed cleanup - orphaned temp file may cause disk issues\n                                LOGGER.warning(\n                                    \"Failed to clean up temporary font file '%s': %s. This may leave an orphaned file on disk.\",\n                                    tmp_name,\n                                    cleanup_error,\n                                )\n\n                self._hbfont = HarfBuzzFont(face)\n            else:\n                # For regular TTF/OTF fonts, load directly from file path (faster)\n                self._hbfont = HarfBuzzFont(\n                    hb.Face(hb.Blob.from_file_path(self.ttffile))\n                )\n\n        return self._hbfont\n\n    def __repr__(self) -> str:\n        return f\"TTFFont(i={self.i}, fontkey={self.fontkey})\"\n\n    def __deepcopy__(self: \"TTFFont\", memo: dict[int, Any]) -> \"TTFFont\":\n        \"\"\"\n        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes\n        but instead share references to immutable objects\n        between the original FPDF instance and the FPDFRecorder instances\n        to avoid performances issues as spotted in issue #1444.\n        \"\"\"\n        copy = TTFFont.__new__(TTFFont)\n        # Immutable attributes:\n        copy.i = self.i\n        copy.type = \"TTF\"\n        copy.ttffile = self.ttffile\n        copy.fontkey = self.fontkey\n        copy.scale = self.scale\n        copy.name = self.name\n        copy.up = self.up\n        copy.ut = self.ut\n        copy.sp = self.sp\n        copy.ss = self.ss\n        copy.emphasis = self.emphasis\n        copy.is_compressed = self.is_compressed\n        # Attributes shared, to improve FPDFRecorder performances:\n        copy.ttfont = self.ttfont\n        copy.cmap = self.cmap\n        copy.desc = self.desc\n        # Attributes deepcopied:\n        copy.cw = deepcopy(self.cw, memo)\n        copy.glyph_ids = deepcopy(self.glyph_ids, memo)\n        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)\n        copy.subset = deepcopy(self.subset, memo)\n        copy.biggest_size_pt = self.biggest_size_pt\n        copy._hbfont = self._hbfont\n        copy.color_font = self.color_font\n        copy.palette_index = self.palette_index\n        return copy\n\n    def close(self) -> None:\n        self.ttfont.close()\n        self._hbfont = None\n\n    def escape_text(self, text: str) -> str:\n        if self.color_font:\n            encoded = text.encode(\"latin-1\", errors=\"replace\")\n            return escape_parens(encoded.decode(\"latin-1\", errors=\"ignore\"))\n        return escape_parens(text.encode(\"utf-16-be\").decode(\"latin-1\"))\n\n    def get_text_width(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[int, float]:\n        if font_size_pt > self.biggest_size_pt:\n            self.biggest_size_pt = font_size_pt\n        if text_shaping_params:\n            return self.shaped_text_width(text, font_size_pt, text_shaping_params)\n        return (len(text), sum(self.cw[ord(c)] for c in text) * font_size_pt * 0.001)\n\n    def shaped_text_width(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[int, float]:\n        \"\"\"\n        When texts are shaped, the length of a string is not always the sum of all individual character widths\n        This method will invoke harfbuzz to perform the text shaping and return the sum of \"x_advance\"\n        and \"x_offset\" for each glyph. This method works for \"left to right\" or \"right to left\" texts.\n        \"\"\"\n        _, glyph_positions = self.perform_harfbuzz_shaping(\n            text, font_size_pt, text_shaping_params\n        )\n\n        # If there is nothing to render (harfbuzz returns None), we return 0 text width\n        if glyph_positions is None:\n            return (0, 0)\n\n        text_width: float = 0\n        for pos in glyph_positions:\n            text_width += (\n                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001\n            )\n        return (len(glyph_positions), text_width)\n\n    # Disabling this check - looks like cython confuses pylint:\n    # pylint: disable=no-member\n    def perform_harfbuzz_shaping(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[Sequence[\"HBGlyphInfo\"], Sequence[\"HBGlyphPosition\"]]:\n        \"\"\"\n        This method invokes Harfbuzz to perform text shaping of the input string\n        \"\"\"\n        self.hbfont.ptem = font_size_pt\n        if TYPE_CHECKING:\n            buf: HBBuffer\n        buf = hb.Buffer()\n        buf.cluster_level = 1\n        buf.add_str(\"\".join(text))\n        buf.guess_segment_properties()\n        features = (\n            text_shaping_params[\"features\"] if text_shaping_params is not None else {}\n        )\n        if text_shaping_params is None:\n            text_shaping_params = {}\n        if (\n            \"fragment_direction\" in text_shaping_params\n            and text_shaping_params[\"fragment_direction\"] is not None\n        ):\n            buf.direction = text_shaping_params[\"fragment_direction\"].value\n        if (\n            \"script\" in text_shaping_params\n            and text_shaping_params[\"script\"] is not None\n        ):\n            buf.script = text_shaping_params[\"script\"]\n        if (\n            \"language\" in text_shaping_params\n            and text_shaping_params[\"language\"] is not None\n        ):\n            buf.language = text_shaping_params[\"language\"]\n        hb.shape(self.hbfont, buf, features)\n        return buf.glyph_infos, buf.glyph_positions\n\n    def encode_text(self, text: str) -> str:\n        txt_mapped = \"\"\n        for char in text:\n            uni = ord(char)\n            # Instead of adding the actual character to the stream its code is\n            # mapped to a position in the font's subset\n            mapped_char: Optional[int] = self.subset.pick(uni)\n            if mapped_char is not None:\n                txt_mapped += chr(mapped_char)\n        return f\"({self.escape_text(txt_mapped)}) Tj\"\n\n    def shape_text(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> Sequence[dict[str, Any]]:\n        \"\"\"\n        This method will invoke harfbuzz for text shaping, include the mapping code\n        of the glyphs on the subset and map input characters to the cluster codes\n        \"\"\"\n        if len(text) == 0:\n            return []\n        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(\n            text, font_size_pt, text_shaping_params\n        )\n        text_info = []\n\n        # Find cluster gaps\n        # Ex: text = \"ABCD\"\n        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph\n        # (ligature or substitution) - the glyph should have both unicodes and it should be translated\n        # properly on the CID to GID mapping\n        #\n        def get_cluster_from_text_index(cluster_list: Sequence[int], index: int) -> int:\n            pos = bisect_left(cluster_list, index)\n            if pos == 0:\n                return cluster_list[0]\n            if pos == len(cluster_list) or cluster_list[pos] != index:\n                return cluster_list[pos - 1]\n            return cluster_list[pos]\n\n        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))\n        cluster_mapping: dict[int, list[int]] = {}\n        for i in range(len(text)):\n            cl = get_cluster_from_text_index(cluster_list, i)\n            if cl in cluster_mapping:\n                cluster_mapping[cl].append(i)\n            else:\n                cluster_mapping[cl] = [i]\n\n        for cluster_seq, gi in enumerate(glyph_infos):\n            unicode = []\n            if gi.cluster in cluster_mapping:\n                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]\n                cluster_mapping.pop(gi.cluster)\n\n            gname = self.ttfont.getGlyphName(gi.codepoint)\n            gwidth = round(self.scale * self.ttfont[\"hmtx\"].metrics[gname][0])\n            glyph = self.subset.get_glyph(\n                glyph=gi.codepoint,\n                unicode=tuple(unicode),\n                glyph_name=gname,\n                glyph_width=gwidth,\n            )\n            if glyph is None:\n                continue\n            force_positioning = False\n            if (\n                gwidth != glyph_positions[cluster_seq].x_advance\n                or glyph_positions[cluster_seq].x_offset != 0\n                or glyph_positions[cluster_seq].y_offset != 0\n                or glyph_positions[cluster_seq].y_advance != 0\n            ):\n                force_positioning = True\n            text_info.append(\n                {\n                    \"mapped_char\": self.subset.pick_glyph(glyph),\n                    \"x_advance\": glyph_positions[cluster_seq].x_advance,\n                    \"y_advance\": glyph_positions[cluster_seq].y_advance,\n                    \"x_offset\": glyph_positions[cluster_seq].x_offset,\n                    \"y_offset\": glyph_positions[cluster_seq].y_offset,\n                    \"force_positioning\": force_positioning,\n                }\n            )\n        return text_info",
      "language": "python"
    },
    {
      "code": "class TTFFont:\n    __slots__ = (  # RAM usage optimization\n        \"i\",\n        \"type\",\n        \"name\",\n        \"desc\",\n        \"glyph_ids\",\n        \"_hbfont\",\n        \"sp\",\n        \"ss\",\n        \"up\",\n        \"ut\",\n        \"cw\",\n        \"ttffile\",\n        \"fontkey\",\n        \"emphasis\",\n        \"scale\",\n        \"subset\",\n        \"cmap\",\n        \"ttfont\",\n        \"missing_glyphs\",\n        \"biggest_size_pt\",\n        \"color_font\",\n        \"unicode_range\",\n        \"palette_index\",\n        \"is_compressed\",\n    )\n\n    def __init__(\n        self,\n        fpdf: \"FPDF\",\n        font_file_path: Path,\n        fontkey: str,\n        style: str,\n        unicode_range: Optional[set[int]] = None,\n        axes_dict: Optional[dict[str, float]] = None,\n        palette_index: Optional[int] = None,\n    ):\n        self.i = len(fpdf.fonts) + 1\n        self.type = \"TTF\"\n        self.ttffile = font_file_path\n        self.is_compressed = str(self.ttffile).lower().endswith((\".woff\", \".woff2\"))\n        self._hbfont: Optional[\"HarfBuzzFont\"] = None\n        self.fontkey = fontkey\n        self.biggest_size_pt: float = 0\n\n        # recalcTimestamp=False means that it doesn't modify the \"modified\" timestamp in head table\n        # if we leave recalcTimestamp=True the tests will break every time\n        try:\n            self.ttfont = ttLib.TTFont(\n                self.ttffile, recalcTimestamp=False, fontNumber=0, lazy=True\n            )\n        except (\n            ImportError,\n            RuntimeError,\n        ) as exc:  # pragma: no cover - defensive messaging\n            # If the user passed a WOFF2 file but brotli is not installed, fontTools\n            # raises an ImportError/RuntimeError during parsing. Provide a clearer hint\n            # only for that specific situation. Allow other exceptions (e.g. FileNotFoundError,\n            # OSError, parsing errors) to propagate normally so they aren't masked here.\n            fname_str = str(self.ttffile).lower()\n            if fname_str.endswith(\".woff2\"):\n                raise RuntimeError(\n                    \"Could not open WOFF2 font. WOFF2 support requires an external Brotli \"\n                    \"library (install 'brotli' or 'brotlicffi'). Original error: \"\n                    f\"{exc!s}\"\n                ) from exc\n            raise\n\n        if axes_dict is not None:\n            if \"fvar\" not in self.ttfont:\n                raise AttributeError(f\"{self.ttffile} is not a variable font\")\n\n            instancer.instantiateVariableFont(\n                self.ttfont,\n                axes_dict,\n                inplace=True,\n                static=True,\n            )\n        if self.is_compressed:\n            # Normalize to SFNT output for embedding and HarfBuzz.\n            self.ttfont.flavor = None\n        upem: float = float(self.ttfont[\"head\"].unitsPerEm)\n        self.scale: float = 1000 / upem\n\n        # check if the font is a TrueType and missing a .notdef glyph\n        # if it is missing, provide a fallback glyph\n        if (\n            \"glyf\" in self.ttfont\n            and \".notdef\"\n            not in self.ttfont[\"glyf\"]  # pyright: ignore[reportOperatorIssue]\n        ):\n            LOGGER.warning(\n                (\n                    \"TrueType Font '%s' is missing the '.notdef' glyph. \"\n                    \"Fallback glyph will be provided.\"\n                ),\n                self.fontkey,\n            )\n            # draw a diagonal cross .notdef glyph\n            xMin, xMax, yMin, yMax = (\n                self.ttfont[\"head\"].xMin,\n                self.ttfont[\"head\"].xMax,\n                self.ttfont[\"head\"].yMin,\n                self.ttfont[\"head\"].yMax,\n            )\n            pen = TTGlyphPen(self.ttfont[\"glyf\"])  # pyright: ignore[reportArgumentType]\n            pen.moveTo((xMin, yMin))\n            pen.lineTo((xMax, yMin))\n            pen.lineTo((xMax, yMax))\n            pen.lineTo((xMin, yMax))\n            pen.closePath()\n            pen.moveTo((xMin, yMin))\n            pen.lineTo((xMax, yMax))\n            pen.closePath()\n            pen.moveTo((xMax, yMin))\n            pen.lineTo((xMin, yMax))\n            pen.closePath()\n\n            self.ttfont[\"glyf\"][  # pyright: ignore[reportIndexIssue]\n                \".notdef\"\n            ] = pen.glyph()\n            self.ttfont[\"hmtx\"][\".notdef\"] = (  # pyright: ignore[reportIndexIssue]\n                xMax - xMin,\n                yMax - yMin,\n            )\n\n        default_width: float = round(\n            self.scale * self.ttfont[\"hmtx\"].metrics[\".notdef\"][0]\n        )\n\n        os2_table = self.ttfont[\"OS/2\"]\n        post_table = self.ttfont[\"post\"]\n\n        try:\n            cap_height = os2_table.sCapHeight\n        except AttributeError:\n            cap_height = self.ttfont[\"hhea\"].ascent\n\n        # entry for the PDF font descriptor specifying various characteristics of the font\n        flags = FontDescriptorFlags.SYMBOLIC\n        if post_table.isFixedPitch:\n            flags |= FontDescriptorFlags.FIXED_PITCH\n        if post_table.italicAngle != 0:\n            flags |= FontDescriptorFlags.ITALIC\n        if os2_table.usWeightClass >= 600:\n            flags |= FontDescriptorFlags.FORCE_BOLD\n\n        self.desc = PDFFontDescriptor(\n            ascent=round(self.ttfont[\"hhea\"].ascent * self.scale),\n            descent=round(self.ttfont[\"hhea\"].descent * self.scale),\n            cap_height=round(cap_height * self.scale),\n            flags=flags,\n            font_b_box=(\n                f\"[{self.ttfont['head'].xMin * self.scale:.0f} {self.ttfont['head'].yMin * self.scale:.0f}\"\n                f\" {self.ttfont['head'].xMax * self.scale:.0f} {self.ttfont['head'].yMax * self.scale:.0f}]\"\n            ),\n            italic_angle=int(post_table.italicAngle),\n            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),\n            missing_width=default_width,\n        )\n\n        # a map unicode_char -> char_width\n        self.cw: dict[int, float] = defaultdict(lambda: default_width)\n\n        # fonttools cmap = unicode char to glyph name\n        # saving only the keys we have a tuple with\n        # the unicode characters available on the font\n        self.cmap: dict[int, str] = self.ttfont.getBestCmap()\n        if not self.cmap:\n            raise NotImplementedError(\n                \"Font not supported as it does not have a unicode cmap table - cf. issue #1396\"\n            )\n\n        if unicode_range is not None and len(unicode_range) != 0:\n            self.cmap = {\n                codepoint: glyph_id\n                for codepoint, glyph_id in self.cmap.items()  # pyright: ignore[reportUnknownVariableType]\n                if codepoint in unicode_range\n            }\n\n        # saving a list of glyph ids to char to allow\n        # subset by unicode (regular) and by glyph\n        # (shaped with harfbuz)\n        self.glyph_ids = {}\n\n        for char in self.cmap:  # pyright: ignore[]\n            # take glyph associated to char\n            glyph = self.cmap[char]\n\n            # take width associated to glyph\n            w = self.ttfont[\"hmtx\"].metrics[glyph][0]\n\n            # probably this check could be deleted\n            if w == 65535:\n                w = 0\n\n            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP\n\n            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)\n\n        self.missing_glyphs: list[int] = []\n\n        self.name = re.sub(\"[ ()]\", \"\", self.ttfont[\"name\"].getBestFullName())\n        self.up = round(post_table.underlinePosition * self.scale)\n        self.ut = round(post_table.underlineThickness * self.scale)\n        self.sp = round(os2_table.yStrikeoutPosition * self.scale)\n        self.ss = round(os2_table.yStrikeoutSize * self.scale)\n        self.emphasis = TextEmphasis.coerce(style)\n        self.subset = SubsetMap(self)\n        self.palette_index = palette_index if palette_index is not None else 0\n        self.color_font = (\n            get_color_font_object(fpdf, self, self.palette_index)\n            if fpdf.render_color_fonts\n            else None\n        )\n\n    # pylint: disable=no-member\n    @property\n    def hbfont(self) -> \"HarfBuzzFont\":\n        if not self._hbfont:\n            if self.is_compressed:\n                # HarfBuzz cannot load compressed WOFF/WOFF2 files directly, so we\n                # re-serialize the fontTools TTFont to a raw SFNT byte buffer.\n                buf = BytesIO()\n                self.ttfont.save(buf)\n                buf.seek(0)\n                ttfont_bytes = buf.read()\n\n                # Try to create a HarfBuzz blob from bytes; if not available, write a\n                # temporary file as a last resort.\n                try:\n                    blob = hb.Blob.from_bytes(ttfont_bytes)\n                    face = hb.Face(blob)\n                except (AttributeError, RuntimeError):\n                    import tempfile, os  # pylint: disable=import-outside-toplevel\n\n                    tmp_name = None\n                    try:\n                        with tempfile.NamedTemporaryFile(\n                            suffix=\".ttf\", delete=False\n                        ) as tmp:\n                            tmp_name = tmp.name\n                            tmp.write(ttfont_bytes)\n                            tmp.flush()\n                        face = hb.Face(hb.Blob.from_file_path(tmp_name))\n                    finally:\n                        if tmp_name:\n                            try:\n                                os.unlink(tmp_name)\n                            except OSError as cleanup_error:\n                                # Log warning about failed cleanup - orphaned temp file may cause disk issues\n                                LOGGER.warning(\n                                    \"Failed to clean up temporary font file '%s': %s. This may leave an orphaned file on disk.\",\n                                    tmp_name,\n                                    cleanup_error,\n                                )\n\n                self._hbfont = HarfBuzzFont(face)\n            else:\n                # For regular TTF/OTF fonts, load directly from file path (faster)\n                self._hbfont = HarfBuzzFont(\n                    hb.Face(hb.Blob.from_file_path(self.ttffile))\n                )\n\n        return self._hbfont\n\n    def __repr__(self) -> str:\n        return f\"TTFFont(i={self.i}, fontkey={self.fontkey})\"\n\n    def __deepcopy__(self: \"TTFFont\", memo: dict[int, Any]) -> \"TTFFont\":\n        \"\"\"\n        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes\n        but instead share references to immutable objects\n        between the original FPDF instance and the FPDFRecorder instances\n        to avoid performances issues as spotted in issue #1444.\n        \"\"\"\n        copy = TTFFont.__new__(TTFFont)\n        # Immutable attributes:\n        copy.i = self.i\n        copy.type = \"TTF\"\n        copy.ttffile = self.ttffile\n        copy.fontkey = self.fontkey\n        copy.scale = self.scale\n        copy.name = self.name\n        copy.up = self.up\n        copy.ut = self.ut\n        copy.sp = self.sp\n        copy.ss = self.ss\n        copy.emphasis = self.emphasis\n        copy.is_compressed = self.is_compressed\n        # Attributes shared, to improve FPDFRecorder performances:\n        copy.ttfont = self.ttfont\n        copy.cmap = self.cmap\n        copy.desc = self.desc\n        # Attributes deepcopied:\n        copy.cw = deepcopy(self.cw, memo)\n        copy.glyph_ids = deepcopy(self.glyph_ids, memo)\n        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)\n        copy.subset = deepcopy(self.subset, memo)\n        copy.biggest_size_pt = self.biggest_size_pt\n        copy._hbfont = self._hbfont\n        copy.color_font = self.color_font\n        copy.palette_index = self.palette_index\n        return copy\n\n    def close(self) -> None:\n        self.ttfont.close()\n        self._hbfont = None\n\n    def escape_text(self, text: str) -> str:\n        if self.color_font:\n            encoded = text.encode(\"latin-1\", errors=\"replace\")\n            return escape_parens(encoded.decode(\"latin-1\", errors=\"ignore\"))\n        return escape_parens(text.encode(\"utf-16-be\").decode(\"latin-1\"))\n\n    def get_text_width(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[int, float]:\n        if font_size_pt > self.biggest_size_pt:\n            self.biggest_size_pt = font_size_pt\n        if text_shaping_params:\n            return self.shaped_text_width(text, font_size_pt, text_shaping_params)\n        return (len(text), sum(self.cw[ord(c)] for c in text) * font_size_pt * 0.001)\n\n    def shaped_text_width(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[int, float]:\n        \"\"\"\n        When texts are shaped, the length of a string is not always the sum of all individual character widths\n        This method will invoke harfbuzz to perform the text shaping and return the sum of \"x_advance\"\n        and \"x_offset\" for each glyph. This method works for \"left to right\" or \"right to left\" texts.\n        \"\"\"\n        _, glyph_positions = self.perform_harfbuzz_shaping(\n            text, font_size_pt, text_shaping_params\n        )\n\n        # If there is nothing to render (harfbuzz returns None), we return 0 text width\n        if glyph_positions is None:\n            return (0, 0)\n\n        text_width: float = 0\n        for pos in glyph_positions:\n            text_width += (\n                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001\n            )\n        return (len(glyph_positions), text_width)\n\n    # Disabling this check - looks like cython confuses pylint:\n    # pylint: disable=no-member\n    def perform_harfbuzz_shaping(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[Sequence[\"HBGlyphInfo\"], Sequence[\"HBGlyphPosition\"]]:\n        \"\"\"\n        This method invokes Harfbuzz to perform text shaping of the input string\n        \"\"\"\n        self.hbfont.ptem = font_size_pt\n        if TYPE_CHECKING:\n            buf: HBBuffer\n        buf = hb.Buffer()\n        buf.cluster_level = 1\n        buf.add_str(\"\".join(text))\n        buf.guess_segment_properties()\n        features = (\n            text_shaping_params[\"features\"] if text_shaping_params is not None else {}\n        )\n        if text_shaping_params is None:\n            text_shaping_params = {}\n        if (\n            \"fragment_direction\" in text_shaping_params\n            and text_shaping_params[\"fragment_direction\"] is not None\n        ):\n            buf.direction = text_shaping_params[\"fragment_direction\"].value\n        if (\n            \"script\" in text_shaping_params\n            and text_shaping_params[\"script\"] is not None\n        ):\n            buf.script = text_shaping_params[\"script\"]\n        if (\n            \"language\" in text_shaping_params\n            and text_shaping_params[\"language\"] is not None\n        ):\n            buf.language = text_shaping_params[\"language\"]\n        hb.shape(self.hbfont, buf, features)\n        return buf.glyph_infos, buf.glyph_positions\n\n    def encode_text(self, text: str) -> str:\n        txt_mapped = \"\"\n        for char in text:\n            uni = ord(char)\n            # Instead of adding the actual character to the stream its code is\n            # mapped to a position in the font's subset\n            mapped_char: Optional[int] = self.subset.pick(uni)\n            if mapped_char is not None:\n                txt_mapped += chr(mapped_char)\n        return f\"({self.escape_text(txt_mapped)}) Tj\"\n\n    def shape_text(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> Sequence[dict[str, Any]]:\n        \"\"\"\n        This method will invoke harfbuzz for text shaping, include the mapping code\n        of the glyphs on the subset and map input characters to the cluster codes\n        \"\"\"\n        if len(text) == 0:\n            return []\n        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(\n            text, font_size_pt, text_shaping_params\n        )\n        text_info = []\n\n        # Find cluster gaps\n        # Ex: text = \"ABCD\"\n        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph\n        # (ligature or substitution) - the glyph should have both unicodes and it should be translated\n        # properly on the CID to GID mapping\n        #\n        def get_cluster_from_text_index(cluster_list: Sequence[int], index: int) -> int:\n            pos = bisect_left(cluster_list, index)\n            if pos == 0:\n                return cluster_list[0]\n            if pos == len(cluster_list) or cluster_list[pos] != index:\n                return cluster_list[pos - 1]\n            return cluster_list[pos]\n\n        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))\n        cluster_mapping: dict[int, list[int]] = {}\n        for i in range(len(text)):\n            cl = get_cluster_from_text_index(cluster_list, i)\n            if cl in cluster_mapping:\n                cluster_mapping[cl].append(i)\n            else:\n                cluster_mapping[cl] = [i]\n\n        for cluster_seq, gi in enumerate(glyph_infos):\n            unicode = []\n            if gi.cluster in cluster_mapping:\n                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]\n                cluster_mapping.pop(gi.cluster)\n\n            gname = self.ttfont.getGlyphName(gi.codepoint)\n            gwidth = round(self.scale * self.ttfont[\"hmtx\"].metrics[gname][0])\n            glyph = self.subset.get_glyph(\n                glyph=gi.codepoint,\n                unicode=tuple(unicode),\n                glyph_name=gname,\n                glyph_width=gwidth,\n            )\n            if glyph is None:\n                continue\n            force_positioning = False\n            if (\n                gwidth != glyph_positions[cluster_seq].x_advance\n                or glyph_positions[cluster_seq].x_offset != 0\n                or glyph_positions[cluster_seq].y_offset != 0\n                or glyph_positions[cluster_seq].y_advance != 0\n            ):\n                force_positioning = True\n            text_info.append(\n                {\n                    \"mapped_char\": self.subset.pick_glyph(glyph),\n                    \"x_advance\": glyph_positions[cluster_seq].x_advance,\n                    \"y_advance\": glyph_positions[cluster_seq].y_advance,\n                    \"x_offset\": glyph_positions[cluster_seq].x_offset,\n                    \"y_offset\": glyph_positions[cluster_seq].y_offset,\n                    \"force_positioning\": force_positioning,\n                }\n            )\n        return text_info",
      "language": "python"
    },
    {
      "code": "class TTFFont:\n    __slots__ = (  # RAM usage optimization\n        \"i\",\n        \"type\",\n        \"name\",\n        \"desc\",\n        \"glyph_ids\",\n        \"_hbfont\",\n        \"sp\",\n        \"ss\",\n        \"up\",\n        \"ut\",\n        \"cw\",\n        \"ttffile\",\n        \"fontkey\",\n        \"emphasis\",\n        \"scale\",\n        \"subset\",\n        \"cmap\",\n        \"ttfont\",\n        \"missing_glyphs\",\n        \"biggest_size_pt\",\n        \"color_font\",\n        \"unicode_range\",\n        \"palette_index\",\n        \"is_compressed\",\n    )\n\n    def __init__(\n        self,\n        fpdf: \"FPDF\",\n        font_file_path: Path,\n        fontkey: str,\n        style: str,\n        unicode_range: Optional[set[int]] = None,\n        axes_dict: Optional[dict[str, float]] = None,\n        palette_index: Optional[int] = None,\n    ):\n        self.i = len(fpdf.fonts) + 1\n        self.type = \"TTF\"\n        self.ttffile = font_file_path\n        self.is_compressed = str(self.ttffile).lower().endswith((\".woff\", \".woff2\"))\n        self._hbfont: Optional[\"HarfBuzzFont\"] = None\n        self.fontkey = fontkey\n        self.biggest_size_pt: float = 0\n\n        # recalcTimestamp=False means that it doesn't modify the \"modified\" timestamp in head table\n        # if we leave recalcTimestamp=True the tests will break every time\n        try:\n            self.ttfont = ttLib.TTFont(\n                self.ttffile, recalcTimestamp=False, fontNumber=0, lazy=True\n            )\n        except (\n            ImportError,\n            RuntimeError,\n        ) as exc:  # pragma: no cover - defensive messaging\n            # If the user passed a WOFF2 file but brotli is not installed, fontTools\n            # raises an ImportError/RuntimeError during parsing. Provide a clearer hint\n            # only for that specific situation. Allow other exceptions (e.g. FileNotFoundError,\n            # OSError, parsing errors) to propagate normally so they aren't masked here.\n            fname_str = str(self.ttffile).lower()\n            if fname_str.endswith(\".woff2\"):\n                raise RuntimeError(\n                    \"Could not open WOFF2 font. WOFF2 support requires an external Brotli \"\n                    \"library (install 'brotli' or 'brotlicffi'). Original error: \"\n                    f\"{exc!s}\"\n                ) from exc\n            raise\n\n        if axes_dict is not None:\n            if \"fvar\" not in self.ttfont:\n                raise AttributeError(f\"{self.ttffile} is not a variable font\")\n\n            instancer.instantiateVariableFont(\n                self.ttfont,\n                axes_dict,\n                inplace=True,\n                static=True,\n            )\n        if self.is_compressed:\n            # Normalize to SFNT output for embedding and HarfBuzz.\n            self.ttfont.flavor = None\n        upem: float = float(self.ttfont[\"head\"].unitsPerEm)\n        self.scale: float = 1000 / upem\n\n        # check if the font is a TrueType and missing a .notdef glyph\n        # if it is missing, provide a fallback glyph\n        if (\n            \"glyf\" in self.ttfont\n            and \".notdef\"\n            not in self.ttfont[\"glyf\"]  # pyright: ignore[reportOperatorIssue]\n        ):\n            LOGGER.warning(\n                (\n                    \"TrueType Font '%s' is missing the '.notdef' glyph. \"\n                    \"Fallback glyph will be provided.\"\n                ),\n                self.fontkey,\n            )\n            # draw a diagonal cross .notdef glyph\n            xMin, xMax, yMin, yMax = (\n                self.ttfont[\"head\"].xMin,\n                self.ttfont[\"head\"].xMax,\n                self.ttfont[\"head\"].yMin,\n                self.ttfont[\"head\"].yMax,\n            )\n            pen = TTGlyphPen(self.ttfont[\"glyf\"])  # pyright: ignore[reportArgumentType]\n            pen.moveTo((xMin, yMin))\n            pen.lineTo((xMax, yMin))\n            pen.lineTo((xMax, yMax))\n            pen.lineTo((xMin, yMax))\n            pen.closePath()\n            pen.moveTo((xMin, yMin))\n            pen.lineTo((xMax, yMax))\n            pen.closePath()\n            pen.moveTo((xMax, yMin))\n            pen.lineTo((xMin, yMax))\n            pen.closePath()\n\n            self.ttfont[\"glyf\"][  # pyright: ignore[reportIndexIssue]\n                \".notdef\"\n            ] = pen.glyph()\n            self.ttfont[\"hmtx\"][\".notdef\"] = (  # pyright: ignore[reportIndexIssue]\n                xMax - xMin,\n                yMax - yMin,\n            )\n\n        default_width: float = round(\n            self.scale * self.ttfont[\"hmtx\"].metrics[\".notdef\"][0]\n        )\n\n        os2_table = self.ttfont[\"OS/2\"]\n        post_table = self.ttfont[\"post\"]\n\n        try:\n            cap_height = os2_table.sCapHeight\n        except AttributeError:\n            cap_height = self.ttfont[\"hhea\"].ascent\n\n        # entry for the PDF font descriptor specifying various characteristics of the font\n        flags = FontDescriptorFlags.SYMBOLIC\n        if post_table.isFixedPitch:\n            flags |= FontDescriptorFlags.FIXED_PITCH\n        if post_table.italicAngle != 0:\n            flags |= FontDescriptorFlags.ITALIC\n        if os2_table.usWeightClass >= 600:\n            flags |= FontDescriptorFlags.FORCE_BOLD\n\n        self.desc = PDFFontDescriptor(\n            ascent=round(self.ttfont[\"hhea\"].ascent * self.scale),\n            descent=round(self.ttfont[\"hhea\"].descent * self.scale),\n            cap_height=round(cap_height * self.scale),\n            flags=flags,\n            font_b_box=(\n                f\"[{self.ttfont['head'].xMin * self.scale:.0f} {self.ttfont['head'].yMin * self.scale:.0f}\"\n                f\" {self.ttfont['head'].xMax * self.scale:.0f} {self.ttfont['head'].yMax * self.scale:.0f}]\"\n            ),\n            italic_angle=int(post_table.italicAngle),\n            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),\n            missing_width=default_width,\n        )\n\n        # a map unicode_char -> char_width\n        self.cw: dict[int, float] = defaultdict(lambda: default_width)\n\n        # fonttools cmap = unicode char to glyph name\n        # saving only the keys we have a tuple with\n        # the unicode characters available on the font\n        self.cmap: dict[int, str] = self.ttfont.getBestCmap()\n        if not self.cmap:\n            raise NotImplementedError(\n                \"Font not supported as it does not have a unicode cmap table - cf. issue #1396\"\n            )\n\n        if unicode_range is not None and len(unicode_range) != 0:\n            self.cmap = {\n                codepoint: glyph_id\n                for codepoint, glyph_id in self.cmap.items()  # pyright: ignore[reportUnknownVariableType]\n                if codepoint in unicode_range\n            }\n\n        # saving a list of glyph ids to char to allow\n        # subset by unicode (regular) and by glyph\n        # (shaped with harfbuz)\n        self.glyph_ids = {}\n\n        for char in self.cmap:  # pyright: ignore[]\n            # take glyph associated to char\n            glyph = self.cmap[char]\n\n            # take width associated to glyph\n            w = self.ttfont[\"hmtx\"].metrics[glyph][0]\n\n            # probably this check could be deleted\n            if w == 65535:\n                w = 0\n\n            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP\n\n            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)\n\n        self.missing_glyphs: list[int] = []\n\n        self.name = re.sub(\"[ ()]\", \"\", self.ttfont[\"name\"].getBestFullName())\n        self.up = round(post_table.underlinePosition * self.scale)\n        self.ut = round(post_table.underlineThickness * self.scale)\n        self.sp = round(os2_table.yStrikeoutPosition * self.scale)\n        self.ss = round(os2_table.yStrikeoutSize * self.scale)\n        self.emphasis = TextEmphasis.coerce(style)\n        self.subset = SubsetMap(self)\n        self.palette_index = palette_index if palette_index is not None else 0\n        self.color_font = (\n            get_color_font_object(fpdf, self, self.palette_index)\n            if fpdf.render_color_fonts\n            else None\n        )\n\n    # pylint: disable=no-member\n    @property\n    def hbfont(self) -> \"HarfBuzzFont\":\n        if not self._hbfont:\n            if self.is_compressed:\n                # HarfBuzz cannot load compressed WOFF/WOFF2 files directly, so we\n                # re-serialize the fontTools TTFont to a raw SFNT byte buffer.\n                buf = BytesIO()\n                self.ttfont.save(buf)\n                buf.seek(0)\n                ttfont_bytes = buf.read()\n\n                # Try to create a HarfBuzz blob from bytes; if not available, write a\n                # temporary file as a last resort.\n                try:\n                    blob = hb.Blob.from_bytes(ttfont_bytes)\n                    face = hb.Face(blob)\n                except (AttributeError, RuntimeError):\n                    import tempfile, os  # pylint: disable=import-outside-toplevel\n\n                    tmp_name = None\n                    try:\n                        with tempfile.NamedTemporaryFile(\n                            suffix=\".ttf\", delete=False\n                        ) as tmp:\n                            tmp_name = tmp.name\n                            tmp.write(ttfont_bytes)\n                            tmp.flush()\n                        face = hb.Face(hb.Blob.from_file_path(tmp_name))\n                    finally:\n                        if tmp_name:\n                            try:\n                                os.unlink(tmp_name)\n                            except OSError as cleanup_error:\n                                # Log warning about failed cleanup - orphaned temp file may cause disk issues\n                                LOGGER.warning(\n                                    \"Failed to clean up temporary font file '%s': %s. This may leave an orphaned file on disk.\",\n                                    tmp_name,\n                                    cleanup_error,\n                                )\n\n                self._hbfont = HarfBuzzFont(face)\n            else:\n                # For regular TTF/OTF fonts, load directly from file path (faster)\n                self._hbfont = HarfBuzzFont(\n                    hb.Face(hb.Blob.from_file_path(self.ttffile))\n                )\n\n        return self._hbfont\n\n    def __repr__(self) -> str:\n        return f\"TTFFont(i={self.i}, fontkey={self.fontkey})\"\n\n    def __deepcopy__(self: \"TTFFont\", memo: dict[int, Any]) -> \"TTFFont\":\n        \"\"\"\n        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes\n        but instead share references to immutable objects\n        between the original FPDF instance and the FPDFRecorder instances\n        to avoid performances issues as spotted in issue #1444.\n        \"\"\"\n        copy = TTFFont.__new__(TTFFont)\n        # Immutable attributes:\n        copy.i = self.i\n        copy.type = \"TTF\"\n        copy.ttffile = self.ttffile\n        copy.fontkey = self.fontkey\n        copy.scale = self.scale\n        copy.name = self.name\n        copy.up = self.up\n        copy.ut = self.ut\n        copy.sp = self.sp\n        copy.ss = self.ss\n        copy.emphasis = self.emphasis\n        copy.is_compressed = self.is_compressed\n        # Attributes shared, to improve FPDFRecorder performances:\n        copy.ttfont = self.ttfont\n        copy.cmap = self.cmap\n        copy.desc = self.desc\n        # Attributes deepcopied:\n        copy.cw = deepcopy(self.cw, memo)\n        copy.glyph_ids = deepcopy(self.glyph_ids, memo)\n        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)\n        copy.subset = deepcopy(self.subset, memo)\n        copy.biggest_size_pt = self.biggest_size_pt\n        copy._hbfont = self._hbfont\n        copy.color_font = self.color_font\n        copy.palette_index = self.palette_index\n        return copy\n\n    def close(self) -> None:\n        self.ttfont.close()\n        self._hbfont = None\n\n    def escape_text(self, text: str) -> str:\n        if self.color_font:\n            encoded = text.encode(\"latin-1\", errors=\"replace\")\n            return escape_parens(encoded.decode(\"latin-1\", errors=\"ignore\"))\n        return escape_parens(text.encode(\"utf-16-be\").decode(\"latin-1\"))\n\n    def get_text_width(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[int, float]:\n        if font_size_pt > self.biggest_size_pt:\n            self.biggest_size_pt = font_size_pt\n        if text_shaping_params:\n            return self.shaped_text_width(text, font_size_pt, text_shaping_params)\n        return (len(text), sum(self.cw[ord(c)] for c in text) * font_size_pt * 0.001)\n\n    def shaped_text_width(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[int, float]:\n        \"\"\"\n        When texts are shaped, the length of a string is not always the sum of all individual character widths\n        This method will invoke harfbuzz to perform the text shaping and return the sum of \"x_advance\"\n        and \"x_offset\" for each glyph. This method works for \"left to right\" or \"right to left\" texts.\n        \"\"\"\n        _, glyph_positions = self.perform_harfbuzz_shaping(\n            text, font_size_pt, text_shaping_params\n        )\n\n        # If there is nothing to render (harfbuzz returns None), we return 0 text width\n        if glyph_positions is None:\n            return (0, 0)\n\n        text_width: float = 0\n        for pos in glyph_positions:\n            text_width += (\n                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001\n            )\n        return (len(glyph_positions), text_width)\n\n    # Disabling this check - looks like cython confuses pylint:\n    # pylint: disable=no-member\n    def perform_harfbuzz_shaping(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[Sequence[\"HBGlyphInfo\"], Sequence[\"HBGlyphPosition\"]]:\n        \"\"\"\n        This method invokes Harfbuzz to perform text shaping of the input string\n        \"\"\"\n        self.hbfont.ptem = font_size_pt\n        if TYPE_CHECKING:\n            buf: HBBuffer\n        buf = hb.Buffer()\n        buf.cluster_level = 1\n        buf.add_str(\"\".join(text))\n        buf.guess_segment_properties()\n        features = (\n            text_shaping_params[\"features\"] if text_shaping_params is not None else {}\n        )\n        if text_shaping_params is None:\n            text_shaping_params = {}\n        if (\n            \"fragment_direction\" in text_shaping_params\n            and text_shaping_params[\"fragment_direction\"] is not None\n        ):\n            buf.direction = text_shaping_params[\"fragment_direction\"].value\n        if (\n            \"script\" in text_shaping_params\n            and text_shaping_params[\"script\"] is not None\n        ):\n            buf.script = text_shaping_params[\"script\"]\n        if (\n            \"language\" in text_shaping_params\n            and text_shaping_params[\"language\"] is not None\n        ):\n            buf.language = text_shaping_params[\"language\"]\n        hb.shape(self.hbfont, buf, features)\n        return buf.glyph_infos, buf.glyph_positions\n\n    def encode_text(self, text: str) -> str:\n        txt_mapped = \"\"\n        for char in text:\n            uni = ord(char)\n            # Instead of adding the actual character to the stream its code is\n            # mapped to a position in the font's subset\n            mapped_char: Optional[int] = self.subset.pick(uni)\n            if mapped_char is not None:\n                txt_mapped += chr(mapped_char)\n        return f\"({self.escape_text(txt_mapped)}) Tj\"\n\n    def shape_text(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> Sequence[dict[str, Any]]:\n        \"\"\"\n        This method will invoke harfbuzz for text shaping, include the mapping code\n        of the glyphs on the subset and map input characters to the cluster codes\n        \"\"\"\n        if len(text) == 0:\n            return []\n        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(\n            text, font_size_pt, text_shaping_params\n        )\n        text_info = []\n\n        # Find cluster gaps\n        # Ex: text = \"ABCD\"\n        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph\n        # (ligature or substitution) - the glyph should have both unicodes and it should be translated\n        # properly on the CID to GID mapping\n        #\n        def get_cluster_from_text_index(cluster_list: Sequence[int], index: int) -> int:\n            pos = bisect_left(cluster_list, index)\n            if pos == 0:\n                return cluster_list[0]\n            if pos == len(cluster_list) or cluster_list[pos] != index:\n                return cluster_list[pos - 1]\n            return cluster_list[pos]\n\n        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))\n        cluster_mapping: dict[int, list[int]] = {}\n        for i in range(len(text)):\n            cl = get_cluster_from_text_index(cluster_list, i)\n            if cl in cluster_mapping:\n                cluster_mapping[cl].append(i)\n            else:\n                cluster_mapping[cl] = [i]\n\n        for cluster_seq, gi in enumerate(glyph_infos):\n            unicode = []\n            if gi.cluster in cluster_mapping:\n                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]\n                cluster_mapping.pop(gi.cluster)\n\n            gname = self.ttfont.getGlyphName(gi.codepoint)\n            gwidth = round(self.scale * self.ttfont[\"hmtx\"].metrics[gname][0])\n            glyph = self.subset.get_glyph(\n                glyph=gi.codepoint,\n                unicode=tuple(unicode),\n                glyph_name=gname,\n                glyph_width=gwidth,\n            )\n            if glyph is None:\n                continue\n            force_positioning = False\n            if (\n                gwidth != glyph_positions[cluster_seq].x_advance\n                or glyph_positions[cluster_seq].x_offset != 0\n                or glyph_positions[cluster_seq].y_offset != 0\n                or glyph_positions[cluster_seq].y_advance != 0\n            ):\n                force_positioning = True\n            text_info.append(\n                {\n                    \"mapped_char\": self.subset.pick_glyph(glyph),\n                    \"x_advance\": glyph_positions[cluster_seq].x_advance,\n                    \"y_advance\": glyph_positions[cluster_seq].y_advance,\n                    \"x_offset\": glyph_positions[cluster_seq].x_offset,\n                    \"y_offset\": glyph_positions[cluster_seq].y_offset,\n                    \"force_positioning\": force_positioning,\n                }\n            )\n        return text_info",
      "language": "python"
    },
    {
      "code": "class TTFFont:\n    __slots__ = (  # RAM usage optimization\n        \"i\",\n        \"type\",\n        \"name\",\n        \"desc\",\n        \"glyph_ids\",\n        \"_hbfont\",\n        \"sp\",\n        \"ss\",\n        \"up\",\n        \"ut\",\n        \"cw\",\n        \"ttffile\",\n        \"fontkey\",\n        \"emphasis\",\n        \"scale\",\n        \"subset\",\n        \"cmap\",\n        \"ttfont\",\n        \"missing_glyphs\",\n        \"biggest_size_pt\",\n        \"color_font\",\n        \"unicode_range\",\n        \"palette_index\",\n        \"is_compressed\",\n    )\n\n    def __init__(\n        self,\n        fpdf: \"FPDF\",\n        font_file_path: Path,\n        fontkey: str,\n        style: str,\n        unicode_range: Optional[set[int]] = None,\n        axes_dict: Optional[dict[str, float]] = None,\n        palette_index: Optional[int] = None,\n    ):\n        self.i = len(fpdf.fonts) + 1\n        self.type = \"TTF\"\n        self.ttffile = font_file_path\n        self.is_compressed = str(self.ttffile).lower().endswith((\".woff\", \".woff2\"))\n        self._hbfont: Optional[\"HarfBuzzFont\"] = None\n        self.fontkey = fontkey\n        self.biggest_size_pt: float = 0\n\n        # recalcTimestamp=False means that it doesn't modify the \"modified\" timestamp in head table\n        # if we leave recalcTimestamp=True the tests will break every time\n        try:\n            self.ttfont = ttLib.TTFont(\n                self.ttffile, recalcTimestamp=False, fontNumber=0, lazy=True\n            )\n        except (\n            ImportError,\n            RuntimeError,\n        ) as exc:  # pragma: no cover - defensive messaging\n            # If the user passed a WOFF2 file but brotli is not installed, fontTools\n            # raises an ImportError/RuntimeError during parsing. Provide a clearer hint\n            # only for that specific situation. Allow other exceptions (e.g. FileNotFoundError,\n            # OSError, parsing errors) to propagate normally so they aren't masked here.\n            fname_str = str(self.ttffile).lower()\n            if fname_str.endswith(\".woff2\"):\n                raise RuntimeError(\n                    \"Could not open WOFF2 font. WOFF2 support requires an external Brotli \"\n                    \"library (install 'brotli' or 'brotlicffi'). Original error: \"\n                    f\"{exc!s}\"\n                ) from exc\n            raise\n\n        if axes_dict is not None:\n            if \"fvar\" not in self.ttfont:\n                raise AttributeError(f\"{self.ttffile} is not a variable font\")\n\n            instancer.instantiateVariableFont(\n                self.ttfont,\n                axes_dict,\n                inplace=True,\n                static=True,\n            )\n        if self.is_compressed:\n            # Normalize to SFNT output for embedding and HarfBuzz.\n            self.ttfont.flavor = None\n        upem: float = float(self.ttfont[\"head\"].unitsPerEm)\n        self.scale: float = 1000 / upem\n\n        # check if the font is a TrueType and missing a .notdef glyph\n        # if it is missing, provide a fallback glyph\n        if (\n            \"glyf\" in self.ttfont\n            and \".notdef\"\n            not in self.ttfont[\"glyf\"]  # pyright: ignore[reportOperatorIssue]\n        ):\n            LOGGER.warning(\n                (\n                    \"TrueType Font '%s' is missing the '.notdef' glyph. \"\n                    \"Fallback glyph will be provided.\"\n                ),\n                self.fontkey,\n            )\n            # draw a diagonal cross .notdef glyph\n            xMin, xMax, yMin, yMax = (\n                self.ttfont[\"head\"].xMin,\n                self.ttfont[\"head\"].xMax,\n                self.ttfont[\"head\"].yMin,\n                self.ttfont[\"head\"].yMax,\n            )\n            pen = TTGlyphPen(self.ttfont[\"glyf\"])  # pyright: ignore[reportArgumentType]\n            pen.moveTo((xMin, yMin))\n            pen.lineTo((xMax, yMin))\n            pen.lineTo((xMax, yMax))\n            pen.lineTo((xMin, yMax))\n            pen.closePath()\n            pen.moveTo((xMin, yMin))\n            pen.lineTo((xMax, yMax))\n            pen.closePath()\n            pen.moveTo((xMax, yMin))\n            pen.lineTo((xMin, yMax))\n            pen.closePath()\n\n            self.ttfont[\"glyf\"][  # pyright: ignore[reportIndexIssue]\n                \".notdef\"\n            ] = pen.glyph()\n            self.ttfont[\"hmtx\"][\".notdef\"] = (  # pyright: ignore[reportIndexIssue]\n                xMax - xMin,\n                yMax - yMin,\n            )\n\n        default_width: float = round(\n            self.scale * self.ttfont[\"hmtx\"].metrics[\".notdef\"][0]\n        )\n\n        os2_table = self.ttfont[\"OS/2\"]\n        post_table = self.ttfont[\"post\"]\n\n        try:\n            cap_height = os2_table.sCapHeight\n        except AttributeError:\n            cap_height = self.ttfont[\"hhea\"].ascent\n\n        # entry for the PDF font descriptor specifying various characteristics of the font\n        flags = FontDescriptorFlags.SYMBOLIC\n        if post_table.isFixedPitch:\n            flags |= FontDescriptorFlags.FIXED_PITCH\n        if post_table.italicAngle != 0:\n            flags |= FontDescriptorFlags.ITALIC\n        if os2_table.usWeightClass >= 600:\n            flags |= FontDescriptorFlags.FORCE_BOLD\n\n        self.desc = PDFFontDescriptor(\n            ascent=round(self.ttfont[\"hhea\"].ascent * self.scale),\n            descent=round(self.ttfont[\"hhea\"].descent * self.scale),\n            cap_height=round(cap_height * self.scale),\n            flags=flags,\n            font_b_box=(\n                f\"[{self.ttfont['head'].xMin * self.scale:.0f} {self.ttfont['head'].yMin * self.scale:.0f}\"\n                f\" {self.ttfont['head'].xMax * self.scale:.0f} {self.ttfont['head'].yMax * self.scale:.0f}]\"\n            ),\n            italic_angle=int(post_table.italicAngle),\n            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),\n            missing_width=default_width,\n        )\n\n        # a map unicode_char -> char_width\n        self.cw: dict[int, float] = defaultdict(lambda: default_width)\n\n        # fonttools cmap = unicode char to glyph name\n        # saving only the keys we have a tuple with\n        # the unicode characters available on the font\n        self.cmap: dict[int, str] = self.ttfont.getBestCmap()\n        if not self.cmap:\n            raise NotImplementedError(\n                \"Font not supported as it does not have a unicode cmap table - cf. issue #1396\"\n            )\n\n        if unicode_range is not None and len(unicode_range) != 0:\n            self.cmap = {\n                codepoint: glyph_id\n                for codepoint, glyph_id in self.cmap.items()  # pyright: ignore[reportUnknownVariableType]\n                if codepoint in unicode_range\n            }\n\n        # saving a list of glyph ids to char to allow\n        # subset by unicode (regular) and by glyph\n        # (shaped with harfbuz)\n        self.glyph_ids = {}\n\n        for char in self.cmap:  # pyright: ignore[]\n            # take glyph associated to char\n            glyph = self.cmap[char]\n\n            # take width associated to glyph\n            w = self.ttfont[\"hmtx\"].metrics[glyph][0]\n\n            # probably this check could be deleted\n            if w == 65535:\n                w = 0\n\n            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP\n\n            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)\n\n        self.missing_glyphs: list[int] = []\n\n        self.name = re.sub(\"[ ()]\", \"\", self.ttfont[\"name\"].getBestFullName())\n        self.up = round(post_table.underlinePosition * self.scale)\n        self.ut = round(post_table.underlineThickness * self.scale)\n        self.sp = round(os2_table.yStrikeoutPosition * self.scale)\n        self.ss = round(os2_table.yStrikeoutSize * self.scale)\n        self.emphasis = TextEmphasis.coerce(style)\n        self.subset = SubsetMap(self)\n        self.palette_index = palette_index if palette_index is not None else 0\n        self.color_font = (\n            get_color_font_object(fpdf, self, self.palette_index)\n            if fpdf.render_color_fonts\n            else None\n        )\n\n    # pylint: disable=no-member\n    @property\n    def hbfont(self) -> \"HarfBuzzFont\":\n        if not self._hbfont:\n            if self.is_compressed:\n                # HarfBuzz cannot load compressed WOFF/WOFF2 files directly, so we\n                # re-serialize the fontTools TTFont to a raw SFNT byte buffer.\n                buf = BytesIO()\n                self.ttfont.save(buf)\n                buf.seek(0)\n                ttfont_bytes = buf.read()\n\n                # Try to create a HarfBuzz blob from bytes; if not available, write a\n                # temporary file as a last resort.\n                try:\n                    blob = hb.Blob.from_bytes(ttfont_bytes)\n                    face = hb.Face(blob)\n                except (AttributeError, RuntimeError):\n                    import tempfile, os  # pylint: disable=import-outside-toplevel\n\n                    tmp_name = None\n                    try:\n                        with tempfile.NamedTemporaryFile(\n                            suffix=\".ttf\", delete=False\n                        ) as tmp:\n                            tmp_name = tmp.name\n                            tmp.write(ttfont_bytes)\n                            tmp.flush()\n                        face = hb.Face(hb.Blob.from_file_path(tmp_name))\n                    finally:\n                        if tmp_name:\n                            try:\n                                os.unlink(tmp_name)\n                            except OSError as cleanup_error:\n                                # Log warning about failed cleanup - orphaned temp file may cause disk issues\n                                LOGGER.warning(\n                                    \"Failed to clean up temporary font file '%s': %s. This may leave an orphaned file on disk.\",\n                                    tmp_name,\n                                    cleanup_error,\n                                )\n\n                self._hbfont = HarfBuzzFont(face)\n            else:\n                # For regular TTF/OTF fonts, load directly from file path (faster)\n                self._hbfont = HarfBuzzFont(\n                    hb.Face(hb.Blob.from_file_path(self.ttffile))\n                )\n\n        return self._hbfont\n\n    def __repr__(self) -> str:\n        return f\"TTFFont(i={self.i}, fontkey={self.fontkey})\"\n\n    def __deepcopy__(self: \"TTFFont\", memo: dict[int, Any]) -> \"TTFFont\":\n        \"\"\"\n        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes\n        but instead share references to immutable objects\n        between the original FPDF instance and the FPDFRecorder instances\n        to avoid performances issues as spotted in issue #1444.\n        \"\"\"\n        copy = TTFFont.__new__(TTFFont)\n        # Immutable attributes:\n        copy.i = self.i\n        copy.type = \"TTF\"\n        copy.ttffile = self.ttffile\n        copy.fontkey = self.fontkey\n        copy.scale = self.scale\n        copy.name = self.name\n        copy.up = self.up\n        copy.ut = self.ut\n        copy.sp = self.sp\n        copy.ss = self.ss\n        copy.emphasis = self.emphasis\n        copy.is_compressed = self.is_compressed\n        # Attributes shared, to improve FPDFRecorder performances:\n        copy.ttfont = self.ttfont\n        copy.cmap = self.cmap\n        copy.desc = self.desc\n        # Attributes deepcopied:\n        copy.cw = deepcopy(self.cw, memo)\n        copy.glyph_ids = deepcopy(self.glyph_ids, memo)\n        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)\n        copy.subset = deepcopy(self.subset, memo)\n        copy.biggest_size_pt = self.biggest_size_pt\n        copy._hbfont = self._hbfont\n        copy.color_font = self.color_font\n        copy.palette_index = self.palette_index\n        return copy\n\n    def close(self) -> None:\n        self.ttfont.close()\n        self._hbfont = None\n\n    def escape_text(self, text: str) -> str:\n        if self.color_font:\n            encoded = text.encode(\"latin-1\", errors=\"replace\")\n            return escape_parens(encoded.decode(\"latin-1\", errors=\"ignore\"))\n        return escape_parens(text.encode(\"utf-16-be\").decode(\"latin-1\"))\n\n    def get_text_width(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[int, float]:\n        if font_size_pt > self.biggest_size_pt:\n            self.biggest_size_pt = font_size_pt\n        if text_shaping_params:\n            return self.shaped_text_width(text, font_size_pt, text_shaping_params)\n        return (len(text), sum(self.cw[ord(c)] for c in text) * font_size_pt * 0.001)\n\n    def shaped_text_width(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[int, float]:\n        \"\"\"\n        When texts are shaped, the length of a string is not always the sum of all individual character widths\n        This method will invoke harfbuzz to perform the text shaping and return the sum of \"x_advance\"\n        and \"x_offset\" for each glyph. This method works for \"left to right\" or \"right to left\" texts.\n        \"\"\"\n        _, glyph_positions = self.perform_harfbuzz_shaping(\n            text, font_size_pt, text_shaping_params\n        )\n\n        # If there is nothing to render (harfbuzz returns None), we return 0 text width\n        if glyph_positions is None:\n            return (0, 0)\n\n        text_width: float = 0\n        for pos in glyph_positions:\n            text_width += (\n                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001\n            )\n        return (len(glyph_positions), text_width)\n\n    # Disabling this check - looks like cython confuses pylint:\n    # pylint: disable=no-member\n    def perform_harfbuzz_shaping(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[Sequence[\"HBGlyphInfo\"], Sequence[\"HBGlyphPosition\"]]:\n        \"\"\"\n        This method invokes Harfbuzz to perform text shaping of the input string\n        \"\"\"\n        self.hbfont.ptem = font_size_pt\n        if TYPE_CHECKING:\n            buf: HBBuffer\n        buf = hb.Buffer()\n        buf.cluster_level = 1\n        buf.add_str(\"\".join(text))\n        buf.guess_segment_properties()\n        features = (\n            text_shaping_params[\"features\"] if text_shaping_params is not None else {}\n        )\n        if text_shaping_params is None:\n            text_shaping_params = {}\n        if (\n            \"fragment_direction\" in text_shaping_params\n            and text_shaping_params[\"fragment_direction\"] is not None\n        ):\n            buf.direction = text_shaping_params[\"fragment_direction\"].value\n        if (\n            \"script\" in text_shaping_params\n            and text_shaping_params[\"script\"] is not None\n        ):\n            buf.script = text_shaping_params[\"script\"]\n        if (\n            \"language\" in text_shaping_params\n            and text_shaping_params[\"language\"] is not None\n        ):\n            buf.language = text_shaping_params[\"language\"]\n        hb.shape(self.hbfont, buf, features)\n        return buf.glyph_infos, buf.glyph_positions\n\n    def encode_text(self, text: str) -> str:\n        txt_mapped = \"\"\n        for char in text:\n            uni = ord(char)\n            # Instead of adding the actual character to the stream its code is\n            # mapped to a position in the font's subset\n            mapped_char: Optional[int] = self.subset.pick(uni)\n            if mapped_char is not None:\n                txt_mapped += chr(mapped_char)\n        return f\"({self.escape_text(txt_mapped)}) Tj\"\n\n    def shape_text(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> Sequence[dict[str, Any]]:\n        \"\"\"\n        This method will invoke harfbuzz for text shaping, include the mapping code\n        of the glyphs on the subset and map input characters to the cluster codes\n        \"\"\"\n        if len(text) == 0:\n            return []\n        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(\n            text, font_size_pt, text_shaping_params\n        )\n        text_info = []\n\n        # Find cluster gaps\n        # Ex: text = \"ABCD\"\n        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph\n        # (ligature or substitution) - the glyph should have both unicodes and it should be translated\n        # properly on the CID to GID mapping\n        #\n        def get_cluster_from_text_index(cluster_list: Sequence[int], index: int) -> int:\n            pos = bisect_left(cluster_list, index)\n            if pos == 0:\n                return cluster_list[0]\n            if pos == len(cluster_list) or cluster_list[pos] != index:\n                return cluster_list[pos - 1]\n            return cluster_list[pos]\n\n        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))\n        cluster_mapping: dict[int, list[int]] = {}\n        for i in range(len(text)):\n            cl = get_cluster_from_text_index(cluster_list, i)\n            if cl in cluster_mapping:\n                cluster_mapping[cl].append(i)\n            else:\n                cluster_mapping[cl] = [i]\n\n        for cluster_seq, gi in enumerate(glyph_infos):\n            unicode = []\n            if gi.cluster in cluster_mapping:\n                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]\n                cluster_mapping.pop(gi.cluster)\n\n            gname = self.ttfont.getGlyphName(gi.codepoint)\n            gwidth = round(self.scale * self.ttfont[\"hmtx\"].metrics[gname][0])\n            glyph = self.subset.get_glyph(\n                glyph=gi.codepoint,\n                unicode=tuple(unicode),\n                glyph_name=gname,\n                glyph_width=gwidth,\n            )\n            if glyph is None:\n                continue\n            force_positioning = False\n            if (\n                gwidth != glyph_positions[cluster_seq].x_advance\n                or glyph_positions[cluster_seq].x_offset != 0\n                or glyph_positions[cluster_seq].y_offset != 0\n                or glyph_positions[cluster_seq].y_advance != 0\n            ):\n                force_positioning = True\n            text_info.append(\n                {\n                    \"mapped_char\": self.subset.pick_glyph(glyph),\n                    \"x_advance\": glyph_positions[cluster_seq].x_advance,\n                    \"y_advance\": glyph_positions[cluster_seq].y_advance,\n                    \"x_offset\": glyph_positions[cluster_seq].x_offset,\n                    \"y_offset\": glyph_positions[cluster_seq].y_offset,\n                    \"force_positioning\": force_positioning,\n                }\n            )\n        return text_info",
      "language": "python"
    },
    {
      "code": "class TTFFont:\n    __slots__ = (  # RAM usage optimization\n        \"i\",\n        \"type\",\n        \"name\",\n        \"desc\",\n        \"glyph_ids\",\n        \"_hbfont\",\n        \"sp\",\n        \"ss\",\n        \"up\",\n        \"ut\",\n        \"cw\",\n        \"ttffile\",\n        \"fontkey\",\n        \"emphasis\",\n        \"scale\",\n        \"subset\",\n        \"cmap\",\n        \"ttfont\",\n        \"missing_glyphs\",\n        \"biggest_size_pt\",\n        \"color_font\",\n        \"unicode_range\",\n        \"palette_index\",\n        \"is_compressed\",\n    )\n\n    def __init__(\n        self,\n        fpdf: \"FPDF\",\n        font_file_path: Path,\n        fontkey: str,\n        style: str,\n        unicode_range: Optional[set[int]] = None,\n        axes_dict: Optional[dict[str, float]] = None,\n        palette_index: Optional[int] = None,\n    ):\n        self.i = len(fpdf.fonts) + 1\n        self.type = \"TTF\"\n        self.ttffile = font_file_path\n        self.is_compressed = str(self.ttffile).lower().endswith((\".woff\", \".woff2\"))\n        self._hbfont: Optional[\"HarfBuzzFont\"] = None\n        self.fontkey = fontkey\n        self.biggest_size_pt: float = 0\n\n        # recalcTimestamp=False means that it doesn't modify the \"modified\" timestamp in head table\n        # if we leave recalcTimestamp=True the tests will break every time\n        try:\n            self.ttfont = ttLib.TTFont(\n                self.ttffile, recalcTimestamp=False, fontNumber=0, lazy=True\n            )\n        except (\n            ImportError,\n            RuntimeError,\n        ) as exc:  # pragma: no cover - defensive messaging\n            # If the user passed a WOFF2 file but brotli is not installed, fontTools\n            # raises an ImportError/RuntimeError during parsing. Provide a clearer hint\n            # only for that specific situation. Allow other exceptions (e.g. FileNotFoundError,\n            # OSError, parsing errors) to propagate normally so they aren't masked here.\n            fname_str = str(self.ttffile).lower()\n            if fname_str.endswith(\".woff2\"):\n                raise RuntimeError(\n                    \"Could not open WOFF2 font. WOFF2 support requires an external Brotli \"\n                    \"library (install 'brotli' or 'brotlicffi'). Original error: \"\n                    f\"{exc!s}\"\n                ) from exc\n            raise\n\n        if axes_dict is not None:\n            if \"fvar\" not in self.ttfont:\n                raise AttributeError(f\"{self.ttffile} is not a variable font\")\n\n            instancer.instantiateVariableFont(\n                self.ttfont,\n                axes_dict,\n                inplace=True,\n                static=True,\n            )\n        if self.is_compressed:\n            # Normalize to SFNT output for embedding and HarfBuzz.\n            self.ttfont.flavor = None\n        upem: float = float(self.ttfont[\"head\"].unitsPerEm)\n        self.scale: float = 1000 / upem\n\n        # check if the font is a TrueType and missing a .notdef glyph\n        # if it is missing, provide a fallback glyph\n        if (\n            \"glyf\" in self.ttfont\n            and \".notdef\"\n            not in self.ttfont[\"glyf\"]  # pyright: ignore[reportOperatorIssue]\n        ):\n            LOGGER.warning(\n                (\n                    \"TrueType Font '%s' is missing the '.notdef' glyph. \"\n                    \"Fallback glyph will be provided.\"\n                ),\n                self.fontkey,\n            )\n            # draw a diagonal cross .notdef glyph\n            xMin, xMax, yMin, yMax = (\n                self.ttfont[\"head\"].xMin,\n                self.ttfont[\"head\"].xMax,\n                self.ttfont[\"head\"].yMin,\n                self.ttfont[\"head\"].yMax,\n            )\n            pen = TTGlyphPen(self.ttfont[\"glyf\"])  # pyright: ignore[reportArgumentType]\n            pen.moveTo((xMin, yMin))\n            pen.lineTo((xMax, yMin))\n            pen.lineTo((xMax, yMax))\n            pen.lineTo((xMin, yMax))\n            pen.closePath()\n            pen.moveTo((xMin, yMin))\n            pen.lineTo((xMax, yMax))\n            pen.closePath()\n            pen.moveTo((xMax, yMin))\n            pen.lineTo((xMin, yMax))\n            pen.closePath()\n\n            self.ttfont[\"glyf\"][  # pyright: ignore[reportIndexIssue]\n                \".notdef\"\n            ] = pen.glyph()\n            self.ttfont[\"hmtx\"][\".notdef\"] = (  # pyright: ignore[reportIndexIssue]\n                xMax - xMin,\n                yMax - yMin,\n            )\n\n        default_width: float = round(\n            self.scale * self.ttfont[\"hmtx\"].metrics[\".notdef\"][0]\n        )\n\n        os2_table = self.ttfont[\"OS/2\"]\n        post_table = self.ttfont[\"post\"]\n\n        try:\n            cap_height = os2_table.sCapHeight\n        except AttributeError:\n            cap_height = self.ttfont[\"hhea\"].ascent\n\n        # entry for the PDF font descriptor specifying various characteristics of the font\n        flags = FontDescriptorFlags.SYMBOLIC\n        if post_table.isFixedPitch:\n            flags |= FontDescriptorFlags.FIXED_PITCH\n        if post_table.italicAngle != 0:\n            flags |= FontDescriptorFlags.ITALIC\n        if os2_table.usWeightClass >= 600:\n            flags |= FontDescriptorFlags.FORCE_BOLD\n\n        self.desc = PDFFontDescriptor(\n            ascent=round(self.ttfont[\"hhea\"].ascent * self.scale),\n            descent=round(self.ttfont[\"hhea\"].descent * self.scale),\n            cap_height=round(cap_height * self.scale),\n            flags=flags,\n            font_b_box=(\n                f\"[{self.ttfont['head'].xMin * self.scale:.0f} {self.ttfont['head'].yMin * self.scale:.0f}\"\n                f\" {self.ttfont['head'].xMax * self.scale:.0f} {self.ttfont['head'].yMax * self.scale:.0f}]\"\n            ),\n            italic_angle=int(post_table.italicAngle),\n            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),\n            missing_width=default_width,\n        )\n\n        # a map unicode_char -> char_width\n        self.cw: dict[int, float] = defaultdict(lambda: default_width)\n\n        # fonttools cmap = unicode char to glyph name\n        # saving only the keys we have a tuple with\n        # the unicode characters available on the font\n        self.cmap: dict[int, str] = self.ttfont.getBestCmap()\n        if not self.cmap:\n            raise NotImplementedError(\n                \"Font not supported as it does not have a unicode cmap table - cf. issue #1396\"\n            )\n\n        if unicode_range is not None and len(unicode_range) != 0:\n            self.cmap = {\n                codepoint: glyph_id\n                for codepoint, glyph_id in self.cmap.items()  # pyright: ignore[reportUnknownVariableType]\n                if codepoint in unicode_range\n            }\n\n        # saving a list of glyph ids to char to allow\n        # subset by unicode (regular) and by glyph\n        # (shaped with harfbuz)\n        self.glyph_ids = {}\n\n        for char in self.cmap:  # pyright: ignore[]\n            # take glyph associated to char\n            glyph = self.cmap[char]\n\n            # take width associated to glyph\n            w = self.ttfont[\"hmtx\"].metrics[glyph][0]\n\n            # probably this check could be deleted\n            if w == 65535:\n                w = 0\n\n            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP\n\n            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)\n\n        self.missing_glyphs: list[int] = []\n\n        self.name = re.sub(\"[ ()]\", \"\", self.ttfont[\"name\"].getBestFullName())\n        self.up = round(post_table.underlinePosition * self.scale)\n        self.ut = round(post_table.underlineThickness * self.scale)\n        self.sp = round(os2_table.yStrikeoutPosition * self.scale)\n        self.ss = round(os2_table.yStrikeoutSize * self.scale)\n        self.emphasis = TextEmphasis.coerce(style)\n        self.subset = SubsetMap(self)\n        self.palette_index = palette_index if palette_index is not None else 0\n        self.color_font = (\n            get_color_font_object(fpdf, self, self.palette_index)\n            if fpdf.render_color_fonts\n            else None\n        )\n\n    # pylint: disable=no-member\n    @property\n    def hbfont(self) -> \"HarfBuzzFont\":\n        if not self._hbfont:\n            if self.is_compressed:\n                # HarfBuzz cannot load compressed WOFF/WOFF2 files directly, so we\n                # re-serialize the fontTools TTFont to a raw SFNT byte buffer.\n                buf = BytesIO()\n                self.ttfont.save(buf)\n                buf.seek(0)\n                ttfont_bytes = buf.read()\n\n                # Try to create a HarfBuzz blob from bytes; if not available, write a\n                # temporary file as a last resort.\n                try:\n                    blob = hb.Blob.from_bytes(ttfont_bytes)\n                    face = hb.Face(blob)\n                except (AttributeError, RuntimeError):\n                    import tempfile, os  # pylint: disable=import-outside-toplevel\n\n                    tmp_name = None\n                    try:\n                        with tempfile.NamedTemporaryFile(\n                            suffix=\".ttf\", delete=False\n                        ) as tmp:\n                            tmp_name = tmp.name\n                            tmp.write(ttfont_bytes)\n                            tmp.flush()\n                        face = hb.Face(hb.Blob.from_file_path(tmp_name))\n                    finally:\n                        if tmp_name:\n                            try:\n                                os.unlink(tmp_name)\n                            except OSError as cleanup_error:\n                                # Log warning about failed cleanup - orphaned temp file may cause disk issues\n                                LOGGER.warning(\n                                    \"Failed to clean up temporary font file '%s': %s. This may leave an orphaned file on disk.\",\n                                    tmp_name,\n                                    cleanup_error,\n                                )\n\n                self._hbfont = HarfBuzzFont(face)\n            else:\n                # For regular TTF/OTF fonts, load directly from file path (faster)\n                self._hbfont = HarfBuzzFont(\n                    hb.Face(hb.Blob.from_file_path(self.ttffile))\n                )\n\n        return self._hbfont\n\n    def __repr__(self) -> str:\n        return f\"TTFFont(i={self.i}, fontkey={self.fontkey})\"\n\n    def __deepcopy__(self: \"TTFFont\", memo: dict[int, Any]) -> \"TTFFont\":\n        \"\"\"\n        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes\n        but instead share references to immutable objects\n        between the original FPDF instance and the FPDFRecorder instances\n        to avoid performances issues as spotted in issue #1444.\n        \"\"\"\n        copy = TTFFont.__new__(TTFFont)\n        # Immutable attributes:\n        copy.i = self.i\n        copy.type = \"TTF\"\n        copy.ttffile = self.ttffile\n        copy.fontkey = self.fontkey\n        copy.scale = self.scale\n        copy.name = self.name\n        copy.up = self.up\n        copy.ut = self.ut\n        copy.sp = self.sp\n        copy.ss = self.ss\n        copy.emphasis = self.emphasis\n        copy.is_compressed = self.is_compressed\n        # Attributes shared, to improve FPDFRecorder performances:\n        copy.ttfont = self.ttfont\n        copy.cmap = self.cmap\n        copy.desc = self.desc\n        # Attributes deepcopied:\n        copy.cw = deepcopy(self.cw, memo)\n        copy.glyph_ids = deepcopy(self.glyph_ids, memo)\n        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)\n        copy.subset = deepcopy(self.subset, memo)\n        copy.biggest_size_pt = self.biggest_size_pt\n        copy._hbfont = self._hbfont\n        copy.color_font = self.color_font\n        copy.palette_index = self.palette_index\n        return copy\n\n    def close(self) -> None:\n        self.ttfont.close()\n        self._hbfont = None\n\n    def escape_text(self, text: str) -> str:\n        if self.color_font:\n            encoded = text.encode(\"latin-1\", errors=\"replace\")\n            return escape_parens(encoded.decode(\"latin-1\", errors=\"ignore\"))\n        return escape_parens(text.encode(\"utf-16-be\").decode(\"latin-1\"))\n\n    def get_text_width(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[int, float]:\n        if font_size_pt > self.biggest_size_pt:\n            self.biggest_size_pt = font_size_pt\n        if text_shaping_params:\n            return self.shaped_text_width(text, font_size_pt, text_shaping_params)\n        return (len(text), sum(self.cw[ord(c)] for c in text) * font_size_pt * 0.001)\n\n    def shaped_text_width(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[int, float]:\n        \"\"\"\n        When texts are shaped, the length of a string is not always the sum of all individual character widths\n        This method will invoke harfbuzz to perform the text shaping and return the sum of \"x_advance\"\n        and \"x_offset\" for each glyph. This method works for \"left to right\" or \"right to left\" texts.\n        \"\"\"\n        _, glyph_positions = self.perform_harfbuzz_shaping(\n            text, font_size_pt, text_shaping_params\n        )\n\n        # If there is nothing to render (harfbuzz returns None), we return 0 text width\n        if glyph_positions is None:\n            return (0, 0)\n\n        text_width: float = 0\n        for pos in glyph_positions:\n            text_width += (\n                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001\n            )\n        return (len(glyph_positions), text_width)\n\n    # Disabling this check - looks like cython confuses pylint:\n    # pylint: disable=no-member\n    def perform_harfbuzz_shaping(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[Sequence[\"HBGlyphInfo\"], Sequence[\"HBGlyphPosition\"]]:\n        \"\"\"\n        This method invokes Harfbuzz to perform text shaping of the input string\n        \"\"\"\n        self.hbfont.ptem = font_size_pt\n        if TYPE_CHECKING:\n            buf: HBBuffer\n        buf = hb.Buffer()\n        buf.cluster_level = 1\n        buf.add_str(\"\".join(text))\n        buf.guess_segment_properties()\n        features = (\n            text_shaping_params[\"features\"] if text_shaping_params is not None else {}\n        )\n        if text_shaping_params is None:\n            text_shaping_params = {}\n        if (\n            \"fragment_direction\" in text_shaping_params\n            and text_shaping_params[\"fragment_direction\"] is not None\n        ):\n            buf.direction = text_shaping_params[\"fragment_direction\"].value\n        if (\n            \"script\" in text_shaping_params\n            and text_shaping_params[\"script\"] is not None\n        ):\n            buf.script = text_shaping_params[\"script\"]\n        if (\n            \"language\" in text_shaping_params\n            and text_shaping_params[\"language\"] is not None\n        ):\n            buf.language = text_shaping_params[\"language\"]\n        hb.shape(self.hbfont, buf, features)\n        return buf.glyph_infos, buf.glyph_positions\n\n    def encode_text(self, text: str) -> str:\n        txt_mapped = \"\"\n        for char in text:\n            uni = ord(char)\n            # Instead of adding the actual character to the stream its code is\n            # mapped to a position in the font's subset\n            mapped_char: Optional[int] = self.subset.pick(uni)\n            if mapped_char is not None:\n                txt_mapped += chr(mapped_char)\n        return f\"({self.escape_text(txt_mapped)}) Tj\"\n\n    def shape_text(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> Sequence[dict[str, Any]]:\n        \"\"\"\n        This method will invoke harfbuzz for text shaping, include the mapping code\n        of the glyphs on the subset and map input characters to the cluster codes\n        \"\"\"\n        if len(text) == 0:\n            return []\n        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(\n            text, font_size_pt, text_shaping_params\n        )\n        text_info = []\n\n        # Find cluster gaps\n        # Ex: text = \"ABCD\"\n        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph\n        # (ligature or substitution) - the glyph should have both unicodes and it should be translated\n        # properly on the CID to GID mapping\n        #\n        def get_cluster_from_text_index(cluster_list: Sequence[int], index: int) -> int:\n            pos = bisect_left(cluster_list, index)\n            if pos == 0:\n                return cluster_list[0]\n            if pos == len(cluster_list) or cluster_list[pos] != index:\n                return cluster_list[pos - 1]\n            return cluster_list[pos]\n\n        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))\n        cluster_mapping: dict[int, list[int]] = {}\n        for i in range(len(text)):\n            cl = get_cluster_from_text_index(cluster_list, i)\n            if cl in cluster_mapping:\n                cluster_mapping[cl].append(i)\n            else:\n                cluster_mapping[cl] = [i]\n\n        for cluster_seq, gi in enumerate(glyph_infos):\n            unicode = []\n            if gi.cluster in cluster_mapping:\n                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]\n                cluster_mapping.pop(gi.cluster)\n\n            gname = self.ttfont.getGlyphName(gi.codepoint)\n            gwidth = round(self.scale * self.ttfont[\"hmtx\"].metrics[gname][0])\n            glyph = self.subset.get_glyph(\n                glyph=gi.codepoint,\n                unicode=tuple(unicode),\n                glyph_name=gname,\n                glyph_width=gwidth,\n            )\n            if glyph is None:\n                continue\n            force_positioning = False\n            if (\n                gwidth != glyph_positions[cluster_seq].x_advance\n                or glyph_positions[cluster_seq].x_offset != 0\n                or glyph_positions[cluster_seq].y_offset != 0\n                or glyph_positions[cluster_seq].y_advance != 0\n            ):\n                force_positioning = True\n            text_info.append(\n                {\n                    \"mapped_char\": self.subset.pick_glyph(glyph),\n                    \"x_advance\": glyph_positions[cluster_seq].x_advance,\n                    \"y_advance\": glyph_positions[cluster_seq].y_advance,\n                    \"x_offset\": glyph_positions[cluster_seq].x_offset,\n                    \"y_offset\": glyph_positions[cluster_seq].y_offset,\n                    \"force_positioning\": force_positioning,\n                }\n            )\n        return text_info",
      "language": "python"
    },
    {
      "code": "@property\ndef hbfont(self) -> \"HarfBuzzFont\":\n    if not self._hbfont:\n        if self.is_compressed:\n            # HarfBuzz cannot load compressed WOFF/WOFF2 files directly, so we\n            # re-serialize the fontTools TTFont to a raw SFNT byte buffer.\n            buf = BytesIO()\n            self.ttfont.save(buf)\n            buf.seek(0)\n            ttfont_bytes = buf.read()\n\n            # Try to create a HarfBuzz blob from bytes; if not available, write a\n            # temporary file as a last resort.\n            try:\n                blob = hb.Blob.from_bytes(ttfont_bytes)\n                face = hb.Face(blob)\n            except (AttributeError, RuntimeError):\n                import tempfile, os  # pylint: disable=import-outside-toplevel\n\n                tmp_name = None\n                try:\n                    with tempfile.NamedTemporaryFile(\n                        suffix=\".ttf\", delete=False\n                    ) as tmp:\n                        tmp_name = tmp.name\n                        tmp.write(ttfont_bytes)\n                        tmp.flush()\n                    face = hb.Face(hb.Blob.from_file_path(tmp_name))\n                finally:\n                    if tmp_name:\n                        try:\n                            os.unlink(tmp_name)\n                        except OSError as cleanup_error:\n                            # Log warning about failed cleanup - orphaned temp file may cause disk issues\n                            LOGGER.warning(\n                                \"Failed to clean up temporary font file '%s': %s. This may leave an orphaned file on disk.\",\n                                tmp_name,\n                                cleanup_error,\n                            )\n\n            self._hbfont = HarfBuzzFont(face)\n        else:\n            # For regular TTF/OTF fonts, load directly from file path (faster)\n            self._hbfont = HarfBuzzFont(\n                hb.Face(hb.Blob.from_file_path(self.ttffile))\n            )\n\n    return self._hbfont",
      "language": "python"
    },
    {
      "code": "class TTFFont:\n    __slots__ = (  # RAM usage optimization\n        \"i\",\n        \"type\",\n        \"name\",\n        \"desc\",\n        \"glyph_ids\",\n        \"_hbfont\",\n        \"sp\",\n        \"ss\",\n        \"up\",\n        \"ut\",\n        \"cw\",\n        \"ttffile\",\n        \"fontkey\",\n        \"emphasis\",\n        \"scale\",\n        \"subset\",\n        \"cmap\",\n        \"ttfont\",\n        \"missing_glyphs\",\n        \"biggest_size_pt\",\n        \"color_font\",\n        \"unicode_range\",\n        \"palette_index\",\n        \"is_compressed\",\n    )\n\n    def __init__(\n        self,\n        fpdf: \"FPDF\",\n        font_file_path: Path,\n        fontkey: str,\n        style: str,\n        unicode_range: Optional[set[int]] = None,\n        axes_dict: Optional[dict[str, float]] = None,\n        palette_index: Optional[int] = None,\n    ):\n        self.i = len(fpdf.fonts) + 1\n        self.type = \"TTF\"\n        self.ttffile = font_file_path\n        self.is_compressed = str(self.ttffile).lower().endswith((\".woff\", \".woff2\"))\n        self._hbfont: Optional[\"HarfBuzzFont\"] = None\n        self.fontkey = fontkey\n        self.biggest_size_pt: float = 0\n\n        # recalcTimestamp=False means that it doesn't modify the \"modified\" timestamp in head table\n        # if we leave recalcTimestamp=True the tests will break every time\n        try:\n            self.ttfont = ttLib.TTFont(\n                self.ttffile, recalcTimestamp=False, fontNumber=0, lazy=True\n            )\n        except (\n            ImportError,\n            RuntimeError,\n        ) as exc:  # pragma: no cover - defensive messaging\n            # If the user passed a WOFF2 file but brotli is not installed, fontTools\n            # raises an ImportError/RuntimeError during parsing. Provide a clearer hint\n            # only for that specific situation. Allow other exceptions (e.g. FileNotFoundError,\n            # OSError, parsing errors) to propagate normally so they aren't masked here.\n            fname_str = str(self.ttffile).lower()\n            if fname_str.endswith(\".woff2\"):\n                raise RuntimeError(\n                    \"Could not open WOFF2 font. WOFF2 support requires an external Brotli \"\n                    \"library (install 'brotli' or 'brotlicffi'). Original error: \"\n                    f\"{exc!s}\"\n                ) from exc\n            raise\n\n        if axes_dict is not None:\n            if \"fvar\" not in self.ttfont:\n                raise AttributeError(f\"{self.ttffile} is not a variable font\")\n\n            instancer.instantiateVariableFont(\n                self.ttfont,\n                axes_dict,\n                inplace=True,\n                static=True,\n            )\n        if self.is_compressed:\n            # Normalize to SFNT output for embedding and HarfBuzz.\n            self.ttfont.flavor = None\n        upem: float = float(self.ttfont[\"head\"].unitsPerEm)\n        self.scale: float = 1000 / upem\n\n        # check if the font is a TrueType and missing a .notdef glyph\n        # if it is missing, provide a fallback glyph\n        if (\n            \"glyf\" in self.ttfont\n            and \".notdef\"\n            not in self.ttfont[\"glyf\"]  # pyright: ignore[reportOperatorIssue]\n        ):\n            LOGGER.warning(\n                (\n                    \"TrueType Font '%s' is missing the '.notdef' glyph. \"\n                    \"Fallback glyph will be provided.\"\n                ),\n                self.fontkey,\n            )\n            # draw a diagonal cross .notdef glyph\n            xMin, xMax, yMin, yMax = (\n                self.ttfont[\"head\"].xMin,\n                self.ttfont[\"head\"].xMax,\n                self.ttfont[\"head\"].yMin,\n                self.ttfont[\"head\"].yMax,\n            )\n            pen = TTGlyphPen(self.ttfont[\"glyf\"])  # pyright: ignore[reportArgumentType]\n            pen.moveTo((xMin, yMin))\n            pen.lineTo((xMax, yMin))\n            pen.lineTo((xMax, yMax))\n            pen.lineTo((xMin, yMax))\n            pen.closePath()\n            pen.moveTo((xMin, yMin))\n            pen.lineTo((xMax, yMax))\n            pen.closePath()\n            pen.moveTo((xMax, yMin))\n            pen.lineTo((xMin, yMax))\n            pen.closePath()\n\n            self.ttfont[\"glyf\"][  # pyright: ignore[reportIndexIssue]\n                \".notdef\"\n            ] = pen.glyph()\n            self.ttfont[\"hmtx\"][\".notdef\"] = (  # pyright: ignore[reportIndexIssue]\n                xMax - xMin,\n                yMax - yMin,\n            )\n\n        default_width: float = round(\n            self.scale * self.ttfont[\"hmtx\"].metrics[\".notdef\"][0]\n        )\n\n        os2_table = self.ttfont[\"OS/2\"]\n        post_table = self.ttfont[\"post\"]\n\n        try:\n            cap_height = os2_table.sCapHeight\n        except AttributeError:\n            cap_height = self.ttfont[\"hhea\"].ascent\n\n        # entry for the PDF font descriptor specifying various characteristics of the font\n        flags = FontDescriptorFlags.SYMBOLIC\n        if post_table.isFixedPitch:\n            flags |= FontDescriptorFlags.FIXED_PITCH\n        if post_table.italicAngle != 0:\n            flags |= FontDescriptorFlags.ITALIC\n        if os2_table.usWeightClass >= 600:\n            flags |= FontDescriptorFlags.FORCE_BOLD\n\n        self.desc = PDFFontDescriptor(\n            ascent=round(self.ttfont[\"hhea\"].ascent * self.scale),\n            descent=round(self.ttfont[\"hhea\"].descent * self.scale),\n            cap_height=round(cap_height * self.scale),\n            flags=flags,\n            font_b_box=(\n                f\"[{self.ttfont['head'].xMin * self.scale:.0f} {self.ttfont['head'].yMin * self.scale:.0f}\"\n                f\" {self.ttfont['head'].xMax * self.scale:.0f} {self.ttfont['head'].yMax * self.scale:.0f}]\"\n            ),\n            italic_angle=int(post_table.italicAngle),\n            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),\n            missing_width=default_width,\n        )\n\n        # a map unicode_char -> char_width\n        self.cw: dict[int, float] = defaultdict(lambda: default_width)\n\n        # fonttools cmap = unicode char to glyph name\n        # saving only the keys we have a tuple with\n        # the unicode characters available on the font\n        self.cmap: dict[int, str] = self.ttfont.getBestCmap()\n        if not self.cmap:\n            raise NotImplementedError(\n                \"Font not supported as it does not have a unicode cmap table - cf. issue #1396\"\n            )\n\n        if unicode_range is not None and len(unicode_range) != 0:\n            self.cmap = {\n                codepoint: glyph_id\n                for codepoint, glyph_id in self.cmap.items()  # pyright: ignore[reportUnknownVariableType]\n                if codepoint in unicode_range\n            }\n\n        # saving a list of glyph ids to char to allow\n        # subset by unicode (regular) and by glyph\n        # (shaped with harfbuz)\n        self.glyph_ids = {}\n\n        for char in self.cmap:  # pyright: ignore[]\n            # take glyph associated to char\n            glyph = self.cmap[char]\n\n            # take width associated to glyph\n            w = self.ttfont[\"hmtx\"].metrics[glyph][0]\n\n            # probably this check could be deleted\n            if w == 65535:\n                w = 0\n\n            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP\n\n            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)\n\n        self.missing_glyphs: list[int] = []\n\n        self.name = re.sub(\"[ ()]\", \"\", self.ttfont[\"name\"].getBestFullName())\n        self.up = round(post_table.underlinePosition * self.scale)\n        self.ut = round(post_table.underlineThickness * self.scale)\n        self.sp = round(os2_table.yStrikeoutPosition * self.scale)\n        self.ss = round(os2_table.yStrikeoutSize * self.scale)\n        self.emphasis = TextEmphasis.coerce(style)\n        self.subset = SubsetMap(self)\n        self.palette_index = palette_index if palette_index is not None else 0\n        self.color_font = (\n            get_color_font_object(fpdf, self, self.palette_index)\n            if fpdf.render_color_fonts\n            else None\n        )\n\n    # pylint: disable=no-member\n    @property\n    def hbfont(self) -> \"HarfBuzzFont\":\n        if not self._hbfont:\n            if self.is_compressed:\n                # HarfBuzz cannot load compressed WOFF/WOFF2 files directly, so we\n                # re-serialize the fontTools TTFont to a raw SFNT byte buffer.\n                buf = BytesIO()\n                self.ttfont.save(buf)\n                buf.seek(0)\n                ttfont_bytes = buf.read()\n\n                # Try to create a HarfBuzz blob from bytes; if not available, write a\n                # temporary file as a last resort.\n                try:\n                    blob = hb.Blob.from_bytes(ttfont_bytes)\n                    face = hb.Face(blob)\n                except (AttributeError, RuntimeError):\n                    import tempfile, os  # pylint: disable=import-outside-toplevel\n\n                    tmp_name = None\n                    try:\n                        with tempfile.NamedTemporaryFile(\n                            suffix=\".ttf\", delete=False\n                        ) as tmp:\n                            tmp_name = tmp.name\n                            tmp.write(ttfont_bytes)\n                            tmp.flush()\n                        face = hb.Face(hb.Blob.from_file_path(tmp_name))\n                    finally:\n                        if tmp_name:\n                            try:\n                                os.unlink(tmp_name)\n                            except OSError as cleanup_error:\n                                # Log warning about failed cleanup - orphaned temp file may cause disk issues\n                                LOGGER.warning(\n                                    \"Failed to clean up temporary font file '%s': %s. This may leave an orphaned file on disk.\",\n                                    tmp_name,\n                                    cleanup_error,\n                                )\n\n                self._hbfont = HarfBuzzFont(face)\n            else:\n                # For regular TTF/OTF fonts, load directly from file path (faster)\n                self._hbfont = HarfBuzzFont(\n                    hb.Face(hb.Blob.from_file_path(self.ttffile))\n                )\n\n        return self._hbfont\n\n    def __repr__(self) -> str:\n        return f\"TTFFont(i={self.i}, fontkey={self.fontkey})\"\n\n    def __deepcopy__(self: \"TTFFont\", memo: dict[int, Any]) -> \"TTFFont\":\n        \"\"\"\n        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes\n        but instead share references to immutable objects\n        between the original FPDF instance and the FPDFRecorder instances\n        to avoid performances issues as spotted in issue #1444.\n        \"\"\"\n        copy = TTFFont.__new__(TTFFont)\n        # Immutable attributes:\n        copy.i = self.i\n        copy.type = \"TTF\"\n        copy.ttffile = self.ttffile\n        copy.fontkey = self.fontkey\n        copy.scale = self.scale\n        copy.name = self.name\n        copy.up = self.up\n        copy.ut = self.ut\n        copy.sp = self.sp\n        copy.ss = self.ss\n        copy.emphasis = self.emphasis\n        copy.is_compressed = self.is_compressed\n        # Attributes shared, to improve FPDFRecorder performances:\n        copy.ttfont = self.ttfont\n        copy.cmap = self.cmap\n        copy.desc = self.desc\n        # Attributes deepcopied:\n        copy.cw = deepcopy(self.cw, memo)\n        copy.glyph_ids = deepcopy(self.glyph_ids, memo)\n        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)\n        copy.subset = deepcopy(self.subset, memo)\n        copy.biggest_size_pt = self.biggest_size_pt\n        copy._hbfont = self._hbfont\n        copy.color_font = self.color_font\n        copy.palette_index = self.palette_index\n        return copy\n\n    def close(self) -> None:\n        self.ttfont.close()\n        self._hbfont = None\n\n    def escape_text(self, text: str) -> str:\n        if self.color_font:\n            encoded = text.encode(\"latin-1\", errors=\"replace\")\n            return escape_parens(encoded.decode(\"latin-1\", errors=\"ignore\"))\n        return escape_parens(text.encode(\"utf-16-be\").decode(\"latin-1\"))\n\n    def get_text_width(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[int, float]:\n        if font_size_pt > self.biggest_size_pt:\n            self.biggest_size_pt = font_size_pt\n        if text_shaping_params:\n            return self.shaped_text_width(text, font_size_pt, text_shaping_params)\n        return (len(text), sum(self.cw[ord(c)] for c in text) * font_size_pt * 0.001)\n\n    def shaped_text_width(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[int, float]:\n        \"\"\"\n        When texts are shaped, the length of a string is not always the sum of all individual character widths\n        This method will invoke harfbuzz to perform the text shaping and return the sum of \"x_advance\"\n        and \"x_offset\" for each glyph. This method works for \"left to right\" or \"right to left\" texts.\n        \"\"\"\n        _, glyph_positions = self.perform_harfbuzz_shaping(\n            text, font_size_pt, text_shaping_params\n        )\n\n        # If there is nothing to render (harfbuzz returns None), we return 0 text width\n        if glyph_positions is None:\n            return (0, 0)\n\n        text_width: float = 0\n        for pos in glyph_positions:\n            text_width += (\n                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001\n            )\n        return (len(glyph_positions), text_width)\n\n    # Disabling this check - looks like cython confuses pylint:\n    # pylint: disable=no-member\n    def perform_harfbuzz_shaping(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[Sequence[\"HBGlyphInfo\"], Sequence[\"HBGlyphPosition\"]]:\n        \"\"\"\n        This method invokes Harfbuzz to perform text shaping of the input string\n        \"\"\"\n        self.hbfont.ptem = font_size_pt\n        if TYPE_CHECKING:\n            buf: HBBuffer\n        buf = hb.Buffer()\n        buf.cluster_level = 1\n        buf.add_str(\"\".join(text))\n        buf.guess_segment_properties()\n        features = (\n            text_shaping_params[\"features\"] if text_shaping_params is not None else {}\n        )\n        if text_shaping_params is None:\n            text_shaping_params = {}\n        if (\n            \"fragment_direction\" in text_shaping_params\n            and text_shaping_params[\"fragment_direction\"] is not None\n        ):\n            buf.direction = text_shaping_params[\"fragment_direction\"].value\n        if (\n            \"script\" in text_shaping_params\n            and text_shaping_params[\"script\"] is not None\n        ):\n            buf.script = text_shaping_params[\"script\"]\n        if (\n            \"language\" in text_shaping_params\n            and text_shaping_params[\"language\"] is not None\n        ):\n            buf.language = text_shaping_params[\"language\"]\n        hb.shape(self.hbfont, buf, features)\n        return buf.glyph_infos, buf.glyph_positions\n\n    def encode_text(self, text: str) -> str:\n        txt_mapped = \"\"\n        for char in text:\n            uni = ord(char)\n            # Instead of adding the actual character to the stream its code is\n            # mapped to a position in the font's subset\n            mapped_char: Optional[int] = self.subset.pick(uni)\n            if mapped_char is not None:\n                txt_mapped += chr(mapped_char)\n        return f\"({self.escape_text(txt_mapped)}) Tj\"\n\n    def shape_text(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> Sequence[dict[str, Any]]:\n        \"\"\"\n        This method will invoke harfbuzz for text shaping, include the mapping code\n        of the glyphs on the subset and map input characters to the cluster codes\n        \"\"\"\n        if len(text) == 0:\n            return []\n        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(\n            text, font_size_pt, text_shaping_params\n        )\n        text_info = []\n\n        # Find cluster gaps\n        # Ex: text = \"ABCD\"\n        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph\n        # (ligature or substitution) - the glyph should have both unicodes and it should be translated\n        # properly on the CID to GID mapping\n        #\n        def get_cluster_from_text_index(cluster_list: Sequence[int], index: int) -> int:\n            pos = bisect_left(cluster_list, index)\n            if pos == 0:\n                return cluster_list[0]\n            if pos == len(cluster_list) or cluster_list[pos] != index:\n                return cluster_list[pos - 1]\n            return cluster_list[pos]\n\n        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))\n        cluster_mapping: dict[int, list[int]] = {}\n        for i in range(len(text)):\n            cl = get_cluster_from_text_index(cluster_list, i)\n            if cl in cluster_mapping:\n                cluster_mapping[cl].append(i)\n            else:\n                cluster_mapping[cl] = [i]\n\n        for cluster_seq, gi in enumerate(glyph_infos):\n            unicode = []\n            if gi.cluster in cluster_mapping:\n                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]\n                cluster_mapping.pop(gi.cluster)\n\n            gname = self.ttfont.getGlyphName(gi.codepoint)\n            gwidth = round(self.scale * self.ttfont[\"hmtx\"].metrics[gname][0])\n            glyph = self.subset.get_glyph(\n                glyph=gi.codepoint,\n                unicode=tuple(unicode),\n                glyph_name=gname,\n                glyph_width=gwidth,\n            )\n            if glyph is None:\n                continue\n            force_positioning = False\n            if (\n                gwidth != glyph_positions[cluster_seq].x_advance\n                or glyph_positions[cluster_seq].x_offset != 0\n                or glyph_positions[cluster_seq].y_offset != 0\n                or glyph_positions[cluster_seq].y_advance != 0\n            ):\n                force_positioning = True\n            text_info.append(\n                {\n                    \"mapped_char\": self.subset.pick_glyph(glyph),\n                    \"x_advance\": glyph_positions[cluster_seq].x_advance,\n                    \"y_advance\": glyph_positions[cluster_seq].y_advance,\n                    \"x_offset\": glyph_positions[cluster_seq].x_offset,\n                    \"y_offset\": glyph_positions[cluster_seq].y_offset,\n                    \"force_positioning\": force_positioning,\n                }\n            )\n        return text_info",
      "language": "python"
    },
    {
      "code": "class TTFFont:\n    __slots__ = (  # RAM usage optimization\n        \"i\",\n        \"type\",\n        \"name\",\n        \"desc\",\n        \"glyph_ids\",\n        \"_hbfont\",\n        \"sp\",\n        \"ss\",\n        \"up\",\n        \"ut\",\n        \"cw\",\n        \"ttffile\",\n        \"fontkey\",\n        \"emphasis\",\n        \"scale\",\n        \"subset\",\n        \"cmap\",\n        \"ttfont\",\n        \"missing_glyphs\",\n        \"biggest_size_pt\",\n        \"color_font\",\n        \"unicode_range\",\n        \"palette_index\",\n        \"is_compressed\",\n    )\n\n    def __init__(\n        self,\n        fpdf: \"FPDF\",\n        font_file_path: Path,\n        fontkey: str,\n        style: str,\n        unicode_range: Optional[set[int]] = None,\n        axes_dict: Optional[dict[str, float]] = None,\n        palette_index: Optional[int] = None,\n    ):\n        self.i = len(fpdf.fonts) + 1\n        self.type = \"TTF\"\n        self.ttffile = font_file_path\n        self.is_compressed = str(self.ttffile).lower().endswith((\".woff\", \".woff2\"))\n        self._hbfont: Optional[\"HarfBuzzFont\"] = None\n        self.fontkey = fontkey\n        self.biggest_size_pt: float = 0\n\n        # recalcTimestamp=False means that it doesn't modify the \"modified\" timestamp in head table\n        # if we leave recalcTimestamp=True the tests will break every time\n        try:\n            self.ttfont = ttLib.TTFont(\n                self.ttffile, recalcTimestamp=False, fontNumber=0, lazy=True\n            )\n        except (\n            ImportError,\n            RuntimeError,\n        ) as exc:  # pragma: no cover - defensive messaging\n            # If the user passed a WOFF2 file but brotli is not installed, fontTools\n            # raises an ImportError/RuntimeError during parsing. Provide a clearer hint\n            # only for that specific situation. Allow other exceptions (e.g. FileNotFoundError,\n            # OSError, parsing errors) to propagate normally so they aren't masked here.\n            fname_str = str(self.ttffile).lower()\n            if fname_str.endswith(\".woff2\"):\n                raise RuntimeError(\n                    \"Could not open WOFF2 font. WOFF2 support requires an external Brotli \"\n                    \"library (install 'brotli' or 'brotlicffi'). Original error: \"\n                    f\"{exc!s}\"\n                ) from exc\n            raise\n\n        if axes_dict is not None:\n            if \"fvar\" not in self.ttfont:\n                raise AttributeError(f\"{self.ttffile} is not a variable font\")\n\n            instancer.instantiateVariableFont(\n                self.ttfont,\n                axes_dict,\n                inplace=True,\n                static=True,\n            )\n        if self.is_compressed:\n            # Normalize to SFNT output for embedding and HarfBuzz.\n            self.ttfont.flavor = None\n        upem: float = float(self.ttfont[\"head\"].unitsPerEm)\n        self.scale: float = 1000 / upem\n\n        # check if the font is a TrueType and missing a .notdef glyph\n        # if it is missing, provide a fallback glyph\n        if (\n            \"glyf\" in self.ttfont\n            and \".notdef\"\n            not in self.ttfont[\"glyf\"]  # pyright: ignore[reportOperatorIssue]\n        ):\n            LOGGER.warning(\n                (\n                    \"TrueType Font '%s' is missing the '.notdef' glyph. \"\n                    \"Fallback glyph will be provided.\"\n                ),\n                self.fontkey,\n            )\n            # draw a diagonal cross .notdef glyph\n            xMin, xMax, yMin, yMax = (\n                self.ttfont[\"head\"].xMin,\n                self.ttfont[\"head\"].xMax,\n                self.ttfont[\"head\"].yMin,\n                self.ttfont[\"head\"].yMax,\n            )\n            pen = TTGlyphPen(self.ttfont[\"glyf\"])  # pyright: ignore[reportArgumentType]\n            pen.moveTo((xMin, yMin))\n            pen.lineTo((xMax, yMin))\n            pen.lineTo((xMax, yMax))\n            pen.lineTo((xMin, yMax))\n            pen.closePath()\n            pen.moveTo((xMin, yMin))\n            pen.lineTo((xMax, yMax))\n            pen.closePath()\n            pen.moveTo((xMax, yMin))\n            pen.lineTo((xMin, yMax))\n            pen.closePath()\n\n            self.ttfont[\"glyf\"][  # pyright: ignore[reportIndexIssue]\n                \".notdef\"\n            ] = pen.glyph()\n            self.ttfont[\"hmtx\"][\".notdef\"] = (  # pyright: ignore[reportIndexIssue]\n                xMax - xMin,\n                yMax - yMin,\n            )\n\n        default_width: float = round(\n            self.scale * self.ttfont[\"hmtx\"].metrics[\".notdef\"][0]\n        )\n\n        os2_table = self.ttfont[\"OS/2\"]\n        post_table = self.ttfont[\"post\"]\n\n        try:\n            cap_height = os2_table.sCapHeight\n        except AttributeError:\n            cap_height = self.ttfont[\"hhea\"].ascent\n\n        # entry for the PDF font descriptor specifying various characteristics of the font\n        flags = FontDescriptorFlags.SYMBOLIC\n        if post_table.isFixedPitch:\n            flags |= FontDescriptorFlags.FIXED_PITCH\n        if post_table.italicAngle != 0:\n            flags |= FontDescriptorFlags.ITALIC\n        if os2_table.usWeightClass >= 600:\n            flags |= FontDescriptorFlags.FORCE_BOLD\n\n        self.desc = PDFFontDescriptor(\n            ascent=round(self.ttfont[\"hhea\"].ascent * self.scale),\n            descent=round(self.ttfont[\"hhea\"].descent * self.scale),\n            cap_height=round(cap_height * self.scale),\n            flags=flags,\n            font_b_box=(\n                f\"[{self.ttfont['head'].xMin * self.scale:.0f} {self.ttfont['head'].yMin * self.scale:.0f}\"\n                f\" {self.ttfont['head'].xMax * self.scale:.0f} {self.ttfont['head'].yMax * self.scale:.0f}]\"\n            ),\n            italic_angle=int(post_table.italicAngle),\n            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),\n            missing_width=default_width,\n        )\n\n        # a map unicode_char -> char_width\n        self.cw: dict[int, float] = defaultdict(lambda: default_width)\n\n        # fonttools cmap = unicode char to glyph name\n        # saving only the keys we have a tuple with\n        # the unicode characters available on the font\n        self.cmap: dict[int, str] = self.ttfont.getBestCmap()\n        if not self.cmap:\n            raise NotImplementedError(\n                \"Font not supported as it does not have a unicode cmap table - cf. issue #1396\"\n            )\n\n        if unicode_range is not None and len(unicode_range) != 0:\n            self.cmap = {\n                codepoint: glyph_id\n                for codepoint, glyph_id in self.cmap.items()  # pyright: ignore[reportUnknownVariableType]\n                if codepoint in unicode_range\n            }\n\n        # saving a list of glyph ids to char to allow\n        # subset by unicode (regular) and by glyph\n        # (shaped with harfbuz)\n        self.glyph_ids = {}\n\n        for char in self.cmap:  # pyright: ignore[]\n            # take glyph associated to char\n            glyph = self.cmap[char]\n\n            # take width associated to glyph\n            w = self.ttfont[\"hmtx\"].metrics[glyph][0]\n\n            # probably this check could be deleted\n            if w == 65535:\n                w = 0\n\n            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP\n\n            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)\n\n        self.missing_glyphs: list[int] = []\n\n        self.name = re.sub(\"[ ()]\", \"\", self.ttfont[\"name\"].getBestFullName())\n        self.up = round(post_table.underlinePosition * self.scale)\n        self.ut = round(post_table.underlineThickness * self.scale)\n        self.sp = round(os2_table.yStrikeoutPosition * self.scale)\n        self.ss = round(os2_table.yStrikeoutSize * self.scale)\n        self.emphasis = TextEmphasis.coerce(style)\n        self.subset = SubsetMap(self)\n        self.palette_index = palette_index if palette_index is not None else 0\n        self.color_font = (\n            get_color_font_object(fpdf, self, self.palette_index)\n            if fpdf.render_color_fonts\n            else None\n        )\n\n    # pylint: disable=no-member\n    @property\n    def hbfont(self) -> \"HarfBuzzFont\":\n        if not self._hbfont:\n            if self.is_compressed:\n                # HarfBuzz cannot load compressed WOFF/WOFF2 files directly, so we\n                # re-serialize the fontTools TTFont to a raw SFNT byte buffer.\n                buf = BytesIO()\n                self.ttfont.save(buf)\n                buf.seek(0)\n                ttfont_bytes = buf.read()\n\n                # Try to create a HarfBuzz blob from bytes; if not available, write a\n                # temporary file as a last resort.\n                try:\n                    blob = hb.Blob.from_bytes(ttfont_bytes)\n                    face = hb.Face(blob)\n                except (AttributeError, RuntimeError):\n                    import tempfile, os  # pylint: disable=import-outside-toplevel\n\n                    tmp_name = None\n                    try:\n                        with tempfile.NamedTemporaryFile(\n                            suffix=\".ttf\", delete=False\n                        ) as tmp:\n                            tmp_name = tmp.name\n                            tmp.write(ttfont_bytes)\n                            tmp.flush()\n                        face = hb.Face(hb.Blob.from_file_path(tmp_name))\n                    finally:\n                        if tmp_name:\n                            try:\n                                os.unlink(tmp_name)\n                            except OSError as cleanup_error:\n                                # Log warning about failed cleanup - orphaned temp file may cause disk issues\n                                LOGGER.warning(\n                                    \"Failed to clean up temporary font file '%s': %s. This may leave an orphaned file on disk.\",\n                                    tmp_name,\n                                    cleanup_error,\n                                )\n\n                self._hbfont = HarfBuzzFont(face)\n            else:\n                # For regular TTF/OTF fonts, load directly from file path (faster)\n                self._hbfont = HarfBuzzFont(\n                    hb.Face(hb.Blob.from_file_path(self.ttffile))\n                )\n\n        return self._hbfont\n\n    def __repr__(self) -> str:\n        return f\"TTFFont(i={self.i}, fontkey={self.fontkey})\"\n\n    def __deepcopy__(self: \"TTFFont\", memo: dict[int, Any]) -> \"TTFFont\":\n        \"\"\"\n        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes\n        but instead share references to immutable objects\n        between the original FPDF instance and the FPDFRecorder instances\n        to avoid performances issues as spotted in issue #1444.\n        \"\"\"\n        copy = TTFFont.__new__(TTFFont)\n        # Immutable attributes:\n        copy.i = self.i\n        copy.type = \"TTF\"\n        copy.ttffile = self.ttffile\n        copy.fontkey = self.fontkey\n        copy.scale = self.scale\n        copy.name = self.name\n        copy.up = self.up\n        copy.ut = self.ut\n        copy.sp = self.sp\n        copy.ss = self.ss\n        copy.emphasis = self.emphasis\n        copy.is_compressed = self.is_compressed\n        # Attributes shared, to improve FPDFRecorder performances:\n        copy.ttfont = self.ttfont\n        copy.cmap = self.cmap\n        copy.desc = self.desc\n        # Attributes deepcopied:\n        copy.cw = deepcopy(self.cw, memo)\n        copy.glyph_ids = deepcopy(self.glyph_ids, memo)\n        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)\n        copy.subset = deepcopy(self.subset, memo)\n        copy.biggest_size_pt = self.biggest_size_pt\n        copy._hbfont = self._hbfont\n        copy.color_font = self.color_font\n        copy.palette_index = self.palette_index\n        return copy\n\n    def close(self) -> None:\n        self.ttfont.close()\n        self._hbfont = None\n\n    def escape_text(self, text: str) -> str:\n        if self.color_font:\n            encoded = text.encode(\"latin-1\", errors=\"replace\")\n            return escape_parens(encoded.decode(\"latin-1\", errors=\"ignore\"))\n        return escape_parens(text.encode(\"utf-16-be\").decode(\"latin-1\"))\n\n    def get_text_width(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[int, float]:\n        if font_size_pt > self.biggest_size_pt:\n            self.biggest_size_pt = font_size_pt\n        if text_shaping_params:\n            return self.shaped_text_width(text, font_size_pt, text_shaping_params)\n        return (len(text), sum(self.cw[ord(c)] for c in text) * font_size_pt * 0.001)\n\n    def shaped_text_width(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[int, float]:\n        \"\"\"\n        When texts are shaped, the length of a string is not always the sum of all individual character widths\n        This method will invoke harfbuzz to perform the text shaping and return the sum of \"x_advance\"\n        and \"x_offset\" for each glyph. This method works for \"left to right\" or \"right to left\" texts.\n        \"\"\"\n        _, glyph_positions = self.perform_harfbuzz_shaping(\n            text, font_size_pt, text_shaping_params\n        )\n\n        # If there is nothing to render (harfbuzz returns None), we return 0 text width\n        if glyph_positions is None:\n            return (0, 0)\n\n        text_width: float = 0\n        for pos in glyph_positions:\n            text_width += (\n                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001\n            )\n        return (len(glyph_positions), text_width)\n\n    # Disabling this check - looks like cython confuses pylint:\n    # pylint: disable=no-member\n    def perform_harfbuzz_shaping(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[Sequence[\"HBGlyphInfo\"], Sequence[\"HBGlyphPosition\"]]:\n        \"\"\"\n        This method invokes Harfbuzz to perform text shaping of the input string\n        \"\"\"\n        self.hbfont.ptem = font_size_pt\n        if TYPE_CHECKING:\n            buf: HBBuffer\n        buf = hb.Buffer()\n        buf.cluster_level = 1\n        buf.add_str(\"\".join(text))\n        buf.guess_segment_properties()\n        features = (\n            text_shaping_params[\"features\"] if text_shaping_params is not None else {}\n        )\n        if text_shaping_params is None:\n            text_shaping_params = {}\n        if (\n            \"fragment_direction\" in text_shaping_params\n            and text_shaping_params[\"fragment_direction\"] is not None\n        ):\n            buf.direction = text_shaping_params[\"fragment_direction\"].value\n        if (\n            \"script\" in text_shaping_params\n            and text_shaping_params[\"script\"] is not None\n        ):\n            buf.script = text_shaping_params[\"script\"]\n        if (\n            \"language\" in text_shaping_params\n            and text_shaping_params[\"language\"] is not None\n        ):\n            buf.language = text_shaping_params[\"language\"]\n        hb.shape(self.hbfont, buf, features)\n        return buf.glyph_infos, buf.glyph_positions\n\n    def encode_text(self, text: str) -> str:\n        txt_mapped = \"\"\n        for char in text:\n            uni = ord(char)\n            # Instead of adding the actual character to the stream its code is\n            # mapped to a position in the font's subset\n            mapped_char: Optional[int] = self.subset.pick(uni)\n            if mapped_char is not None:\n                txt_mapped += chr(mapped_char)\n        return f\"({self.escape_text(txt_mapped)}) Tj\"\n\n    def shape_text(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> Sequence[dict[str, Any]]:\n        \"\"\"\n        This method will invoke harfbuzz for text shaping, include the mapping code\n        of the glyphs on the subset and map input characters to the cluster codes\n        \"\"\"\n        if len(text) == 0:\n            return []\n        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(\n            text, font_size_pt, text_shaping_params\n        )\n        text_info = []\n\n        # Find cluster gaps\n        # Ex: text = \"ABCD\"\n        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph\n        # (ligature or substitution) - the glyph should have both unicodes and it should be translated\n        # properly on the CID to GID mapping\n        #\n        def get_cluster_from_text_index(cluster_list: Sequence[int], index: int) -> int:\n            pos = bisect_left(cluster_list, index)\n            if pos == 0:\n                return cluster_list[0]\n            if pos == len(cluster_list) or cluster_list[pos] != index:\n                return cluster_list[pos - 1]\n            return cluster_list[pos]\n\n        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))\n        cluster_mapping: dict[int, list[int]] = {}\n        for i in range(len(text)):\n            cl = get_cluster_from_text_index(cluster_list, i)\n            if cl in cluster_mapping:\n                cluster_mapping[cl].append(i)\n            else:\n                cluster_mapping[cl] = [i]\n\n        for cluster_seq, gi in enumerate(glyph_infos):\n            unicode = []\n            if gi.cluster in cluster_mapping:\n                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]\n                cluster_mapping.pop(gi.cluster)\n\n            gname = self.ttfont.getGlyphName(gi.codepoint)\n            gwidth = round(self.scale * self.ttfont[\"hmtx\"].metrics[gname][0])\n            glyph = self.subset.get_glyph(\n                glyph=gi.codepoint,\n                unicode=tuple(unicode),\n                glyph_name=gname,\n                glyph_width=gwidth,\n            )\n            if glyph is None:\n                continue\n            force_positioning = False\n            if (\n                gwidth != glyph_positions[cluster_seq].x_advance\n                or glyph_positions[cluster_seq].x_offset != 0\n                or glyph_positions[cluster_seq].y_offset != 0\n                or glyph_positions[cluster_seq].y_advance != 0\n            ):\n                force_positioning = True\n            text_info.append(\n                {\n                    \"mapped_char\": self.subset.pick_glyph(glyph),\n                    \"x_advance\": glyph_positions[cluster_seq].x_advance,\n                    \"y_advance\": glyph_positions[cluster_seq].y_advance,\n                    \"x_offset\": glyph_positions[cluster_seq].x_offset,\n                    \"y_offset\": glyph_positions[cluster_seq].y_offset,\n                    \"force_positioning\": force_positioning,\n                }\n            )\n        return text_info",
      "language": "python"
    },
    {
      "code": "class TTFFont:\n    __slots__ = (  # RAM usage optimization\n        \"i\",\n        \"type\",\n        \"name\",\n        \"desc\",\n        \"glyph_ids\",\n        \"_hbfont\",\n        \"sp\",\n        \"ss\",\n        \"up\",\n        \"ut\",\n        \"cw\",\n        \"ttffile\",\n        \"fontkey\",\n        \"emphasis\",\n        \"scale\",\n        \"subset\",\n        \"cmap\",\n        \"ttfont\",\n        \"missing_glyphs\",\n        \"biggest_size_pt\",\n        \"color_font\",\n        \"unicode_range\",\n        \"palette_index\",\n        \"is_compressed\",\n    )\n\n    def __init__(\n        self,\n        fpdf: \"FPDF\",\n        font_file_path: Path,\n        fontkey: str,\n        style: str,\n        unicode_range: Optional[set[int]] = None,\n        axes_dict: Optional[dict[str, float]] = None,\n        palette_index: Optional[int] = None,\n    ):\n        self.i = len(fpdf.fonts) + 1\n        self.type = \"TTF\"\n        self.ttffile = font_file_path\n        self.is_compressed = str(self.ttffile).lower().endswith((\".woff\", \".woff2\"))\n        self._hbfont: Optional[\"HarfBuzzFont\"] = None\n        self.fontkey = fontkey\n        self.biggest_size_pt: float = 0\n\n        # recalcTimestamp=False means that it doesn't modify the \"modified\" timestamp in head table\n        # if we leave recalcTimestamp=True the tests will break every time\n        try:\n            self.ttfont = ttLib.TTFont(\n                self.ttffile, recalcTimestamp=False, fontNumber=0, lazy=True\n            )\n        except (\n            ImportError,\n            RuntimeError,\n        ) as exc:  # pragma: no cover - defensive messaging\n            # If the user passed a WOFF2 file but brotli is not installed, fontTools\n            # raises an ImportError/RuntimeError during parsing. Provide a clearer hint\n            # only for that specific situation. Allow other exceptions (e.g. FileNotFoundError,\n            # OSError, parsing errors) to propagate normally so they aren't masked here.\n            fname_str = str(self.ttffile).lower()\n            if fname_str.endswith(\".woff2\"):\n                raise RuntimeError(\n                    \"Could not open WOFF2 font. WOFF2 support requires an external Brotli \"\n                    \"library (install 'brotli' or 'brotlicffi'). Original error: \"\n                    f\"{exc!s}\"\n                ) from exc\n            raise\n\n        if axes_dict is not None:\n            if \"fvar\" not in self.ttfont:\n                raise AttributeError(f\"{self.ttffile} is not a variable font\")\n\n            instancer.instantiateVariableFont(\n                self.ttfont,\n                axes_dict,\n                inplace=True,\n                static=True,\n            )\n        if self.is_compressed:\n            # Normalize to SFNT output for embedding and HarfBuzz.\n            self.ttfont.flavor = None\n        upem: float = float(self.ttfont[\"head\"].unitsPerEm)\n        self.scale: float = 1000 / upem\n\n        # check if the font is a TrueType and missing a .notdef glyph\n        # if it is missing, provide a fallback glyph\n        if (\n            \"glyf\" in self.ttfont\n            and \".notdef\"\n            not in self.ttfont[\"glyf\"]  # pyright: ignore[reportOperatorIssue]\n        ):\n            LOGGER.warning(\n                (\n                    \"TrueType Font '%s' is missing the '.notdef' glyph. \"\n                    \"Fallback glyph will be provided.\"\n                ),\n                self.fontkey,\n            )\n            # draw a diagonal cross .notdef glyph\n            xMin, xMax, yMin, yMax = (\n                self.ttfont[\"head\"].xMin,\n                self.ttfont[\"head\"].xMax,\n                self.ttfont[\"head\"].yMin,\n                self.ttfont[\"head\"].yMax,\n            )\n            pen = TTGlyphPen(self.ttfont[\"glyf\"])  # pyright: ignore[reportArgumentType]\n            pen.moveTo((xMin, yMin))\n            pen.lineTo((xMax, yMin))\n            pen.lineTo((xMax, yMax))\n            pen.lineTo((xMin, yMax))\n            pen.closePath()\n            pen.moveTo((xMin, yMin))\n            pen.lineTo((xMax, yMax))\n            pen.closePath()\n            pen.moveTo((xMax, yMin))\n            pen.lineTo((xMin, yMax))\n            pen.closePath()\n\n            self.ttfont[\"glyf\"][  # pyright: ignore[reportIndexIssue]\n                \".notdef\"\n            ] = pen.glyph()\n            self.ttfont[\"hmtx\"][\".notdef\"] = (  # pyright: ignore[reportIndexIssue]\n                xMax - xMin,\n                yMax - yMin,\n            )\n\n        default_width: float = round(\n            self.scale * self.ttfont[\"hmtx\"].metrics[\".notdef\"][0]\n        )\n\n        os2_table = self.ttfont[\"OS/2\"]\n        post_table = self.ttfont[\"post\"]\n\n        try:\n            cap_height = os2_table.sCapHeight\n        except AttributeError:\n            cap_height = self.ttfont[\"hhea\"].ascent\n\n        # entry for the PDF font descriptor specifying various characteristics of the font\n        flags = FontDescriptorFlags.SYMBOLIC\n        if post_table.isFixedPitch:\n            flags |= FontDescriptorFlags.FIXED_PITCH\n        if post_table.italicAngle != 0:\n            flags |= FontDescriptorFlags.ITALIC\n        if os2_table.usWeightClass >= 600:\n            flags |= FontDescriptorFlags.FORCE_BOLD\n\n        self.desc = PDFFontDescriptor(\n            ascent=round(self.ttfont[\"hhea\"].ascent * self.scale),\n            descent=round(self.ttfont[\"hhea\"].descent * self.scale),\n            cap_height=round(cap_height * self.scale),\n            flags=flags,\n            font_b_box=(\n                f\"[{self.ttfont['head'].xMin * self.scale:.0f} {self.ttfont['head'].yMin * self.scale:.0f}\"\n                f\" {self.ttfont['head'].xMax * self.scale:.0f} {self.ttfont['head'].yMax * self.scale:.0f}]\"\n            ),\n            italic_angle=int(post_table.italicAngle),\n            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),\n            missing_width=default_width,\n        )\n\n        # a map unicode_char -> char_width\n        self.cw: dict[int, float] = defaultdict(lambda: default_width)\n\n        # fonttools cmap = unicode char to glyph name\n        # saving only the keys we have a tuple with\n        # the unicode characters available on the font\n        self.cmap: dict[int, str] = self.ttfont.getBestCmap()\n        if not self.cmap:\n            raise NotImplementedError(\n                \"Font not supported as it does not have a unicode cmap table - cf. issue #1396\"\n            )\n\n        if unicode_range is not None and len(unicode_range) != 0:\n            self.cmap = {\n                codepoint: glyph_id\n                for codepoint, glyph_id in self.cmap.items()  # pyright: ignore[reportUnknownVariableType]\n                if codepoint in unicode_range\n            }\n\n        # saving a list of glyph ids to char to allow\n        # subset by unicode (regular) and by glyph\n        # (shaped with harfbuz)\n        self.glyph_ids = {}\n\n        for char in self.cmap:  # pyright: ignore[]\n            # take glyph associated to char\n            glyph = self.cmap[char]\n\n            # take width associated to glyph\n            w = self.ttfont[\"hmtx\"].metrics[glyph][0]\n\n            # probably this check could be deleted\n            if w == 65535:\n                w = 0\n\n            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP\n\n            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)\n\n        self.missing_glyphs: list[int] = []\n\n        self.name = re.sub(\"[ ()]\", \"\", self.ttfont[\"name\"].getBestFullName())\n        self.up = round(post_table.underlinePosition * self.scale)\n        self.ut = round(post_table.underlineThickness * self.scale)\n        self.sp = round(os2_table.yStrikeoutPosition * self.scale)\n        self.ss = round(os2_table.yStrikeoutSize * self.scale)\n        self.emphasis = TextEmphasis.coerce(style)\n        self.subset = SubsetMap(self)\n        self.palette_index = palette_index if palette_index is not None else 0\n        self.color_font = (\n            get_color_font_object(fpdf, self, self.palette_index)\n            if fpdf.render_color_fonts\n            else None\n        )\n\n    # pylint: disable=no-member\n    @property\n    def hbfont(self) -> \"HarfBuzzFont\":\n        if not self._hbfont:\n            if self.is_compressed:\n                # HarfBuzz cannot load compressed WOFF/WOFF2 files directly, so we\n                # re-serialize the fontTools TTFont to a raw SFNT byte buffer.\n                buf = BytesIO()\n                self.ttfont.save(buf)\n                buf.seek(0)\n                ttfont_bytes = buf.read()\n\n                # Try to create a HarfBuzz blob from bytes; if not available, write a\n                # temporary file as a last resort.\n                try:\n                    blob = hb.Blob.from_bytes(ttfont_bytes)\n                    face = hb.Face(blob)\n                except (AttributeError, RuntimeError):\n                    import tempfile, os  # pylint: disable=import-outside-toplevel\n\n                    tmp_name = None\n                    try:\n                        with tempfile.NamedTemporaryFile(\n                            suffix=\".ttf\", delete=False\n                        ) as tmp:\n                            tmp_name = tmp.name\n                            tmp.write(ttfont_bytes)\n                            tmp.flush()\n                        face = hb.Face(hb.Blob.from_file_path(tmp_name))\n                    finally:\n                        if tmp_name:\n                            try:\n                                os.unlink(tmp_name)\n                            except OSError as cleanup_error:\n                                # Log warning about failed cleanup - orphaned temp file may cause disk issues\n                                LOGGER.warning(\n                                    \"Failed to clean up temporary font file '%s': %s. This may leave an orphaned file on disk.\",\n                                    tmp_name,\n                                    cleanup_error,\n                                )\n\n                self._hbfont = HarfBuzzFont(face)\n            else:\n                # For regular TTF/OTF fonts, load directly from file path (faster)\n                self._hbfont = HarfBuzzFont(\n                    hb.Face(hb.Blob.from_file_path(self.ttffile))\n                )\n\n        return self._hbfont\n\n    def __repr__(self) -> str:\n        return f\"TTFFont(i={self.i}, fontkey={self.fontkey})\"\n\n    def __deepcopy__(self: \"TTFFont\", memo: dict[int, Any]) -> \"TTFFont\":\n        \"\"\"\n        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes\n        but instead share references to immutable objects\n        between the original FPDF instance and the FPDFRecorder instances\n        to avoid performances issues as spotted in issue #1444.\n        \"\"\"\n        copy = TTFFont.__new__(TTFFont)\n        # Immutable attributes:\n        copy.i = self.i\n        copy.type = \"TTF\"\n        copy.ttffile = self.ttffile\n        copy.fontkey = self.fontkey\n        copy.scale = self.scale\n        copy.name = self.name\n        copy.up = self.up\n        copy.ut = self.ut\n        copy.sp = self.sp\n        copy.ss = self.ss\n        copy.emphasis = self.emphasis\n        copy.is_compressed = self.is_compressed\n        # Attributes shared, to improve FPDFRecorder performances:\n        copy.ttfont = self.ttfont\n        copy.cmap = self.cmap\n        copy.desc = self.desc\n        # Attributes deepcopied:\n        copy.cw = deepcopy(self.cw, memo)\n        copy.glyph_ids = deepcopy(self.glyph_ids, memo)\n        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)\n        copy.subset = deepcopy(self.subset, memo)\n        copy.biggest_size_pt = self.biggest_size_pt\n        copy._hbfont = self._hbfont\n        copy.color_font = self.color_font\n        copy.palette_index = self.palette_index\n        return copy\n\n    def close(self) -> None:\n        self.ttfont.close()\n        self._hbfont = None\n\n    def escape_text(self, text: str) -> str:\n        if self.color_font:\n            encoded = text.encode(\"latin-1\", errors=\"replace\")\n            return escape_parens(encoded.decode(\"latin-1\", errors=\"ignore\"))\n        return escape_parens(text.encode(\"utf-16-be\").decode(\"latin-1\"))\n\n    def get_text_width(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[int, float]:\n        if font_size_pt > self.biggest_size_pt:\n            self.biggest_size_pt = font_size_pt\n        if text_shaping_params:\n            return self.shaped_text_width(text, font_size_pt, text_shaping_params)\n        return (len(text), sum(self.cw[ord(c)] for c in text) * font_size_pt * 0.001)\n\n    def shaped_text_width(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[int, float]:\n        \"\"\"\n        When texts are shaped, the length of a string is not always the sum of all individual character widths\n        This method will invoke harfbuzz to perform the text shaping and return the sum of \"x_advance\"\n        and \"x_offset\" for each glyph. This method works for \"left to right\" or \"right to left\" texts.\n        \"\"\"\n        _, glyph_positions = self.perform_harfbuzz_shaping(\n            text, font_size_pt, text_shaping_params\n        )\n\n        # If there is nothing to render (harfbuzz returns None), we return 0 text width\n        if glyph_positions is None:\n            return (0, 0)\n\n        text_width: float = 0\n        for pos in glyph_positions:\n            text_width += (\n                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001\n            )\n        return (len(glyph_positions), text_width)\n\n    # Disabling this check - looks like cython confuses pylint:\n    # pylint: disable=no-member\n    def perform_harfbuzz_shaping(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[Sequence[\"HBGlyphInfo\"], Sequence[\"HBGlyphPosition\"]]:\n        \"\"\"\n        This method invokes Harfbuzz to perform text shaping of the input string\n        \"\"\"\n        self.hbfont.ptem = font_size_pt\n        if TYPE_CHECKING:\n            buf: HBBuffer\n        buf = hb.Buffer()\n        buf.cluster_level = 1\n        buf.add_str(\"\".join(text))\n        buf.guess_segment_properties()\n        features = (\n            text_shaping_params[\"features\"] if text_shaping_params is not None else {}\n        )\n        if text_shaping_params is None:\n            text_shaping_params = {}\n        if (\n            \"fragment_direction\" in text_shaping_params\n            and text_shaping_params[\"fragment_direction\"] is not None\n        ):\n            buf.direction = text_shaping_params[\"fragment_direction\"].value\n        if (\n            \"script\" in text_shaping_params\n            and text_shaping_params[\"script\"] is not None\n        ):\n            buf.script = text_shaping_params[\"script\"]\n        if (\n            \"language\" in text_shaping_params\n            and text_shaping_params[\"language\"] is not None\n        ):\n            buf.language = text_shaping_params[\"language\"]\n        hb.shape(self.hbfont, buf, features)\n        return buf.glyph_infos, buf.glyph_positions\n\n    def encode_text(self, text: str) -> str:\n        txt_mapped = \"\"\n        for char in text:\n            uni = ord(char)\n            # Instead of adding the actual character to the stream its code is\n            # mapped to a position in the font's subset\n            mapped_char: Optional[int] = self.subset.pick(uni)\n            if mapped_char is not None:\n                txt_mapped += chr(mapped_char)\n        return f\"({self.escape_text(txt_mapped)}) Tj\"\n\n    def shape_text(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> Sequence[dict[str, Any]]:\n        \"\"\"\n        This method will invoke harfbuzz for text shaping, include the mapping code\n        of the glyphs on the subset and map input characters to the cluster codes\n        \"\"\"\n        if len(text) == 0:\n            return []\n        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(\n            text, font_size_pt, text_shaping_params\n        )\n        text_info = []\n\n        # Find cluster gaps\n        # Ex: text = \"ABCD\"\n        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph\n        # (ligature or substitution) - the glyph should have both unicodes and it should be translated\n        # properly on the CID to GID mapping\n        #\n        def get_cluster_from_text_index(cluster_list: Sequence[int], index: int) -> int:\n            pos = bisect_left(cluster_list, index)\n            if pos == 0:\n                return cluster_list[0]\n            if pos == len(cluster_list) or cluster_list[pos] != index:\n                return cluster_list[pos - 1]\n            return cluster_list[pos]\n\n        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))\n        cluster_mapping: dict[int, list[int]] = {}\n        for i in range(len(text)):\n            cl = get_cluster_from_text_index(cluster_list, i)\n            if cl in cluster_mapping:\n                cluster_mapping[cl].append(i)\n            else:\n                cluster_mapping[cl] = [i]\n\n        for cluster_seq, gi in enumerate(glyph_infos):\n            unicode = []\n            if gi.cluster in cluster_mapping:\n                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]\n                cluster_mapping.pop(gi.cluster)\n\n            gname = self.ttfont.getGlyphName(gi.codepoint)\n            gwidth = round(self.scale * self.ttfont[\"hmtx\"].metrics[gname][0])\n            glyph = self.subset.get_glyph(\n                glyph=gi.codepoint,\n                unicode=tuple(unicode),\n                glyph_name=gname,\n                glyph_width=gwidth,\n            )\n            if glyph is None:\n                continue\n            force_positioning = False\n            if (\n                gwidth != glyph_positions[cluster_seq].x_advance\n                or glyph_positions[cluster_seq].x_offset != 0\n                or glyph_positions[cluster_seq].y_offset != 0\n                or glyph_positions[cluster_seq].y_advance != 0\n            ):\n                force_positioning = True\n            text_info.append(\n                {\n                    \"mapped_char\": self.subset.pick_glyph(glyph),\n                    \"x_advance\": glyph_positions[cluster_seq].x_advance,\n                    \"y_advance\": glyph_positions[cluster_seq].y_advance,\n                    \"x_offset\": glyph_positions[cluster_seq].x_offset,\n                    \"y_offset\": glyph_positions[cluster_seq].y_offset,\n                    \"force_positioning\": force_positioning,\n                }\n            )\n        return text_info",
      "language": "python"
    },
    {
      "code": "class TTFFont:\n    __slots__ = (  # RAM usage optimization\n        \"i\",\n        \"type\",\n        \"name\",\n        \"desc\",\n        \"glyph_ids\",\n        \"_hbfont\",\n        \"sp\",\n        \"ss\",\n        \"up\",\n        \"ut\",\n        \"cw\",\n        \"ttffile\",\n        \"fontkey\",\n        \"emphasis\",\n        \"scale\",\n        \"subset\",\n        \"cmap\",\n        \"ttfont\",\n        \"missing_glyphs\",\n        \"biggest_size_pt\",\n        \"color_font\",\n        \"unicode_range\",\n        \"palette_index\",\n        \"is_compressed\",\n    )\n\n    def __init__(\n        self,\n        fpdf: \"FPDF\",\n        font_file_path: Path,\n        fontkey: str,\n        style: str,\n        unicode_range: Optional[set[int]] = None,\n        axes_dict: Optional[dict[str, float]] = None,\n        palette_index: Optional[int] = None,\n    ):\n        self.i = len(fpdf.fonts) + 1\n        self.type = \"TTF\"\n        self.ttffile = font_file_path\n        self.is_compressed = str(self.ttffile).lower().endswith((\".woff\", \".woff2\"))\n        self._hbfont: Optional[\"HarfBuzzFont\"] = None\n        self.fontkey = fontkey\n        self.biggest_size_pt: float = 0\n\n        # recalcTimestamp=False means that it doesn't modify the \"modified\" timestamp in head table\n        # if we leave recalcTimestamp=True the tests will break every time\n        try:\n            self.ttfont = ttLib.TTFont(\n                self.ttffile, recalcTimestamp=False, fontNumber=0, lazy=True\n            )\n        except (\n            ImportError,\n            RuntimeError,\n        ) as exc:  # pragma: no cover - defensive messaging\n            # If the user passed a WOFF2 file but brotli is not installed, fontTools\n            # raises an ImportError/RuntimeError during parsing. Provide a clearer hint\n            # only for that specific situation. Allow other exceptions (e.g. FileNotFoundError,\n            # OSError, parsing errors) to propagate normally so they aren't masked here.\n            fname_str = str(self.ttffile).lower()\n            if fname_str.endswith(\".woff2\"):\n                raise RuntimeError(\n                    \"Could not open WOFF2 font. WOFF2 support requires an external Brotli \"\n                    \"library (install 'brotli' or 'brotlicffi'). Original error: \"\n                    f\"{exc!s}\"\n                ) from exc\n            raise\n\n        if axes_dict is not None:\n            if \"fvar\" not in self.ttfont:\n                raise AttributeError(f\"{self.ttffile} is not a variable font\")\n\n            instancer.instantiateVariableFont(\n                self.ttfont,\n                axes_dict,\n                inplace=True,\n                static=True,\n            )\n        if self.is_compressed:\n            # Normalize to SFNT output for embedding and HarfBuzz.\n            self.ttfont.flavor = None\n        upem: float = float(self.ttfont[\"head\"].unitsPerEm)\n        self.scale: float = 1000 / upem\n\n        # check if the font is a TrueType and missing a .notdef glyph\n        # if it is missing, provide a fallback glyph\n        if (\n            \"glyf\" in self.ttfont\n            and \".notdef\"\n            not in self.ttfont[\"glyf\"]  # pyright: ignore[reportOperatorIssue]\n        ):\n            LOGGER.warning(\n                (\n                    \"TrueType Font '%s' is missing the '.notdef' glyph. \"\n                    \"Fallback glyph will be provided.\"\n                ),\n                self.fontkey,\n            )\n            # draw a diagonal cross .notdef glyph\n            xMin, xMax, yMin, yMax = (\n                self.ttfont[\"head\"].xMin,\n                self.ttfont[\"head\"].xMax,\n                self.ttfont[\"head\"].yMin,\n                self.ttfont[\"head\"].yMax,\n            )\n            pen = TTGlyphPen(self.ttfont[\"glyf\"])  # pyright: ignore[reportArgumentType]\n            pen.moveTo((xMin, yMin))\n            pen.lineTo((xMax, yMin))\n            pen.lineTo((xMax, yMax))\n            pen.lineTo((xMin, yMax))\n            pen.closePath()\n            pen.moveTo((xMin, yMin))\n            pen.lineTo((xMax, yMax))\n            pen.closePath()\n            pen.moveTo((xMax, yMin))\n            pen.lineTo((xMin, yMax))\n            pen.closePath()\n\n            self.ttfont[\"glyf\"][  # pyright: ignore[reportIndexIssue]\n                \".notdef\"\n            ] = pen.glyph()\n            self.ttfont[\"hmtx\"][\".notdef\"] = (  # pyright: ignore[reportIndexIssue]\n                xMax - xMin,\n                yMax - yMin,\n            )\n\n        default_width: float = round(\n            self.scale * self.ttfont[\"hmtx\"].metrics[\".notdef\"][0]\n        )\n\n        os2_table = self.ttfont[\"OS/2\"]\n        post_table = self.ttfont[\"post\"]\n\n        try:\n            cap_height = os2_table.sCapHeight\n        except AttributeError:\n            cap_height = self.ttfont[\"hhea\"].ascent\n\n        # entry for the PDF font descriptor specifying various characteristics of the font\n        flags = FontDescriptorFlags.SYMBOLIC\n        if post_table.isFixedPitch:\n            flags |= FontDescriptorFlags.FIXED_PITCH\n        if post_table.italicAngle != 0:\n            flags |= FontDescriptorFlags.ITALIC\n        if os2_table.usWeightClass >= 600:\n            flags |= FontDescriptorFlags.FORCE_BOLD\n\n        self.desc = PDFFontDescriptor(\n            ascent=round(self.ttfont[\"hhea\"].ascent * self.scale),\n            descent=round(self.ttfont[\"hhea\"].descent * self.scale),\n            cap_height=round(cap_height * self.scale),\n            flags=flags,\n            font_b_box=(\n                f\"[{self.ttfont['head'].xMin * self.scale:.0f} {self.ttfont['head'].yMin * self.scale:.0f}\"\n                f\" {self.ttfont['head'].xMax * self.scale:.0f} {self.ttfont['head'].yMax * self.scale:.0f}]\"\n            ),\n            italic_angle=int(post_table.italicAngle),\n            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),\n            missing_width=default_width,\n        )\n\n        # a map unicode_char -> char_width\n        self.cw: dict[int, float] = defaultdict(lambda: default_width)\n\n        # fonttools cmap = unicode char to glyph name\n        # saving only the keys we have a tuple with\n        # the unicode characters available on the font\n        self.cmap: dict[int, str] = self.ttfont.getBestCmap()\n        if not self.cmap:\n            raise NotImplementedError(\n                \"Font not supported as it does not have a unicode cmap table - cf. issue #1396\"\n            )\n\n        if unicode_range is not None and len(unicode_range) != 0:\n            self.cmap = {\n                codepoint: glyph_id\n                for codepoint, glyph_id in self.cmap.items()  # pyright: ignore[reportUnknownVariableType]\n                if codepoint in unicode_range\n            }\n\n        # saving a list of glyph ids to char to allow\n        # subset by unicode (regular) and by glyph\n        # (shaped with harfbuz)\n        self.glyph_ids = {}\n\n        for char in self.cmap:  # pyright: ignore[]\n            # take glyph associated to char\n            glyph = self.cmap[char]\n\n            # take width associated to glyph\n            w = self.ttfont[\"hmtx\"].metrics[glyph][0]\n\n            # probably this check could be deleted\n            if w == 65535:\n                w = 0\n\n            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP\n\n            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)\n\n        self.missing_glyphs: list[int] = []\n\n        self.name = re.sub(\"[ ()]\", \"\", self.ttfont[\"name\"].getBestFullName())\n        self.up = round(post_table.underlinePosition * self.scale)\n        self.ut = round(post_table.underlineThickness * self.scale)\n        self.sp = round(os2_table.yStrikeoutPosition * self.scale)\n        self.ss = round(os2_table.yStrikeoutSize * self.scale)\n        self.emphasis = TextEmphasis.coerce(style)\n        self.subset = SubsetMap(self)\n        self.palette_index = palette_index if palette_index is not None else 0\n        self.color_font = (\n            get_color_font_object(fpdf, self, self.palette_index)\n            if fpdf.render_color_fonts\n            else None\n        )\n\n    # pylint: disable=no-member\n    @property\n    def hbfont(self) -> \"HarfBuzzFont\":\n        if not self._hbfont:\n            if self.is_compressed:\n                # HarfBuzz cannot load compressed WOFF/WOFF2 files directly, so we\n                # re-serialize the fontTools TTFont to a raw SFNT byte buffer.\n                buf = BytesIO()\n                self.ttfont.save(buf)\n                buf.seek(0)\n                ttfont_bytes = buf.read()\n\n                # Try to create a HarfBuzz blob from bytes; if not available, write a\n                # temporary file as a last resort.\n                try:\n                    blob = hb.Blob.from_bytes(ttfont_bytes)\n                    face = hb.Face(blob)\n                except (AttributeError, RuntimeError):\n                    import tempfile, os  # pylint: disable=import-outside-toplevel\n\n                    tmp_name = None\n                    try:\n                        with tempfile.NamedTemporaryFile(\n                            suffix=\".ttf\", delete=False\n                        ) as tmp:\n                            tmp_name = tmp.name\n                            tmp.write(ttfont_bytes)\n                            tmp.flush()\n                        face = hb.Face(hb.Blob.from_file_path(tmp_name))\n                    finally:\n                        if tmp_name:\n                            try:\n                                os.unlink(tmp_name)\n                            except OSError as cleanup_error:\n                                # Log warning about failed cleanup - orphaned temp file may cause disk issues\n                                LOGGER.warning(\n                                    \"Failed to clean up temporary font file '%s': %s. This may leave an orphaned file on disk.\",\n                                    tmp_name,\n                                    cleanup_error,\n                                )\n\n                self._hbfont = HarfBuzzFont(face)\n            else:\n                # For regular TTF/OTF fonts, load directly from file path (faster)\n                self._hbfont = HarfBuzzFont(\n                    hb.Face(hb.Blob.from_file_path(self.ttffile))\n                )\n\n        return self._hbfont\n\n    def __repr__(self) -> str:\n        return f\"TTFFont(i={self.i}, fontkey={self.fontkey})\"\n\n    def __deepcopy__(self: \"TTFFont\", memo: dict[int, Any]) -> \"TTFFont\":\n        \"\"\"\n        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes\n        but instead share references to immutable objects\n        between the original FPDF instance and the FPDFRecorder instances\n        to avoid performances issues as spotted in issue #1444.\n        \"\"\"\n        copy = TTFFont.__new__(TTFFont)\n        # Immutable attributes:\n        copy.i = self.i\n        copy.type = \"TTF\"\n        copy.ttffile = self.ttffile\n        copy.fontkey = self.fontkey\n        copy.scale = self.scale\n        copy.name = self.name\n        copy.up = self.up\n        copy.ut = self.ut\n        copy.sp = self.sp\n        copy.ss = self.ss\n        copy.emphasis = self.emphasis\n        copy.is_compressed = self.is_compressed\n        # Attributes shared, to improve FPDFRecorder performances:\n        copy.ttfont = self.ttfont\n        copy.cmap = self.cmap\n        copy.desc = self.desc\n        # Attributes deepcopied:\n        copy.cw = deepcopy(self.cw, memo)\n        copy.glyph_ids = deepcopy(self.glyph_ids, memo)\n        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)\n        copy.subset = deepcopy(self.subset, memo)\n        copy.biggest_size_pt = self.biggest_size_pt\n        copy._hbfont = self._hbfont\n        copy.color_font = self.color_font\n        copy.palette_index = self.palette_index\n        return copy\n\n    def close(self) -> None:\n        self.ttfont.close()\n        self._hbfont = None\n\n    def escape_text(self, text: str) -> str:\n        if self.color_font:\n            encoded = text.encode(\"latin-1\", errors=\"replace\")\n            return escape_parens(encoded.decode(\"latin-1\", errors=\"ignore\"))\n        return escape_parens(text.encode(\"utf-16-be\").decode(\"latin-1\"))\n\n    def get_text_width(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[int, float]:\n        if font_size_pt > self.biggest_size_pt:\n            self.biggest_size_pt = font_size_pt\n        if text_shaping_params:\n            return self.shaped_text_width(text, font_size_pt, text_shaping_params)\n        return (len(text), sum(self.cw[ord(c)] for c in text) * font_size_pt * 0.001)\n\n    def shaped_text_width(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[int, float]:\n        \"\"\"\n        When texts are shaped, the length of a string is not always the sum of all individual character widths\n        This method will invoke harfbuzz to perform the text shaping and return the sum of \"x_advance\"\n        and \"x_offset\" for each glyph. This method works for \"left to right\" or \"right to left\" texts.\n        \"\"\"\n        _, glyph_positions = self.perform_harfbuzz_shaping(\n            text, font_size_pt, text_shaping_params\n        )\n\n        # If there is nothing to render (harfbuzz returns None), we return 0 text width\n        if glyph_positions is None:\n            return (0, 0)\n\n        text_width: float = 0\n        for pos in glyph_positions:\n            text_width += (\n                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001\n            )\n        return (len(glyph_positions), text_width)\n\n    # Disabling this check - looks like cython confuses pylint:\n    # pylint: disable=no-member\n    def perform_harfbuzz_shaping(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[Sequence[\"HBGlyphInfo\"], Sequence[\"HBGlyphPosition\"]]:\n        \"\"\"\n        This method invokes Harfbuzz to perform text shaping of the input string\n        \"\"\"\n        self.hbfont.ptem = font_size_pt\n        if TYPE_CHECKING:\n            buf: HBBuffer\n        buf = hb.Buffer()\n        buf.cluster_level = 1\n        buf.add_str(\"\".join(text))\n        buf.guess_segment_properties()\n        features = (\n            text_shaping_params[\"features\"] if text_shaping_params is not None else {}\n        )\n        if text_shaping_params is None:\n            text_shaping_params = {}\n        if (\n            \"fragment_direction\" in text_shaping_params\n            and text_shaping_params[\"fragment_direction\"] is not None\n        ):\n            buf.direction = text_shaping_params[\"fragment_direction\"].value\n        if (\n            \"script\" in text_shaping_params\n            and text_shaping_params[\"script\"] is not None\n        ):\n            buf.script = text_shaping_params[\"script\"]\n        if (\n            \"language\" in text_shaping_params\n            and text_shaping_params[\"language\"] is not None\n        ):\n            buf.language = text_shaping_params[\"language\"]\n        hb.shape(self.hbfont, buf, features)\n        return buf.glyph_infos, buf.glyph_positions\n\n    def encode_text(self, text: str) -> str:\n        txt_mapped = \"\"\n        for char in text:\n            uni = ord(char)\n            # Instead of adding the actual character to the stream its code is\n            # mapped to a position in the font's subset\n            mapped_char: Optional[int] = self.subset.pick(uni)\n            if mapped_char is not None:\n                txt_mapped += chr(mapped_char)\n        return f\"({self.escape_text(txt_mapped)}) Tj\"\n\n    def shape_text(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> Sequence[dict[str, Any]]:\n        \"\"\"\n        This method will invoke harfbuzz for text shaping, include the mapping code\n        of the glyphs on the subset and map input characters to the cluster codes\n        \"\"\"\n        if len(text) == 0:\n            return []\n        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(\n            text, font_size_pt, text_shaping_params\n        )\n        text_info = []\n\n        # Find cluster gaps\n        # Ex: text = \"ABCD\"\n        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph\n        # (ligature or substitution) - the glyph should have both unicodes and it should be translated\n        # properly on the CID to GID mapping\n        #\n        def get_cluster_from_text_index(cluster_list: Sequence[int], index: int) -> int:\n            pos = bisect_left(cluster_list, index)\n            if pos == 0:\n                return cluster_list[0]\n            if pos == len(cluster_list) or cluster_list[pos] != index:\n                return cluster_list[pos - 1]\n            return cluster_list[pos]\n\n        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))\n        cluster_mapping: dict[int, list[int]] = {}\n        for i in range(len(text)):\n            cl = get_cluster_from_text_index(cluster_list, i)\n            if cl in cluster_mapping:\n                cluster_mapping[cl].append(i)\n            else:\n                cluster_mapping[cl] = [i]\n\n        for cluster_seq, gi in enumerate(glyph_infos):\n            unicode = []\n            if gi.cluster in cluster_mapping:\n                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]\n                cluster_mapping.pop(gi.cluster)\n\n            gname = self.ttfont.getGlyphName(gi.codepoint)\n            gwidth = round(self.scale * self.ttfont[\"hmtx\"].metrics[gname][0])\n            glyph = self.subset.get_glyph(\n                glyph=gi.codepoint,\n                unicode=tuple(unicode),\n                glyph_name=gname,\n                glyph_width=gwidth,\n            )\n            if glyph is None:\n                continue\n            force_positioning = False\n            if (\n                gwidth != glyph_positions[cluster_seq].x_advance\n                or glyph_positions[cluster_seq].x_offset != 0\n                or glyph_positions[cluster_seq].y_offset != 0\n                or glyph_positions[cluster_seq].y_advance != 0\n            ):\n                force_positioning = True\n            text_info.append(\n                {\n                    \"mapped_char\": self.subset.pick_glyph(glyph),\n                    \"x_advance\": glyph_positions[cluster_seq].x_advance,\n                    \"y_advance\": glyph_positions[cluster_seq].y_advance,\n                    \"x_offset\": glyph_positions[cluster_seq].x_offset,\n                    \"y_offset\": glyph_positions[cluster_seq].y_offset,\n                    \"force_positioning\": force_positioning,\n                }\n            )\n        return text_info",
      "language": "python"
    },
    {
      "code": "class TTFFont:\n    __slots__ = (  # RAM usage optimization\n        \"i\",\n        \"type\",\n        \"name\",\n        \"desc\",\n        \"glyph_ids\",\n        \"_hbfont\",\n        \"sp\",\n        \"ss\",\n        \"up\",\n        \"ut\",\n        \"cw\",\n        \"ttffile\",\n        \"fontkey\",\n        \"emphasis\",\n        \"scale\",\n        \"subset\",\n        \"cmap\",\n        \"ttfont\",\n        \"missing_glyphs\",\n        \"biggest_size_pt\",\n        \"color_font\",\n        \"unicode_range\",\n        \"palette_index\",\n        \"is_compressed\",\n    )\n\n    def __init__(\n        self,\n        fpdf: \"FPDF\",\n        font_file_path: Path,\n        fontkey: str,\n        style: str,\n        unicode_range: Optional[set[int]] = None,\n        axes_dict: Optional[dict[str, float]] = None,\n        palette_index: Optional[int] = None,\n    ):\n        self.i = len(fpdf.fonts) + 1\n        self.type = \"TTF\"\n        self.ttffile = font_file_path\n        self.is_compressed = str(self.ttffile).lower().endswith((\".woff\", \".woff2\"))\n        self._hbfont: Optional[\"HarfBuzzFont\"] = None\n        self.fontkey = fontkey\n        self.biggest_size_pt: float = 0\n\n        # recalcTimestamp=False means that it doesn't modify the \"modified\" timestamp in head table\n        # if we leave recalcTimestamp=True the tests will break every time\n        try:\n            self.ttfont = ttLib.TTFont(\n                self.ttffile, recalcTimestamp=False, fontNumber=0, lazy=True\n            )\n        except (\n            ImportError,\n            RuntimeError,\n        ) as exc:  # pragma: no cover - defensive messaging\n            # If the user passed a WOFF2 file but brotli is not installed, fontTools\n            # raises an ImportError/RuntimeError during parsing. Provide a clearer hint\n            # only for that specific situation. Allow other exceptions (e.g. FileNotFoundError,\n            # OSError, parsing errors) to propagate normally so they aren't masked here.\n            fname_str = str(self.ttffile).lower()\n            if fname_str.endswith(\".woff2\"):\n                raise RuntimeError(\n                    \"Could not open WOFF2 font. WOFF2 support requires an external Brotli \"\n                    \"library (install 'brotli' or 'brotlicffi'). Original error: \"\n                    f\"{exc!s}\"\n                ) from exc\n            raise\n\n        if axes_dict is not None:\n            if \"fvar\" not in self.ttfont:\n                raise AttributeError(f\"{self.ttffile} is not a variable font\")\n\n            instancer.instantiateVariableFont(\n                self.ttfont,\n                axes_dict,\n                inplace=True,\n                static=True,\n            )\n        if self.is_compressed:\n            # Normalize to SFNT output for embedding and HarfBuzz.\n            self.ttfont.flavor = None\n        upem: float = float(self.ttfont[\"head\"].unitsPerEm)\n        self.scale: float = 1000 / upem\n\n        # check if the font is a TrueType and missing a .notdef glyph\n        # if it is missing, provide a fallback glyph\n        if (\n            \"glyf\" in self.ttfont\n            and \".notdef\"\n            not in self.ttfont[\"glyf\"]  # pyright: ignore[reportOperatorIssue]\n        ):\n            LOGGER.warning(\n                (\n                    \"TrueType Font '%s' is missing the '.notdef' glyph. \"\n                    \"Fallback glyph will be provided.\"\n                ),\n                self.fontkey,\n            )\n            # draw a diagonal cross .notdef glyph\n            xMin, xMax, yMin, yMax = (\n                self.ttfont[\"head\"].xMin,\n                self.ttfont[\"head\"].xMax,\n                self.ttfont[\"head\"].yMin,\n                self.ttfont[\"head\"].yMax,\n            )\n            pen = TTGlyphPen(self.ttfont[\"glyf\"])  # pyright: ignore[reportArgumentType]\n            pen.moveTo((xMin, yMin))\n            pen.lineTo((xMax, yMin))\n            pen.lineTo((xMax, yMax))\n            pen.lineTo((xMin, yMax))\n            pen.closePath()\n            pen.moveTo((xMin, yMin))\n            pen.lineTo((xMax, yMax))\n            pen.closePath()\n            pen.moveTo((xMax, yMin))\n            pen.lineTo((xMin, yMax))\n            pen.closePath()\n\n            self.ttfont[\"glyf\"][  # pyright: ignore[reportIndexIssue]\n                \".notdef\"\n            ] = pen.glyph()\n            self.ttfont[\"hmtx\"][\".notdef\"] = (  # pyright: ignore[reportIndexIssue]\n                xMax - xMin,\n                yMax - yMin,\n            )\n\n        default_width: float = round(\n            self.scale * self.ttfont[\"hmtx\"].metrics[\".notdef\"][0]\n        )\n\n        os2_table = self.ttfont[\"OS/2\"]\n        post_table = self.ttfont[\"post\"]\n\n        try:\n            cap_height = os2_table.sCapHeight\n        except AttributeError:\n            cap_height = self.ttfont[\"hhea\"].ascent\n\n        # entry for the PDF font descriptor specifying various characteristics of the font\n        flags = FontDescriptorFlags.SYMBOLIC\n        if post_table.isFixedPitch:\n            flags |= FontDescriptorFlags.FIXED_PITCH\n        if post_table.italicAngle != 0:\n            flags |= FontDescriptorFlags.ITALIC\n        if os2_table.usWeightClass >= 600:\n            flags |= FontDescriptorFlags.FORCE_BOLD\n\n        self.desc = PDFFontDescriptor(\n            ascent=round(self.ttfont[\"hhea\"].ascent * self.scale),\n            descent=round(self.ttfont[\"hhea\"].descent * self.scale),\n            cap_height=round(cap_height * self.scale),\n            flags=flags,\n            font_b_box=(\n                f\"[{self.ttfont['head'].xMin * self.scale:.0f} {self.ttfont['head'].yMin * self.scale:.0f}\"\n                f\" {self.ttfont['head'].xMax * self.scale:.0f} {self.ttfont['head'].yMax * self.scale:.0f}]\"\n            ),\n            italic_angle=int(post_table.italicAngle),\n            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),\n            missing_width=default_width,\n        )\n\n        # a map unicode_char -> char_width\n        self.cw: dict[int, float] = defaultdict(lambda: default_width)\n\n        # fonttools cmap = unicode char to glyph name\n        # saving only the keys we have a tuple with\n        # the unicode characters available on the font\n        self.cmap: dict[int, str] = self.ttfont.getBestCmap()\n        if not self.cmap:\n            raise NotImplementedError(\n                \"Font not supported as it does not have a unicode cmap table - cf. issue #1396\"\n            )\n\n        if unicode_range is not None and len(unicode_range) != 0:\n            self.cmap = {\n                codepoint: glyph_id\n                for codepoint, glyph_id in self.cmap.items()  # pyright: ignore[reportUnknownVariableType]\n                if codepoint in unicode_range\n            }\n\n        # saving a list of glyph ids to char to allow\n        # subset by unicode (regular) and by glyph\n        # (shaped with harfbuz)\n        self.glyph_ids = {}\n\n        for char in self.cmap:  # pyright: ignore[]\n            # take glyph associated to char\n            glyph = self.cmap[char]\n\n            # take width associated to glyph\n            w = self.ttfont[\"hmtx\"].metrics[glyph][0]\n\n            # probably this check could be deleted\n            if w == 65535:\n                w = 0\n\n            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP\n\n            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)\n\n        self.missing_glyphs: list[int] = []\n\n        self.name = re.sub(\"[ ()]\", \"\", self.ttfont[\"name\"].getBestFullName())\n        self.up = round(post_table.underlinePosition * self.scale)\n        self.ut = round(post_table.underlineThickness * self.scale)\n        self.sp = round(os2_table.yStrikeoutPosition * self.scale)\n        self.ss = round(os2_table.yStrikeoutSize * self.scale)\n        self.emphasis = TextEmphasis.coerce(style)\n        self.subset = SubsetMap(self)\n        self.palette_index = palette_index if palette_index is not None else 0\n        self.color_font = (\n            get_color_font_object(fpdf, self, self.palette_index)\n            if fpdf.render_color_fonts\n            else None\n        )\n\n    # pylint: disable=no-member\n    @property\n    def hbfont(self) -> \"HarfBuzzFont\":\n        if not self._hbfont:\n            if self.is_compressed:\n                # HarfBuzz cannot load compressed WOFF/WOFF2 files directly, so we\n                # re-serialize the fontTools TTFont to a raw SFNT byte buffer.\n                buf = BytesIO()\n                self.ttfont.save(buf)\n                buf.seek(0)\n                ttfont_bytes = buf.read()\n\n                # Try to create a HarfBuzz blob from bytes; if not available, write a\n                # temporary file as a last resort.\n                try:\n                    blob = hb.Blob.from_bytes(ttfont_bytes)\n                    face = hb.Face(blob)\n                except (AttributeError, RuntimeError):\n                    import tempfile, os  # pylint: disable=import-outside-toplevel\n\n                    tmp_name = None\n                    try:\n                        with tempfile.NamedTemporaryFile(\n                            suffix=\".ttf\", delete=False\n                        ) as tmp:\n                            tmp_name = tmp.name\n                            tmp.write(ttfont_bytes)\n                            tmp.flush()\n                        face = hb.Face(hb.Blob.from_file_path(tmp_name))\n                    finally:\n                        if tmp_name:\n                            try:\n                                os.unlink(tmp_name)\n                            except OSError as cleanup_error:\n                                # Log warning about failed cleanup - orphaned temp file may cause disk issues\n                                LOGGER.warning(\n                                    \"Failed to clean up temporary font file '%s': %s. This may leave an orphaned file on disk.\",\n                                    tmp_name,\n                                    cleanup_error,\n                                )\n\n                self._hbfont = HarfBuzzFont(face)\n            else:\n                # For regular TTF/OTF fonts, load directly from file path (faster)\n                self._hbfont = HarfBuzzFont(\n                    hb.Face(hb.Blob.from_file_path(self.ttffile))\n                )\n\n        return self._hbfont\n\n    def __repr__(self) -> str:\n        return f\"TTFFont(i={self.i}, fontkey={self.fontkey})\"\n\n    def __deepcopy__(self: \"TTFFont\", memo: dict[int, Any]) -> \"TTFFont\":\n        \"\"\"\n        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes\n        but instead share references to immutable objects\n        between the original FPDF instance and the FPDFRecorder instances\n        to avoid performances issues as spotted in issue #1444.\n        \"\"\"\n        copy = TTFFont.__new__(TTFFont)\n        # Immutable attributes:\n        copy.i = self.i\n        copy.type = \"TTF\"\n        copy.ttffile = self.ttffile\n        copy.fontkey = self.fontkey\n        copy.scale = self.scale\n        copy.name = self.name\n        copy.up = self.up\n        copy.ut = self.ut\n        copy.sp = self.sp\n        copy.ss = self.ss\n        copy.emphasis = self.emphasis\n        copy.is_compressed = self.is_compressed\n        # Attributes shared, to improve FPDFRecorder performances:\n        copy.ttfont = self.ttfont\n        copy.cmap = self.cmap\n        copy.desc = self.desc\n        # Attributes deepcopied:\n        copy.cw = deepcopy(self.cw, memo)\n        copy.glyph_ids = deepcopy(self.glyph_ids, memo)\n        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)\n        copy.subset = deepcopy(self.subset, memo)\n        copy.biggest_size_pt = self.biggest_size_pt\n        copy._hbfont = self._hbfont\n        copy.color_font = self.color_font\n        copy.palette_index = self.palette_index\n        return copy\n\n    def close(self) -> None:\n        self.ttfont.close()\n        self._hbfont = None\n\n    def escape_text(self, text: str) -> str:\n        if self.color_font:\n            encoded = text.encode(\"latin-1\", errors=\"replace\")\n            return escape_parens(encoded.decode(\"latin-1\", errors=\"ignore\"))\n        return escape_parens(text.encode(\"utf-16-be\").decode(\"latin-1\"))\n\n    def get_text_width(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[int, float]:\n        if font_size_pt > self.biggest_size_pt:\n            self.biggest_size_pt = font_size_pt\n        if text_shaping_params:\n            return self.shaped_text_width(text, font_size_pt, text_shaping_params)\n        return (len(text), sum(self.cw[ord(c)] for c in text) * font_size_pt * 0.001)\n\n    def shaped_text_width(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[int, float]:\n        \"\"\"\n        When texts are shaped, the length of a string is not always the sum of all individual character widths\n        This method will invoke harfbuzz to perform the text shaping and return the sum of \"x_advance\"\n        and \"x_offset\" for each glyph. This method works for \"left to right\" or \"right to left\" texts.\n        \"\"\"\n        _, glyph_positions = self.perform_harfbuzz_shaping(\n            text, font_size_pt, text_shaping_params\n        )\n\n        # If there is nothing to render (harfbuzz returns None), we return 0 text width\n        if glyph_positions is None:\n            return (0, 0)\n\n        text_width: float = 0\n        for pos in glyph_positions:\n            text_width += (\n                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001\n            )\n        return (len(glyph_positions), text_width)\n\n    # Disabling this check - looks like cython confuses pylint:\n    # pylint: disable=no-member\n    def perform_harfbuzz_shaping(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[Sequence[\"HBGlyphInfo\"], Sequence[\"HBGlyphPosition\"]]:\n        \"\"\"\n        This method invokes Harfbuzz to perform text shaping of the input string\n        \"\"\"\n        self.hbfont.ptem = font_size_pt\n        if TYPE_CHECKING:\n            buf: HBBuffer\n        buf = hb.Buffer()\n        buf.cluster_level = 1\n        buf.add_str(\"\".join(text))\n        buf.guess_segment_properties()\n        features = (\n            text_shaping_params[\"features\"] if text_shaping_params is not None else {}\n        )\n        if text_shaping_params is None:\n            text_shaping_params = {}\n        if (\n            \"fragment_direction\" in text_shaping_params\n            and text_shaping_params[\"fragment_direction\"] is not None\n        ):\n            buf.direction = text_shaping_params[\"fragment_direction\"].value\n        if (\n            \"script\" in text_shaping_params\n            and text_shaping_params[\"script\"] is not None\n        ):\n            buf.script = text_shaping_params[\"script\"]\n        if (\n            \"language\" in text_shaping_params\n            and text_shaping_params[\"language\"] is not None\n        ):\n            buf.language = text_shaping_params[\"language\"]\n        hb.shape(self.hbfont, buf, features)\n        return buf.glyph_infos, buf.glyph_positions\n\n    def encode_text(self, text: str) -> str:\n        txt_mapped = \"\"\n        for char in text:\n            uni = ord(char)\n            # Instead of adding the actual character to the stream its code is\n            # mapped to a position in the font's subset\n            mapped_char: Optional[int] = self.subset.pick(uni)\n            if mapped_char is not None:\n                txt_mapped += chr(mapped_char)\n        return f\"({self.escape_text(txt_mapped)}) Tj\"\n\n    def shape_text(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> Sequence[dict[str, Any]]:\n        \"\"\"\n        This method will invoke harfbuzz for text shaping, include the mapping code\n        of the glyphs on the subset and map input characters to the cluster codes\n        \"\"\"\n        if len(text) == 0:\n            return []\n        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(\n            text, font_size_pt, text_shaping_params\n        )\n        text_info = []\n\n        # Find cluster gaps\n        # Ex: text = \"ABCD\"\n        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph\n        # (ligature or substitution) - the glyph should have both unicodes and it should be translated\n        # properly on the CID to GID mapping\n        #\n        def get_cluster_from_text_index(cluster_list: Sequence[int], index: int) -> int:\n            pos = bisect_left(cluster_list, index)\n            if pos == 0:\n                return cluster_list[0]\n            if pos == len(cluster_list) or cluster_list[pos] != index:\n                return cluster_list[pos - 1]\n            return cluster_list[pos]\n\n        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))\n        cluster_mapping: dict[int, list[int]] = {}\n        for i in range(len(text)):\n            cl = get_cluster_from_text_index(cluster_list, i)\n            if cl in cluster_mapping:\n                cluster_mapping[cl].append(i)\n            else:\n                cluster_mapping[cl] = [i]\n\n        for cluster_seq, gi in enumerate(glyph_infos):\n            unicode = []\n            if gi.cluster in cluster_mapping:\n                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]\n                cluster_mapping.pop(gi.cluster)\n\n            gname = self.ttfont.getGlyphName(gi.codepoint)\n            gwidth = round(self.scale * self.ttfont[\"hmtx\"].metrics[gname][0])\n            glyph = self.subset.get_glyph(\n                glyph=gi.codepoint,\n                unicode=tuple(unicode),\n                glyph_name=gname,\n                glyph_width=gwidth,\n            )\n            if glyph is None:\n                continue\n            force_positioning = False\n            if (\n                gwidth != glyph_positions[cluster_seq].x_advance\n                or glyph_positions[cluster_seq].x_offset != 0\n                or glyph_positions[cluster_seq].y_offset != 0\n                or glyph_positions[cluster_seq].y_advance != 0\n            ):\n                force_positioning = True\n            text_info.append(\n                {\n                    \"mapped_char\": self.subset.pick_glyph(glyph),\n                    \"x_advance\": glyph_positions[cluster_seq].x_advance,\n                    \"y_advance\": glyph_positions[cluster_seq].y_advance,\n                    \"x_offset\": glyph_positions[cluster_seq].x_offset,\n                    \"y_offset\": glyph_positions[cluster_seq].y_offset,\n                    \"force_positioning\": force_positioning,\n                }\n            )\n        return text_info",
      "language": "python"
    },
    {
      "code": "class TTFFont:\n    __slots__ = (  # RAM usage optimization\n        \"i\",\n        \"type\",\n        \"name\",\n        \"desc\",\n        \"glyph_ids\",\n        \"_hbfont\",\n        \"sp\",\n        \"ss\",\n        \"up\",\n        \"ut\",\n        \"cw\",\n        \"ttffile\",\n        \"fontkey\",\n        \"emphasis\",\n        \"scale\",\n        \"subset\",\n        \"cmap\",\n        \"ttfont\",\n        \"missing_glyphs\",\n        \"biggest_size_pt\",\n        \"color_font\",\n        \"unicode_range\",\n        \"palette_index\",\n        \"is_compressed\",\n    )\n\n    def __init__(\n        self,\n        fpdf: \"FPDF\",\n        font_file_path: Path,\n        fontkey: str,\n        style: str,\n        unicode_range: Optional[set[int]] = None,\n        axes_dict: Optional[dict[str, float]] = None,\n        palette_index: Optional[int] = None,\n    ):\n        self.i = len(fpdf.fonts) + 1\n        self.type = \"TTF\"\n        self.ttffile = font_file_path\n        self.is_compressed = str(self.ttffile).lower().endswith((\".woff\", \".woff2\"))\n        self._hbfont: Optional[\"HarfBuzzFont\"] = None\n        self.fontkey = fontkey\n        self.biggest_size_pt: float = 0\n\n        # recalcTimestamp=False means that it doesn't modify the \"modified\" timestamp in head table\n        # if we leave recalcTimestamp=True the tests will break every time\n        try:\n            self.ttfont = ttLib.TTFont(\n                self.ttffile, recalcTimestamp=False, fontNumber=0, lazy=True\n            )\n        except (\n            ImportError,\n            RuntimeError,\n        ) as exc:  # pragma: no cover - defensive messaging\n            # If the user passed a WOFF2 file but brotli is not installed, fontTools\n            # raises an ImportError/RuntimeError during parsing. Provide a clearer hint\n            # only for that specific situation. Allow other exceptions (e.g. FileNotFoundError,\n            # OSError, parsing errors) to propagate normally so they aren't masked here.\n            fname_str = str(self.ttffile).lower()\n            if fname_str.endswith(\".woff2\"):\n                raise RuntimeError(\n                    \"Could not open WOFF2 font. WOFF2 support requires an external Brotli \"\n                    \"library (install 'brotli' or 'brotlicffi'). Original error: \"\n                    f\"{exc!s}\"\n                ) from exc\n            raise\n\n        if axes_dict is not None:\n            if \"fvar\" not in self.ttfont:\n                raise AttributeError(f\"{self.ttffile} is not a variable font\")\n\n            instancer.instantiateVariableFont(\n                self.ttfont,\n                axes_dict,\n                inplace=True,\n                static=True,\n            )\n        if self.is_compressed:\n            # Normalize to SFNT output for embedding and HarfBuzz.\n            self.ttfont.flavor = None\n        upem: float = float(self.ttfont[\"head\"].unitsPerEm)\n        self.scale: float = 1000 / upem\n\n        # check if the font is a TrueType and missing a .notdef glyph\n        # if it is missing, provide a fallback glyph\n        if (\n            \"glyf\" in self.ttfont\n            and \".notdef\"\n            not in self.ttfont[\"glyf\"]  # pyright: ignore[reportOperatorIssue]\n        ):\n            LOGGER.warning(\n                (\n                    \"TrueType Font '%s' is missing the '.notdef' glyph. \"\n                    \"Fallback glyph will be provided.\"\n                ),\n                self.fontkey,\n            )\n            # draw a diagonal cross .notdef glyph\n            xMin, xMax, yMin, yMax = (\n                self.ttfont[\"head\"].xMin,\n                self.ttfont[\"head\"].xMax,\n                self.ttfont[\"head\"].yMin,\n                self.ttfont[\"head\"].yMax,\n            )\n            pen = TTGlyphPen(self.ttfont[\"glyf\"])  # pyright: ignore[reportArgumentType]\n            pen.moveTo((xMin, yMin))\n            pen.lineTo((xMax, yMin))\n            pen.lineTo((xMax, yMax))\n            pen.lineTo((xMin, yMax))\n            pen.closePath()\n            pen.moveTo((xMin, yMin))\n            pen.lineTo((xMax, yMax))\n            pen.closePath()\n            pen.moveTo((xMax, yMin))\n            pen.lineTo((xMin, yMax))\n            pen.closePath()\n\n            self.ttfont[\"glyf\"][  # pyright: ignore[reportIndexIssue]\n                \".notdef\"\n            ] = pen.glyph()\n            self.ttfont[\"hmtx\"][\".notdef\"] = (  # pyright: ignore[reportIndexIssue]\n                xMax - xMin,\n                yMax - yMin,\n            )\n\n        default_width: float = round(\n            self.scale * self.ttfont[\"hmtx\"].metrics[\".notdef\"][0]\n        )\n\n        os2_table = self.ttfont[\"OS/2\"]\n        post_table = self.ttfont[\"post\"]\n\n        try:\n            cap_height = os2_table.sCapHeight\n        except AttributeError:\n            cap_height = self.ttfont[\"hhea\"].ascent\n\n        # entry for the PDF font descriptor specifying various characteristics of the font\n        flags = FontDescriptorFlags.SYMBOLIC\n        if post_table.isFixedPitch:\n            flags |= FontDescriptorFlags.FIXED_PITCH\n        if post_table.italicAngle != 0:\n            flags |= FontDescriptorFlags.ITALIC\n        if os2_table.usWeightClass >= 600:\n            flags |= FontDescriptorFlags.FORCE_BOLD\n\n        self.desc = PDFFontDescriptor(\n            ascent=round(self.ttfont[\"hhea\"].ascent * self.scale),\n            descent=round(self.ttfont[\"hhea\"].descent * self.scale),\n            cap_height=round(cap_height * self.scale),\n            flags=flags,\n            font_b_box=(\n                f\"[{self.ttfont['head'].xMin * self.scale:.0f} {self.ttfont['head'].yMin * self.scale:.0f}\"\n                f\" {self.ttfont['head'].xMax * self.scale:.0f} {self.ttfont['head'].yMax * self.scale:.0f}]\"\n            ),\n            italic_angle=int(post_table.italicAngle),\n            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),\n            missing_width=default_width,\n        )\n\n        # a map unicode_char -> char_width\n        self.cw: dict[int, float] = defaultdict(lambda: default_width)\n\n        # fonttools cmap = unicode char to glyph name\n        # saving only the keys we have a tuple with\n        # the unicode characters available on the font\n        self.cmap: dict[int, str] = self.ttfont.getBestCmap()\n        if not self.cmap:\n            raise NotImplementedError(\n                \"Font not supported as it does not have a unicode cmap table - cf. issue #1396\"\n            )\n\n        if unicode_range is not None and len(unicode_range) != 0:\n            self.cmap = {\n                codepoint: glyph_id\n                for codepoint, glyph_id in self.cmap.items()  # pyright: ignore[reportUnknownVariableType]\n                if codepoint in unicode_range\n            }\n\n        # saving a list of glyph ids to char to allow\n        # subset by unicode (regular) and by glyph\n        # (shaped with harfbuz)\n        self.glyph_ids = {}\n\n        for char in self.cmap:  # pyright: ignore[]\n            # take glyph associated to char\n            glyph = self.cmap[char]\n\n            # take width associated to glyph\n            w = self.ttfont[\"hmtx\"].metrics[glyph][0]\n\n            # probably this check could be deleted\n            if w == 65535:\n                w = 0\n\n            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP\n\n            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)\n\n        self.missing_glyphs: list[int] = []\n\n        self.name = re.sub(\"[ ()]\", \"\", self.ttfont[\"name\"].getBestFullName())\n        self.up = round(post_table.underlinePosition * self.scale)\n        self.ut = round(post_table.underlineThickness * self.scale)\n        self.sp = round(os2_table.yStrikeoutPosition * self.scale)\n        self.ss = round(os2_table.yStrikeoutSize * self.scale)\n        self.emphasis = TextEmphasis.coerce(style)\n        self.subset = SubsetMap(self)\n        self.palette_index = palette_index if palette_index is not None else 0\n        self.color_font = (\n            get_color_font_object(fpdf, self, self.palette_index)\n            if fpdf.render_color_fonts\n            else None\n        )\n\n    # pylint: disable=no-member\n    @property\n    def hbfont(self) -> \"HarfBuzzFont\":\n        if not self._hbfont:\n            if self.is_compressed:\n                # HarfBuzz cannot load compressed WOFF/WOFF2 files directly, so we\n                # re-serialize the fontTools TTFont to a raw SFNT byte buffer.\n                buf = BytesIO()\n                self.ttfont.save(buf)\n                buf.seek(0)\n                ttfont_bytes = buf.read()\n\n                # Try to create a HarfBuzz blob from bytes; if not available, write a\n                # temporary file as a last resort.\n                try:\n                    blob = hb.Blob.from_bytes(ttfont_bytes)\n                    face = hb.Face(blob)\n                except (AttributeError, RuntimeError):\n                    import tempfile, os  # pylint: disable=import-outside-toplevel\n\n                    tmp_name = None\n                    try:\n                        with tempfile.NamedTemporaryFile(\n                            suffix=\".ttf\", delete=False\n                        ) as tmp:\n                            tmp_name = tmp.name\n                            tmp.write(ttfont_bytes)\n                            tmp.flush()\n                        face = hb.Face(hb.Blob.from_file_path(tmp_name))\n                    finally:\n                        if tmp_name:\n                            try:\n                                os.unlink(tmp_name)\n                            except OSError as cleanup_error:\n                                # Log warning about failed cleanup - orphaned temp file may cause disk issues\n                                LOGGER.warning(\n                                    \"Failed to clean up temporary font file '%s': %s. This may leave an orphaned file on disk.\",\n                                    tmp_name,\n                                    cleanup_error,\n                                )\n\n                self._hbfont = HarfBuzzFont(face)\n            else:\n                # For regular TTF/OTF fonts, load directly from file path (faster)\n                self._hbfont = HarfBuzzFont(\n                    hb.Face(hb.Blob.from_file_path(self.ttffile))\n                )\n\n        return self._hbfont\n\n    def __repr__(self) -> str:\n        return f\"TTFFont(i={self.i}, fontkey={self.fontkey})\"\n\n    def __deepcopy__(self: \"TTFFont\", memo: dict[int, Any]) -> \"TTFFont\":\n        \"\"\"\n        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes\n        but instead share references to immutable objects\n        between the original FPDF instance and the FPDFRecorder instances\n        to avoid performances issues as spotted in issue #1444.\n        \"\"\"\n        copy = TTFFont.__new__(TTFFont)\n        # Immutable attributes:\n        copy.i = self.i\n        copy.type = \"TTF\"\n        copy.ttffile = self.ttffile\n        copy.fontkey = self.fontkey\n        copy.scale = self.scale\n        copy.name = self.name\n        copy.up = self.up\n        copy.ut = self.ut\n        copy.sp = self.sp\n        copy.ss = self.ss\n        copy.emphasis = self.emphasis\n        copy.is_compressed = self.is_compressed\n        # Attributes shared, to improve FPDFRecorder performances:\n        copy.ttfont = self.ttfont\n        copy.cmap = self.cmap\n        copy.desc = self.desc\n        # Attributes deepcopied:\n        copy.cw = deepcopy(self.cw, memo)\n        copy.glyph_ids = deepcopy(self.glyph_ids, memo)\n        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)\n        copy.subset = deepcopy(self.subset, memo)\n        copy.biggest_size_pt = self.biggest_size_pt\n        copy._hbfont = self._hbfont\n        copy.color_font = self.color_font\n        copy.palette_index = self.palette_index\n        return copy\n\n    def close(self) -> None:\n        self.ttfont.close()\n        self._hbfont = None\n\n    def escape_text(self, text: str) -> str:\n        if self.color_font:\n            encoded = text.encode(\"latin-1\", errors=\"replace\")\n            return escape_parens(encoded.decode(\"latin-1\", errors=\"ignore\"))\n        return escape_parens(text.encode(\"utf-16-be\").decode(\"latin-1\"))\n\n    def get_text_width(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[int, float]:\n        if font_size_pt > self.biggest_size_pt:\n            self.biggest_size_pt = font_size_pt\n        if text_shaping_params:\n            return self.shaped_text_width(text, font_size_pt, text_shaping_params)\n        return (len(text), sum(self.cw[ord(c)] for c in text) * font_size_pt * 0.001)\n\n    def shaped_text_width(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[int, float]:\n        \"\"\"\n        When texts are shaped, the length of a string is not always the sum of all individual character widths\n        This method will invoke harfbuzz to perform the text shaping and return the sum of \"x_advance\"\n        and \"x_offset\" for each glyph. This method works for \"left to right\" or \"right to left\" texts.\n        \"\"\"\n        _, glyph_positions = self.perform_harfbuzz_shaping(\n            text, font_size_pt, text_shaping_params\n        )\n\n        # If there is nothing to render (harfbuzz returns None), we return 0 text width\n        if glyph_positions is None:\n            return (0, 0)\n\n        text_width: float = 0\n        for pos in glyph_positions:\n            text_width += (\n                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001\n            )\n        return (len(glyph_positions), text_width)\n\n    # Disabling this check - looks like cython confuses pylint:\n    # pylint: disable=no-member\n    def perform_harfbuzz_shaping(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[Sequence[\"HBGlyphInfo\"], Sequence[\"HBGlyphPosition\"]]:\n        \"\"\"\n        This method invokes Harfbuzz to perform text shaping of the input string\n        \"\"\"\n        self.hbfont.ptem = font_size_pt\n        if TYPE_CHECKING:\n            buf: HBBuffer\n        buf = hb.Buffer()\n        buf.cluster_level = 1\n        buf.add_str(\"\".join(text))\n        buf.guess_segment_properties()\n        features = (\n            text_shaping_params[\"features\"] if text_shaping_params is not None else {}\n        )\n        if text_shaping_params is None:\n            text_shaping_params = {}\n        if (\n            \"fragment_direction\" in text_shaping_params\n            and text_shaping_params[\"fragment_direction\"] is not None\n        ):\n            buf.direction = text_shaping_params[\"fragment_direction\"].value\n        if (\n            \"script\" in text_shaping_params\n            and text_shaping_params[\"script\"] is not None\n        ):\n            buf.script = text_shaping_params[\"script\"]\n        if (\n            \"language\" in text_shaping_params\n            and text_shaping_params[\"language\"] is not None\n        ):\n            buf.language = text_shaping_params[\"language\"]\n        hb.shape(self.hbfont, buf, features)\n        return buf.glyph_infos, buf.glyph_positions\n\n    def encode_text(self, text: str) -> str:\n        txt_mapped = \"\"\n        for char in text:\n            uni = ord(char)\n            # Instead of adding the actual character to the stream its code is\n            # mapped to a position in the font's subset\n            mapped_char: Optional[int] = self.subset.pick(uni)\n            if mapped_char is not None:\n                txt_mapped += chr(mapped_char)\n        return f\"({self.escape_text(txt_mapped)}) Tj\"\n\n    def shape_text(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> Sequence[dict[str, Any]]:\n        \"\"\"\n        This method will invoke harfbuzz for text shaping, include the mapping code\n        of the glyphs on the subset and map input characters to the cluster codes\n        \"\"\"\n        if len(text) == 0:\n            return []\n        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(\n            text, font_size_pt, text_shaping_params\n        )\n        text_info = []\n\n        # Find cluster gaps\n        # Ex: text = \"ABCD\"\n        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph\n        # (ligature or substitution) - the glyph should have both unicodes and it should be translated\n        # properly on the CID to GID mapping\n        #\n        def get_cluster_from_text_index(cluster_list: Sequence[int], index: int) -> int:\n            pos = bisect_left(cluster_list, index)\n            if pos == 0:\n                return cluster_list[0]\n            if pos == len(cluster_list) or cluster_list[pos] != index:\n                return cluster_list[pos - 1]\n            return cluster_list[pos]\n\n        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))\n        cluster_mapping: dict[int, list[int]] = {}\n        for i in range(len(text)):\n            cl = get_cluster_from_text_index(cluster_list, i)\n            if cl in cluster_mapping:\n                cluster_mapping[cl].append(i)\n            else:\n                cluster_mapping[cl] = [i]\n\n        for cluster_seq, gi in enumerate(glyph_infos):\n            unicode = []\n            if gi.cluster in cluster_mapping:\n                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]\n                cluster_mapping.pop(gi.cluster)\n\n            gname = self.ttfont.getGlyphName(gi.codepoint)\n            gwidth = round(self.scale * self.ttfont[\"hmtx\"].metrics[gname][0])\n            glyph = self.subset.get_glyph(\n                glyph=gi.codepoint,\n                unicode=tuple(unicode),\n                glyph_name=gname,\n                glyph_width=gwidth,\n            )\n            if glyph is None:\n                continue\n            force_positioning = False\n            if (\n                gwidth != glyph_positions[cluster_seq].x_advance\n                or glyph_positions[cluster_seq].x_offset != 0\n                or glyph_positions[cluster_seq].y_offset != 0\n                or glyph_positions[cluster_seq].y_advance != 0\n            ):\n                force_positioning = True\n            text_info.append(\n                {\n                    \"mapped_char\": self.subset.pick_glyph(glyph),\n                    \"x_advance\": glyph_positions[cluster_seq].x_advance,\n                    \"y_advance\": glyph_positions[cluster_seq].y_advance,\n                    \"x_offset\": glyph_positions[cluster_seq].x_offset,\n                    \"y_offset\": glyph_positions[cluster_seq].y_offset,\n                    \"force_positioning\": force_positioning,\n                }\n            )\n        return text_info",
      "language": "python"
    },
    {
      "code": "class TTFFont:\n    __slots__ = (  # RAM usage optimization\n        \"i\",\n        \"type\",\n        \"name\",\n        \"desc\",\n        \"glyph_ids\",\n        \"_hbfont\",\n        \"sp\",\n        \"ss\",\n        \"up\",\n        \"ut\",\n        \"cw\",\n        \"ttffile\",\n        \"fontkey\",\n        \"emphasis\",\n        \"scale\",\n        \"subset\",\n        \"cmap\",\n        \"ttfont\",\n        \"missing_glyphs\",\n        \"biggest_size_pt\",\n        \"color_font\",\n        \"unicode_range\",\n        \"palette_index\",\n        \"is_compressed\",\n    )\n\n    def __init__(\n        self,\n        fpdf: \"FPDF\",\n        font_file_path: Path,\n        fontkey: str,\n        style: str,\n        unicode_range: Optional[set[int]] = None,\n        axes_dict: Optional[dict[str, float]] = None,\n        palette_index: Optional[int] = None,\n    ):\n        self.i = len(fpdf.fonts) + 1\n        self.type = \"TTF\"\n        self.ttffile = font_file_path\n        self.is_compressed = str(self.ttffile).lower().endswith((\".woff\", \".woff2\"))\n        self._hbfont: Optional[\"HarfBuzzFont\"] = None\n        self.fontkey = fontkey\n        self.biggest_size_pt: float = 0\n\n        # recalcTimestamp=False means that it doesn't modify the \"modified\" timestamp in head table\n        # if we leave recalcTimestamp=True the tests will break every time\n        try:\n            self.ttfont = ttLib.TTFont(\n                self.ttffile, recalcTimestamp=False, fontNumber=0, lazy=True\n            )\n        except (\n            ImportError,\n            RuntimeError,\n        ) as exc:  # pragma: no cover - defensive messaging\n            # If the user passed a WOFF2 file but brotli is not installed, fontTools\n            # raises an ImportError/RuntimeError during parsing. Provide a clearer hint\n            # only for that specific situation. Allow other exceptions (e.g. FileNotFoundError,\n            # OSError, parsing errors) to propagate normally so they aren't masked here.\n            fname_str = str(self.ttffile).lower()\n            if fname_str.endswith(\".woff2\"):\n                raise RuntimeError(\n                    \"Could not open WOFF2 font. WOFF2 support requires an external Brotli \"\n                    \"library (install 'brotli' or 'brotlicffi'). Original error: \"\n                    f\"{exc!s}\"\n                ) from exc\n            raise\n\n        if axes_dict is not None:\n            if \"fvar\" not in self.ttfont:\n                raise AttributeError(f\"{self.ttffile} is not a variable font\")\n\n            instancer.instantiateVariableFont(\n                self.ttfont,\n                axes_dict,\n                inplace=True,\n                static=True,\n            )\n        if self.is_compressed:\n            # Normalize to SFNT output for embedding and HarfBuzz.\n            self.ttfont.flavor = None\n        upem: float = float(self.ttfont[\"head\"].unitsPerEm)\n        self.scale: float = 1000 / upem\n\n        # check if the font is a TrueType and missing a .notdef glyph\n        # if it is missing, provide a fallback glyph\n        if (\n            \"glyf\" in self.ttfont\n            and \".notdef\"\n            not in self.ttfont[\"glyf\"]  # pyright: ignore[reportOperatorIssue]\n        ):\n            LOGGER.warning(\n                (\n                    \"TrueType Font '%s' is missing the '.notdef' glyph. \"\n                    \"Fallback glyph will be provided.\"\n                ),\n                self.fontkey,\n            )\n            # draw a diagonal cross .notdef glyph\n            xMin, xMax, yMin, yMax = (\n                self.ttfont[\"head\"].xMin,\n                self.ttfont[\"head\"].xMax,\n                self.ttfont[\"head\"].yMin,\n                self.ttfont[\"head\"].yMax,\n            )\n            pen = TTGlyphPen(self.ttfont[\"glyf\"])  # pyright: ignore[reportArgumentType]\n            pen.moveTo((xMin, yMin))\n            pen.lineTo((xMax, yMin))\n            pen.lineTo((xMax, yMax))\n            pen.lineTo((xMin, yMax))\n            pen.closePath()\n            pen.moveTo((xMin, yMin))\n            pen.lineTo((xMax, yMax))\n            pen.closePath()\n            pen.moveTo((xMax, yMin))\n            pen.lineTo((xMin, yMax))\n            pen.closePath()\n\n            self.ttfont[\"glyf\"][  # pyright: ignore[reportIndexIssue]\n                \".notdef\"\n            ] = pen.glyph()\n            self.ttfont[\"hmtx\"][\".notdef\"] = (  # pyright: ignore[reportIndexIssue]\n                xMax - xMin,\n                yMax - yMin,\n            )\n\n        default_width: float = round(\n            self.scale * self.ttfont[\"hmtx\"].metrics[\".notdef\"][0]\n        )\n\n        os2_table = self.ttfont[\"OS/2\"]\n        post_table = self.ttfont[\"post\"]\n\n        try:\n            cap_height = os2_table.sCapHeight\n        except AttributeError:\n            cap_height = self.ttfont[\"hhea\"].ascent\n\n        # entry for the PDF font descriptor specifying various characteristics of the font\n        flags = FontDescriptorFlags.SYMBOLIC\n        if post_table.isFixedPitch:\n            flags |= FontDescriptorFlags.FIXED_PITCH\n        if post_table.italicAngle != 0:\n            flags |= FontDescriptorFlags.ITALIC\n        if os2_table.usWeightClass >= 600:\n            flags |= FontDescriptorFlags.FORCE_BOLD\n\n        self.desc = PDFFontDescriptor(\n            ascent=round(self.ttfont[\"hhea\"].ascent * self.scale),\n            descent=round(self.ttfont[\"hhea\"].descent * self.scale),\n            cap_height=round(cap_height * self.scale),\n            flags=flags,\n            font_b_box=(\n                f\"[{self.ttfont['head'].xMin * self.scale:.0f} {self.ttfont['head'].yMin * self.scale:.0f}\"\n                f\" {self.ttfont['head'].xMax * self.scale:.0f} {self.ttfont['head'].yMax * self.scale:.0f}]\"\n            ),\n            italic_angle=int(post_table.italicAngle),\n            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),\n            missing_width=default_width,\n        )\n\n        # a map unicode_char -> char_width\n        self.cw: dict[int, float] = defaultdict(lambda: default_width)\n\n        # fonttools cmap = unicode char to glyph name\n        # saving only the keys we have a tuple with\n        # the unicode characters available on the font\n        self.cmap: dict[int, str] = self.ttfont.getBestCmap()\n        if not self.cmap:\n            raise NotImplementedError(\n                \"Font not supported as it does not have a unicode cmap table - cf. issue #1396\"\n            )\n\n        if unicode_range is not None and len(unicode_range) != 0:\n            self.cmap = {\n                codepoint: glyph_id\n                for codepoint, glyph_id in self.cmap.items()  # pyright: ignore[reportUnknownVariableType]\n                if codepoint in unicode_range\n            }\n\n        # saving a list of glyph ids to char to allow\n        # subset by unicode (regular) and by glyph\n        # (shaped with harfbuz)\n        self.glyph_ids = {}\n\n        for char in self.cmap:  # pyright: ignore[]\n            # take glyph associated to char\n            glyph = self.cmap[char]\n\n            # take width associated to glyph\n            w = self.ttfont[\"hmtx\"].metrics[glyph][0]\n\n            # probably this check could be deleted\n            if w == 65535:\n                w = 0\n\n            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP\n\n            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)\n\n        self.missing_glyphs: list[int] = []\n\n        self.name = re.sub(\"[ ()]\", \"\", self.ttfont[\"name\"].getBestFullName())\n        self.up = round(post_table.underlinePosition * self.scale)\n        self.ut = round(post_table.underlineThickness * self.scale)\n        self.sp = round(os2_table.yStrikeoutPosition * self.scale)\n        self.ss = round(os2_table.yStrikeoutSize * self.scale)\n        self.emphasis = TextEmphasis.coerce(style)\n        self.subset = SubsetMap(self)\n        self.palette_index = palette_index if palette_index is not None else 0\n        self.color_font = (\n            get_color_font_object(fpdf, self, self.palette_index)\n            if fpdf.render_color_fonts\n            else None\n        )\n\n    # pylint: disable=no-member\n    @property\n    def hbfont(self) -> \"HarfBuzzFont\":\n        if not self._hbfont:\n            if self.is_compressed:\n                # HarfBuzz cannot load compressed WOFF/WOFF2 files directly, so we\n                # re-serialize the fontTools TTFont to a raw SFNT byte buffer.\n                buf = BytesIO()\n                self.ttfont.save(buf)\n                buf.seek(0)\n                ttfont_bytes = buf.read()\n\n                # Try to create a HarfBuzz blob from bytes; if not available, write a\n                # temporary file as a last resort.\n                try:\n                    blob = hb.Blob.from_bytes(ttfont_bytes)\n                    face = hb.Face(blob)\n                except (AttributeError, RuntimeError):\n                    import tempfile, os  # pylint: disable=import-outside-toplevel\n\n                    tmp_name = None\n                    try:\n                        with tempfile.NamedTemporaryFile(\n                            suffix=\".ttf\", delete=False\n                        ) as tmp:\n                            tmp_name = tmp.name\n                            tmp.write(ttfont_bytes)\n                            tmp.flush()\n                        face = hb.Face(hb.Blob.from_file_path(tmp_name))\n                    finally:\n                        if tmp_name:\n                            try:\n                                os.unlink(tmp_name)\n                            except OSError as cleanup_error:\n                                # Log warning about failed cleanup - orphaned temp file may cause disk issues\n                                LOGGER.warning(\n                                    \"Failed to clean up temporary font file '%s': %s. This may leave an orphaned file on disk.\",\n                                    tmp_name,\n                                    cleanup_error,\n                                )\n\n                self._hbfont = HarfBuzzFont(face)\n            else:\n                # For regular TTF/OTF fonts, load directly from file path (faster)\n                self._hbfont = HarfBuzzFont(\n                    hb.Face(hb.Blob.from_file_path(self.ttffile))\n                )\n\n        return self._hbfont\n\n    def __repr__(self) -> str:\n        return f\"TTFFont(i={self.i}, fontkey={self.fontkey})\"\n\n    def __deepcopy__(self: \"TTFFont\", memo: dict[int, Any]) -> \"TTFFont\":\n        \"\"\"\n        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes\n        but instead share references to immutable objects\n        between the original FPDF instance and the FPDFRecorder instances\n        to avoid performances issues as spotted in issue #1444.\n        \"\"\"\n        copy = TTFFont.__new__(TTFFont)\n        # Immutable attributes:\n        copy.i = self.i\n        copy.type = \"TTF\"\n        copy.ttffile = self.ttffile\n        copy.fontkey = self.fontkey\n        copy.scale = self.scale\n        copy.name = self.name\n        copy.up = self.up\n        copy.ut = self.ut\n        copy.sp = self.sp\n        copy.ss = self.ss\n        copy.emphasis = self.emphasis\n        copy.is_compressed = self.is_compressed\n        # Attributes shared, to improve FPDFRecorder performances:\n        copy.ttfont = self.ttfont\n        copy.cmap = self.cmap\n        copy.desc = self.desc\n        # Attributes deepcopied:\n        copy.cw = deepcopy(self.cw, memo)\n        copy.glyph_ids = deepcopy(self.glyph_ids, memo)\n        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)\n        copy.subset = deepcopy(self.subset, memo)\n        copy.biggest_size_pt = self.biggest_size_pt\n        copy._hbfont = self._hbfont\n        copy.color_font = self.color_font\n        copy.palette_index = self.palette_index\n        return copy\n\n    def close(self) -> None:\n        self.ttfont.close()\n        self._hbfont = None\n\n    def escape_text(self, text: str) -> str:\n        if self.color_font:\n            encoded = text.encode(\"latin-1\", errors=\"replace\")\n            return escape_parens(encoded.decode(\"latin-1\", errors=\"ignore\"))\n        return escape_parens(text.encode(\"utf-16-be\").decode(\"latin-1\"))\n\n    def get_text_width(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[int, float]:\n        if font_size_pt > self.biggest_size_pt:\n            self.biggest_size_pt = font_size_pt\n        if text_shaping_params:\n            return self.shaped_text_width(text, font_size_pt, text_shaping_params)\n        return (len(text), sum(self.cw[ord(c)] for c in text) * font_size_pt * 0.001)\n\n    def shaped_text_width(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[int, float]:\n        \"\"\"\n        When texts are shaped, the length of a string is not always the sum of all individual character widths\n        This method will invoke harfbuzz to perform the text shaping and return the sum of \"x_advance\"\n        and \"x_offset\" for each glyph. This method works for \"left to right\" or \"right to left\" texts.\n        \"\"\"\n        _, glyph_positions = self.perform_harfbuzz_shaping(\n            text, font_size_pt, text_shaping_params\n        )\n\n        # If there is nothing to render (harfbuzz returns None), we return 0 text width\n        if glyph_positions is None:\n            return (0, 0)\n\n        text_width: float = 0\n        for pos in glyph_positions:\n            text_width += (\n                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001\n            )\n        return (len(glyph_positions), text_width)\n\n    # Disabling this check - looks like cython confuses pylint:\n    # pylint: disable=no-member\n    def perform_harfbuzz_shaping(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[Sequence[\"HBGlyphInfo\"], Sequence[\"HBGlyphPosition\"]]:\n        \"\"\"\n        This method invokes Harfbuzz to perform text shaping of the input string\n        \"\"\"\n        self.hbfont.ptem = font_size_pt\n        if TYPE_CHECKING:\n            buf: HBBuffer\n        buf = hb.Buffer()\n        buf.cluster_level = 1\n        buf.add_str(\"\".join(text))\n        buf.guess_segment_properties()\n        features = (\n            text_shaping_params[\"features\"] if text_shaping_params is not None else {}\n        )\n        if text_shaping_params is None:\n            text_shaping_params = {}\n        if (\n            \"fragment_direction\" in text_shaping_params\n            and text_shaping_params[\"fragment_direction\"] is not None\n        ):\n            buf.direction = text_shaping_params[\"fragment_direction\"].value\n        if (\n            \"script\" in text_shaping_params\n            and text_shaping_params[\"script\"] is not None\n        ):\n            buf.script = text_shaping_params[\"script\"]\n        if (\n            \"language\" in text_shaping_params\n            and text_shaping_params[\"language\"] is not None\n        ):\n            buf.language = text_shaping_params[\"language\"]\n        hb.shape(self.hbfont, buf, features)\n        return buf.glyph_infos, buf.glyph_positions\n\n    def encode_text(self, text: str) -> str:\n        txt_mapped = \"\"\n        for char in text:\n            uni = ord(char)\n            # Instead of adding the actual character to the stream its code is\n            # mapped to a position in the font's subset\n            mapped_char: Optional[int] = self.subset.pick(uni)\n            if mapped_char is not None:\n                txt_mapped += chr(mapped_char)\n        return f\"({self.escape_text(txt_mapped)}) Tj\"\n\n    def shape_text(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> Sequence[dict[str, Any]]:\n        \"\"\"\n        This method will invoke harfbuzz for text shaping, include the mapping code\n        of the glyphs on the subset and map input characters to the cluster codes\n        \"\"\"\n        if len(text) == 0:\n            return []\n        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(\n            text, font_size_pt, text_shaping_params\n        )\n        text_info = []\n\n        # Find cluster gaps\n        # Ex: text = \"ABCD\"\n        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph\n        # (ligature or substitution) - the glyph should have both unicodes and it should be translated\n        # properly on the CID to GID mapping\n        #\n        def get_cluster_from_text_index(cluster_list: Sequence[int], index: int) -> int:\n            pos = bisect_left(cluster_list, index)\n            if pos == 0:\n                return cluster_list[0]\n            if pos == len(cluster_list) or cluster_list[pos] != index:\n                return cluster_list[pos - 1]\n            return cluster_list[pos]\n\n        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))\n        cluster_mapping: dict[int, list[int]] = {}\n        for i in range(len(text)):\n            cl = get_cluster_from_text_index(cluster_list, i)\n            if cl in cluster_mapping:\n                cluster_mapping[cl].append(i)\n            else:\n                cluster_mapping[cl] = [i]\n\n        for cluster_seq, gi in enumerate(glyph_infos):\n            unicode = []\n            if gi.cluster in cluster_mapping:\n                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]\n                cluster_mapping.pop(gi.cluster)\n\n            gname = self.ttfont.getGlyphName(gi.codepoint)\n            gwidth = round(self.scale * self.ttfont[\"hmtx\"].metrics[gname][0])\n            glyph = self.subset.get_glyph(\n                glyph=gi.codepoint,\n                unicode=tuple(unicode),\n                glyph_name=gname,\n                glyph_width=gwidth,\n            )\n            if glyph is None:\n                continue\n            force_positioning = False\n            if (\n                gwidth != glyph_positions[cluster_seq].x_advance\n                or glyph_positions[cluster_seq].x_offset != 0\n                or glyph_positions[cluster_seq].y_offset != 0\n                or glyph_positions[cluster_seq].y_advance != 0\n            ):\n                force_positioning = True\n            text_info.append(\n                {\n                    \"mapped_char\": self.subset.pick_glyph(glyph),\n                    \"x_advance\": glyph_positions[cluster_seq].x_advance,\n                    \"y_advance\": glyph_positions[cluster_seq].y_advance,\n                    \"x_offset\": glyph_positions[cluster_seq].x_offset,\n                    \"y_offset\": glyph_positions[cluster_seq].y_offset,\n                    \"force_positioning\": force_positioning,\n                }\n            )\n        return text_info",
      "language": "python"
    },
    {
      "code": "class TTFFont:\n    __slots__ = (  # RAM usage optimization\n        \"i\",\n        \"type\",\n        \"name\",\n        \"desc\",\n        \"glyph_ids\",\n        \"_hbfont\",\n        \"sp\",\n        \"ss\",\n        \"up\",\n        \"ut\",\n        \"cw\",\n        \"ttffile\",\n        \"fontkey\",\n        \"emphasis\",\n        \"scale\",\n        \"subset\",\n        \"cmap\",\n        \"ttfont\",\n        \"missing_glyphs\",\n        \"biggest_size_pt\",\n        \"color_font\",\n        \"unicode_range\",\n        \"palette_index\",\n        \"is_compressed\",\n    )\n\n    def __init__(\n        self,\n        fpdf: \"FPDF\",\n        font_file_path: Path,\n        fontkey: str,\n        style: str,\n        unicode_range: Optional[set[int]] = None,\n        axes_dict: Optional[dict[str, float]] = None,\n        palette_index: Optional[int] = None,\n    ):\n        self.i = len(fpdf.fonts) + 1\n        self.type = \"TTF\"\n        self.ttffile = font_file_path\n        self.is_compressed = str(self.ttffile).lower().endswith((\".woff\", \".woff2\"))\n        self._hbfont: Optional[\"HarfBuzzFont\"] = None\n        self.fontkey = fontkey\n        self.biggest_size_pt: float = 0\n\n        # recalcTimestamp=False means that it doesn't modify the \"modified\" timestamp in head table\n        # if we leave recalcTimestamp=True the tests will break every time\n        try:\n            self.ttfont = ttLib.TTFont(\n                self.ttffile, recalcTimestamp=False, fontNumber=0, lazy=True\n            )\n        except (\n            ImportError,\n            RuntimeError,\n        ) as exc:  # pragma: no cover - defensive messaging\n            # If the user passed a WOFF2 file but brotli is not installed, fontTools\n            # raises an ImportError/RuntimeError during parsing. Provide a clearer hint\n            # only for that specific situation. Allow other exceptions (e.g. FileNotFoundError,\n            # OSError, parsing errors) to propagate normally so they aren't masked here.\n            fname_str = str(self.ttffile).lower()\n            if fname_str.endswith(\".woff2\"):\n                raise RuntimeError(\n                    \"Could not open WOFF2 font. WOFF2 support requires an external Brotli \"\n                    \"library (install 'brotli' or 'brotlicffi'). Original error: \"\n                    f\"{exc!s}\"\n                ) from exc\n            raise\n\n        if axes_dict is not None:\n            if \"fvar\" not in self.ttfont:\n                raise AttributeError(f\"{self.ttffile} is not a variable font\")\n\n            instancer.instantiateVariableFont(\n                self.ttfont,\n                axes_dict,\n                inplace=True,\n                static=True,\n            )\n        if self.is_compressed:\n            # Normalize to SFNT output for embedding and HarfBuzz.\n            self.ttfont.flavor = None\n        upem: float = float(self.ttfont[\"head\"].unitsPerEm)\n        self.scale: float = 1000 / upem\n\n        # check if the font is a TrueType and missing a .notdef glyph\n        # if it is missing, provide a fallback glyph\n        if (\n            \"glyf\" in self.ttfont\n            and \".notdef\"\n            not in self.ttfont[\"glyf\"]  # pyright: ignore[reportOperatorIssue]\n        ):\n            LOGGER.warning(\n                (\n                    \"TrueType Font '%s' is missing the '.notdef' glyph. \"\n                    \"Fallback glyph will be provided.\"\n                ),\n                self.fontkey,\n            )\n            # draw a diagonal cross .notdef glyph\n            xMin, xMax, yMin, yMax = (\n                self.ttfont[\"head\"].xMin,\n                self.ttfont[\"head\"].xMax,\n                self.ttfont[\"head\"].yMin,\n                self.ttfont[\"head\"].yMax,\n            )\n            pen = TTGlyphPen(self.ttfont[\"glyf\"])  # pyright: ignore[reportArgumentType]\n            pen.moveTo((xMin, yMin))\n            pen.lineTo((xMax, yMin))\n            pen.lineTo((xMax, yMax))\n            pen.lineTo((xMin, yMax))\n            pen.closePath()\n            pen.moveTo((xMin, yMin))\n            pen.lineTo((xMax, yMax))\n            pen.closePath()\n            pen.moveTo((xMax, yMin))\n            pen.lineTo((xMin, yMax))\n            pen.closePath()\n\n            self.ttfont[\"glyf\"][  # pyright: ignore[reportIndexIssue]\n                \".notdef\"\n            ] = pen.glyph()\n            self.ttfont[\"hmtx\"][\".notdef\"] = (  # pyright: ignore[reportIndexIssue]\n                xMax - xMin,\n                yMax - yMin,\n            )\n\n        default_width: float = round(\n            self.scale * self.ttfont[\"hmtx\"].metrics[\".notdef\"][0]\n        )\n\n        os2_table = self.ttfont[\"OS/2\"]\n        post_table = self.ttfont[\"post\"]\n\n        try:\n            cap_height = os2_table.sCapHeight\n        except AttributeError:\n            cap_height = self.ttfont[\"hhea\"].ascent\n\n        # entry for the PDF font descriptor specifying various characteristics of the font\n        flags = FontDescriptorFlags.SYMBOLIC\n        if post_table.isFixedPitch:\n            flags |= FontDescriptorFlags.FIXED_PITCH\n        if post_table.italicAngle != 0:\n            flags |= FontDescriptorFlags.ITALIC\n        if os2_table.usWeightClass >= 600:\n            flags |= FontDescriptorFlags.FORCE_BOLD\n\n        self.desc = PDFFontDescriptor(\n            ascent=round(self.ttfont[\"hhea\"].ascent * self.scale),\n            descent=round(self.ttfont[\"hhea\"].descent * self.scale),\n            cap_height=round(cap_height * self.scale),\n            flags=flags,\n            font_b_box=(\n                f\"[{self.ttfont['head'].xMin * self.scale:.0f} {self.ttfont['head'].yMin * self.scale:.0f}\"\n                f\" {self.ttfont['head'].xMax * self.scale:.0f} {self.ttfont['head'].yMax * self.scale:.0f}]\"\n            ),\n            italic_angle=int(post_table.italicAngle),\n            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),\n            missing_width=default_width,\n        )\n\n        # a map unicode_char -> char_width\n        self.cw: dict[int, float] = defaultdict(lambda: default_width)\n\n        # fonttools cmap = unicode char to glyph name\n        # saving only the keys we have a tuple with\n        # the unicode characters available on the font\n        self.cmap: dict[int, str] = self.ttfont.getBestCmap()\n        if not self.cmap:\n            raise NotImplementedError(\n                \"Font not supported as it does not have a unicode cmap table - cf. issue #1396\"\n            )\n\n        if unicode_range is not None and len(unicode_range) != 0:\n            self.cmap = {\n                codepoint: glyph_id\n                for codepoint, glyph_id in self.cmap.items()  # pyright: ignore[reportUnknownVariableType]\n                if codepoint in unicode_range\n            }\n\n        # saving a list of glyph ids to char to allow\n        # subset by unicode (regular) and by glyph\n        # (shaped with harfbuz)\n        self.glyph_ids = {}\n\n        for char in self.cmap:  # pyright: ignore[]\n            # take glyph associated to char\n            glyph = self.cmap[char]\n\n            # take width associated to glyph\n            w = self.ttfont[\"hmtx\"].metrics[glyph][0]\n\n            # probably this check could be deleted\n            if w == 65535:\n                w = 0\n\n            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP\n\n            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)\n\n        self.missing_glyphs: list[int] = []\n\n        self.name = re.sub(\"[ ()]\", \"\", self.ttfont[\"name\"].getBestFullName())\n        self.up = round(post_table.underlinePosition * self.scale)\n        self.ut = round(post_table.underlineThickness * self.scale)\n        self.sp = round(os2_table.yStrikeoutPosition * self.scale)\n        self.ss = round(os2_table.yStrikeoutSize * self.scale)\n        self.emphasis = TextEmphasis.coerce(style)\n        self.subset = SubsetMap(self)\n        self.palette_index = palette_index if palette_index is not None else 0\n        self.color_font = (\n            get_color_font_object(fpdf, self, self.palette_index)\n            if fpdf.render_color_fonts\n            else None\n        )\n\n    # pylint: disable=no-member\n    @property\n    def hbfont(self) -> \"HarfBuzzFont\":\n        if not self._hbfont:\n            if self.is_compressed:\n                # HarfBuzz cannot load compressed WOFF/WOFF2 files directly, so we\n                # re-serialize the fontTools TTFont to a raw SFNT byte buffer.\n                buf = BytesIO()\n                self.ttfont.save(buf)\n                buf.seek(0)\n                ttfont_bytes = buf.read()\n\n                # Try to create a HarfBuzz blob from bytes; if not available, write a\n                # temporary file as a last resort.\n                try:\n                    blob = hb.Blob.from_bytes(ttfont_bytes)\n                    face = hb.Face(blob)\n                except (AttributeError, RuntimeError):\n                    import tempfile, os  # pylint: disable=import-outside-toplevel\n\n                    tmp_name = None\n                    try:\n                        with tempfile.NamedTemporaryFile(\n                            suffix=\".ttf\", delete=False\n                        ) as tmp:\n                            tmp_name = tmp.name\n                            tmp.write(ttfont_bytes)\n                            tmp.flush()\n                        face = hb.Face(hb.Blob.from_file_path(tmp_name))\n                    finally:\n                        if tmp_name:\n                            try:\n                                os.unlink(tmp_name)\n                            except OSError as cleanup_error:\n                                # Log warning about failed cleanup - orphaned temp file may cause disk issues\n                                LOGGER.warning(\n                                    \"Failed to clean up temporary font file '%s': %s. This may leave an orphaned file on disk.\",\n                                    tmp_name,\n                                    cleanup_error,\n                                )\n\n                self._hbfont = HarfBuzzFont(face)\n            else:\n                # For regular TTF/OTF fonts, load directly from file path (faster)\n                self._hbfont = HarfBuzzFont(\n                    hb.Face(hb.Blob.from_file_path(self.ttffile))\n                )\n\n        return self._hbfont\n\n    def __repr__(self) -> str:\n        return f\"TTFFont(i={self.i}, fontkey={self.fontkey})\"\n\n    def __deepcopy__(self: \"TTFFont\", memo: dict[int, Any]) -> \"TTFFont\":\n        \"\"\"\n        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes\n        but instead share references to immutable objects\n        between the original FPDF instance and the FPDFRecorder instances\n        to avoid performances issues as spotted in issue #1444.\n        \"\"\"\n        copy = TTFFont.__new__(TTFFont)\n        # Immutable attributes:\n        copy.i = self.i\n        copy.type = \"TTF\"\n        copy.ttffile = self.ttffile\n        copy.fontkey = self.fontkey\n        copy.scale = self.scale\n        copy.name = self.name\n        copy.up = self.up\n        copy.ut = self.ut\n        copy.sp = self.sp\n        copy.ss = self.ss\n        copy.emphasis = self.emphasis\n        copy.is_compressed = self.is_compressed\n        # Attributes shared, to improve FPDFRecorder performances:\n        copy.ttfont = self.ttfont\n        copy.cmap = self.cmap\n        copy.desc = self.desc\n        # Attributes deepcopied:\n        copy.cw = deepcopy(self.cw, memo)\n        copy.glyph_ids = deepcopy(self.glyph_ids, memo)\n        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)\n        copy.subset = deepcopy(self.subset, memo)\n        copy.biggest_size_pt = self.biggest_size_pt\n        copy._hbfont = self._hbfont\n        copy.color_font = self.color_font\n        copy.palette_index = self.palette_index\n        return copy\n\n    def close(self) -> None:\n        self.ttfont.close()\n        self._hbfont = None\n\n    def escape_text(self, text: str) -> str:\n        if self.color_font:\n            encoded = text.encode(\"latin-1\", errors=\"replace\")\n            return escape_parens(encoded.decode(\"latin-1\", errors=\"ignore\"))\n        return escape_parens(text.encode(\"utf-16-be\").decode(\"latin-1\"))\n\n    def get_text_width(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[int, float]:\n        if font_size_pt > self.biggest_size_pt:\n            self.biggest_size_pt = font_size_pt\n        if text_shaping_params:\n            return self.shaped_text_width(text, font_size_pt, text_shaping_params)\n        return (len(text), sum(self.cw[ord(c)] for c in text) * font_size_pt * 0.001)\n\n    def shaped_text_width(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[int, float]:\n        \"\"\"\n        When texts are shaped, the length of a string is not always the sum of all individual character widths\n        This method will invoke harfbuzz to perform the text shaping and return the sum of \"x_advance\"\n        and \"x_offset\" for each glyph. This method works for \"left to right\" or \"right to left\" texts.\n        \"\"\"\n        _, glyph_positions = self.perform_harfbuzz_shaping(\n            text, font_size_pt, text_shaping_params\n        )\n\n        # If there is nothing to render (harfbuzz returns None), we return 0 text width\n        if glyph_positions is None:\n            return (0, 0)\n\n        text_width: float = 0\n        for pos in glyph_positions:\n            text_width += (\n                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001\n            )\n        return (len(glyph_positions), text_width)\n\n    # Disabling this check - looks like cython confuses pylint:\n    # pylint: disable=no-member\n    def perform_harfbuzz_shaping(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[Sequence[\"HBGlyphInfo\"], Sequence[\"HBGlyphPosition\"]]:\n        \"\"\"\n        This method invokes Harfbuzz to perform text shaping of the input string\n        \"\"\"\n        self.hbfont.ptem = font_size_pt\n        if TYPE_CHECKING:\n            buf: HBBuffer\n        buf = hb.Buffer()\n        buf.cluster_level = 1\n        buf.add_str(\"\".join(text))\n        buf.guess_segment_properties()\n        features = (\n            text_shaping_params[\"features\"] if text_shaping_params is not None else {}\n        )\n        if text_shaping_params is None:\n            text_shaping_params = {}\n        if (\n            \"fragment_direction\" in text_shaping_params\n            and text_shaping_params[\"fragment_direction\"] is not None\n        ):\n            buf.direction = text_shaping_params[\"fragment_direction\"].value\n        if (\n            \"script\" in text_shaping_params\n            and text_shaping_params[\"script\"] is not None\n        ):\n            buf.script = text_shaping_params[\"script\"]\n        if (\n            \"language\" in text_shaping_params\n            and text_shaping_params[\"language\"] is not None\n        ):\n            buf.language = text_shaping_params[\"language\"]\n        hb.shape(self.hbfont, buf, features)\n        return buf.glyph_infos, buf.glyph_positions\n\n    def encode_text(self, text: str) -> str:\n        txt_mapped = \"\"\n        for char in text:\n            uni = ord(char)\n            # Instead of adding the actual character to the stream its code is\n            # mapped to a position in the font's subset\n            mapped_char: Optional[int] = self.subset.pick(uni)\n            if mapped_char is not None:\n                txt_mapped += chr(mapped_char)\n        return f\"({self.escape_text(txt_mapped)}) Tj\"\n\n    def shape_text(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> Sequence[dict[str, Any]]:\n        \"\"\"\n        This method will invoke harfbuzz for text shaping, include the mapping code\n        of the glyphs on the subset and map input characters to the cluster codes\n        \"\"\"\n        if len(text) == 0:\n            return []\n        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(\n            text, font_size_pt, text_shaping_params\n        )\n        text_info = []\n\n        # Find cluster gaps\n        # Ex: text = \"ABCD\"\n        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph\n        # (ligature or substitution) - the glyph should have both unicodes and it should be translated\n        # properly on the CID to GID mapping\n        #\n        def get_cluster_from_text_index(cluster_list: Sequence[int], index: int) -> int:\n            pos = bisect_left(cluster_list, index)\n            if pos == 0:\n                return cluster_list[0]\n            if pos == len(cluster_list) or cluster_list[pos] != index:\n                return cluster_list[pos - 1]\n            return cluster_list[pos]\n\n        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))\n        cluster_mapping: dict[int, list[int]] = {}\n        for i in range(len(text)):\n            cl = get_cluster_from_text_index(cluster_list, i)\n            if cl in cluster_mapping:\n                cluster_mapping[cl].append(i)\n            else:\n                cluster_mapping[cl] = [i]\n\n        for cluster_seq, gi in enumerate(glyph_infos):\n            unicode = []\n            if gi.cluster in cluster_mapping:\n                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]\n                cluster_mapping.pop(gi.cluster)\n\n            gname = self.ttfont.getGlyphName(gi.codepoint)\n            gwidth = round(self.scale * self.ttfont[\"hmtx\"].metrics[gname][0])\n            glyph = self.subset.get_glyph(\n                glyph=gi.codepoint,\n                unicode=tuple(unicode),\n                glyph_name=gname,\n                glyph_width=gwidth,\n            )\n            if glyph is None:\n                continue\n            force_positioning = False\n            if (\n                gwidth != glyph_positions[cluster_seq].x_advance\n                or glyph_positions[cluster_seq].x_offset != 0\n                or glyph_positions[cluster_seq].y_offset != 0\n                or glyph_positions[cluster_seq].y_advance != 0\n            ):\n                force_positioning = True\n            text_info.append(\n                {\n                    \"mapped_char\": self.subset.pick_glyph(glyph),\n                    \"x_advance\": glyph_positions[cluster_seq].x_advance,\n                    \"y_advance\": glyph_positions[cluster_seq].y_advance,\n                    \"x_offset\": glyph_positions[cluster_seq].x_offset,\n                    \"y_offset\": glyph_positions[cluster_seq].y_offset,\n                    \"force_positioning\": force_positioning,\n                }\n            )\n        return text_info",
      "language": "python"
    },
    {
      "code": "class TTFFont:\n    __slots__ = (  # RAM usage optimization\n        \"i\",\n        \"type\",\n        \"name\",\n        \"desc\",\n        \"glyph_ids\",\n        \"_hbfont\",\n        \"sp\",\n        \"ss\",\n        \"up\",\n        \"ut\",\n        \"cw\",\n        \"ttffile\",\n        \"fontkey\",\n        \"emphasis\",\n        \"scale\",\n        \"subset\",\n        \"cmap\",\n        \"ttfont\",\n        \"missing_glyphs\",\n        \"biggest_size_pt\",\n        \"color_font\",\n        \"unicode_range\",\n        \"palette_index\",\n        \"is_compressed\",\n    )\n\n    def __init__(\n        self,\n        fpdf: \"FPDF\",\n        font_file_path: Path,\n        fontkey: str,\n        style: str,\n        unicode_range: Optional[set[int]] = None,\n        axes_dict: Optional[dict[str, float]] = None,\n        palette_index: Optional[int] = None,\n    ):\n        self.i = len(fpdf.fonts) + 1\n        self.type = \"TTF\"\n        self.ttffile = font_file_path\n        self.is_compressed = str(self.ttffile).lower().endswith((\".woff\", \".woff2\"))\n        self._hbfont: Optional[\"HarfBuzzFont\"] = None\n        self.fontkey = fontkey\n        self.biggest_size_pt: float = 0\n\n        # recalcTimestamp=False means that it doesn't modify the \"modified\" timestamp in head table\n        # if we leave recalcTimestamp=True the tests will break every time\n        try:\n            self.ttfont = ttLib.TTFont(\n                self.ttffile, recalcTimestamp=False, fontNumber=0, lazy=True\n            )\n        except (\n            ImportError,\n            RuntimeError,\n        ) as exc:  # pragma: no cover - defensive messaging\n            # If the user passed a WOFF2 file but brotli is not installed, fontTools\n            # raises an ImportError/RuntimeError during parsing. Provide a clearer hint\n            # only for that specific situation. Allow other exceptions (e.g. FileNotFoundError,\n            # OSError, parsing errors) to propagate normally so they aren't masked here.\n            fname_str = str(self.ttffile).lower()\n            if fname_str.endswith(\".woff2\"):\n                raise RuntimeError(\n                    \"Could not open WOFF2 font. WOFF2 support requires an external Brotli \"\n                    \"library (install 'brotli' or 'brotlicffi'). Original error: \"\n                    f\"{exc!s}\"\n                ) from exc\n            raise\n\n        if axes_dict is not None:\n            if \"fvar\" not in self.ttfont:\n                raise AttributeError(f\"{self.ttffile} is not a variable font\")\n\n            instancer.instantiateVariableFont(\n                self.ttfont,\n                axes_dict,\n                inplace=True,\n                static=True,\n            )\n        if self.is_compressed:\n            # Normalize to SFNT output for embedding and HarfBuzz.\n            self.ttfont.flavor = None\n        upem: float = float(self.ttfont[\"head\"].unitsPerEm)\n        self.scale: float = 1000 / upem\n\n        # check if the font is a TrueType and missing a .notdef glyph\n        # if it is missing, provide a fallback glyph\n        if (\n            \"glyf\" in self.ttfont\n            and \".notdef\"\n            not in self.ttfont[\"glyf\"]  # pyright: ignore[reportOperatorIssue]\n        ):\n            LOGGER.warning(\n                (\n                    \"TrueType Font '%s' is missing the '.notdef' glyph. \"\n                    \"Fallback glyph will be provided.\"\n                ),\n                self.fontkey,\n            )\n            # draw a diagonal cross .notdef glyph\n            xMin, xMax, yMin, yMax = (\n                self.ttfont[\"head\"].xMin,\n                self.ttfont[\"head\"].xMax,\n                self.ttfont[\"head\"].yMin,\n                self.ttfont[\"head\"].yMax,\n            )\n            pen = TTGlyphPen(self.ttfont[\"glyf\"])  # pyright: ignore[reportArgumentType]\n            pen.moveTo((xMin, yMin))\n            pen.lineTo((xMax, yMin))\n            pen.lineTo((xMax, yMax))\n            pen.lineTo((xMin, yMax))\n            pen.closePath()\n            pen.moveTo((xMin, yMin))\n            pen.lineTo((xMax, yMax))\n            pen.closePath()\n            pen.moveTo((xMax, yMin))\n            pen.lineTo((xMin, yMax))\n            pen.closePath()\n\n            self.ttfont[\"glyf\"][  # pyright: ignore[reportIndexIssue]\n                \".notdef\"\n            ] = pen.glyph()\n            self.ttfont[\"hmtx\"][\".notdef\"] = (  # pyright: ignore[reportIndexIssue]\n                xMax - xMin,\n                yMax - yMin,\n            )\n\n        default_width: float = round(\n            self.scale * self.ttfont[\"hmtx\"].metrics[\".notdef\"][0]\n        )\n\n        os2_table = self.ttfont[\"OS/2\"]\n        post_table = self.ttfont[\"post\"]\n\n        try:\n            cap_height = os2_table.sCapHeight\n        except AttributeError:\n            cap_height = self.ttfont[\"hhea\"].ascent\n\n        # entry for the PDF font descriptor specifying various characteristics of the font\n        flags = FontDescriptorFlags.SYMBOLIC\n        if post_table.isFixedPitch:\n            flags |= FontDescriptorFlags.FIXED_PITCH\n        if post_table.italicAngle != 0:\n            flags |= FontDescriptorFlags.ITALIC\n        if os2_table.usWeightClass >= 600:\n            flags |= FontDescriptorFlags.FORCE_BOLD\n\n        self.desc = PDFFontDescriptor(\n            ascent=round(self.ttfont[\"hhea\"].ascent * self.scale),\n            descent=round(self.ttfont[\"hhea\"].descent * self.scale),\n            cap_height=round(cap_height * self.scale),\n            flags=flags,\n            font_b_box=(\n                f\"[{self.ttfont['head'].xMin * self.scale:.0f} {self.ttfont['head'].yMin * self.scale:.0f}\"\n                f\" {self.ttfont['head'].xMax * self.scale:.0f} {self.ttfont['head'].yMax * self.scale:.0f}]\"\n            ),\n            italic_angle=int(post_table.italicAngle),\n            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),\n            missing_width=default_width,\n        )\n\n        # a map unicode_char -> char_width\n        self.cw: dict[int, float] = defaultdict(lambda: default_width)\n\n        # fonttools cmap = unicode char to glyph name\n        # saving only the keys we have a tuple with\n        # the unicode characters available on the font\n        self.cmap: dict[int, str] = self.ttfont.getBestCmap()\n        if not self.cmap:\n            raise NotImplementedError(\n                \"Font not supported as it does not have a unicode cmap table - cf. issue #1396\"\n            )\n\n        if unicode_range is not None and len(unicode_range) != 0:\n            self.cmap = {\n                codepoint: glyph_id\n                for codepoint, glyph_id in self.cmap.items()  # pyright: ignore[reportUnknownVariableType]\n                if codepoint in unicode_range\n            }\n\n        # saving a list of glyph ids to char to allow\n        # subset by unicode (regular) and by glyph\n        # (shaped with harfbuz)\n        self.glyph_ids = {}\n\n        for char in self.cmap:  # pyright: ignore[]\n            # take glyph associated to char\n            glyph = self.cmap[char]\n\n            # take width associated to glyph\n            w = self.ttfont[\"hmtx\"].metrics[glyph][0]\n\n            # probably this check could be deleted\n            if w == 65535:\n                w = 0\n\n            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP\n\n            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)\n\n        self.missing_glyphs: list[int] = []\n\n        self.name = re.sub(\"[ ()]\", \"\", self.ttfont[\"name\"].getBestFullName())\n        self.up = round(post_table.underlinePosition * self.scale)\n        self.ut = round(post_table.underlineThickness * self.scale)\n        self.sp = round(os2_table.yStrikeoutPosition * self.scale)\n        self.ss = round(os2_table.yStrikeoutSize * self.scale)\n        self.emphasis = TextEmphasis.coerce(style)\n        self.subset = SubsetMap(self)\n        self.palette_index = palette_index if palette_index is not None else 0\n        self.color_font = (\n            get_color_font_object(fpdf, self, self.palette_index)\n            if fpdf.render_color_fonts\n            else None\n        )\n\n    # pylint: disable=no-member\n    @property\n    def hbfont(self) -> \"HarfBuzzFont\":\n        if not self._hbfont:\n            if self.is_compressed:\n                # HarfBuzz cannot load compressed WOFF/WOFF2 files directly, so we\n                # re-serialize the fontTools TTFont to a raw SFNT byte buffer.\n                buf = BytesIO()\n                self.ttfont.save(buf)\n                buf.seek(0)\n                ttfont_bytes = buf.read()\n\n                # Try to create a HarfBuzz blob from bytes; if not available, write a\n                # temporary file as a last resort.\n                try:\n                    blob = hb.Blob.from_bytes(ttfont_bytes)\n                    face = hb.Face(blob)\n                except (AttributeError, RuntimeError):\n                    import tempfile, os  # pylint: disable=import-outside-toplevel\n\n                    tmp_name = None\n                    try:\n                        with tempfile.NamedTemporaryFile(\n                            suffix=\".ttf\", delete=False\n                        ) as tmp:\n                            tmp_name = tmp.name\n                            tmp.write(ttfont_bytes)\n                            tmp.flush()\n                        face = hb.Face(hb.Blob.from_file_path(tmp_name))\n                    finally:\n                        if tmp_name:\n                            try:\n                                os.unlink(tmp_name)\n                            except OSError as cleanup_error:\n                                # Log warning about failed cleanup - orphaned temp file may cause disk issues\n                                LOGGER.warning(\n                                    \"Failed to clean up temporary font file '%s': %s. This may leave an orphaned file on disk.\",\n                                    tmp_name,\n                                    cleanup_error,\n                                )\n\n                self._hbfont = HarfBuzzFont(face)\n            else:\n                # For regular TTF/OTF fonts, load directly from file path (faster)\n                self._hbfont = HarfBuzzFont(\n                    hb.Face(hb.Blob.from_file_path(self.ttffile))\n                )\n\n        return self._hbfont\n\n    def __repr__(self) -> str:\n        return f\"TTFFont(i={self.i}, fontkey={self.fontkey})\"\n\n    def __deepcopy__(self: \"TTFFont\", memo: dict[int, Any]) -> \"TTFFont\":\n        \"\"\"\n        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes\n        but instead share references to immutable objects\n        between the original FPDF instance and the FPDFRecorder instances\n        to avoid performances issues as spotted in issue #1444.\n        \"\"\"\n        copy = TTFFont.__new__(TTFFont)\n        # Immutable attributes:\n        copy.i = self.i\n        copy.type = \"TTF\"\n        copy.ttffile = self.ttffile\n        copy.fontkey = self.fontkey\n        copy.scale = self.scale\n        copy.name = self.name\n        copy.up = self.up\n        copy.ut = self.ut\n        copy.sp = self.sp\n        copy.ss = self.ss\n        copy.emphasis = self.emphasis\n        copy.is_compressed = self.is_compressed\n        # Attributes shared, to improve FPDFRecorder performances:\n        copy.ttfont = self.ttfont\n        copy.cmap = self.cmap\n        copy.desc = self.desc\n        # Attributes deepcopied:\n        copy.cw = deepcopy(self.cw, memo)\n        copy.glyph_ids = deepcopy(self.glyph_ids, memo)\n        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)\n        copy.subset = deepcopy(self.subset, memo)\n        copy.biggest_size_pt = self.biggest_size_pt\n        copy._hbfont = self._hbfont\n        copy.color_font = self.color_font\n        copy.palette_index = self.palette_index\n        return copy\n\n    def close(self) -> None:\n        self.ttfont.close()\n        self._hbfont = None\n\n    def escape_text(self, text: str) -> str:\n        if self.color_font:\n            encoded = text.encode(\"latin-1\", errors=\"replace\")\n            return escape_parens(encoded.decode(\"latin-1\", errors=\"ignore\"))\n        return escape_parens(text.encode(\"utf-16-be\").decode(\"latin-1\"))\n\n    def get_text_width(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[int, float]:\n        if font_size_pt > self.biggest_size_pt:\n            self.biggest_size_pt = font_size_pt\n        if text_shaping_params:\n            return self.shaped_text_width(text, font_size_pt, text_shaping_params)\n        return (len(text), sum(self.cw[ord(c)] for c in text) * font_size_pt * 0.001)\n\n    def shaped_text_width(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[int, float]:\n        \"\"\"\n        When texts are shaped, the length of a string is not always the sum of all individual character widths\n        This method will invoke harfbuzz to perform the text shaping and return the sum of \"x_advance\"\n        and \"x_offset\" for each glyph. This method works for \"left to right\" or \"right to left\" texts.\n        \"\"\"\n        _, glyph_positions = self.perform_harfbuzz_shaping(\n            text, font_size_pt, text_shaping_params\n        )\n\n        # If there is nothing to render (harfbuzz returns None), we return 0 text width\n        if glyph_positions is None:\n            return (0, 0)\n\n        text_width: float = 0\n        for pos in glyph_positions:\n            text_width += (\n                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001\n            )\n        return (len(glyph_positions), text_width)\n\n    # Disabling this check - looks like cython confuses pylint:\n    # pylint: disable=no-member\n    def perform_harfbuzz_shaping(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[Sequence[\"HBGlyphInfo\"], Sequence[\"HBGlyphPosition\"]]:\n        \"\"\"\n        This method invokes Harfbuzz to perform text shaping of the input string\n        \"\"\"\n        self.hbfont.ptem = font_size_pt\n        if TYPE_CHECKING:\n            buf: HBBuffer\n        buf = hb.Buffer()\n        buf.cluster_level = 1\n        buf.add_str(\"\".join(text))\n        buf.guess_segment_properties()\n        features = (\n            text_shaping_params[\"features\"] if text_shaping_params is not None else {}\n        )\n        if text_shaping_params is None:\n            text_shaping_params = {}\n        if (\n            \"fragment_direction\" in text_shaping_params\n            and text_shaping_params[\"fragment_direction\"] is not None\n        ):\n            buf.direction = text_shaping_params[\"fragment_direction\"].value\n        if (\n            \"script\" in text_shaping_params\n            and text_shaping_params[\"script\"] is not None\n        ):\n            buf.script = text_shaping_params[\"script\"]\n        if (\n            \"language\" in text_shaping_params\n            and text_shaping_params[\"language\"] is not None\n        ):\n            buf.language = text_shaping_params[\"language\"]\n        hb.shape(self.hbfont, buf, features)\n        return buf.glyph_infos, buf.glyph_positions\n\n    def encode_text(self, text: str) -> str:\n        txt_mapped = \"\"\n        for char in text:\n            uni = ord(char)\n            # Instead of adding the actual character to the stream its code is\n            # mapped to a position in the font's subset\n            mapped_char: Optional[int] = self.subset.pick(uni)\n            if mapped_char is not None:\n                txt_mapped += chr(mapped_char)\n        return f\"({self.escape_text(txt_mapped)}) Tj\"\n\n    def shape_text(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> Sequence[dict[str, Any]]:\n        \"\"\"\n        This method will invoke harfbuzz for text shaping, include the mapping code\n        of the glyphs on the subset and map input characters to the cluster codes\n        \"\"\"\n        if len(text) == 0:\n            return []\n        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(\n            text, font_size_pt, text_shaping_params\n        )\n        text_info = []\n\n        # Find cluster gaps\n        # Ex: text = \"ABCD\"\n        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph\n        # (ligature or substitution) - the glyph should have both unicodes and it should be translated\n        # properly on the CID to GID mapping\n        #\n        def get_cluster_from_text_index(cluster_list: Sequence[int], index: int) -> int:\n            pos = bisect_left(cluster_list, index)\n            if pos == 0:\n                return cluster_list[0]\n            if pos == len(cluster_list) or cluster_list[pos] != index:\n                return cluster_list[pos - 1]\n            return cluster_list[pos]\n\n        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))\n        cluster_mapping: dict[int, list[int]] = {}\n        for i in range(len(text)):\n            cl = get_cluster_from_text_index(cluster_list, i)\n            if cl in cluster_mapping:\n                cluster_mapping[cl].append(i)\n            else:\n                cluster_mapping[cl] = [i]\n\n        for cluster_seq, gi in enumerate(glyph_infos):\n            unicode = []\n            if gi.cluster in cluster_mapping:\n                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]\n                cluster_mapping.pop(gi.cluster)\n\n            gname = self.ttfont.getGlyphName(gi.codepoint)\n            gwidth = round(self.scale * self.ttfont[\"hmtx\"].metrics[gname][0])\n            glyph = self.subset.get_glyph(\n                glyph=gi.codepoint,\n                unicode=tuple(unicode),\n                glyph_name=gname,\n                glyph_width=gwidth,\n            )\n            if glyph is None:\n                continue\n            force_positioning = False\n            if (\n                gwidth != glyph_positions[cluster_seq].x_advance\n                or glyph_positions[cluster_seq].x_offset != 0\n                or glyph_positions[cluster_seq].y_offset != 0\n                or glyph_positions[cluster_seq].y_advance != 0\n            ):\n                force_positioning = True\n            text_info.append(\n                {\n                    \"mapped_char\": self.subset.pick_glyph(glyph),\n                    \"x_advance\": glyph_positions[cluster_seq].x_advance,\n                    \"y_advance\": glyph_positions[cluster_seq].y_advance,\n                    \"x_offset\": glyph_positions[cluster_seq].x_offset,\n                    \"y_offset\": glyph_positions[cluster_seq].y_offset,\n                    \"force_positioning\": force_positioning,\n                }\n            )\n        return text_info",
      "language": "python"
    },
    {
      "code": "class TTFFont:\n    __slots__ = (  # RAM usage optimization\n        \"i\",\n        \"type\",\n        \"name\",\n        \"desc\",\n        \"glyph_ids\",\n        \"_hbfont\",\n        \"sp\",\n        \"ss\",\n        \"up\",\n        \"ut\",\n        \"cw\",\n        \"ttffile\",\n        \"fontkey\",\n        \"emphasis\",\n        \"scale\",\n        \"subset\",\n        \"cmap\",\n        \"ttfont\",\n        \"missing_glyphs\",\n        \"biggest_size_pt\",\n        \"color_font\",\n        \"unicode_range\",\n        \"palette_index\",\n        \"is_compressed\",\n    )\n\n    def __init__(\n        self,\n        fpdf: \"FPDF\",\n        font_file_path: Path,\n        fontkey: str,\n        style: str,\n        unicode_range: Optional[set[int]] = None,\n        axes_dict: Optional[dict[str, float]] = None,\n        palette_index: Optional[int] = None,\n    ):\n        self.i = len(fpdf.fonts) + 1\n        self.type = \"TTF\"\n        self.ttffile = font_file_path\n        self.is_compressed = str(self.ttffile).lower().endswith((\".woff\", \".woff2\"))\n        self._hbfont: Optional[\"HarfBuzzFont\"] = None\n        self.fontkey = fontkey\n        self.biggest_size_pt: float = 0\n\n        # recalcTimestamp=False means that it doesn't modify the \"modified\" timestamp in head table\n        # if we leave recalcTimestamp=True the tests will break every time\n        try:\n            self.ttfont = ttLib.TTFont(\n                self.ttffile, recalcTimestamp=False, fontNumber=0, lazy=True\n            )\n        except (\n            ImportError,\n            RuntimeError,\n        ) as exc:  # pragma: no cover - defensive messaging\n            # If the user passed a WOFF2 file but brotli is not installed, fontTools\n            # raises an ImportError/RuntimeError during parsing. Provide a clearer hint\n            # only for that specific situation. Allow other exceptions (e.g. FileNotFoundError,\n            # OSError, parsing errors) to propagate normally so they aren't masked here.\n            fname_str = str(self.ttffile).lower()\n            if fname_str.endswith(\".woff2\"):\n                raise RuntimeError(\n                    \"Could not open WOFF2 font. WOFF2 support requires an external Brotli \"\n                    \"library (install 'brotli' or 'brotlicffi'). Original error: \"\n                    f\"{exc!s}\"\n                ) from exc\n            raise\n\n        if axes_dict is not None:\n            if \"fvar\" not in self.ttfont:\n                raise AttributeError(f\"{self.ttffile} is not a variable font\")\n\n            instancer.instantiateVariableFont(\n                self.ttfont,\n                axes_dict,\n                inplace=True,\n                static=True,\n            )\n        if self.is_compressed:\n            # Normalize to SFNT output for embedding and HarfBuzz.\n            self.ttfont.flavor = None\n        upem: float = float(self.ttfont[\"head\"].unitsPerEm)\n        self.scale: float = 1000 / upem\n\n        # check if the font is a TrueType and missing a .notdef glyph\n        # if it is missing, provide a fallback glyph\n        if (\n            \"glyf\" in self.ttfont\n            and \".notdef\"\n            not in self.ttfont[\"glyf\"]  # pyright: ignore[reportOperatorIssue]\n        ):\n            LOGGER.warning(\n                (\n                    \"TrueType Font '%s' is missing the '.notdef' glyph. \"\n                    \"Fallback glyph will be provided.\"\n                ),\n                self.fontkey,\n            )\n            # draw a diagonal cross .notdef glyph\n            xMin, xMax, yMin, yMax = (\n                self.ttfont[\"head\"].xMin,\n                self.ttfont[\"head\"].xMax,\n                self.ttfont[\"head\"].yMin,\n                self.ttfont[\"head\"].yMax,\n            )\n            pen = TTGlyphPen(self.ttfont[\"glyf\"])  # pyright: ignore[reportArgumentType]\n            pen.moveTo((xMin, yMin))\n            pen.lineTo((xMax, yMin))\n            pen.lineTo((xMax, yMax))\n            pen.lineTo((xMin, yMax))\n            pen.closePath()\n            pen.moveTo((xMin, yMin))\n            pen.lineTo((xMax, yMax))\n            pen.closePath()\n            pen.moveTo((xMax, yMin))\n            pen.lineTo((xMin, yMax))\n            pen.closePath()\n\n            self.ttfont[\"glyf\"][  # pyright: ignore[reportIndexIssue]\n                \".notdef\"\n            ] = pen.glyph()\n            self.ttfont[\"hmtx\"][\".notdef\"] = (  # pyright: ignore[reportIndexIssue]\n                xMax - xMin,\n                yMax - yMin,\n            )\n\n        default_width: float = round(\n            self.scale * self.ttfont[\"hmtx\"].metrics[\".notdef\"][0]\n        )\n\n        os2_table = self.ttfont[\"OS/2\"]\n        post_table = self.ttfont[\"post\"]\n\n        try:\n            cap_height = os2_table.sCapHeight\n        except AttributeError:\n            cap_height = self.ttfont[\"hhea\"].ascent\n\n        # entry for the PDF font descriptor specifying various characteristics of the font\n        flags = FontDescriptorFlags.SYMBOLIC\n        if post_table.isFixedPitch:\n            flags |= FontDescriptorFlags.FIXED_PITCH\n        if post_table.italicAngle != 0:\n            flags |= FontDescriptorFlags.ITALIC\n        if os2_table.usWeightClass >= 600:\n            flags |= FontDescriptorFlags.FORCE_BOLD\n\n        self.desc = PDFFontDescriptor(\n            ascent=round(self.ttfont[\"hhea\"].ascent * self.scale),\n            descent=round(self.ttfont[\"hhea\"].descent * self.scale),\n            cap_height=round(cap_height * self.scale),\n            flags=flags,\n            font_b_box=(\n                f\"[{self.ttfont['head'].xMin * self.scale:.0f} {self.ttfont['head'].yMin * self.scale:.0f}\"\n                f\" {self.ttfont['head'].xMax * self.scale:.0f} {self.ttfont['head'].yMax * self.scale:.0f}]\"\n            ),\n            italic_angle=int(post_table.italicAngle),\n            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),\n            missing_width=default_width,\n        )\n\n        # a map unicode_char -> char_width\n        self.cw: dict[int, float] = defaultdict(lambda: default_width)\n\n        # fonttools cmap = unicode char to glyph name\n        # saving only the keys we have a tuple with\n        # the unicode characters available on the font\n        self.cmap: dict[int, str] = self.ttfont.getBestCmap()\n        if not self.cmap:\n            raise NotImplementedError(\n                \"Font not supported as it does not have a unicode cmap table - cf. issue #1396\"\n            )\n\n        if unicode_range is not None and len(unicode_range) != 0:\n            self.cmap = {\n                codepoint: glyph_id\n                for codepoint, glyph_id in self.cmap.items()  # pyright: ignore[reportUnknownVariableType]\n                if codepoint in unicode_range\n            }\n\n        # saving a list of glyph ids to char to allow\n        # subset by unicode (regular) and by glyph\n        # (shaped with harfbuz)\n        self.glyph_ids = {}\n\n        for char in self.cmap:  # pyright: ignore[]\n            # take glyph associated to char\n            glyph = self.cmap[char]\n\n            # take width associated to glyph\n            w = self.ttfont[\"hmtx\"].metrics[glyph][0]\n\n            # probably this check could be deleted\n            if w == 65535:\n                w = 0\n\n            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP\n\n            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)\n\n        self.missing_glyphs: list[int] = []\n\n        self.name = re.sub(\"[ ()]\", \"\", self.ttfont[\"name\"].getBestFullName())\n        self.up = round(post_table.underlinePosition * self.scale)\n        self.ut = round(post_table.underlineThickness * self.scale)\n        self.sp = round(os2_table.yStrikeoutPosition * self.scale)\n        self.ss = round(os2_table.yStrikeoutSize * self.scale)\n        self.emphasis = TextEmphasis.coerce(style)\n        self.subset = SubsetMap(self)\n        self.palette_index = palette_index if palette_index is not None else 0\n        self.color_font = (\n            get_color_font_object(fpdf, self, self.palette_index)\n            if fpdf.render_color_fonts\n            else None\n        )\n\n    # pylint: disable=no-member\n    @property\n    def hbfont(self) -> \"HarfBuzzFont\":\n        if not self._hbfont:\n            if self.is_compressed:\n                # HarfBuzz cannot load compressed WOFF/WOFF2 files directly, so we\n                # re-serialize the fontTools TTFont to a raw SFNT byte buffer.\n                buf = BytesIO()\n                self.ttfont.save(buf)\n                buf.seek(0)\n                ttfont_bytes = buf.read()\n\n                # Try to create a HarfBuzz blob from bytes; if not available, write a\n                # temporary file as a last resort.\n                try:\n                    blob = hb.Blob.from_bytes(ttfont_bytes)\n                    face = hb.Face(blob)\n                except (AttributeError, RuntimeError):\n                    import tempfile, os  # pylint: disable=import-outside-toplevel\n\n                    tmp_name = None\n                    try:\n                        with tempfile.NamedTemporaryFile(\n                            suffix=\".ttf\", delete=False\n                        ) as tmp:\n                            tmp_name = tmp.name\n                            tmp.write(ttfont_bytes)\n                            tmp.flush()\n                        face = hb.Face(hb.Blob.from_file_path(tmp_name))\n                    finally:\n                        if tmp_name:\n                            try:\n                                os.unlink(tmp_name)\n                            except OSError as cleanup_error:\n                                # Log warning about failed cleanup - orphaned temp file may cause disk issues\n                                LOGGER.warning(\n                                    \"Failed to clean up temporary font file '%s': %s. This may leave an orphaned file on disk.\",\n                                    tmp_name,\n                                    cleanup_error,\n                                )\n\n                self._hbfont = HarfBuzzFont(face)\n            else:\n                # For regular TTF/OTF fonts, load directly from file path (faster)\n                self._hbfont = HarfBuzzFont(\n                    hb.Face(hb.Blob.from_file_path(self.ttffile))\n                )\n\n        return self._hbfont\n\n    def __repr__(self) -> str:\n        return f\"TTFFont(i={self.i}, fontkey={self.fontkey})\"\n\n    def __deepcopy__(self: \"TTFFont\", memo: dict[int, Any]) -> \"TTFFont\":\n        \"\"\"\n        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes\n        but instead share references to immutable objects\n        between the original FPDF instance and the FPDFRecorder instances\n        to avoid performances issues as spotted in issue #1444.\n        \"\"\"\n        copy = TTFFont.__new__(TTFFont)\n        # Immutable attributes:\n        copy.i = self.i\n        copy.type = \"TTF\"\n        copy.ttffile = self.ttffile\n        copy.fontkey = self.fontkey\n        copy.scale = self.scale\n        copy.name = self.name\n        copy.up = self.up\n        copy.ut = self.ut\n        copy.sp = self.sp\n        copy.ss = self.ss\n        copy.emphasis = self.emphasis\n        copy.is_compressed = self.is_compressed\n        # Attributes shared, to improve FPDFRecorder performances:\n        copy.ttfont = self.ttfont\n        copy.cmap = self.cmap\n        copy.desc = self.desc\n        # Attributes deepcopied:\n        copy.cw = deepcopy(self.cw, memo)\n        copy.glyph_ids = deepcopy(self.glyph_ids, memo)\n        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)\n        copy.subset = deepcopy(self.subset, memo)\n        copy.biggest_size_pt = self.biggest_size_pt\n        copy._hbfont = self._hbfont\n        copy.color_font = self.color_font\n        copy.palette_index = self.palette_index\n        return copy\n\n    def close(self) -> None:\n        self.ttfont.close()\n        self._hbfont = None\n\n    def escape_text(self, text: str) -> str:\n        if self.color_font:\n            encoded = text.encode(\"latin-1\", errors=\"replace\")\n            return escape_parens(encoded.decode(\"latin-1\", errors=\"ignore\"))\n        return escape_parens(text.encode(\"utf-16-be\").decode(\"latin-1\"))\n\n    def get_text_width(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[int, float]:\n        if font_size_pt > self.biggest_size_pt:\n            self.biggest_size_pt = font_size_pt\n        if text_shaping_params:\n            return self.shaped_text_width(text, font_size_pt, text_shaping_params)\n        return (len(text), sum(self.cw[ord(c)] for c in text) * font_size_pt * 0.001)\n\n    def shaped_text_width(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[int, float]:\n        \"\"\"\n        When texts are shaped, the length of a string is not always the sum of all individual character widths\n        This method will invoke harfbuzz to perform the text shaping and return the sum of \"x_advance\"\n        and \"x_offset\" for each glyph. This method works for \"left to right\" or \"right to left\" texts.\n        \"\"\"\n        _, glyph_positions = self.perform_harfbuzz_shaping(\n            text, font_size_pt, text_shaping_params\n        )\n\n        # If there is nothing to render (harfbuzz returns None), we return 0 text width\n        if glyph_positions is None:\n            return (0, 0)\n\n        text_width: float = 0\n        for pos in glyph_positions:\n            text_width += (\n                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001\n            )\n        return (len(glyph_positions), text_width)\n\n    # Disabling this check - looks like cython confuses pylint:\n    # pylint: disable=no-member\n    def perform_harfbuzz_shaping(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[Sequence[\"HBGlyphInfo\"], Sequence[\"HBGlyphPosition\"]]:\n        \"\"\"\n        This method invokes Harfbuzz to perform text shaping of the input string\n        \"\"\"\n        self.hbfont.ptem = font_size_pt\n        if TYPE_CHECKING:\n            buf: HBBuffer\n        buf = hb.Buffer()\n        buf.cluster_level = 1\n        buf.add_str(\"\".join(text))\n        buf.guess_segment_properties()\n        features = (\n            text_shaping_params[\"features\"] if text_shaping_params is not None else {}\n        )\n        if text_shaping_params is None:\n            text_shaping_params = {}\n        if (\n            \"fragment_direction\" in text_shaping_params\n            and text_shaping_params[\"fragment_direction\"] is not None\n        ):\n            buf.direction = text_shaping_params[\"fragment_direction\"].value\n        if (\n            \"script\" in text_shaping_params\n            and text_shaping_params[\"script\"] is not None\n        ):\n            buf.script = text_shaping_params[\"script\"]\n        if (\n            \"language\" in text_shaping_params\n            and text_shaping_params[\"language\"] is not None\n        ):\n            buf.language = text_shaping_params[\"language\"]\n        hb.shape(self.hbfont, buf, features)\n        return buf.glyph_infos, buf.glyph_positions\n\n    def encode_text(self, text: str) -> str:\n        txt_mapped = \"\"\n        for char in text:\n            uni = ord(char)\n            # Instead of adding the actual character to the stream its code is\n            # mapped to a position in the font's subset\n            mapped_char: Optional[int] = self.subset.pick(uni)\n            if mapped_char is not None:\n                txt_mapped += chr(mapped_char)\n        return f\"({self.escape_text(txt_mapped)}) Tj\"\n\n    def shape_text(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> Sequence[dict[str, Any]]:\n        \"\"\"\n        This method will invoke harfbuzz for text shaping, include the mapping code\n        of the glyphs on the subset and map input characters to the cluster codes\n        \"\"\"\n        if len(text) == 0:\n            return []\n        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(\n            text, font_size_pt, text_shaping_params\n        )\n        text_info = []\n\n        # Find cluster gaps\n        # Ex: text = \"ABCD\"\n        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph\n        # (ligature or substitution) - the glyph should have both unicodes and it should be translated\n        # properly on the CID to GID mapping\n        #\n        def get_cluster_from_text_index(cluster_list: Sequence[int], index: int) -> int:\n            pos = bisect_left(cluster_list, index)\n            if pos == 0:\n                return cluster_list[0]\n            if pos == len(cluster_list) or cluster_list[pos] != index:\n                return cluster_list[pos - 1]\n            return cluster_list[pos]\n\n        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))\n        cluster_mapping: dict[int, list[int]] = {}\n        for i in range(len(text)):\n            cl = get_cluster_from_text_index(cluster_list, i)\n            if cl in cluster_mapping:\n                cluster_mapping[cl].append(i)\n            else:\n                cluster_mapping[cl] = [i]\n\n        for cluster_seq, gi in enumerate(glyph_infos):\n            unicode = []\n            if gi.cluster in cluster_mapping:\n                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]\n                cluster_mapping.pop(gi.cluster)\n\n            gname = self.ttfont.getGlyphName(gi.codepoint)\n            gwidth = round(self.scale * self.ttfont[\"hmtx\"].metrics[gname][0])\n            glyph = self.subset.get_glyph(\n                glyph=gi.codepoint,\n                unicode=tuple(unicode),\n                glyph_name=gname,\n                glyph_width=gwidth,\n            )\n            if glyph is None:\n                continue\n            force_positioning = False\n            if (\n                gwidth != glyph_positions[cluster_seq].x_advance\n                or glyph_positions[cluster_seq].x_offset != 0\n                or glyph_positions[cluster_seq].y_offset != 0\n                or glyph_positions[cluster_seq].y_advance != 0\n            ):\n                force_positioning = True\n            text_info.append(\n                {\n                    \"mapped_char\": self.subset.pick_glyph(glyph),\n                    \"x_advance\": glyph_positions[cluster_seq].x_advance,\n                    \"y_advance\": glyph_positions[cluster_seq].y_advance,\n                    \"x_offset\": glyph_positions[cluster_seq].x_offset,\n                    \"y_offset\": glyph_positions[cluster_seq].y_offset,\n                    \"force_positioning\": force_positioning,\n                }\n            )\n        return text_info",
      "language": "python"
    },
    {
      "code": "class TTFFont:\n    __slots__ = (  # RAM usage optimization\n        \"i\",\n        \"type\",\n        \"name\",\n        \"desc\",\n        \"glyph_ids\",\n        \"_hbfont\",\n        \"sp\",\n        \"ss\",\n        \"up\",\n        \"ut\",\n        \"cw\",\n        \"ttffile\",\n        \"fontkey\",\n        \"emphasis\",\n        \"scale\",\n        \"subset\",\n        \"cmap\",\n        \"ttfont\",\n        \"missing_glyphs\",\n        \"biggest_size_pt\",\n        \"color_font\",\n        \"unicode_range\",\n        \"palette_index\",\n        \"is_compressed\",\n    )\n\n    def __init__(\n        self,\n        fpdf: \"FPDF\",\n        font_file_path: Path,\n        fontkey: str,\n        style: str,\n        unicode_range: Optional[set[int]] = None,\n        axes_dict: Optional[dict[str, float]] = None,\n        palette_index: Optional[int] = None,\n    ):\n        self.i = len(fpdf.fonts) + 1\n        self.type = \"TTF\"\n        self.ttffile = font_file_path\n        self.is_compressed = str(self.ttffile).lower().endswith((\".woff\", \".woff2\"))\n        self._hbfont: Optional[\"HarfBuzzFont\"] = None\n        self.fontkey = fontkey\n        self.biggest_size_pt: float = 0\n\n        # recalcTimestamp=False means that it doesn't modify the \"modified\" timestamp in head table\n        # if we leave recalcTimestamp=True the tests will break every time\n        try:\n            self.ttfont = ttLib.TTFont(\n                self.ttffile, recalcTimestamp=False, fontNumber=0, lazy=True\n            )\n        except (\n            ImportError,\n            RuntimeError,\n        ) as exc:  # pragma: no cover - defensive messaging\n            # If the user passed a WOFF2 file but brotli is not installed, fontTools\n            # raises an ImportError/RuntimeError during parsing. Provide a clearer hint\n            # only for that specific situation. Allow other exceptions (e.g. FileNotFoundError,\n            # OSError, parsing errors) to propagate normally so they aren't masked here.\n            fname_str = str(self.ttffile).lower()\n            if fname_str.endswith(\".woff2\"):\n                raise RuntimeError(\n                    \"Could not open WOFF2 font. WOFF2 support requires an external Brotli \"\n                    \"library (install 'brotli' or 'brotlicffi'). Original error: \"\n                    f\"{exc!s}\"\n                ) from exc\n            raise\n\n        if axes_dict is not None:\n            if \"fvar\" not in self.ttfont:\n                raise AttributeError(f\"{self.ttffile} is not a variable font\")\n\n            instancer.instantiateVariableFont(\n                self.ttfont,\n                axes_dict,\n                inplace=True,\n                static=True,\n            )\n        if self.is_compressed:\n            # Normalize to SFNT output for embedding and HarfBuzz.\n            self.ttfont.flavor = None\n        upem: float = float(self.ttfont[\"head\"].unitsPerEm)\n        self.scale: float = 1000 / upem\n\n        # check if the font is a TrueType and missing a .notdef glyph\n        # if it is missing, provide a fallback glyph\n        if (\n            \"glyf\" in self.ttfont\n            and \".notdef\"\n            not in self.ttfont[\"glyf\"]  # pyright: ignore[reportOperatorIssue]\n        ):\n            LOGGER.warning(\n                (\n                    \"TrueType Font '%s' is missing the '.notdef' glyph. \"\n                    \"Fallback glyph will be provided.\"\n                ),\n                self.fontkey,\n            )\n            # draw a diagonal cross .notdef glyph\n            xMin, xMax, yMin, yMax = (\n                self.ttfont[\"head\"].xMin,\n                self.ttfont[\"head\"].xMax,\n                self.ttfont[\"head\"].yMin,\n                self.ttfont[\"head\"].yMax,\n            )\n            pen = TTGlyphPen(self.ttfont[\"glyf\"])  # pyright: ignore[reportArgumentType]\n            pen.moveTo((xMin, yMin))\n            pen.lineTo((xMax, yMin))\n            pen.lineTo((xMax, yMax))\n            pen.lineTo((xMin, yMax))\n            pen.closePath()\n            pen.moveTo((xMin, yMin))\n            pen.lineTo((xMax, yMax))\n            pen.closePath()\n            pen.moveTo((xMax, yMin))\n            pen.lineTo((xMin, yMax))\n            pen.closePath()\n\n            self.ttfont[\"glyf\"][  # pyright: ignore[reportIndexIssue]\n                \".notdef\"\n            ] = pen.glyph()\n            self.ttfont[\"hmtx\"][\".notdef\"] = (  # pyright: ignore[reportIndexIssue]\n                xMax - xMin,\n                yMax - yMin,\n            )\n\n        default_width: float = round(\n            self.scale * self.ttfont[\"hmtx\"].metrics[\".notdef\"][0]\n        )\n\n        os2_table = self.ttfont[\"OS/2\"]\n        post_table = self.ttfont[\"post\"]\n\n        try:\n            cap_height = os2_table.sCapHeight\n        except AttributeError:\n            cap_height = self.ttfont[\"hhea\"].ascent\n\n        # entry for the PDF font descriptor specifying various characteristics of the font\n        flags = FontDescriptorFlags.SYMBOLIC\n        if post_table.isFixedPitch:\n            flags |= FontDescriptorFlags.FIXED_PITCH\n        if post_table.italicAngle != 0:\n            flags |= FontDescriptorFlags.ITALIC\n        if os2_table.usWeightClass >= 600:\n            flags |= FontDescriptorFlags.FORCE_BOLD\n\n        self.desc = PDFFontDescriptor(\n            ascent=round(self.ttfont[\"hhea\"].ascent * self.scale),\n            descent=round(self.ttfont[\"hhea\"].descent * self.scale),\n            cap_height=round(cap_height * self.scale),\n            flags=flags,\n            font_b_box=(\n                f\"[{self.ttfont['head'].xMin * self.scale:.0f} {self.ttfont['head'].yMin * self.scale:.0f}\"\n                f\" {self.ttfont['head'].xMax * self.scale:.0f} {self.ttfont['head'].yMax * self.scale:.0f}]\"\n            ),\n            italic_angle=int(post_table.italicAngle),\n            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),\n            missing_width=default_width,\n        )\n\n        # a map unicode_char -> char_width\n        self.cw: dict[int, float] = defaultdict(lambda: default_width)\n\n        # fonttools cmap = unicode char to glyph name\n        # saving only the keys we have a tuple with\n        # the unicode characters available on the font\n        self.cmap: dict[int, str] = self.ttfont.getBestCmap()\n        if not self.cmap:\n            raise NotImplementedError(\n                \"Font not supported as it does not have a unicode cmap table - cf. issue #1396\"\n            )\n\n        if unicode_range is not None and len(unicode_range) != 0:\n            self.cmap = {\n                codepoint: glyph_id\n                for codepoint, glyph_id in self.cmap.items()  # pyright: ignore[reportUnknownVariableType]\n                if codepoint in unicode_range\n            }\n\n        # saving a list of glyph ids to char to allow\n        # subset by unicode (regular) and by glyph\n        # (shaped with harfbuz)\n        self.glyph_ids = {}\n\n        for char in self.cmap:  # pyright: ignore[]\n            # take glyph associated to char\n            glyph = self.cmap[char]\n\n            # take width associated to glyph\n            w = self.ttfont[\"hmtx\"].metrics[glyph][0]\n\n            # probably this check could be deleted\n            if w == 65535:\n                w = 0\n\n            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP\n\n            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)\n\n        self.missing_glyphs: list[int] = []\n\n        self.name = re.sub(\"[ ()]\", \"\", self.ttfont[\"name\"].getBestFullName())\n        self.up = round(post_table.underlinePosition * self.scale)\n        self.ut = round(post_table.underlineThickness * self.scale)\n        self.sp = round(os2_table.yStrikeoutPosition * self.scale)\n        self.ss = round(os2_table.yStrikeoutSize * self.scale)\n        self.emphasis = TextEmphasis.coerce(style)\n        self.subset = SubsetMap(self)\n        self.palette_index = palette_index if palette_index is not None else 0\n        self.color_font = (\n            get_color_font_object(fpdf, self, self.palette_index)\n            if fpdf.render_color_fonts\n            else None\n        )\n\n    # pylint: disable=no-member\n    @property\n    def hbfont(self) -> \"HarfBuzzFont\":\n        if not self._hbfont:\n            if self.is_compressed:\n                # HarfBuzz cannot load compressed WOFF/WOFF2 files directly, so we\n                # re-serialize the fontTools TTFont to a raw SFNT byte buffer.\n                buf = BytesIO()\n                self.ttfont.save(buf)\n                buf.seek(0)\n                ttfont_bytes = buf.read()\n\n                # Try to create a HarfBuzz blob from bytes; if not available, write a\n                # temporary file as a last resort.\n                try:\n                    blob = hb.Blob.from_bytes(ttfont_bytes)\n                    face = hb.Face(blob)\n                except (AttributeError, RuntimeError):\n                    import tempfile, os  # pylint: disable=import-outside-toplevel\n\n                    tmp_name = None\n                    try:\n                        with tempfile.NamedTemporaryFile(\n                            suffix=\".ttf\", delete=False\n                        ) as tmp:\n                            tmp_name = tmp.name\n                            tmp.write(ttfont_bytes)\n                            tmp.flush()\n                        face = hb.Face(hb.Blob.from_file_path(tmp_name))\n                    finally:\n                        if tmp_name:\n                            try:\n                                os.unlink(tmp_name)\n                            except OSError as cleanup_error:\n                                # Log warning about failed cleanup - orphaned temp file may cause disk issues\n                                LOGGER.warning(\n                                    \"Failed to clean up temporary font file '%s': %s. This may leave an orphaned file on disk.\",\n                                    tmp_name,\n                                    cleanup_error,\n                                )\n\n                self._hbfont = HarfBuzzFont(face)\n            else:\n                # For regular TTF/OTF fonts, load directly from file path (faster)\n                self._hbfont = HarfBuzzFont(\n                    hb.Face(hb.Blob.from_file_path(self.ttffile))\n                )\n\n        return self._hbfont\n\n    def __repr__(self) -> str:\n        return f\"TTFFont(i={self.i}, fontkey={self.fontkey})\"\n\n    def __deepcopy__(self: \"TTFFont\", memo: dict[int, Any]) -> \"TTFFont\":\n        \"\"\"\n        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes\n        but instead share references to immutable objects\n        between the original FPDF instance and the FPDFRecorder instances\n        to avoid performances issues as spotted in issue #1444.\n        \"\"\"\n        copy = TTFFont.__new__(TTFFont)\n        # Immutable attributes:\n        copy.i = self.i\n        copy.type = \"TTF\"\n        copy.ttffile = self.ttffile\n        copy.fontkey = self.fontkey\n        copy.scale = self.scale\n        copy.name = self.name\n        copy.up = self.up\n        copy.ut = self.ut\n        copy.sp = self.sp\n        copy.ss = self.ss\n        copy.emphasis = self.emphasis\n        copy.is_compressed = self.is_compressed\n        # Attributes shared, to improve FPDFRecorder performances:\n        copy.ttfont = self.ttfont\n        copy.cmap = self.cmap\n        copy.desc = self.desc\n        # Attributes deepcopied:\n        copy.cw = deepcopy(self.cw, memo)\n        copy.glyph_ids = deepcopy(self.glyph_ids, memo)\n        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)\n        copy.subset = deepcopy(self.subset, memo)\n        copy.biggest_size_pt = self.biggest_size_pt\n        copy._hbfont = self._hbfont\n        copy.color_font = self.color_font\n        copy.palette_index = self.palette_index\n        return copy\n\n    def close(self) -> None:\n        self.ttfont.close()\n        self._hbfont = None\n\n    def escape_text(self, text: str) -> str:\n        if self.color_font:\n            encoded = text.encode(\"latin-1\", errors=\"replace\")\n            return escape_parens(encoded.decode(\"latin-1\", errors=\"ignore\"))\n        return escape_parens(text.encode(\"utf-16-be\").decode(\"latin-1\"))\n\n    def get_text_width(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[int, float]:\n        if font_size_pt > self.biggest_size_pt:\n            self.biggest_size_pt = font_size_pt\n        if text_shaping_params:\n            return self.shaped_text_width(text, font_size_pt, text_shaping_params)\n        return (len(text), sum(self.cw[ord(c)] for c in text) * font_size_pt * 0.001)\n\n    def shaped_text_width(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[int, float]:\n        \"\"\"\n        When texts are shaped, the length of a string is not always the sum of all individual character widths\n        This method will invoke harfbuzz to perform the text shaping and return the sum of \"x_advance\"\n        and \"x_offset\" for each glyph. This method works for \"left to right\" or \"right to left\" texts.\n        \"\"\"\n        _, glyph_positions = self.perform_harfbuzz_shaping(\n            text, font_size_pt, text_shaping_params\n        )\n\n        # If there is nothing to render (harfbuzz returns None), we return 0 text width\n        if glyph_positions is None:\n            return (0, 0)\n\n        text_width: float = 0\n        for pos in glyph_positions:\n            text_width += (\n                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001\n            )\n        return (len(glyph_positions), text_width)\n\n    # Disabling this check - looks like cython confuses pylint:\n    # pylint: disable=no-member\n    def perform_harfbuzz_shaping(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[Sequence[\"HBGlyphInfo\"], Sequence[\"HBGlyphPosition\"]]:\n        \"\"\"\n        This method invokes Harfbuzz to perform text shaping of the input string\n        \"\"\"\n        self.hbfont.ptem = font_size_pt\n        if TYPE_CHECKING:\n            buf: HBBuffer\n        buf = hb.Buffer()\n        buf.cluster_level = 1\n        buf.add_str(\"\".join(text))\n        buf.guess_segment_properties()\n        features = (\n            text_shaping_params[\"features\"] if text_shaping_params is not None else {}\n        )\n        if text_shaping_params is None:\n            text_shaping_params = {}\n        if (\n            \"fragment_direction\" in text_shaping_params\n            and text_shaping_params[\"fragment_direction\"] is not None\n        ):\n            buf.direction = text_shaping_params[\"fragment_direction\"].value\n        if (\n            \"script\" in text_shaping_params\n            and text_shaping_params[\"script\"] is not None\n        ):\n            buf.script = text_shaping_params[\"script\"]\n        if (\n            \"language\" in text_shaping_params\n            and text_shaping_params[\"language\"] is not None\n        ):\n            buf.language = text_shaping_params[\"language\"]\n        hb.shape(self.hbfont, buf, features)\n        return buf.glyph_infos, buf.glyph_positions\n\n    def encode_text(self, text: str) -> str:\n        txt_mapped = \"\"\n        for char in text:\n            uni = ord(char)\n            # Instead of adding the actual character to the stream its code is\n            # mapped to a position in the font's subset\n            mapped_char: Optional[int] = self.subset.pick(uni)\n            if mapped_char is not None:\n                txt_mapped += chr(mapped_char)\n        return f\"({self.escape_text(txt_mapped)}) Tj\"\n\n    def shape_text(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> Sequence[dict[str, Any]]:\n        \"\"\"\n        This method will invoke harfbuzz for text shaping, include the mapping code\n        of the glyphs on the subset and map input characters to the cluster codes\n        \"\"\"\n        if len(text) == 0:\n            return []\n        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(\n            text, font_size_pt, text_shaping_params\n        )\n        text_info = []\n\n        # Find cluster gaps\n        # Ex: text = \"ABCD\"\n        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph\n        # (ligature or substitution) - the glyph should have both unicodes and it should be translated\n        # properly on the CID to GID mapping\n        #\n        def get_cluster_from_text_index(cluster_list: Sequence[int], index: int) -> int:\n            pos = bisect_left(cluster_list, index)\n            if pos == 0:\n                return cluster_list[0]\n            if pos == len(cluster_list) or cluster_list[pos] != index:\n                return cluster_list[pos - 1]\n            return cluster_list[pos]\n\n        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))\n        cluster_mapping: dict[int, list[int]] = {}\n        for i in range(len(text)):\n            cl = get_cluster_from_text_index(cluster_list, i)\n            if cl in cluster_mapping:\n                cluster_mapping[cl].append(i)\n            else:\n                cluster_mapping[cl] = [i]\n\n        for cluster_seq, gi in enumerate(glyph_infos):\n            unicode = []\n            if gi.cluster in cluster_mapping:\n                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]\n                cluster_mapping.pop(gi.cluster)\n\n            gname = self.ttfont.getGlyphName(gi.codepoint)\n            gwidth = round(self.scale * self.ttfont[\"hmtx\"].metrics[gname][0])\n            glyph = self.subset.get_glyph(\n                glyph=gi.codepoint,\n                unicode=tuple(unicode),\n                glyph_name=gname,\n                glyph_width=gwidth,\n            )\n            if glyph is None:\n                continue\n            force_positioning = False\n            if (\n                gwidth != glyph_positions[cluster_seq].x_advance\n                or glyph_positions[cluster_seq].x_offset != 0\n                or glyph_positions[cluster_seq].y_offset != 0\n                or glyph_positions[cluster_seq].y_advance != 0\n            ):\n                force_positioning = True\n            text_info.append(\n                {\n                    \"mapped_char\": self.subset.pick_glyph(glyph),\n                    \"x_advance\": glyph_positions[cluster_seq].x_advance,\n                    \"y_advance\": glyph_positions[cluster_seq].y_advance,\n                    \"x_offset\": glyph_positions[cluster_seq].x_offset,\n                    \"y_offset\": glyph_positions[cluster_seq].y_offset,\n                    \"force_positioning\": force_positioning,\n                }\n            )\n        return text_info",
      "language": "python"
    },
    {
      "code": "class TTFFont:\n    __slots__ = (  # RAM usage optimization\n        \"i\",\n        \"type\",\n        \"name\",\n        \"desc\",\n        \"glyph_ids\",\n        \"_hbfont\",\n        \"sp\",\n        \"ss\",\n        \"up\",\n        \"ut\",\n        \"cw\",\n        \"ttffile\",\n        \"fontkey\",\n        \"emphasis\",\n        \"scale\",\n        \"subset\",\n        \"cmap\",\n        \"ttfont\",\n        \"missing_glyphs\",\n        \"biggest_size_pt\",\n        \"color_font\",\n        \"unicode_range\",\n        \"palette_index\",\n        \"is_compressed\",\n    )\n\n    def __init__(\n        self,\n        fpdf: \"FPDF\",\n        font_file_path: Path,\n        fontkey: str,\n        style: str,\n        unicode_range: Optional[set[int]] = None,\n        axes_dict: Optional[dict[str, float]] = None,\n        palette_index: Optional[int] = None,\n    ):\n        self.i = len(fpdf.fonts) + 1\n        self.type = \"TTF\"\n        self.ttffile = font_file_path\n        self.is_compressed = str(self.ttffile).lower().endswith((\".woff\", \".woff2\"))\n        self._hbfont: Optional[\"HarfBuzzFont\"] = None\n        self.fontkey = fontkey\n        self.biggest_size_pt: float = 0\n\n        # recalcTimestamp=False means that it doesn't modify the \"modified\" timestamp in head table\n        # if we leave recalcTimestamp=True the tests will break every time\n        try:\n            self.ttfont = ttLib.TTFont(\n                self.ttffile, recalcTimestamp=False, fontNumber=0, lazy=True\n            )\n        except (\n            ImportError,\n            RuntimeError,\n        ) as exc:  # pragma: no cover - defensive messaging\n            # If the user passed a WOFF2 file but brotli is not installed, fontTools\n            # raises an ImportError/RuntimeError during parsing. Provide a clearer hint\n            # only for that specific situation. Allow other exceptions (e.g. FileNotFoundError,\n            # OSError, parsing errors) to propagate normally so they aren't masked here.\n            fname_str = str(self.ttffile).lower()\n            if fname_str.endswith(\".woff2\"):\n                raise RuntimeError(\n                    \"Could not open WOFF2 font. WOFF2 support requires an external Brotli \"\n                    \"library (install 'brotli' or 'brotlicffi'). Original error: \"\n                    f\"{exc!s}\"\n                ) from exc\n            raise\n\n        if axes_dict is not None:\n            if \"fvar\" not in self.ttfont:\n                raise AttributeError(f\"{self.ttffile} is not a variable font\")\n\n            instancer.instantiateVariableFont(\n                self.ttfont,\n                axes_dict,\n                inplace=True,\n                static=True,\n            )\n        if self.is_compressed:\n            # Normalize to SFNT output for embedding and HarfBuzz.\n            self.ttfont.flavor = None\n        upem: float = float(self.ttfont[\"head\"].unitsPerEm)\n        self.scale: float = 1000 / upem\n\n        # check if the font is a TrueType and missing a .notdef glyph\n        # if it is missing, provide a fallback glyph\n        if (\n            \"glyf\" in self.ttfont\n            and \".notdef\"\n            not in self.ttfont[\"glyf\"]  # pyright: ignore[reportOperatorIssue]\n        ):\n            LOGGER.warning(\n                (\n                    \"TrueType Font '%s' is missing the '.notdef' glyph. \"\n                    \"Fallback glyph will be provided.\"\n                ),\n                self.fontkey,\n            )\n            # draw a diagonal cross .notdef glyph\n            xMin, xMax, yMin, yMax = (\n                self.ttfont[\"head\"].xMin,\n                self.ttfont[\"head\"].xMax,\n                self.ttfont[\"head\"].yMin,\n                self.ttfont[\"head\"].yMax,\n            )\n            pen = TTGlyphPen(self.ttfont[\"glyf\"])  # pyright: ignore[reportArgumentType]\n            pen.moveTo((xMin, yMin))\n            pen.lineTo((xMax, yMin))\n            pen.lineTo((xMax, yMax))\n            pen.lineTo((xMin, yMax))\n            pen.closePath()\n            pen.moveTo((xMin, yMin))\n            pen.lineTo((xMax, yMax))\n            pen.closePath()\n            pen.moveTo((xMax, yMin))\n            pen.lineTo((xMin, yMax))\n            pen.closePath()\n\n            self.ttfont[\"glyf\"][  # pyright: ignore[reportIndexIssue]\n                \".notdef\"\n            ] = pen.glyph()\n            self.ttfont[\"hmtx\"][\".notdef\"] = (  # pyright: ignore[reportIndexIssue]\n                xMax - xMin,\n                yMax - yMin,\n            )\n\n        default_width: float = round(\n            self.scale * self.ttfont[\"hmtx\"].metrics[\".notdef\"][0]\n        )\n\n        os2_table = self.ttfont[\"OS/2\"]\n        post_table = self.ttfont[\"post\"]\n\n        try:\n            cap_height = os2_table.sCapHeight\n        except AttributeError:\n            cap_height = self.ttfont[\"hhea\"].ascent\n\n        # entry for the PDF font descriptor specifying various characteristics of the font\n        flags = FontDescriptorFlags.SYMBOLIC\n        if post_table.isFixedPitch:\n            flags |= FontDescriptorFlags.FIXED_PITCH\n        if post_table.italicAngle != 0:\n            flags |= FontDescriptorFlags.ITALIC\n        if os2_table.usWeightClass >= 600:\n            flags |= FontDescriptorFlags.FORCE_BOLD\n\n        self.desc = PDFFontDescriptor(\n            ascent=round(self.ttfont[\"hhea\"].ascent * self.scale),\n            descent=round(self.ttfont[\"hhea\"].descent * self.scale),\n            cap_height=round(cap_height * self.scale),\n            flags=flags,\n            font_b_box=(\n                f\"[{self.ttfont['head'].xMin * self.scale:.0f} {self.ttfont['head'].yMin * self.scale:.0f}\"\n                f\" {self.ttfont['head'].xMax * self.scale:.0f} {self.ttfont['head'].yMax * self.scale:.0f}]\"\n            ),\n            italic_angle=int(post_table.italicAngle),\n            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),\n            missing_width=default_width,\n        )\n\n        # a map unicode_char -> char_width\n        self.cw: dict[int, float] = defaultdict(lambda: default_width)\n\n        # fonttools cmap = unicode char to glyph name\n        # saving only the keys we have a tuple with\n        # the unicode characters available on the font\n        self.cmap: dict[int, str] = self.ttfont.getBestCmap()\n        if not self.cmap:\n            raise NotImplementedError(\n                \"Font not supported as it does not have a unicode cmap table - cf. issue #1396\"\n            )\n\n        if unicode_range is not None and len(unicode_range) != 0:\n            self.cmap = {\n                codepoint: glyph_id\n                for codepoint, glyph_id in self.cmap.items()  # pyright: ignore[reportUnknownVariableType]\n                if codepoint in unicode_range\n            }\n\n        # saving a list of glyph ids to char to allow\n        # subset by unicode (regular) and by glyph\n        # (shaped with harfbuz)\n        self.glyph_ids = {}\n\n        for char in self.cmap:  # pyright: ignore[]\n            # take glyph associated to char\n            glyph = self.cmap[char]\n\n            # take width associated to glyph\n            w = self.ttfont[\"hmtx\"].metrics[glyph][0]\n\n            # probably this check could be deleted\n            if w == 65535:\n                w = 0\n\n            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP\n\n            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)\n\n        self.missing_glyphs: list[int] = []\n\n        self.name = re.sub(\"[ ()]\", \"\", self.ttfont[\"name\"].getBestFullName())\n        self.up = round(post_table.underlinePosition * self.scale)\n        self.ut = round(post_table.underlineThickness * self.scale)\n        self.sp = round(os2_table.yStrikeoutPosition * self.scale)\n        self.ss = round(os2_table.yStrikeoutSize * self.scale)\n        self.emphasis = TextEmphasis.coerce(style)\n        self.subset = SubsetMap(self)\n        self.palette_index = palette_index if palette_index is not None else 0\n        self.color_font = (\n            get_color_font_object(fpdf, self, self.palette_index)\n            if fpdf.render_color_fonts\n            else None\n        )\n\n    # pylint: disable=no-member\n    @property\n    def hbfont(self) -> \"HarfBuzzFont\":\n        if not self._hbfont:\n            if self.is_compressed:\n                # HarfBuzz cannot load compressed WOFF/WOFF2 files directly, so we\n                # re-serialize the fontTools TTFont to a raw SFNT byte buffer.\n                buf = BytesIO()\n                self.ttfont.save(buf)\n                buf.seek(0)\n                ttfont_bytes = buf.read()\n\n                # Try to create a HarfBuzz blob from bytes; if not available, write a\n                # temporary file as a last resort.\n                try:\n                    blob = hb.Blob.from_bytes(ttfont_bytes)\n                    face = hb.Face(blob)\n                except (AttributeError, RuntimeError):\n                    import tempfile, os  # pylint: disable=import-outside-toplevel\n\n                    tmp_name = None\n                    try:\n                        with tempfile.NamedTemporaryFile(\n                            suffix=\".ttf\", delete=False\n                        ) as tmp:\n                            tmp_name = tmp.name\n                            tmp.write(ttfont_bytes)\n                            tmp.flush()\n                        face = hb.Face(hb.Blob.from_file_path(tmp_name))\n                    finally:\n                        if tmp_name:\n                            try:\n                                os.unlink(tmp_name)\n                            except OSError as cleanup_error:\n                                # Log warning about failed cleanup - orphaned temp file may cause disk issues\n                                LOGGER.warning(\n                                    \"Failed to clean up temporary font file '%s': %s. This may leave an orphaned file on disk.\",\n                                    tmp_name,\n                                    cleanup_error,\n                                )\n\n                self._hbfont = HarfBuzzFont(face)\n            else:\n                # For regular TTF/OTF fonts, load directly from file path (faster)\n                self._hbfont = HarfBuzzFont(\n                    hb.Face(hb.Blob.from_file_path(self.ttffile))\n                )\n\n        return self._hbfont\n\n    def __repr__(self) -> str:\n        return f\"TTFFont(i={self.i}, fontkey={self.fontkey})\"\n\n    def __deepcopy__(self: \"TTFFont\", memo: dict[int, Any]) -> \"TTFFont\":\n        \"\"\"\n        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes\n        but instead share references to immutable objects\n        between the original FPDF instance and the FPDFRecorder instances\n        to avoid performances issues as spotted in issue #1444.\n        \"\"\"\n        copy = TTFFont.__new__(TTFFont)\n        # Immutable attributes:\n        copy.i = self.i\n        copy.type = \"TTF\"\n        copy.ttffile = self.ttffile\n        copy.fontkey = self.fontkey\n        copy.scale = self.scale\n        copy.name = self.name\n        copy.up = self.up\n        copy.ut = self.ut\n        copy.sp = self.sp\n        copy.ss = self.ss\n        copy.emphasis = self.emphasis\n        copy.is_compressed = self.is_compressed\n        # Attributes shared, to improve FPDFRecorder performances:\n        copy.ttfont = self.ttfont\n        copy.cmap = self.cmap\n        copy.desc = self.desc\n        # Attributes deepcopied:\n        copy.cw = deepcopy(self.cw, memo)\n        copy.glyph_ids = deepcopy(self.glyph_ids, memo)\n        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)\n        copy.subset = deepcopy(self.subset, memo)\n        copy.biggest_size_pt = self.biggest_size_pt\n        copy._hbfont = self._hbfont\n        copy.color_font = self.color_font\n        copy.palette_index = self.palette_index\n        return copy\n\n    def close(self) -> None:\n        self.ttfont.close()\n        self._hbfont = None\n\n    def escape_text(self, text: str) -> str:\n        if self.color_font:\n            encoded = text.encode(\"latin-1\", errors=\"replace\")\n            return escape_parens(encoded.decode(\"latin-1\", errors=\"ignore\"))\n        return escape_parens(text.encode(\"utf-16-be\").decode(\"latin-1\"))\n\n    def get_text_width(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[int, float]:\n        if font_size_pt > self.biggest_size_pt:\n            self.biggest_size_pt = font_size_pt\n        if text_shaping_params:\n            return self.shaped_text_width(text, font_size_pt, text_shaping_params)\n        return (len(text), sum(self.cw[ord(c)] for c in text) * font_size_pt * 0.001)\n\n    def shaped_text_width(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[int, float]:\n        \"\"\"\n        When texts are shaped, the length of a string is not always the sum of all individual character widths\n        This method will invoke harfbuzz to perform the text shaping and return the sum of \"x_advance\"\n        and \"x_offset\" for each glyph. This method works for \"left to right\" or \"right to left\" texts.\n        \"\"\"\n        _, glyph_positions = self.perform_harfbuzz_shaping(\n            text, font_size_pt, text_shaping_params\n        )\n\n        # If there is nothing to render (harfbuzz returns None), we return 0 text width\n        if glyph_positions is None:\n            return (0, 0)\n\n        text_width: float = 0\n        for pos in glyph_positions:\n            text_width += (\n                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001\n            )\n        return (len(glyph_positions), text_width)\n\n    # Disabling this check - looks like cython confuses pylint:\n    # pylint: disable=no-member\n    def perform_harfbuzz_shaping(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[Sequence[\"HBGlyphInfo\"], Sequence[\"HBGlyphPosition\"]]:\n        \"\"\"\n        This method invokes Harfbuzz to perform text shaping of the input string\n        \"\"\"\n        self.hbfont.ptem = font_size_pt\n        if TYPE_CHECKING:\n            buf: HBBuffer\n        buf = hb.Buffer()\n        buf.cluster_level = 1\n        buf.add_str(\"\".join(text))\n        buf.guess_segment_properties()\n        features = (\n            text_shaping_params[\"features\"] if text_shaping_params is not None else {}\n        )\n        if text_shaping_params is None:\n            text_shaping_params = {}\n        if (\n            \"fragment_direction\" in text_shaping_params\n            and text_shaping_params[\"fragment_direction\"] is not None\n        ):\n            buf.direction = text_shaping_params[\"fragment_direction\"].value\n        if (\n            \"script\" in text_shaping_params\n            and text_shaping_params[\"script\"] is not None\n        ):\n            buf.script = text_shaping_params[\"script\"]\n        if (\n            \"language\" in text_shaping_params\n            and text_shaping_params[\"language\"] is not None\n        ):\n            buf.language = text_shaping_params[\"language\"]\n        hb.shape(self.hbfont, buf, features)\n        return buf.glyph_infos, buf.glyph_positions\n\n    def encode_text(self, text: str) -> str:\n        txt_mapped = \"\"\n        for char in text:\n            uni = ord(char)\n            # Instead of adding the actual character to the stream its code is\n            # mapped to a position in the font's subset\n            mapped_char: Optional[int] = self.subset.pick(uni)\n            if mapped_char is not None:\n                txt_mapped += chr(mapped_char)\n        return f\"({self.escape_text(txt_mapped)}) Tj\"\n\n    def shape_text(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> Sequence[dict[str, Any]]:\n        \"\"\"\n        This method will invoke harfbuzz for text shaping, include the mapping code\n        of the glyphs on the subset and map input characters to the cluster codes\n        \"\"\"\n        if len(text) == 0:\n            return []\n        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(\n            text, font_size_pt, text_shaping_params\n        )\n        text_info = []\n\n        # Find cluster gaps\n        # Ex: text = \"ABCD\"\n        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph\n        # (ligature or substitution) - the glyph should have both unicodes and it should be translated\n        # properly on the CID to GID mapping\n        #\n        def get_cluster_from_text_index(cluster_list: Sequence[int], index: int) -> int:\n            pos = bisect_left(cluster_list, index)\n            if pos == 0:\n                return cluster_list[0]\n            if pos == len(cluster_list) or cluster_list[pos] != index:\n                return cluster_list[pos - 1]\n            return cluster_list[pos]\n\n        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))\n        cluster_mapping: dict[int, list[int]] = {}\n        for i in range(len(text)):\n            cl = get_cluster_from_text_index(cluster_list, i)\n            if cl in cluster_mapping:\n                cluster_mapping[cl].append(i)\n            else:\n                cluster_mapping[cl] = [i]\n\n        for cluster_seq, gi in enumerate(glyph_infos):\n            unicode = []\n            if gi.cluster in cluster_mapping:\n                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]\n                cluster_mapping.pop(gi.cluster)\n\n            gname = self.ttfont.getGlyphName(gi.codepoint)\n            gwidth = round(self.scale * self.ttfont[\"hmtx\"].metrics[gname][0])\n            glyph = self.subset.get_glyph(\n                glyph=gi.codepoint,\n                unicode=tuple(unicode),\n                glyph_name=gname,\n                glyph_width=gwidth,\n            )\n            if glyph is None:\n                continue\n            force_positioning = False\n            if (\n                gwidth != glyph_positions[cluster_seq].x_advance\n                or glyph_positions[cluster_seq].x_offset != 0\n                or glyph_positions[cluster_seq].y_offset != 0\n                or glyph_positions[cluster_seq].y_advance != 0\n            ):\n                force_positioning = True\n            text_info.append(\n                {\n                    \"mapped_char\": self.subset.pick_glyph(glyph),\n                    \"x_advance\": glyph_positions[cluster_seq].x_advance,\n                    \"y_advance\": glyph_positions[cluster_seq].y_advance,\n                    \"x_offset\": glyph_positions[cluster_seq].x_offset,\n                    \"y_offset\": glyph_positions[cluster_seq].y_offset,\n                    \"force_positioning\": force_positioning,\n                }\n            )\n        return text_info",
      "language": "python"
    },
    {
      "code": "class TTFFont:\n    __slots__ = (  # RAM usage optimization\n        \"i\",\n        \"type\",\n        \"name\",\n        \"desc\",\n        \"glyph_ids\",\n        \"_hbfont\",\n        \"sp\",\n        \"ss\",\n        \"up\",\n        \"ut\",\n        \"cw\",\n        \"ttffile\",\n        \"fontkey\",\n        \"emphasis\",\n        \"scale\",\n        \"subset\",\n        \"cmap\",\n        \"ttfont\",\n        \"missing_glyphs\",\n        \"biggest_size_pt\",\n        \"color_font\",\n        \"unicode_range\",\n        \"palette_index\",\n        \"is_compressed\",\n    )\n\n    def __init__(\n        self,\n        fpdf: \"FPDF\",\n        font_file_path: Path,\n        fontkey: str,\n        style: str,\n        unicode_range: Optional[set[int]] = None,\n        axes_dict: Optional[dict[str, float]] = None,\n        palette_index: Optional[int] = None,\n    ):\n        self.i = len(fpdf.fonts) + 1\n        self.type = \"TTF\"\n        self.ttffile = font_file_path\n        self.is_compressed = str(self.ttffile).lower().endswith((\".woff\", \".woff2\"))\n        self._hbfont: Optional[\"HarfBuzzFont\"] = None\n        self.fontkey = fontkey\n        self.biggest_size_pt: float = 0\n\n        # recalcTimestamp=False means that it doesn't modify the \"modified\" timestamp in head table\n        # if we leave recalcTimestamp=True the tests will break every time\n        try:\n            self.ttfont = ttLib.TTFont(\n                self.ttffile, recalcTimestamp=False, fontNumber=0, lazy=True\n            )\n        except (\n            ImportError,\n            RuntimeError,\n        ) as exc:  # pragma: no cover - defensive messaging\n            # If the user passed a WOFF2 file but brotli is not installed, fontTools\n            # raises an ImportError/RuntimeError during parsing. Provide a clearer hint\n            # only for that specific situation. Allow other exceptions (e.g. FileNotFoundError,\n            # OSError, parsing errors) to propagate normally so they aren't masked here.\n            fname_str = str(self.ttffile).lower()\n            if fname_str.endswith(\".woff2\"):\n                raise RuntimeError(\n                    \"Could not open WOFF2 font. WOFF2 support requires an external Brotli \"\n                    \"library (install 'brotli' or 'brotlicffi'). Original error: \"\n                    f\"{exc!s}\"\n                ) from exc\n            raise\n\n        if axes_dict is not None:\n            if \"fvar\" not in self.ttfont:\n                raise AttributeError(f\"{self.ttffile} is not a variable font\")\n\n            instancer.instantiateVariableFont(\n                self.ttfont,\n                axes_dict,\n                inplace=True,\n                static=True,\n            )\n        if self.is_compressed:\n            # Normalize to SFNT output for embedding and HarfBuzz.\n            self.ttfont.flavor = None\n        upem: float = float(self.ttfont[\"head\"].unitsPerEm)\n        self.scale: float = 1000 / upem\n\n        # check if the font is a TrueType and missing a .notdef glyph\n        # if it is missing, provide a fallback glyph\n        if (\n            \"glyf\" in self.ttfont\n            and \".notdef\"\n            not in self.ttfont[\"glyf\"]  # pyright: ignore[reportOperatorIssue]\n        ):\n            LOGGER.warning(\n                (\n                    \"TrueType Font '%s' is missing the '.notdef' glyph. \"\n                    \"Fallback glyph will be provided.\"\n                ),\n                self.fontkey,\n            )\n            # draw a diagonal cross .notdef glyph\n            xMin, xMax, yMin, yMax = (\n                self.ttfont[\"head\"].xMin,\n                self.ttfont[\"head\"].xMax,\n                self.ttfont[\"head\"].yMin,\n                self.ttfont[\"head\"].yMax,\n            )\n            pen = TTGlyphPen(self.ttfont[\"glyf\"])  # pyright: ignore[reportArgumentType]\n            pen.moveTo((xMin, yMin))\n            pen.lineTo((xMax, yMin))\n            pen.lineTo((xMax, yMax))\n            pen.lineTo((xMin, yMax))\n            pen.closePath()\n            pen.moveTo((xMin, yMin))\n            pen.lineTo((xMax, yMax))\n            pen.closePath()\n            pen.moveTo((xMax, yMin))\n            pen.lineTo((xMin, yMax))\n            pen.closePath()\n\n            self.ttfont[\"glyf\"][  # pyright: ignore[reportIndexIssue]\n                \".notdef\"\n            ] = pen.glyph()\n            self.ttfont[\"hmtx\"][\".notdef\"] = (  # pyright: ignore[reportIndexIssue]\n                xMax - xMin,\n                yMax - yMin,\n            )\n\n        default_width: float = round(\n            self.scale * self.ttfont[\"hmtx\"].metrics[\".notdef\"][0]\n        )\n\n        os2_table = self.ttfont[\"OS/2\"]\n        post_table = self.ttfont[\"post\"]\n\n        try:\n            cap_height = os2_table.sCapHeight\n        except AttributeError:\n            cap_height = self.ttfont[\"hhea\"].ascent\n\n        # entry for the PDF font descriptor specifying various characteristics of the font\n        flags = FontDescriptorFlags.SYMBOLIC\n        if post_table.isFixedPitch:\n            flags |= FontDescriptorFlags.FIXED_PITCH\n        if post_table.italicAngle != 0:\n            flags |= FontDescriptorFlags.ITALIC\n        if os2_table.usWeightClass >= 600:\n            flags |= FontDescriptorFlags.FORCE_BOLD\n\n        self.desc = PDFFontDescriptor(\n            ascent=round(self.ttfont[\"hhea\"].ascent * self.scale),\n            descent=round(self.ttfont[\"hhea\"].descent * self.scale),\n            cap_height=round(cap_height * self.scale),\n            flags=flags,\n            font_b_box=(\n                f\"[{self.ttfont['head'].xMin * self.scale:.0f} {self.ttfont['head'].yMin * self.scale:.0f}\"\n                f\" {self.ttfont['head'].xMax * self.scale:.0f} {self.ttfont['head'].yMax * self.scale:.0f}]\"\n            ),\n            italic_angle=int(post_table.italicAngle),\n            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),\n            missing_width=default_width,\n        )\n\n        # a map unicode_char -> char_width\n        self.cw: dict[int, float] = defaultdict(lambda: default_width)\n\n        # fonttools cmap = unicode char to glyph name\n        # saving only the keys we have a tuple with\n        # the unicode characters available on the font\n        self.cmap: dict[int, str] = self.ttfont.getBestCmap()\n        if not self.cmap:\n            raise NotImplementedError(\n                \"Font not supported as it does not have a unicode cmap table - cf. issue #1396\"\n            )\n\n        if unicode_range is not None and len(unicode_range) != 0:\n            self.cmap = {\n                codepoint: glyph_id\n                for codepoint, glyph_id in self.cmap.items()  # pyright: ignore[reportUnknownVariableType]\n                if codepoint in unicode_range\n            }\n\n        # saving a list of glyph ids to char to allow\n        # subset by unicode (regular) and by glyph\n        # (shaped with harfbuz)\n        self.glyph_ids = {}\n\n        for char in self.cmap:  # pyright: ignore[]\n            # take glyph associated to char\n            glyph = self.cmap[char]\n\n            # take width associated to glyph\n            w = self.ttfont[\"hmtx\"].metrics[glyph][0]\n\n            # probably this check could be deleted\n            if w == 65535:\n                w = 0\n\n            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP\n\n            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)\n\n        self.missing_glyphs: list[int] = []\n\n        self.name = re.sub(\"[ ()]\", \"\", self.ttfont[\"name\"].getBestFullName())\n        self.up = round(post_table.underlinePosition * self.scale)\n        self.ut = round(post_table.underlineThickness * self.scale)\n        self.sp = round(os2_table.yStrikeoutPosition * self.scale)\n        self.ss = round(os2_table.yStrikeoutSize * self.scale)\n        self.emphasis = TextEmphasis.coerce(style)\n        self.subset = SubsetMap(self)\n        self.palette_index = palette_index if palette_index is not None else 0\n        self.color_font = (\n            get_color_font_object(fpdf, self, self.palette_index)\n            if fpdf.render_color_fonts\n            else None\n        )\n\n    # pylint: disable=no-member\n    @property\n    def hbfont(self) -> \"HarfBuzzFont\":\n        if not self._hbfont:\n            if self.is_compressed:\n                # HarfBuzz cannot load compressed WOFF/WOFF2 files directly, so we\n                # re-serialize the fontTools TTFont to a raw SFNT byte buffer.\n                buf = BytesIO()\n                self.ttfont.save(buf)\n                buf.seek(0)\n                ttfont_bytes = buf.read()\n\n                # Try to create a HarfBuzz blob from bytes; if not available, write a\n                # temporary file as a last resort.\n                try:\n                    blob = hb.Blob.from_bytes(ttfont_bytes)\n                    face = hb.Face(blob)\n                except (AttributeError, RuntimeError):\n                    import tempfile, os  # pylint: disable=import-outside-toplevel\n\n                    tmp_name = None\n                    try:\n                        with tempfile.NamedTemporaryFile(\n                            suffix=\".ttf\", delete=False\n                        ) as tmp:\n                            tmp_name = tmp.name\n                            tmp.write(ttfont_bytes)\n                            tmp.flush()\n                        face = hb.Face(hb.Blob.from_file_path(tmp_name))\n                    finally:\n                        if tmp_name:\n                            try:\n                                os.unlink(tmp_name)\n                            except OSError as cleanup_error:\n                                # Log warning about failed cleanup - orphaned temp file may cause disk issues\n                                LOGGER.warning(\n                                    \"Failed to clean up temporary font file '%s': %s. This may leave an orphaned file on disk.\",\n                                    tmp_name,\n                                    cleanup_error,\n                                )\n\n                self._hbfont = HarfBuzzFont(face)\n            else:\n                # For regular TTF/OTF fonts, load directly from file path (faster)\n                self._hbfont = HarfBuzzFont(\n                    hb.Face(hb.Blob.from_file_path(self.ttffile))\n                )\n\n        return self._hbfont\n\n    def __repr__(self) -> str:\n        return f\"TTFFont(i={self.i}, fontkey={self.fontkey})\"\n\n    def __deepcopy__(self: \"TTFFont\", memo: dict[int, Any]) -> \"TTFFont\":\n        \"\"\"\n        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes\n        but instead share references to immutable objects\n        between the original FPDF instance and the FPDFRecorder instances\n        to avoid performances issues as spotted in issue #1444.\n        \"\"\"\n        copy = TTFFont.__new__(TTFFont)\n        # Immutable attributes:\n        copy.i = self.i\n        copy.type = \"TTF\"\n        copy.ttffile = self.ttffile\n        copy.fontkey = self.fontkey\n        copy.scale = self.scale\n        copy.name = self.name\n        copy.up = self.up\n        copy.ut = self.ut\n        copy.sp = self.sp\n        copy.ss = self.ss\n        copy.emphasis = self.emphasis\n        copy.is_compressed = self.is_compressed\n        # Attributes shared, to improve FPDFRecorder performances:\n        copy.ttfont = self.ttfont\n        copy.cmap = self.cmap\n        copy.desc = self.desc\n        # Attributes deepcopied:\n        copy.cw = deepcopy(self.cw, memo)\n        copy.glyph_ids = deepcopy(self.glyph_ids, memo)\n        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)\n        copy.subset = deepcopy(self.subset, memo)\n        copy.biggest_size_pt = self.biggest_size_pt\n        copy._hbfont = self._hbfont\n        copy.color_font = self.color_font\n        copy.palette_index = self.palette_index\n        return copy\n\n    def close(self) -> None:\n        self.ttfont.close()\n        self._hbfont = None\n\n    def escape_text(self, text: str) -> str:\n        if self.color_font:\n            encoded = text.encode(\"latin-1\", errors=\"replace\")\n            return escape_parens(encoded.decode(\"latin-1\", errors=\"ignore\"))\n        return escape_parens(text.encode(\"utf-16-be\").decode(\"latin-1\"))\n\n    def get_text_width(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[int, float]:\n        if font_size_pt > self.biggest_size_pt:\n            self.biggest_size_pt = font_size_pt\n        if text_shaping_params:\n            return self.shaped_text_width(text, font_size_pt, text_shaping_params)\n        return (len(text), sum(self.cw[ord(c)] for c in text) * font_size_pt * 0.001)\n\n    def shaped_text_width(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[int, float]:\n        \"\"\"\n        When texts are shaped, the length of a string is not always the sum of all individual character widths\n        This method will invoke harfbuzz to perform the text shaping and return the sum of \"x_advance\"\n        and \"x_offset\" for each glyph. This method works for \"left to right\" or \"right to left\" texts.\n        \"\"\"\n        _, glyph_positions = self.perform_harfbuzz_shaping(\n            text, font_size_pt, text_shaping_params\n        )\n\n        # If there is nothing to render (harfbuzz returns None), we return 0 text width\n        if glyph_positions is None:\n            return (0, 0)\n\n        text_width: float = 0\n        for pos in glyph_positions:\n            text_width += (\n                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001\n            )\n        return (len(glyph_positions), text_width)\n\n    # Disabling this check - looks like cython confuses pylint:\n    # pylint: disable=no-member\n    def perform_harfbuzz_shaping(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[Sequence[\"HBGlyphInfo\"], Sequence[\"HBGlyphPosition\"]]:\n        \"\"\"\n        This method invokes Harfbuzz to perform text shaping of the input string\n        \"\"\"\n        self.hbfont.ptem = font_size_pt\n        if TYPE_CHECKING:\n            buf: HBBuffer\n        buf = hb.Buffer()\n        buf.cluster_level = 1\n        buf.add_str(\"\".join(text))\n        buf.guess_segment_properties()\n        features = (\n            text_shaping_params[\"features\"] if text_shaping_params is not None else {}\n        )\n        if text_shaping_params is None:\n            text_shaping_params = {}\n        if (\n            \"fragment_direction\" in text_shaping_params\n            and text_shaping_params[\"fragment_direction\"] is not None\n        ):\n            buf.direction = text_shaping_params[\"fragment_direction\"].value\n        if (\n            \"script\" in text_shaping_params\n            and text_shaping_params[\"script\"] is not None\n        ):\n            buf.script = text_shaping_params[\"script\"]\n        if (\n            \"language\" in text_shaping_params\n            and text_shaping_params[\"language\"] is not None\n        ):\n            buf.language = text_shaping_params[\"language\"]\n        hb.shape(self.hbfont, buf, features)\n        return buf.glyph_infos, buf.glyph_positions\n\n    def encode_text(self, text: str) -> str:\n        txt_mapped = \"\"\n        for char in text:\n            uni = ord(char)\n            # Instead of adding the actual character to the stream its code is\n            # mapped to a position in the font's subset\n            mapped_char: Optional[int] = self.subset.pick(uni)\n            if mapped_char is not None:\n                txt_mapped += chr(mapped_char)\n        return f\"({self.escape_text(txt_mapped)}) Tj\"\n\n    def shape_text(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> Sequence[dict[str, Any]]:\n        \"\"\"\n        This method will invoke harfbuzz for text shaping, include the mapping code\n        of the glyphs on the subset and map input characters to the cluster codes\n        \"\"\"\n        if len(text) == 0:\n            return []\n        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(\n            text, font_size_pt, text_shaping_params\n        )\n        text_info = []\n\n        # Find cluster gaps\n        # Ex: text = \"ABCD\"\n        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph\n        # (ligature or substitution) - the glyph should have both unicodes and it should be translated\n        # properly on the CID to GID mapping\n        #\n        def get_cluster_from_text_index(cluster_list: Sequence[int], index: int) -> int:\n            pos = bisect_left(cluster_list, index)\n            if pos == 0:\n                return cluster_list[0]\n            if pos == len(cluster_list) or cluster_list[pos] != index:\n                return cluster_list[pos - 1]\n            return cluster_list[pos]\n\n        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))\n        cluster_mapping: dict[int, list[int]] = {}\n        for i in range(len(text)):\n            cl = get_cluster_from_text_index(cluster_list, i)\n            if cl in cluster_mapping:\n                cluster_mapping[cl].append(i)\n            else:\n                cluster_mapping[cl] = [i]\n\n        for cluster_seq, gi in enumerate(glyph_infos):\n            unicode = []\n            if gi.cluster in cluster_mapping:\n                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]\n                cluster_mapping.pop(gi.cluster)\n\n            gname = self.ttfont.getGlyphName(gi.codepoint)\n            gwidth = round(self.scale * self.ttfont[\"hmtx\"].metrics[gname][0])\n            glyph = self.subset.get_glyph(\n                glyph=gi.codepoint,\n                unicode=tuple(unicode),\n                glyph_name=gname,\n                glyph_width=gwidth,\n            )\n            if glyph is None:\n                continue\n            force_positioning = False\n            if (\n                gwidth != glyph_positions[cluster_seq].x_advance\n                or glyph_positions[cluster_seq].x_offset != 0\n                or glyph_positions[cluster_seq].y_offset != 0\n                or glyph_positions[cluster_seq].y_advance != 0\n            ):\n                force_positioning = True\n            text_info.append(\n                {\n                    \"mapped_char\": self.subset.pick_glyph(glyph),\n                    \"x_advance\": glyph_positions[cluster_seq].x_advance,\n                    \"y_advance\": glyph_positions[cluster_seq].y_advance,\n                    \"x_offset\": glyph_positions[cluster_seq].x_offset,\n                    \"y_offset\": glyph_positions[cluster_seq].y_offset,\n                    \"force_positioning\": force_positioning,\n                }\n            )\n        return text_info",
      "language": "python"
    },
    {
      "code": "class TTFFont:\n    __slots__ = (  # RAM usage optimization\n        \"i\",\n        \"type\",\n        \"name\",\n        \"desc\",\n        \"glyph_ids\",\n        \"_hbfont\",\n        \"sp\",\n        \"ss\",\n        \"up\",\n        \"ut\",\n        \"cw\",\n        \"ttffile\",\n        \"fontkey\",\n        \"emphasis\",\n        \"scale\",\n        \"subset\",\n        \"cmap\",\n        \"ttfont\",\n        \"missing_glyphs\",\n        \"biggest_size_pt\",\n        \"color_font\",\n        \"unicode_range\",\n        \"palette_index\",\n        \"is_compressed\",\n    )\n\n    def __init__(\n        self,\n        fpdf: \"FPDF\",\n        font_file_path: Path,\n        fontkey: str,\n        style: str,\n        unicode_range: Optional[set[int]] = None,\n        axes_dict: Optional[dict[str, float]] = None,\n        palette_index: Optional[int] = None,\n    ):\n        self.i = len(fpdf.fonts) + 1\n        self.type = \"TTF\"\n        self.ttffile = font_file_path\n        self.is_compressed = str(self.ttffile).lower().endswith((\".woff\", \".woff2\"))\n        self._hbfont: Optional[\"HarfBuzzFont\"] = None\n        self.fontkey = fontkey\n        self.biggest_size_pt: float = 0\n\n        # recalcTimestamp=False means that it doesn't modify the \"modified\" timestamp in head table\n        # if we leave recalcTimestamp=True the tests will break every time\n        try:\n            self.ttfont = ttLib.TTFont(\n                self.ttffile, recalcTimestamp=False, fontNumber=0, lazy=True\n            )\n        except (\n            ImportError,\n            RuntimeError,\n        ) as exc:  # pragma: no cover - defensive messaging\n            # If the user passed a WOFF2 file but brotli is not installed, fontTools\n            # raises an ImportError/RuntimeError during parsing. Provide a clearer hint\n            # only for that specific situation. Allow other exceptions (e.g. FileNotFoundError,\n            # OSError, parsing errors) to propagate normally so they aren't masked here.\n            fname_str = str(self.ttffile).lower()\n            if fname_str.endswith(\".woff2\"):\n                raise RuntimeError(\n                    \"Could not open WOFF2 font. WOFF2 support requires an external Brotli \"\n                    \"library (install 'brotli' or 'brotlicffi'). Original error: \"\n                    f\"{exc!s}\"\n                ) from exc\n            raise\n\n        if axes_dict is not None:\n            if \"fvar\" not in self.ttfont:\n                raise AttributeError(f\"{self.ttffile} is not a variable font\")\n\n            instancer.instantiateVariableFont(\n                self.ttfont,\n                axes_dict,\n                inplace=True,\n                static=True,\n            )\n        if self.is_compressed:\n            # Normalize to SFNT output for embedding and HarfBuzz.\n            self.ttfont.flavor = None\n        upem: float = float(self.ttfont[\"head\"].unitsPerEm)\n        self.scale: float = 1000 / upem\n\n        # check if the font is a TrueType and missing a .notdef glyph\n        # if it is missing, provide a fallback glyph\n        if (\n            \"glyf\" in self.ttfont\n            and \".notdef\"\n            not in self.ttfont[\"glyf\"]  # pyright: ignore[reportOperatorIssue]\n        ):\n            LOGGER.warning(\n                (\n                    \"TrueType Font '%s' is missing the '.notdef' glyph. \"\n                    \"Fallback glyph will be provided.\"\n                ),\n                self.fontkey,\n            )\n            # draw a diagonal cross .notdef glyph\n            xMin, xMax, yMin, yMax = (\n                self.ttfont[\"head\"].xMin,\n                self.ttfont[\"head\"].xMax,\n                self.ttfont[\"head\"].yMin,\n                self.ttfont[\"head\"].yMax,\n            )\n            pen = TTGlyphPen(self.ttfont[\"glyf\"])  # pyright: ignore[reportArgumentType]\n            pen.moveTo((xMin, yMin))\n            pen.lineTo((xMax, yMin))\n            pen.lineTo((xMax, yMax))\n            pen.lineTo((xMin, yMax))\n            pen.closePath()\n            pen.moveTo((xMin, yMin))\n            pen.lineTo((xMax, yMax))\n            pen.closePath()\n            pen.moveTo((xMax, yMin))\n            pen.lineTo((xMin, yMax))\n            pen.closePath()\n\n            self.ttfont[\"glyf\"][  # pyright: ignore[reportIndexIssue]\n                \".notdef\"\n            ] = pen.glyph()\n            self.ttfont[\"hmtx\"][\".notdef\"] = (  # pyright: ignore[reportIndexIssue]\n                xMax - xMin,\n                yMax - yMin,\n            )\n\n        default_width: float = round(\n            self.scale * self.ttfont[\"hmtx\"].metrics[\".notdef\"][0]\n        )\n\n        os2_table = self.ttfont[\"OS/2\"]\n        post_table = self.ttfont[\"post\"]\n\n        try:\n            cap_height = os2_table.sCapHeight\n        except AttributeError:\n            cap_height = self.ttfont[\"hhea\"].ascent\n\n        # entry for the PDF font descriptor specifying various characteristics of the font\n        flags = FontDescriptorFlags.SYMBOLIC\n        if post_table.isFixedPitch:\n            flags |= FontDescriptorFlags.FIXED_PITCH\n        if post_table.italicAngle != 0:\n            flags |= FontDescriptorFlags.ITALIC\n        if os2_table.usWeightClass >= 600:\n            flags |= FontDescriptorFlags.FORCE_BOLD\n\n        self.desc = PDFFontDescriptor(\n            ascent=round(self.ttfont[\"hhea\"].ascent * self.scale),\n            descent=round(self.ttfont[\"hhea\"].descent * self.scale),\n            cap_height=round(cap_height * self.scale),\n            flags=flags,\n            font_b_box=(\n                f\"[{self.ttfont['head'].xMin * self.scale:.0f} {self.ttfont['head'].yMin * self.scale:.0f}\"\n                f\" {self.ttfont['head'].xMax * self.scale:.0f} {self.ttfont['head'].yMax * self.scale:.0f}]\"\n            ),\n            italic_angle=int(post_table.italicAngle),\n            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),\n            missing_width=default_width,\n        )\n\n        # a map unicode_char -> char_width\n        self.cw: dict[int, float] = defaultdict(lambda: default_width)\n\n        # fonttools cmap = unicode char to glyph name\n        # saving only the keys we have a tuple with\n        # the unicode characters available on the font\n        self.cmap: dict[int, str] = self.ttfont.getBestCmap()\n        if not self.cmap:\n            raise NotImplementedError(\n                \"Font not supported as it does not have a unicode cmap table - cf. issue #1396\"\n            )\n\n        if unicode_range is not None and len(unicode_range) != 0:\n            self.cmap = {\n                codepoint: glyph_id\n                for codepoint, glyph_id in self.cmap.items()  # pyright: ignore[reportUnknownVariableType]\n                if codepoint in unicode_range\n            }\n\n        # saving a list of glyph ids to char to allow\n        # subset by unicode (regular) and by glyph\n        # (shaped with harfbuz)\n        self.glyph_ids = {}\n\n        for char in self.cmap:  # pyright: ignore[]\n            # take glyph associated to char\n            glyph = self.cmap[char]\n\n            # take width associated to glyph\n            w = self.ttfont[\"hmtx\"].metrics[glyph][0]\n\n            # probably this check could be deleted\n            if w == 65535:\n                w = 0\n\n            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP\n\n            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)\n\n        self.missing_glyphs: list[int] = []\n\n        self.name = re.sub(\"[ ()]\", \"\", self.ttfont[\"name\"].getBestFullName())\n        self.up = round(post_table.underlinePosition * self.scale)\n        self.ut = round(post_table.underlineThickness * self.scale)\n        self.sp = round(os2_table.yStrikeoutPosition * self.scale)\n        self.ss = round(os2_table.yStrikeoutSize * self.scale)\n        self.emphasis = TextEmphasis.coerce(style)\n        self.subset = SubsetMap(self)\n        self.palette_index = palette_index if palette_index is not None else 0\n        self.color_font = (\n            get_color_font_object(fpdf, self, self.palette_index)\n            if fpdf.render_color_fonts\n            else None\n        )\n\n    # pylint: disable=no-member\n    @property\n    def hbfont(self) -> \"HarfBuzzFont\":\n        if not self._hbfont:\n            if self.is_compressed:\n                # HarfBuzz cannot load compressed WOFF/WOFF2 files directly, so we\n                # re-serialize the fontTools TTFont to a raw SFNT byte buffer.\n                buf = BytesIO()\n                self.ttfont.save(buf)\n                buf.seek(0)\n                ttfont_bytes = buf.read()\n\n                # Try to create a HarfBuzz blob from bytes; if not available, write a\n                # temporary file as a last resort.\n                try:\n                    blob = hb.Blob.from_bytes(ttfont_bytes)\n                    face = hb.Face(blob)\n                except (AttributeError, RuntimeError):\n                    import tempfile, os  # pylint: disable=import-outside-toplevel\n\n                    tmp_name = None\n                    try:\n                        with tempfile.NamedTemporaryFile(\n                            suffix=\".ttf\", delete=False\n                        ) as tmp:\n                            tmp_name = tmp.name\n                            tmp.write(ttfont_bytes)\n                            tmp.flush()\n                        face = hb.Face(hb.Blob.from_file_path(tmp_name))\n                    finally:\n                        if tmp_name:\n                            try:\n                                os.unlink(tmp_name)\n                            except OSError as cleanup_error:\n                                # Log warning about failed cleanup - orphaned temp file may cause disk issues\n                                LOGGER.warning(\n                                    \"Failed to clean up temporary font file '%s': %s. This may leave an orphaned file on disk.\",\n                                    tmp_name,\n                                    cleanup_error,\n                                )\n\n                self._hbfont = HarfBuzzFont(face)\n            else:\n                # For regular TTF/OTF fonts, load directly from file path (faster)\n                self._hbfont = HarfBuzzFont(\n                    hb.Face(hb.Blob.from_file_path(self.ttffile))\n                )\n\n        return self._hbfont\n\n    def __repr__(self) -> str:\n        return f\"TTFFont(i={self.i}, fontkey={self.fontkey})\"\n\n    def __deepcopy__(self: \"TTFFont\", memo: dict[int, Any]) -> \"TTFFont\":\n        \"\"\"\n        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes\n        but instead share references to immutable objects\n        between the original FPDF instance and the FPDFRecorder instances\n        to avoid performances issues as spotted in issue #1444.\n        \"\"\"\n        copy = TTFFont.__new__(TTFFont)\n        # Immutable attributes:\n        copy.i = self.i\n        copy.type = \"TTF\"\n        copy.ttffile = self.ttffile\n        copy.fontkey = self.fontkey\n        copy.scale = self.scale\n        copy.name = self.name\n        copy.up = self.up\n        copy.ut = self.ut\n        copy.sp = self.sp\n        copy.ss = self.ss\n        copy.emphasis = self.emphasis\n        copy.is_compressed = self.is_compressed\n        # Attributes shared, to improve FPDFRecorder performances:\n        copy.ttfont = self.ttfont\n        copy.cmap = self.cmap\n        copy.desc = self.desc\n        # Attributes deepcopied:\n        copy.cw = deepcopy(self.cw, memo)\n        copy.glyph_ids = deepcopy(self.glyph_ids, memo)\n        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)\n        copy.subset = deepcopy(self.subset, memo)\n        copy.biggest_size_pt = self.biggest_size_pt\n        copy._hbfont = self._hbfont\n        copy.color_font = self.color_font\n        copy.palette_index = self.palette_index\n        return copy\n\n    def close(self) -> None:\n        self.ttfont.close()\n        self._hbfont = None\n\n    def escape_text(self, text: str) -> str:\n        if self.color_font:\n            encoded = text.encode(\"latin-1\", errors=\"replace\")\n            return escape_parens(encoded.decode(\"latin-1\", errors=\"ignore\"))\n        return escape_parens(text.encode(\"utf-16-be\").decode(\"latin-1\"))\n\n    def get_text_width(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[int, float]:\n        if font_size_pt > self.biggest_size_pt:\n            self.biggest_size_pt = font_size_pt\n        if text_shaping_params:\n            return self.shaped_text_width(text, font_size_pt, text_shaping_params)\n        return (len(text), sum(self.cw[ord(c)] for c in text) * font_size_pt * 0.001)\n\n    def shaped_text_width(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[int, float]:\n        \"\"\"\n        When texts are shaped, the length of a string is not always the sum of all individual character widths\n        This method will invoke harfbuzz to perform the text shaping and return the sum of \"x_advance\"\n        and \"x_offset\" for each glyph. This method works for \"left to right\" or \"right to left\" texts.\n        \"\"\"\n        _, glyph_positions = self.perform_harfbuzz_shaping(\n            text, font_size_pt, text_shaping_params\n        )\n\n        # If there is nothing to render (harfbuzz returns None), we return 0 text width\n        if glyph_positions is None:\n            return (0, 0)\n\n        text_width: float = 0\n        for pos in glyph_positions:\n            text_width += (\n                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001\n            )\n        return (len(glyph_positions), text_width)\n\n    # Disabling this check - looks like cython confuses pylint:\n    # pylint: disable=no-member\n    def perform_harfbuzz_shaping(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[Sequence[\"HBGlyphInfo\"], Sequence[\"HBGlyphPosition\"]]:\n        \"\"\"\n        This method invokes Harfbuzz to perform text shaping of the input string\n        \"\"\"\n        self.hbfont.ptem = font_size_pt\n        if TYPE_CHECKING:\n            buf: HBBuffer\n        buf = hb.Buffer()\n        buf.cluster_level = 1\n        buf.add_str(\"\".join(text))\n        buf.guess_segment_properties()\n        features = (\n            text_shaping_params[\"features\"] if text_shaping_params is not None else {}\n        )\n        if text_shaping_params is None:\n            text_shaping_params = {}\n        if (\n            \"fragment_direction\" in text_shaping_params\n            and text_shaping_params[\"fragment_direction\"] is not None\n        ):\n            buf.direction = text_shaping_params[\"fragment_direction\"].value\n        if (\n            \"script\" in text_shaping_params\n            and text_shaping_params[\"script\"] is not None\n        ):\n            buf.script = text_shaping_params[\"script\"]\n        if (\n            \"language\" in text_shaping_params\n            and text_shaping_params[\"language\"] is not None\n        ):\n            buf.language = text_shaping_params[\"language\"]\n        hb.shape(self.hbfont, buf, features)\n        return buf.glyph_infos, buf.glyph_positions\n\n    def encode_text(self, text: str) -> str:\n        txt_mapped = \"\"\n        for char in text:\n            uni = ord(char)\n            # Instead of adding the actual character to the stream its code is\n            # mapped to a position in the font's subset\n            mapped_char: Optional[int] = self.subset.pick(uni)\n            if mapped_char is not None:\n                txt_mapped += chr(mapped_char)\n        return f\"({self.escape_text(txt_mapped)}) Tj\"\n\n    def shape_text(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> Sequence[dict[str, Any]]:\n        \"\"\"\n        This method will invoke harfbuzz for text shaping, include the mapping code\n        of the glyphs on the subset and map input characters to the cluster codes\n        \"\"\"\n        if len(text) == 0:\n            return []\n        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(\n            text, font_size_pt, text_shaping_params\n        )\n        text_info = []\n\n        # Find cluster gaps\n        # Ex: text = \"ABCD\"\n        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph\n        # (ligature or substitution) - the glyph should have both unicodes and it should be translated\n        # properly on the CID to GID mapping\n        #\n        def get_cluster_from_text_index(cluster_list: Sequence[int], index: int) -> int:\n            pos = bisect_left(cluster_list, index)\n            if pos == 0:\n                return cluster_list[0]\n            if pos == len(cluster_list) or cluster_list[pos] != index:\n                return cluster_list[pos - 1]\n            return cluster_list[pos]\n\n        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))\n        cluster_mapping: dict[int, list[int]] = {}\n        for i in range(len(text)):\n            cl = get_cluster_from_text_index(cluster_list, i)\n            if cl in cluster_mapping:\n                cluster_mapping[cl].append(i)\n            else:\n                cluster_mapping[cl] = [i]\n\n        for cluster_seq, gi in enumerate(glyph_infos):\n            unicode = []\n            if gi.cluster in cluster_mapping:\n                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]\n                cluster_mapping.pop(gi.cluster)\n\n            gname = self.ttfont.getGlyphName(gi.codepoint)\n            gwidth = round(self.scale * self.ttfont[\"hmtx\"].metrics[gname][0])\n            glyph = self.subset.get_glyph(\n                glyph=gi.codepoint,\n                unicode=tuple(unicode),\n                glyph_name=gname,\n                glyph_width=gwidth,\n            )\n            if glyph is None:\n                continue\n            force_positioning = False\n            if (\n                gwidth != glyph_positions[cluster_seq].x_advance\n                or glyph_positions[cluster_seq].x_offset != 0\n                or glyph_positions[cluster_seq].y_offset != 0\n                or glyph_positions[cluster_seq].y_advance != 0\n            ):\n                force_positioning = True\n            text_info.append(\n                {\n                    \"mapped_char\": self.subset.pick_glyph(glyph),\n                    \"x_advance\": glyph_positions[cluster_seq].x_advance,\n                    \"y_advance\": glyph_positions[cluster_seq].y_advance,\n                    \"x_offset\": glyph_positions[cluster_seq].x_offset,\n                    \"y_offset\": glyph_positions[cluster_seq].y_offset,\n                    \"force_positioning\": force_positioning,\n                }\n            )\n        return text_info",
      "language": "python"
    },
    {
      "code": "class TTFFont:\n    __slots__ = (  # RAM usage optimization\n        \"i\",\n        \"type\",\n        \"name\",\n        \"desc\",\n        \"glyph_ids\",\n        \"_hbfont\",\n        \"sp\",\n        \"ss\",\n        \"up\",\n        \"ut\",\n        \"cw\",\n        \"ttffile\",\n        \"fontkey\",\n        \"emphasis\",\n        \"scale\",\n        \"subset\",\n        \"cmap\",\n        \"ttfont\",\n        \"missing_glyphs\",\n        \"biggest_size_pt\",\n        \"color_font\",\n        \"unicode_range\",\n        \"palette_index\",\n        \"is_compressed\",\n    )\n\n    def __init__(\n        self,\n        fpdf: \"FPDF\",\n        font_file_path: Path,\n        fontkey: str,\n        style: str,\n        unicode_range: Optional[set[int]] = None,\n        axes_dict: Optional[dict[str, float]] = None,\n        palette_index: Optional[int] = None,\n    ):\n        self.i = len(fpdf.fonts) + 1\n        self.type = \"TTF\"\n        self.ttffile = font_file_path\n        self.is_compressed = str(self.ttffile).lower().endswith((\".woff\", \".woff2\"))\n        self._hbfont: Optional[\"HarfBuzzFont\"] = None\n        self.fontkey = fontkey\n        self.biggest_size_pt: float = 0\n\n        # recalcTimestamp=False means that it doesn't modify the \"modified\" timestamp in head table\n        # if we leave recalcTimestamp=True the tests will break every time\n        try:\n            self.ttfont = ttLib.TTFont(\n                self.ttffile, recalcTimestamp=False, fontNumber=0, lazy=True\n            )\n        except (\n            ImportError,\n            RuntimeError,\n        ) as exc:  # pragma: no cover - defensive messaging\n            # If the user passed a WOFF2 file but brotli is not installed, fontTools\n            # raises an ImportError/RuntimeError during parsing. Provide a clearer hint\n            # only for that specific situation. Allow other exceptions (e.g. FileNotFoundError,\n            # OSError, parsing errors) to propagate normally so they aren't masked here.\n            fname_str = str(self.ttffile).lower()\n            if fname_str.endswith(\".woff2\"):\n                raise RuntimeError(\n                    \"Could not open WOFF2 font. WOFF2 support requires an external Brotli \"\n                    \"library (install 'brotli' or 'brotlicffi'). Original error: \"\n                    f\"{exc!s}\"\n                ) from exc\n            raise\n\n        if axes_dict is not None:\n            if \"fvar\" not in self.ttfont:\n                raise AttributeError(f\"{self.ttffile} is not a variable font\")\n\n            instancer.instantiateVariableFont(\n                self.ttfont,\n                axes_dict,\n                inplace=True,\n                static=True,\n            )\n        if self.is_compressed:\n            # Normalize to SFNT output for embedding and HarfBuzz.\n            self.ttfont.flavor = None\n        upem: float = float(self.ttfont[\"head\"].unitsPerEm)\n        self.scale: float = 1000 / upem\n\n        # check if the font is a TrueType and missing a .notdef glyph\n        # if it is missing, provide a fallback glyph\n        if (\n            \"glyf\" in self.ttfont\n            and \".notdef\"\n            not in self.ttfont[\"glyf\"]  # pyright: ignore[reportOperatorIssue]\n        ):\n            LOGGER.warning(\n                (\n                    \"TrueType Font '%s' is missing the '.notdef' glyph. \"\n                    \"Fallback glyph will be provided.\"\n                ),\n                self.fontkey,\n            )\n            # draw a diagonal cross .notdef glyph\n            xMin, xMax, yMin, yMax = (\n                self.ttfont[\"head\"].xMin,\n                self.ttfont[\"head\"].xMax,\n                self.ttfont[\"head\"].yMin,\n                self.ttfont[\"head\"].yMax,\n            )\n            pen = TTGlyphPen(self.ttfont[\"glyf\"])  # pyright: ignore[reportArgumentType]\n            pen.moveTo((xMin, yMin))\n            pen.lineTo((xMax, yMin))\n            pen.lineTo((xMax, yMax))\n            pen.lineTo((xMin, yMax))\n            pen.closePath()\n            pen.moveTo((xMin, yMin))\n            pen.lineTo((xMax, yMax))\n            pen.closePath()\n            pen.moveTo((xMax, yMin))\n            pen.lineTo((xMin, yMax))\n            pen.closePath()\n\n            self.ttfont[\"glyf\"][  # pyright: ignore[reportIndexIssue]\n                \".notdef\"\n            ] = pen.glyph()\n            self.ttfont[\"hmtx\"][\".notdef\"] = (  # pyright: ignore[reportIndexIssue]\n                xMax - xMin,\n                yMax - yMin,\n            )\n\n        default_width: float = round(\n            self.scale * self.ttfont[\"hmtx\"].metrics[\".notdef\"][0]\n        )\n\n        os2_table = self.ttfont[\"OS/2\"]\n        post_table = self.ttfont[\"post\"]\n\n        try:\n            cap_height = os2_table.sCapHeight\n        except AttributeError:\n            cap_height = self.ttfont[\"hhea\"].ascent\n\n        # entry for the PDF font descriptor specifying various characteristics of the font\n        flags = FontDescriptorFlags.SYMBOLIC\n        if post_table.isFixedPitch:\n            flags |= FontDescriptorFlags.FIXED_PITCH\n        if post_table.italicAngle != 0:\n            flags |= FontDescriptorFlags.ITALIC\n        if os2_table.usWeightClass >= 600:\n            flags |= FontDescriptorFlags.FORCE_BOLD\n\n        self.desc = PDFFontDescriptor(\n            ascent=round(self.ttfont[\"hhea\"].ascent * self.scale),\n            descent=round(self.ttfont[\"hhea\"].descent * self.scale),\n            cap_height=round(cap_height * self.scale),\n            flags=flags,\n            font_b_box=(\n                f\"[{self.ttfont['head'].xMin * self.scale:.0f} {self.ttfont['head'].yMin * self.scale:.0f}\"\n                f\" {self.ttfont['head'].xMax * self.scale:.0f} {self.ttfont['head'].yMax * self.scale:.0f}]\"\n            ),\n            italic_angle=int(post_table.italicAngle),\n            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),\n            missing_width=default_width,\n        )\n\n        # a map unicode_char -> char_width\n        self.cw: dict[int, float] = defaultdict(lambda: default_width)\n\n        # fonttools cmap = unicode char to glyph name\n        # saving only the keys we have a tuple with\n        # the unicode characters available on the font\n        self.cmap: dict[int, str] = self.ttfont.getBestCmap()\n        if not self.cmap:\n            raise NotImplementedError(\n                \"Font not supported as it does not have a unicode cmap table - cf. issue #1396\"\n            )\n\n        if unicode_range is not None and len(unicode_range) != 0:\n            self.cmap = {\n                codepoint: glyph_id\n                for codepoint, glyph_id in self.cmap.items()  # pyright: ignore[reportUnknownVariableType]\n                if codepoint in unicode_range\n            }\n\n        # saving a list of glyph ids to char to allow\n        # subset by unicode (regular) and by glyph\n        # (shaped with harfbuz)\n        self.glyph_ids = {}\n\n        for char in self.cmap:  # pyright: ignore[]\n            # take glyph associated to char\n            glyph = self.cmap[char]\n\n            # take width associated to glyph\n            w = self.ttfont[\"hmtx\"].metrics[glyph][0]\n\n            # probably this check could be deleted\n            if w == 65535:\n                w = 0\n\n            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP\n\n            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)\n\n        self.missing_glyphs: list[int] = []\n\n        self.name = re.sub(\"[ ()]\", \"\", self.ttfont[\"name\"].getBestFullName())\n        self.up = round(post_table.underlinePosition * self.scale)\n        self.ut = round(post_table.underlineThickness * self.scale)\n        self.sp = round(os2_table.yStrikeoutPosition * self.scale)\n        self.ss = round(os2_table.yStrikeoutSize * self.scale)\n        self.emphasis = TextEmphasis.coerce(style)\n        self.subset = SubsetMap(self)\n        self.palette_index = palette_index if palette_index is not None else 0\n        self.color_font = (\n            get_color_font_object(fpdf, self, self.palette_index)\n            if fpdf.render_color_fonts\n            else None\n        )\n\n    # pylint: disable=no-member\n    @property\n    def hbfont(self) -> \"HarfBuzzFont\":\n        if not self._hbfont:\n            if self.is_compressed:\n                # HarfBuzz cannot load compressed WOFF/WOFF2 files directly, so we\n                # re-serialize the fontTools TTFont to a raw SFNT byte buffer.\n                buf = BytesIO()\n                self.ttfont.save(buf)\n                buf.seek(0)\n                ttfont_bytes = buf.read()\n\n                # Try to create a HarfBuzz blob from bytes; if not available, write a\n                # temporary file as a last resort.\n                try:\n                    blob = hb.Blob.from_bytes(ttfont_bytes)\n                    face = hb.Face(blob)\n                except (AttributeError, RuntimeError):\n                    import tempfile, os  # pylint: disable=import-outside-toplevel\n\n                    tmp_name = None\n                    try:\n                        with tempfile.NamedTemporaryFile(\n                            suffix=\".ttf\", delete=False\n                        ) as tmp:\n                            tmp_name = tmp.name\n                            tmp.write(ttfont_bytes)\n                            tmp.flush()\n                        face = hb.Face(hb.Blob.from_file_path(tmp_name))\n                    finally:\n                        if tmp_name:\n                            try:\n                                os.unlink(tmp_name)\n                            except OSError as cleanup_error:\n                                # Log warning about failed cleanup - orphaned temp file may cause disk issues\n                                LOGGER.warning(\n                                    \"Failed to clean up temporary font file '%s': %s. This may leave an orphaned file on disk.\",\n                                    tmp_name,\n                                    cleanup_error,\n                                )\n\n                self._hbfont = HarfBuzzFont(face)\n            else:\n                # For regular TTF/OTF fonts, load directly from file path (faster)\n                self._hbfont = HarfBuzzFont(\n                    hb.Face(hb.Blob.from_file_path(self.ttffile))\n                )\n\n        return self._hbfont\n\n    def __repr__(self) -> str:\n        return f\"TTFFont(i={self.i}, fontkey={self.fontkey})\"\n\n    def __deepcopy__(self: \"TTFFont\", memo: dict[int, Any]) -> \"TTFFont\":\n        \"\"\"\n        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes\n        but instead share references to immutable objects\n        between the original FPDF instance and the FPDFRecorder instances\n        to avoid performances issues as spotted in issue #1444.\n        \"\"\"\n        copy = TTFFont.__new__(TTFFont)\n        # Immutable attributes:\n        copy.i = self.i\n        copy.type = \"TTF\"\n        copy.ttffile = self.ttffile\n        copy.fontkey = self.fontkey\n        copy.scale = self.scale\n        copy.name = self.name\n        copy.up = self.up\n        copy.ut = self.ut\n        copy.sp = self.sp\n        copy.ss = self.ss\n        copy.emphasis = self.emphasis\n        copy.is_compressed = self.is_compressed\n        # Attributes shared, to improve FPDFRecorder performances:\n        copy.ttfont = self.ttfont\n        copy.cmap = self.cmap\n        copy.desc = self.desc\n        # Attributes deepcopied:\n        copy.cw = deepcopy(self.cw, memo)\n        copy.glyph_ids = deepcopy(self.glyph_ids, memo)\n        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)\n        copy.subset = deepcopy(self.subset, memo)\n        copy.biggest_size_pt = self.biggest_size_pt\n        copy._hbfont = self._hbfont\n        copy.color_font = self.color_font\n        copy.palette_index = self.palette_index\n        return copy\n\n    def close(self) -> None:\n        self.ttfont.close()\n        self._hbfont = None\n\n    def escape_text(self, text: str) -> str:\n        if self.color_font:\n            encoded = text.encode(\"latin-1\", errors=\"replace\")\n            return escape_parens(encoded.decode(\"latin-1\", errors=\"ignore\"))\n        return escape_parens(text.encode(\"utf-16-be\").decode(\"latin-1\"))\n\n    def get_text_width(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[int, float]:\n        if font_size_pt > self.biggest_size_pt:\n            self.biggest_size_pt = font_size_pt\n        if text_shaping_params:\n            return self.shaped_text_width(text, font_size_pt, text_shaping_params)\n        return (len(text), sum(self.cw[ord(c)] for c in text) * font_size_pt * 0.001)\n\n    def shaped_text_width(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[int, float]:\n        \"\"\"\n        When texts are shaped, the length of a string is not always the sum of all individual character widths\n        This method will invoke harfbuzz to perform the text shaping and return the sum of \"x_advance\"\n        and \"x_offset\" for each glyph. This method works for \"left to right\" or \"right to left\" texts.\n        \"\"\"\n        _, glyph_positions = self.perform_harfbuzz_shaping(\n            text, font_size_pt, text_shaping_params\n        )\n\n        # If there is nothing to render (harfbuzz returns None), we return 0 text width\n        if glyph_positions is None:\n            return (0, 0)\n\n        text_width: float = 0\n        for pos in glyph_positions:\n            text_width += (\n                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001\n            )\n        return (len(glyph_positions), text_width)\n\n    # Disabling this check - looks like cython confuses pylint:\n    # pylint: disable=no-member\n    def perform_harfbuzz_shaping(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> tuple[Sequence[\"HBGlyphInfo\"], Sequence[\"HBGlyphPosition\"]]:\n        \"\"\"\n        This method invokes Harfbuzz to perform text shaping of the input string\n        \"\"\"\n        self.hbfont.ptem = font_size_pt\n        if TYPE_CHECKING:\n            buf: HBBuffer\n        buf = hb.Buffer()\n        buf.cluster_level = 1\n        buf.add_str(\"\".join(text))\n        buf.guess_segment_properties()\n        features = (\n            text_shaping_params[\"features\"] if text_shaping_params is not None else {}\n        )\n        if text_shaping_params is None:\n            text_shaping_params = {}\n        if (\n            \"fragment_direction\" in text_shaping_params\n            and text_shaping_params[\"fragment_direction\"] is not None\n        ):\n            buf.direction = text_shaping_params[\"fragment_direction\"].value\n        if (\n            \"script\" in text_shaping_params\n            and text_shaping_params[\"script\"] is not None\n        ):\n            buf.script = text_shaping_params[\"script\"]\n        if (\n            \"language\" in text_shaping_params\n            and text_shaping_params[\"language\"] is not None\n        ):\n            buf.language = text_shaping_params[\"language\"]\n        hb.shape(self.hbfont, buf, features)\n        return buf.glyph_infos, buf.glyph_positions\n\n    def encode_text(self, text: str) -> str:\n        txt_mapped = \"\"\n        for char in text:\n            uni = ord(char)\n            # Instead of adding the actual character to the stream its code is\n            # mapped to a position in the font's subset\n            mapped_char: Optional[int] = self.subset.pick(uni)\n            if mapped_char is not None:\n                txt_mapped += chr(mapped_char)\n        return f\"({self.escape_text(txt_mapped)}) Tj\"\n\n    def shape_text(\n        self,\n        text: str,\n        font_size_pt: float,\n        text_shaping_params: Optional[dict[str, Any]],\n    ) -> Sequence[dict[str, Any]]:\n        \"\"\"\n        This method will invoke harfbuzz for text shaping, include the mapping code\n        of the glyphs on the subset and map input characters to the cluster codes\n        \"\"\"\n        if len(text) == 0:\n            return []\n        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(\n            text, font_size_pt, text_shaping_params\n        )\n        text_info = []\n\n        # Find cluster gaps\n        # Ex: text = \"ABCD\"\n        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph\n        # (ligature or substitution) - the glyph should have both unicodes and it should be translated\n        # properly on the CID to GID mapping\n        #\n        def get_cluster_from_text_index(cluster_list: Sequence[int], index: int) -> int:\n            pos = bisect_left(cluster_list, index)\n            if pos == 0:\n                return cluster_list[0]\n            if pos == len(cluster_list) or cluster_list[pos] != index:\n                return cluster_list[pos - 1]\n            return cluster_list[pos]\n\n        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))\n        cluster_mapping: dict[int, list[int]] = {}\n        for i in range(len(text)):\n            cl = get_cluster_from_text_index(cluster_list, i)\n            if cl in cluster_mapping:\n                cluster_mapping[cl].append(i)\n            else:\n                cluster_mapping[cl] = [i]\n\n        for cluster_seq, gi in enumerate(glyph_infos):\n            unicode = []\n            if gi.cluster in cluster_mapping:\n                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]\n                cluster_mapping.pop(gi.cluster)\n\n            gname = self.ttfont.getGlyphName(gi.codepoint)\n            gwidth = round(self.scale * self.ttfont[\"hmtx\"].metrics[gname][0])\n            glyph = self.subset.get_glyph(\n                glyph=gi.codepoint,\n                unicode=tuple(unicode),\n                glyph_name=gname,\n                glyph_width=gwidth,\n            )\n            if glyph is None:\n                continue\n            force_positioning = False\n            if (\n                gwidth != glyph_positions[cluster_seq].x_advance\n                or glyph_positions[cluster_seq].x_offset != 0\n                or glyph_positions[cluster_seq].y_offset != 0\n                or glyph_positions[cluster_seq].y_advance != 0\n            ):\n                force_positioning = True\n            text_info.append(\n                {\n                    \"mapped_char\": self.subset.pick_glyph(glyph),\n                    \"x_advance\": glyph_positions[cluster_seq].x_advance,\n                    \"y_advance\": glyph_positions[cluster_seq].y_advance,\n                    \"x_offset\": glyph_positions[cluster_seq].x_offset,\n                    \"y_offset\": glyph_positions[cluster_seq].y_offset,\n                    \"force_positioning\": force_positioning,\n                }\n            )\n        return text_info",
      "language": "python"
    },
    {
      "code": "def close(self) -> None:\n    self.ttfont.close()\n    self._hbfont = None",
      "language": "python"
    },
    {
      "code": "def encode_text(self, text: str) -> str:\n    txt_mapped = \"\"\n    for char in text:\n        uni = ord(char)\n        # Instead of adding the actual character to the stream its code is\n        # mapped to a position in the font's subset\n        mapped_char: Optional[int] = self.subset.pick(uni)\n        if mapped_char is not None:\n            txt_mapped += chr(mapped_char)\n    return f\"({self.escape_text(txt_mapped)}) Tj\"",
      "language": "python"
    },
    {
      "code": "def escape_text(self, text: str) -> str:\n    if self.color_font:\n        encoded = text.encode(\"latin-1\", errors=\"replace\")\n        return escape_parens(encoded.decode(\"latin-1\", errors=\"ignore\"))\n    return escape_parens(text.encode(\"utf-16-be\").decode(\"latin-1\"))",
      "language": "python"
    },
    {
      "code": "def get_text_width(\n    self,\n    text: str,\n    font_size_pt: float,\n    text_shaping_params: Optional[dict[str, Any]],\n) -> tuple[int, float]:\n    if font_size_pt > self.biggest_size_pt:\n        self.biggest_size_pt = font_size_pt\n    if text_shaping_params:\n        return self.shaped_text_width(text, font_size_pt, text_shaping_params)\n    return (len(text), sum(self.cw[ord(c)] for c in text) * font_size_pt * 0.001)",
      "language": "python"
    },
    {
      "code": "def perform_harfbuzz_shaping(\n    self,\n    text: str,\n    font_size_pt: float,\n    text_shaping_params: Optional[dict[str, Any]],\n) -> tuple[Sequence[\"HBGlyphInfo\"], Sequence[\"HBGlyphPosition\"]]:\n    \"\"\"\n    This method invokes Harfbuzz to perform text shaping of the input string\n    \"\"\"\n    self.hbfont.ptem = font_size_pt\n    if TYPE_CHECKING:\n        buf: HBBuffer\n    buf = hb.Buffer()\n    buf.cluster_level = 1\n    buf.add_str(\"\".join(text))\n    buf.guess_segment_properties()\n    features = (\n        text_shaping_params[\"features\"] if text_shaping_params is not None else {}\n    )\n    if text_shaping_params is None:\n        text_shaping_params = {}\n    if (\n        \"fragment_direction\" in text_shaping_params\n        and text_shaping_params[\"fragment_direction\"] is not None\n    ):\n        buf.direction = text_shaping_params[\"fragment_direction\"].value\n    if (\n        \"script\" in text_shaping_params\n        and text_shaping_params[\"script\"] is not None\n    ):\n        buf.script = text_shaping_params[\"script\"]\n    if (\n        \"language\" in text_shaping_params\n        and text_shaping_params[\"language\"] is not None\n    ):\n        buf.language = text_shaping_params[\"language\"]\n    hb.shape(self.hbfont, buf, features)\n    return buf.glyph_infos, buf.glyph_positions",
      "language": "python"
    },
    {
      "code": "def shape_text(\n    self,\n    text: str,\n    font_size_pt: float,\n    text_shaping_params: Optional[dict[str, Any]],\n) -> Sequence[dict[str, Any]]:\n    \"\"\"\n    This method will invoke harfbuzz for text shaping, include the mapping code\n    of the glyphs on the subset and map input characters to the cluster codes\n    \"\"\"\n    if len(text) == 0:\n        return []\n    glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(\n        text, font_size_pt, text_shaping_params\n    )\n    text_info = []\n\n    # Find cluster gaps\n    # Ex: text = \"ABCD\"\n    # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph\n    # (ligature or substitution) - the glyph should have both unicodes and it should be translated\n    # properly on the CID to GID mapping\n    #\n    def get_cluster_from_text_index(cluster_list: Sequence[int], index: int) -> int:\n        pos = bisect_left(cluster_list, index)\n        if pos == 0:\n            return cluster_list[0]\n        if pos == len(cluster_list) or cluster_list[pos] != index:\n            return cluster_list[pos - 1]\n        return cluster_list[pos]\n\n    cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))\n    cluster_mapping: dict[int, list[int]] = {}\n    for i in range(len(text)):\n        cl = get_cluster_from_text_index(cluster_list, i)\n        if cl in cluster_mapping:\n            cluster_mapping[cl].append(i)\n        else:\n            cluster_mapping[cl] = [i]\n\n    for cluster_seq, gi in enumerate(glyph_infos):\n        unicode = []\n        if gi.cluster in cluster_mapping:\n            unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]\n            cluster_mapping.pop(gi.cluster)\n\n        gname = self.ttfont.getGlyphName(gi.codepoint)\n        gwidth = round(self.scale * self.ttfont[\"hmtx\"].metrics[gname][0])\n        glyph = self.subset.get_glyph(\n            glyph=gi.codepoint,\n            unicode=tuple(unicode),\n            glyph_name=gname,\n            glyph_width=gwidth,\n        )\n        if glyph is None:\n            continue\n        force_positioning = False\n        if (\n            gwidth != glyph_positions[cluster_seq].x_advance\n            or glyph_positions[cluster_seq].x_offset != 0\n            or glyph_positions[cluster_seq].y_offset != 0\n            or glyph_positions[cluster_seq].y_advance != 0\n        ):\n            force_positioning = True\n        text_info.append(\n            {\n                \"mapped_char\": self.subset.pick_glyph(glyph),\n                \"x_advance\": glyph_positions[cluster_seq].x_advance,\n                \"y_advance\": glyph_positions[cluster_seq].y_advance,\n                \"x_offset\": glyph_positions[cluster_seq].x_offset,\n                \"y_offset\": glyph_positions[cluster_seq].y_offset,\n                \"force_positioning\": force_positioning,\n            }\n        )\n    return text_info",
      "language": "python"
    },
    {
      "code": "def shaped_text_width(\n    self,\n    text: str,\n    font_size_pt: float,\n    text_shaping_params: Optional[dict[str, Any]],\n) -> tuple[int, float]:\n    \"\"\"\n    When texts are shaped, the length of a string is not always the sum of all individual character widths\n    This method will invoke harfbuzz to perform the text shaping and return the sum of \"x_advance\"\n    and \"x_offset\" for each glyph. This method works for \"left to right\" or \"right to left\" texts.\n    \"\"\"\n    _, glyph_positions = self.perform_harfbuzz_shaping(\n        text, font_size_pt, text_shaping_params\n    )\n\n    # If there is nothing to render (harfbuzz returns None), we return 0 text width\n    if glyph_positions is None:\n        return (0, 0)\n\n    text_width: float = 0\n    for pos in glyph_positions:\n        text_width += (\n            round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001\n        )\n    return (len(glyph_positions), text_width)",
      "language": "python"
    },
    {
      "code": "class TextStyle(FontFace):\n    \"\"\"\n    Subclass of `FontFace` that allows to specify vertical & horizontal spacing\n    \"\"\"\n\n    def __init__(\n        self,\n        font_family: Optional[str] = None,  # None means \"no override\"\n        #                                     Whereas \"\" means \"no emphasis\"\n        font_style: Optional[str | TextEmphasis] = None,\n        font_size_pt: Optional[float] = None,\n        color: Optional[\n            Union[str, float, Sequence[float], DeviceGray, DeviceRGB, DeviceCMYK]\n        ] = None,  # grey scale or (red, green, blue),\n        fill_color: Optional[\n            Union[float, Sequence[float], DeviceGray, DeviceRGB, DeviceCMYK]\n        ] = None,  # grey scale or (red, green, blue),\n        underline: bool = False,\n        t_margin: Optional[float] = None,\n        l_margin: Optional[float | Align | str] = None,\n        b_margin: Optional[float] = None,\n    ) -> None:\n        if isinstance(font_style, TextEmphasis):\n            font_style = font_style.style\n        super().__init__(\n            font_family,\n            ((font_style or \"\") + \"U\") if underline else font_style,\n            font_size_pt,\n            color,\n            fill_color,\n        )\n        self.t_margin = t_margin or 0\n\n        if isinstance(l_margin, (int, float)):\n            self.l_margin: Optional[float | Align] = float(l_margin)\n        elif l_margin:\n            self.l_margin = Align.coerce(l_margin)\n        else:\n            self.l_margin = 0\n\n        self.b_margin = b_margin or 0\n\n    def __repr__(self) -> str:\n        return (\n            super().__repr__()[:-1]\n            + f\", t_margin={self.t_margin}, l_margin={self.l_margin}, b_margin={self.b_margin})\"\n        )\n\n    # override parent method\n    def replace(  # type: ignore[override]\n        self,\n        /,\n        font_family: Optional[str] = None,\n        emphasis: Optional[TextEmphasis] = None,\n        font_size_pt: Optional[float] = None,\n        color: Optional[DeviceGray | DeviceRGB | DeviceCMYK] = None,\n        fill_color: Optional[DeviceGray | DeviceRGB | DeviceCMYK] = None,\n        t_margin: Optional[float] = None,\n        l_margin: Optional[float | Align] = None,\n        b_margin: Optional[float] = None,\n    ) -> \"TextStyle\":\n        \"\"\"\n        Create a new TextStyle instance, with new values for some attributes.\n        Same as `dataclasses.replace()`\n        \"\"\"\n        return TextStyle(\n            font_family=font_family or self.family,\n            font_style=self.emphasis if emphasis is None else emphasis.style,\n            font_size_pt=font_size_pt or self.size_pt,\n            color=color or self.color,\n            fill_color=fill_color or self.fill_color,\n            t_margin=self.t_margin if t_margin is None else t_margin,\n            l_margin=self.l_margin if l_margin is None else l_margin,\n            b_margin=self.b_margin if b_margin is None else b_margin,\n        )",
      "language": "python"
    },
    {
      "code": "def replace(  # type: ignore[override]\n    self,\n    /,\n    font_family: Optional[str] = None,\n    emphasis: Optional[TextEmphasis] = None,\n    font_size_pt: Optional[float] = None,\n    color: Optional[DeviceGray | DeviceRGB | DeviceCMYK] = None,\n    fill_color: Optional[DeviceGray | DeviceRGB | DeviceCMYK] = None,\n    t_margin: Optional[float] = None,\n    l_margin: Optional[float | Align] = None,\n    b_margin: Optional[float] = None,\n) -> \"TextStyle\":\n    \"\"\"\n    Create a new TextStyle instance, with new values for some attributes.\n    Same as `dataclasses.replace()`\n    \"\"\"\n    return TextStyle(\n        font_family=font_family or self.family,\n        font_style=self.emphasis if emphasis is None else emphasis.style,\n        font_size_pt=font_size_pt or self.size_pt,\n        color=color or self.color,\n        fill_color=fill_color or self.fill_color,\n        t_margin=self.t_margin if t_margin is None else t_margin,\n        l_margin=self.l_margin if l_margin is None else l_margin,\n        b_margin=self.b_margin if b_margin is None else b_margin,\n    )",
      "language": "python"
    }
  ],
  "patterns": [
    {
      "description": "Return a new object replacing specified fields with new values. This is especially useful for frozen classes. Example usage:: @dataclass(frozen=True) class C: x: int y: int c = C(1, 2) c1 = replace(c, x=3) assert c1.x == 3 and c1.y == 2",
      "code": "class Glyph\n(glyph_id:Â int, unicode:Â intÂ |Â tuple[int,Â ...], glyph_name:Â str, glyph_width:Â int)"
    },
    {
      "description": "This is especially useful for frozen classes. Example usage::",
      "code": "class Glyph\n(glyph_id:Â int, unicode:Â intÂ |Â tuple[int,Â ...], glyph_name:Â str, glyph_width:Â int)"
    }
  ],
  "links": [
    "https://py-pdf.github.io/fpdf2/Unicode.html",
    "https://py-pdf.github.io/fpdf2/fpdf/enums.html",
    "https://py-pdf.github.io/fpdf2/fpdf/drawing_primitives.html",
    "https://py-pdf.github.io/fpdf2/fpdf/graphics_state.html",
    "https://py-pdf.github.io/fpdf2/fpdf/fonts.html",
    "https://py-pdf.github.io/fpdf2/fpdf/syntax.html",
    "https://py-pdf.github.io/fpdf2/fpdf/index.html"
  ]
}