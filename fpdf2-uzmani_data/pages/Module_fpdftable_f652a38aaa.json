{
  "url": "https://py-pdf.github.io/fpdf2/fpdf/table.html",
  "title": "Module fpdf.table",
  "content": "Usage documentation at: https://py-pdf.github.io/fpdf2/Tables.html\n\nDraws a box using the provided style - private helper used by table for drawing the cell and table borders. Difference between this and rect() is that border can be defined as \"L,R,T,B\" to draw only some of the four borders; compatible with get_border(i,k)\n\nInternal representation of a table cell\n\nObject that Table.row() yields, used to build a row in a table\n\nAdds a cell to the row.\n\nRowLayoutInfo(height: float, pagebreak_height: float, rendered_heights: Dict[int, float], merged_heights: List[float])\n\nThe type of the None singleton.\n\nThe type of the None singleton.\n\nThe type of the None singleton.\n\nThe type of the None singleton.\n\nRowSpanLayoutInfo(column: int, start: int, length: int, contents_height: float)\n\nThe type of the None singleton.\n\nThe type of the None singleton.\n\nThe type of the None singleton.\n\nThe type of the None singleton.\n\nObject that FPDF.table() yields, used to build a table in the document. Detailed usage documentation: https://py-pdf.github.io/fpdf2/Tables.html\n\nThis is an internal method called by fpdf.FPDF.table() once the table is finished\n\nAdds a row to the table. Returns a Row object.",
  "headings": [
    {
      "level": "h1",
      "text": "Module fpdf.table",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Functions",
      "id": "header-functions"
    },
    {
      "level": "h2",
      "text": "Classes",
      "id": "header-classes"
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    }
  ],
  "code_samples": [
    {
      "code": "def draw_box_borders(\n    pdf: \"FPDF\",\n    x1: float,\n    y1: float,\n    x2: float,\n    y2: float,\n    border: str | Literal[0, 1],\n    fill_color: Optional[DeviceCMYK | DeviceGray | DeviceRGB] = None,\n) -> None:\n    \"\"\"Draws a box using the provided style - private helper used by table for drawing the cell and table borders.\n    Difference between this and rect() is that border can be defined as \"L,R,T,B\" to draw only some of the four borders;\n    compatible with get_border(i,k)\n\n    See Also: rect()\"\"\"\n    if fill_color:\n        prev_fill_color = pdf.fill_color\n        pdf.set_fill_color(fill_color)\n\n    sl: list[str] = []\n\n    k = pdf.k\n\n    # y top to bottom instead of bottom to top\n    y1 = pdf.h - y1\n    y2 = pdf.h - y2\n\n    # scale\n    x1 *= k\n    x2 *= k\n    y2 *= k\n    y1 *= k\n\n    if isinstance(border, str) and set(border).issuperset(\"LTRB\"):\n        border = 1\n\n    if fill_color:\n        op = \"B\" if border == 1 else \"f\"\n        sl.append(f\"{x1:.2f} {y2:.2f} \" f\"{x2 - x1:.2f} {y1 - y2:.2f} re {op}\")\n    elif border == 1:\n        sl.append(f\"{x1:.2f} {y2:.2f} \" f\"{x2 - x1:.2f} {y1 - y2:.2f} re S\")\n\n    if isinstance(border, str):\n        if \"L\" in border:\n            sl.append(f\"{x1:.2f} {y2:.2f} m \" f\"{x1:.2f} {y1:.2f} l S\")\n        if \"B\" in border:\n            sl.append(f\"{x1:.2f} {y2:.2f} m \" f\"{x2:.2f} {y2:.2f} l S\")\n        if \"R\" in border:\n            sl.append(f\"{x2:.2f} {y2:.2f} m \" f\"{x2:.2f} {y1:.2f} l S\")\n        if \"T\" in border:\n            sl.append(f\"{x1:.2f} {y1:.2f} m \" f\"{x2:.2f} {y1:.2f} l S\")\n\n    s = \" \".join(sl)\n    pdf._out(  # pyright: ignore[reportPrivateUsage] # pylint: disable=protected-access\n        s\n    )\n\n    if fill_color:\n        pdf.set_fill_color(prev_fill_color)  # type: ignore[arg-type]",
      "language": "python"
    },
    {
      "code": "@dataclass(frozen=True)\nclass Cell:\n    \"Internal representation of a table cell\"\n\n    __slots__ = (  # RAM usage optimization\n        \"text\",\n        \"align\",\n        \"v_align\",\n        \"style\",\n        \"img\",\n        \"img_fill_width\",\n        \"colspan\",\n        \"rowspan\",\n        \"padding\",\n        \"link\",\n        \"border\",\n    )\n    text: str\n    align: Optional[Union[str, Align]]\n    v_align: Optional[Union[str, VAlign]]\n    style: Optional[FontFace]\n    img: Optional[ImageType]\n    img_fill_width: bool\n    colspan: int\n    rowspan: int\n    padding: Optional[float | Sequence[float] | Padding]\n    link: Optional[Union[str, int]]\n    border: CellBordersLayout\n\n    def write(self, text: str, align: Optional[Align | str] = None) -> None:\n        raise NotImplementedError(\"Not implemented yet\")",
      "language": "python"
    },
    {
      "code": "@dataclass(frozen=True)\nclass Cell:\n    \"Internal representation of a table cell\"\n\n    __slots__ = (  # RAM usage optimization\n        \"text\",\n        \"align\",\n        \"v_align\",\n        \"style\",\n        \"img\",\n        \"img_fill_width\",\n        \"colspan\",\n        \"rowspan\",\n        \"padding\",\n        \"link\",\n        \"border\",\n    )\n    text: str\n    align: Optional[Union[str, Align]]\n    v_align: Optional[Union[str, VAlign]]\n    style: Optional[FontFace]\n    img: Optional[ImageType]\n    img_fill_width: bool\n    colspan: int\n    rowspan: int\n    padding: Optional[float | Sequence[float] | Padding]\n    link: Optional[Union[str, int]]\n    border: CellBordersLayout\n\n    def write(self, text: str, align: Optional[Align | str] = None) -> None:\n        raise NotImplementedError(\"Not implemented yet\")",
      "language": "python"
    },
    {
      "code": "@dataclass(frozen=True)\nclass Cell:\n    \"Internal representation of a table cell\"\n\n    __slots__ = (  # RAM usage optimization\n        \"text\",\n        \"align\",\n        \"v_align\",\n        \"style\",\n        \"img\",\n        \"img_fill_width\",\n        \"colspan\",\n        \"rowspan\",\n        \"padding\",\n        \"link\",\n        \"border\",\n    )\n    text: str\n    align: Optional[Union[str, Align]]\n    v_align: Optional[Union[str, VAlign]]\n    style: Optional[FontFace]\n    img: Optional[ImageType]\n    img_fill_width: bool\n    colspan: int\n    rowspan: int\n    padding: Optional[float | Sequence[float] | Padding]\n    link: Optional[Union[str, int]]\n    border: CellBordersLayout\n\n    def write(self, text: str, align: Optional[Align | str] = None) -> None:\n        raise NotImplementedError(\"Not implemented yet\")",
      "language": "python"
    },
    {
      "code": "@dataclass(frozen=True)\nclass Cell:\n    \"Internal representation of a table cell\"\n\n    __slots__ = (  # RAM usage optimization\n        \"text\",\n        \"align\",\n        \"v_align\",\n        \"style\",\n        \"img\",\n        \"img_fill_width\",\n        \"colspan\",\n        \"rowspan\",\n        \"padding\",\n        \"link\",\n        \"border\",\n    )\n    text: str\n    align: Optional[Union[str, Align]]\n    v_align: Optional[Union[str, VAlign]]\n    style: Optional[FontFace]\n    img: Optional[ImageType]\n    img_fill_width: bool\n    colspan: int\n    rowspan: int\n    padding: Optional[float | Sequence[float] | Padding]\n    link: Optional[Union[str, int]]\n    border: CellBordersLayout\n\n    def write(self, text: str, align: Optional[Align | str] = None) -> None:\n        raise NotImplementedError(\"Not implemented yet\")",
      "language": "python"
    },
    {
      "code": "@dataclass(frozen=True)\nclass Cell:\n    \"Internal representation of a table cell\"\n\n    __slots__ = (  # RAM usage optimization\n        \"text\",\n        \"align\",\n        \"v_align\",\n        \"style\",\n        \"img\",\n        \"img_fill_width\",\n        \"colspan\",\n        \"rowspan\",\n        \"padding\",\n        \"link\",\n        \"border\",\n    )\n    text: str\n    align: Optional[Union[str, Align]]\n    v_align: Optional[Union[str, VAlign]]\n    style: Optional[FontFace]\n    img: Optional[ImageType]\n    img_fill_width: bool\n    colspan: int\n    rowspan: int\n    padding: Optional[float | Sequence[float] | Padding]\n    link: Optional[Union[str, int]]\n    border: CellBordersLayout\n\n    def write(self, text: str, align: Optional[Align | str] = None) -> None:\n        raise NotImplementedError(\"Not implemented yet\")",
      "language": "python"
    },
    {
      "code": "@dataclass(frozen=True)\nclass Cell:\n    \"Internal representation of a table cell\"\n\n    __slots__ = (  # RAM usage optimization\n        \"text\",\n        \"align\",\n        \"v_align\",\n        \"style\",\n        \"img\",\n        \"img_fill_width\",\n        \"colspan\",\n        \"rowspan\",\n        \"padding\",\n        \"link\",\n        \"border\",\n    )\n    text: str\n    align: Optional[Union[str, Align]]\n    v_align: Optional[Union[str, VAlign]]\n    style: Optional[FontFace]\n    img: Optional[ImageType]\n    img_fill_width: bool\n    colspan: int\n    rowspan: int\n    padding: Optional[float | Sequence[float] | Padding]\n    link: Optional[Union[str, int]]\n    border: CellBordersLayout\n\n    def write(self, text: str, align: Optional[Align | str] = None) -> None:\n        raise NotImplementedError(\"Not implemented yet\")",
      "language": "python"
    },
    {
      "code": "@dataclass(frozen=True)\nclass Cell:\n    \"Internal representation of a table cell\"\n\n    __slots__ = (  # RAM usage optimization\n        \"text\",\n        \"align\",\n        \"v_align\",\n        \"style\",\n        \"img\",\n        \"img_fill_width\",\n        \"colspan\",\n        \"rowspan\",\n        \"padding\",\n        \"link\",\n        \"border\",\n    )\n    text: str\n    align: Optional[Union[str, Align]]\n    v_align: Optional[Union[str, VAlign]]\n    style: Optional[FontFace]\n    img: Optional[ImageType]\n    img_fill_width: bool\n    colspan: int\n    rowspan: int\n    padding: Optional[float | Sequence[float] | Padding]\n    link: Optional[Union[str, int]]\n    border: CellBordersLayout\n\n    def write(self, text: str, align: Optional[Align | str] = None) -> None:\n        raise NotImplementedError(\"Not implemented yet\")",
      "language": "python"
    },
    {
      "code": "@dataclass(frozen=True)\nclass Cell:\n    \"Internal representation of a table cell\"\n\n    __slots__ = (  # RAM usage optimization\n        \"text\",\n        \"align\",\n        \"v_align\",\n        \"style\",\n        \"img\",\n        \"img_fill_width\",\n        \"colspan\",\n        \"rowspan\",\n        \"padding\",\n        \"link\",\n        \"border\",\n    )\n    text: str\n    align: Optional[Union[str, Align]]\n    v_align: Optional[Union[str, VAlign]]\n    style: Optional[FontFace]\n    img: Optional[ImageType]\n    img_fill_width: bool\n    colspan: int\n    rowspan: int\n    padding: Optional[float | Sequence[float] | Padding]\n    link: Optional[Union[str, int]]\n    border: CellBordersLayout\n\n    def write(self, text: str, align: Optional[Align | str] = None) -> None:\n        raise NotImplementedError(\"Not implemented yet\")",
      "language": "python"
    },
    {
      "code": "@dataclass(frozen=True)\nclass Cell:\n    \"Internal representation of a table cell\"\n\n    __slots__ = (  # RAM usage optimization\n        \"text\",\n        \"align\",\n        \"v_align\",\n        \"style\",\n        \"img\",\n        \"img_fill_width\",\n        \"colspan\",\n        \"rowspan\",\n        \"padding\",\n        \"link\",\n        \"border\",\n    )\n    text: str\n    align: Optional[Union[str, Align]]\n    v_align: Optional[Union[str, VAlign]]\n    style: Optional[FontFace]\n    img: Optional[ImageType]\n    img_fill_width: bool\n    colspan: int\n    rowspan: int\n    padding: Optional[float | Sequence[float] | Padding]\n    link: Optional[Union[str, int]]\n    border: CellBordersLayout\n\n    def write(self, text: str, align: Optional[Align | str] = None) -> None:\n        raise NotImplementedError(\"Not implemented yet\")",
      "language": "python"
    },
    {
      "code": "@dataclass(frozen=True)\nclass Cell:\n    \"Internal representation of a table cell\"\n\n    __slots__ = (  # RAM usage optimization\n        \"text\",\n        \"align\",\n        \"v_align\",\n        \"style\",\n        \"img\",\n        \"img_fill_width\",\n        \"colspan\",\n        \"rowspan\",\n        \"padding\",\n        \"link\",\n        \"border\",\n    )\n    text: str\n    align: Optional[Union[str, Align]]\n    v_align: Optional[Union[str, VAlign]]\n    style: Optional[FontFace]\n    img: Optional[ImageType]\n    img_fill_width: bool\n    colspan: int\n    rowspan: int\n    padding: Optional[float | Sequence[float] | Padding]\n    link: Optional[Union[str, int]]\n    border: CellBordersLayout\n\n    def write(self, text: str, align: Optional[Align | str] = None) -> None:\n        raise NotImplementedError(\"Not implemented yet\")",
      "language": "python"
    },
    {
      "code": "@dataclass(frozen=True)\nclass Cell:\n    \"Internal representation of a table cell\"\n\n    __slots__ = (  # RAM usage optimization\n        \"text\",\n        \"align\",\n        \"v_align\",\n        \"style\",\n        \"img\",\n        \"img_fill_width\",\n        \"colspan\",\n        \"rowspan\",\n        \"padding\",\n        \"link\",\n        \"border\",\n    )\n    text: str\n    align: Optional[Union[str, Align]]\n    v_align: Optional[Union[str, VAlign]]\n    style: Optional[FontFace]\n    img: Optional[ImageType]\n    img_fill_width: bool\n    colspan: int\n    rowspan: int\n    padding: Optional[float | Sequence[float] | Padding]\n    link: Optional[Union[str, int]]\n    border: CellBordersLayout\n\n    def write(self, text: str, align: Optional[Align | str] = None) -> None:\n        raise NotImplementedError(\"Not implemented yet\")",
      "language": "python"
    },
    {
      "code": "@dataclass(frozen=True)\nclass Cell:\n    \"Internal representation of a table cell\"\n\n    __slots__ = (  # RAM usage optimization\n        \"text\",\n        \"align\",\n        \"v_align\",\n        \"style\",\n        \"img\",\n        \"img_fill_width\",\n        \"colspan\",\n        \"rowspan\",\n        \"padding\",\n        \"link\",\n        \"border\",\n    )\n    text: str\n    align: Optional[Union[str, Align]]\n    v_align: Optional[Union[str, VAlign]]\n    style: Optional[FontFace]\n    img: Optional[ImageType]\n    img_fill_width: bool\n    colspan: int\n    rowspan: int\n    padding: Optional[float | Sequence[float] | Padding]\n    link: Optional[Union[str, int]]\n    border: CellBordersLayout\n\n    def write(self, text: str, align: Optional[Align | str] = None) -> None:\n        raise NotImplementedError(\"Not implemented yet\")",
      "language": "python"
    },
    {
      "code": "def write(self, text: str, align: Optional[Align | str] = None) -> None:\n    raise NotImplementedError(\"Not implemented yet\")",
      "language": "python"
    },
    {
      "code": "class Row:\n    \"Object that `Table.row()` yields, used to build a row in a table\"\n\n    def __init__(\n        self,\n        table: Table,\n        style: Optional[FontFace] = None,\n        v_align: Optional[str | VAlign] = None,\n        min_height: Optional[float] = None,\n    ) -> None:\n        self._table = table\n        self.cells: List[Optional[TableSpan | Cell]] = []\n        self.style: Optional[FontFace] = style\n        self.v_align = VAlign.coerce(v_align) if v_align else v_align\n        self.min_height = min_height\n\n    @property\n    def cols_count(self) -> int:\n        return sum(getattr(cell, \"colspan\", cell is not None) for cell in self.cells)\n\n    @property\n    def max_rowspan(self) -> int:\n        spans = {cell.rowspan for cell in self.cells if isinstance(cell, Cell)}\n        return max(spans) if len(spans) else 1\n\n    def convert_spans(\n        self, active_rowspans: Dict[int, int]\n    ) -> Tuple[Dict[int, int], Sequence[int]]:\n        # convert colspans\n        prev_col = 0\n        cells: List[Optional[Cell | TableSpan]] = []\n        for i, cell in enumerate(self.cells):\n            if cell is None:\n                continue\n            if cell == TableSpan.COL:\n                prev_cell = cells[prev_col]\n                if not isinstance(prev_cell, Cell):\n                    raise FPDFException(\n                        \"Invalid location for TableSpan.COL placeholder entry\"\n                    )\n                cells[prev_col] = replace(prev_cell, colspan=prev_cell.colspan + 1)\n                cells.append(None)  # processed\n            else:\n                cells.append(cell)\n                prev_col = i\n                if isinstance(cell, Cell) and cell.colspan > 1:  # expand any colspans\n                    cells.extend([None] * (cell.colspan - 1))\n        # now we can correctly interpret active_rowspans\n        remaining_rowspans: dict[int, int] = {}\n        for k, v in active_rowspans.items():\n            cells.insert(k, None)\n            if v > 1:\n                remaining_rowspans[k] = v - 1\n        # accumulate any rowspans\n        reverse_rowspans: list[int] = []\n        for i, cell in enumerate(cells):\n            if isinstance(cell, Cell) and cell.rowspan > 1:\n                for k in range(i, i + cell.colspan):\n                    remaining_rowspans[k] = cell.rowspan - 1\n            elif cell == TableSpan.ROW:\n                reverse_rowspans.append(i)\n                cells[i] = None  # processed\n        self.cells = cells\n        return remaining_rowspans, reverse_rowspans\n\n    def cell(\n        self,\n        text: str = \"\",\n        align: Optional[str | Align] = None,\n        v_align: Optional[str | VAlign] = None,\n        style: Optional[FontFace] = None,\n        img: Optional[ImageType] = None,\n        img_fill_width: bool = False,\n        colspan: int = 1,\n        rowspan: int = 1,\n        padding: Optional[Tuple[float, ...]] = None,\n        link: Optional[str | int] = None,\n        border: CellBordersLayout = CellBordersLayout.INHERIT,\n    ) -> Union[\"Cell\", TableSpan]:\n        \"\"\"\n        Adds a cell to the row.\n\n        Args:\n            text (str): string content, can contain several lines.\n                In that case, the row height will grow proportionally.\n            align (str, fpdf.enums.Align): optional text alignment.\n            v_align (str, fpdf.enums.VAlign): optional vertical text alignment.\n            style (fpdf.fonts.FontFace): optional text style.\n            img: optional. Either a string representing a file path to an image,\n                an URL to an image, an io.BytesIO, or a instance of `PIL.Image.Image`.\n            img_fill_width (bool): optional, defaults to False. Indicates to render the image\n                using the full width of the current table column.\n            colspan (int): optional number of columns this cell should span.\n            rowspan (int): optional number of rows this cell should span.\n            padding (tuple): optional padding (left, top, right, bottom) for the cell.\n            link (str, int): optional link, either an URL or an integer returned by `FPDF.add_link`, defining an internal link to a page\n            border (fpdf.enums.CellBordersLayout): optional cell borders, defaults to `CellBordersLayout.INHERIT`\n\n        \"\"\"\n        if text and img:\n            raise NotImplementedError(\n                \"fpdf2 currently does not support inserting text with an image in the same table cell.\"\n                \" Pull Requests are welcome to implement this ðŸ˜Š\"\n            )\n\n        if isinstance(text, TableSpan):\n            # Special placeholder object, converted to colspan/rowspan during processing\n            self.cells.append(text)\n            return text\n\n        if not style:\n            # pylint: disable=protected-access\n            # We capture the current font settings:\n            font_face = (\n                self._table._fpdf.font_face()  # pyright: ignore[reportPrivateUsage]\n            )\n            if font_face not in (\n                self.style,\n                self._table._initial_style,  # pyright: ignore[reportPrivateUsage]\n            ):\n                style = font_face\n\n        cell = Cell(\n            text,\n            align,\n            VAlign.coerce(v_align) if v_align else v_align,\n            style,\n            img,\n            img_fill_width,\n            colspan,\n            rowspan,\n            padding,\n            link,\n            CellBordersLayout.coerce(border),\n        )\n        self.cells.append(cell)\n        return cell",
      "language": "python"
    },
    {
      "code": "@property\ndef cols_count(self) -> int:\n    return sum(getattr(cell, \"colspan\", cell is not None) for cell in self.cells)",
      "language": "python"
    },
    {
      "code": "@property\ndef max_rowspan(self) -> int:\n    spans = {cell.rowspan for cell in self.cells if isinstance(cell, Cell)}\n    return max(spans) if len(spans) else 1",
      "language": "python"
    },
    {
      "code": "def cell(\n    self,\n    text: str = \"\",\n    align: Optional[str | Align] = None,\n    v_align: Optional[str | VAlign] = None,\n    style: Optional[FontFace] = None,\n    img: Optional[ImageType] = None,\n    img_fill_width: bool = False,\n    colspan: int = 1,\n    rowspan: int = 1,\n    padding: Optional[Tuple[float, ...]] = None,\n    link: Optional[str | int] = None,\n    border: CellBordersLayout = CellBordersLayout.INHERIT,\n) -> Union[\"Cell\", TableSpan]:\n    \"\"\"\n    Adds a cell to the row.\n\n    Args:\n        text (str): string content, can contain several lines.\n            In that case, the row height will grow proportionally.\n        align (str, fpdf.enums.Align): optional text alignment.\n        v_align (str, fpdf.enums.VAlign): optional vertical text alignment.\n        style (fpdf.fonts.FontFace): optional text style.\n        img: optional. Either a string representing a file path to an image,\n            an URL to an image, an io.BytesIO, or a instance of `PIL.Image.Image`.\n        img_fill_width (bool): optional, defaults to False. Indicates to render the image\n            using the full width of the current table column.\n        colspan (int): optional number of columns this cell should span.\n        rowspan (int): optional number of rows this cell should span.\n        padding (tuple): optional padding (left, top, right, bottom) for the cell.\n        link (str, int): optional link, either an URL or an integer returned by `FPDF.add_link`, defining an internal link to a page\n        border (fpdf.enums.CellBordersLayout): optional cell borders, defaults to `CellBordersLayout.INHERIT`\n\n    \"\"\"\n    if text and img:\n        raise NotImplementedError(\n            \"fpdf2 currently does not support inserting text with an image in the same table cell.\"\n            \" Pull Requests are welcome to implement this ðŸ˜Š\"\n        )\n\n    if isinstance(text, TableSpan):\n        # Special placeholder object, converted to colspan/rowspan during processing\n        self.cells.append(text)\n        return text\n\n    if not style:\n        # pylint: disable=protected-access\n        # We capture the current font settings:\n        font_face = (\n            self._table._fpdf.font_face()  # pyright: ignore[reportPrivateUsage]\n        )\n        if font_face not in (\n            self.style,\n            self._table._initial_style,  # pyright: ignore[reportPrivateUsage]\n        ):\n            style = font_face\n\n    cell = Cell(\n        text,\n        align,\n        VAlign.coerce(v_align) if v_align else v_align,\n        style,\n        img,\n        img_fill_width,\n        colspan,\n        rowspan,\n        padding,\n        link,\n        CellBordersLayout.coerce(border),\n    )\n    self.cells.append(cell)\n    return cell",
      "language": "python"
    },
    {
      "code": "def convert_spans(\n    self, active_rowspans: Dict[int, int]\n) -> Tuple[Dict[int, int], Sequence[int]]:\n    # convert colspans\n    prev_col = 0\n    cells: List[Optional[Cell | TableSpan]] = []\n    for i, cell in enumerate(self.cells):\n        if cell is None:\n            continue\n        if cell == TableSpan.COL:\n            prev_cell = cells[prev_col]\n            if not isinstance(prev_cell, Cell):\n                raise FPDFException(\n                    \"Invalid location for TableSpan.COL placeholder entry\"\n                )\n            cells[prev_col] = replace(prev_cell, colspan=prev_cell.colspan + 1)\n            cells.append(None)  # processed\n        else:\n            cells.append(cell)\n            prev_col = i\n            if isinstance(cell, Cell) and cell.colspan > 1:  # expand any colspans\n                cells.extend([None] * (cell.colspan - 1))\n    # now we can correctly interpret active_rowspans\n    remaining_rowspans: dict[int, int] = {}\n    for k, v in active_rowspans.items():\n        cells.insert(k, None)\n        if v > 1:\n            remaining_rowspans[k] = v - 1\n    # accumulate any rowspans\n    reverse_rowspans: list[int] = []\n    for i, cell in enumerate(cells):\n        if isinstance(cell, Cell) and cell.rowspan > 1:\n            for k in range(i, i + cell.colspan):\n                remaining_rowspans[k] = cell.rowspan - 1\n        elif cell == TableSpan.ROW:\n            reverse_rowspans.append(i)\n            cells[i] = None  # processed\n    self.cells = cells\n    return remaining_rowspans, reverse_rowspans",
      "language": "python"
    },
    {
      "code": "@dataclass(frozen=True)\nclass RowLayoutInfo:\n    height: float\n    # accumulated rowspans to take in account when considering page breaks:\n    pagebreak_height: float\n    # heights of every cell in the row:\n    rendered_heights: Dict[int, float]\n    merged_heights: List[float]",
      "language": "python"
    },
    {
      "code": "@dataclass(frozen=True)\nclass RowSpanLayoutInfo:\n    column: int\n    start: int\n    length: int\n    contents_height: float\n\n    def row_range(self) -> range:\n        return range(self.start, self.start + self.length)",
      "language": "python"
    },
    {
      "code": "def row_range(self) -> range:\n    return range(self.start, self.start + self.length)",
      "language": "python"
    },
    {
      "code": "class Table:\n    \"\"\"\n    Object that `fpdf.fpdf.FPDF.table()` yields, used to build a table in the document.\n    Detailed usage documentation: https://py-pdf.github.io/fpdf2/Tables.html\n    \"\"\"\n\n    def __init__(\n        self,\n        fpdf: \"FPDF\",\n        rows: Sequence[str] = (),\n        *,\n        align: str | Align = \"CENTER\",\n        v_align: str | VAlign = \"MIDDLE\",\n        borders_layout: str | TableBordersLayout = TableBordersLayout.ALL,\n        cell_fill_color: Optional[\n            float | Sequence[float] | str | DeviceRGB | DeviceGray | DeviceCMYK\n        ] = None,\n        cell_fill_mode: str | TableCellFillMode = TableCellFillMode.NONE,\n        col_widths: Optional[float | Sequence[float]] = None,\n        first_row_as_headings: bool = True,\n        gutter_height: float = 0,\n        gutter_width: float = 0,\n        headings_style: FontFace = DEFAULT_HEADINGS_STYLE,\n        line_height: Optional[Number] = None,\n        markdown: bool = False,\n        text_align: str | Align = \"JUSTIFY\",\n        width: Optional[Number] = None,\n        wrapmode: WrapMode = WrapMode.WORD,\n        padding: Optional[Number | Sequence[Number] | Padding] = None,\n        outer_border_width: Optional[Number] = None,\n        num_heading_rows: Number = 1,\n        repeat_headings: TableHeadingsDisplay | str | int = 1,\n        min_row_height: Optional[Number] = None,\n    ):\n        \"\"\"\n        Args:\n            fpdf (fpdf.FPDF): FPDF current instance\n            rows: optional. Sequence of rows (iterable) of str to initiate the table cells with text content\n            align (str, fpdf.enums.Align): optional, default to CENTER. Sets the table horizontal position relative to the page,\n                when it's not using the full page width\n            borders_layout (str, fpdf.enums.TableBordersLayout): optional, default to ALL. Control what cell borders are drawn\n            cell_fill_color (float, tuple, fpdf.drawing.DeviceGray, fpdf.drawing.DeviceRGB): optional.\n                Defines the cells background color\n            cell_fill_mode (str, fpdf.enums.TableCellFillMode): optional. Defines which cells are filled with color in the background\n            col_widths (float, tuple): optional. Sets column width. Can be a single number or a sequence of numbers.\n                 When `col_widths` is a single number, it is interpreted as a fixed column width in document units.\n                 When `col_widths` is provided as an array, the values are considered to be fractions of the full effective page width,\n                 meaning that `col_widths=(1, 1, 2)` is strictly equivalent to `col_widths=(25, 25, 50)`.\n            first_row_as_headings (bool): optional, default to True. If False, the first row of the table\n                is not styled differently from the others\n            gutter_height (float): optional vertical space between rows\n            gutter_width (float): optional horizontal space between columns\n            headings_style (fpdf.fonts.FontFace): optional, default to bold.\n                Defines the visual style of the top headings row: size, color, emphasis...\n            line_height (number): optional. Defines how much vertical space a line of text will occupy\n            markdown (bool): optional, default to False. Enable markdown interpretation of cells textual content\n            text_align (str, fpdf.enums.Align, tuple): optional, default to JUSTIFY. Control text alignment inside cells.\n            v_align (str, fpdf.enums.VAlign): optional, default to CENTER. Control vertical alignment of cells content\n            width (number): optional. Sets the table width\n            wrapmode (fpdf.enums.WrapMode): \"WORD\" for word based line wrapping (default),\n                \"CHAR\" for character based line wrapping.\n            padding (number, tuple, Padding): optional. Sets the cell padding. Can be a single number or a sequence of numbers, default:0\n                If padding for left and right ends up being non-zero then c_margin is ignored.\n            outer_border_width (number): optional. Sets the width of the outer borders of the table.\n                Only relevant when borders_layout is ALL or NO_HORIZONTAL_LINES. Otherwise, the border widths are controlled by FPDF.set_line_width()\n            num_heading_rows (number): optional. Sets the number of heading rows, default value is 1. If this value is not 1,\n                first_row_as_headings needs to be True if num_heading_rows>1 and False if num_heading_rows=0. For backwards compatibility,\n                first_row_as_headings is used in case num_heading_rows is 1.\n            repeat_headings (fpdf.enums.TableHeadingsDisplay): optional, indicates whether to print table headings on every page, default to 1.\n        \"\"\"\n        self._fpdf = fpdf\n        self._table_align = Align.coerce(align)\n        self._v_align = VAlign.coerce(v_align)\n        self._borders_layout = TableBordersLayout.coerce(borders_layout)\n        self._outer_border_width = outer_border_width\n        self._cell_fill_color = cell_fill_color\n        self._cell_fill_mode = TableCellFillMode.coerce(cell_fill_mode)\n        self._col_widths: Optional[float | Sequence[float]] = col_widths\n        self._first_row_as_headings: bool = first_row_as_headings\n        self._gutter_height = gutter_height\n        self._gutter_width = gutter_width\n        self._headings_style = headings_style\n        self._line_height: float = (\n            2 * fpdf.font_size if line_height is None else float(line_height)\n        )\n        self._markdown = markdown\n        self._text_align = text_align\n        self._width = width\n        self._wrapmode = wrapmode\n        self._num_heading_rows = int(num_heading_rows)\n        self._repeat_headings = TableHeadingsDisplay.coerce(repeat_headings)\n        self._min_row_height = min_row_height\n        self._initial_style: Optional[FontFace] = None\n        self.rows: List[Row] = []\n\n        if padding is None:\n            self._padding = Padding.new(0)\n        else:\n            self._padding = Padding.new(padding)\n\n        # check table_border_layout and outer_border_width\n        if self._borders_layout not in (\n            TableBordersLayout.ALL,\n            TableBordersLayout.NO_HORIZONTAL_LINES,\n        ):\n            if outer_border_width is not None:\n                raise ValueError(\n                    \"outer_border_width is only allowed when borders_layout is ALL or NO_HORIZONTAL_LINES\"\n                )\n            self._outer_border_width = None\n        # _outer_border_margin : vertical spacing around table\n        if self._outer_border_width:\n            assert outer_border_width is not None\n            self._outer_border_margin = (\n                (gutter_width + float(outer_border_width) / 2),\n                (gutter_height + float(outer_border_width) / 2),\n            )\n        else:\n            self._outer_border_margin = (0, 0)\n\n        # check first_row_as_headings for non-default case num_heading_rows != 1\n        if self._num_heading_rows != 1:\n            if self._num_heading_rows == 0 and self._first_row_as_headings:\n                raise ValueError(\n                    \"first_row_as_headings needs to be False if num_heading_rows == 0\"\n                )\n            if self._num_heading_rows > 1 and not self._first_row_as_headings:\n                raise ValueError(\n                    \"first_row_as_headings needs to be True if num_heading_rows > 0\"\n                )\n        # for backwards compatibility, we respect the value of first_row_as_headings when num_heading_rows==1\n        else:\n            if not self._first_row_as_headings:\n                self._num_heading_rows = 0\n\n        for row in rows:\n            self.row(row)\n\n    def row(\n        self,\n        cells: Sequence[str] = (),\n        style: Optional[FontFace] = None,\n        v_align: Optional[str | VAlign] = None,\n        min_height: Optional[float] = None,\n    ) -> \"Row\":\n        \"Adds a row to the table. Returns a `Row` object.\"\n        if self._initial_style is None:\n            self._initial_style = self._fpdf.font_face()\n        row = Row(self, style=style, v_align=v_align, min_height=min_height)\n        self.rows.append(row)\n        for cell in cells:\n            if isinstance(cell, dict):\n                row.cell(**cell)  # pyright: ignore[reportArgumentType]\n            else:\n                row.cell(cell)\n        return row\n\n    def render(self) -> None:\n        \"This is an internal method called by `fpdf.FPDF.table()` once the table is finished\"\n        # Starting with some sanity checks:\n        self._cols_count = max(row.cols_count for row in self.rows) if self.rows else 0\n        if self._width is None:\n            if self._col_widths and isinstance(self._col_widths, NumberClass):\n                self._width = self._cols_count * self._col_widths\n            else:\n                self._width = self._fpdf.epw\n        elif self._col_widths and isinstance(self._col_widths, NumberClass):\n            if self._cols_count * self._col_widths != self._width:\n                raise ValueError(\n                    f\"Invalid value provided width={self._width} should be a multiple of col_widths={self._col_widths}\"\n                )\n        if self._width > self._fpdf.epw:\n            raise ValueError(\n                f\"Invalid value provided width={self._width}: effective page width is {self._fpdf.epw}\"\n            )\n        if self._table_align == Align.J:\n            raise ValueError(\n                \"JUSTIFY is an invalid value for FPDF.table() 'align' parameter\"\n            )\n        if self._num_heading_rows > 0:\n            if not self._headings_style:\n                raise ValueError(\n                    \"headings_style must be provided to FPDF.table() if num_heading_rows>1 or first_row_as_headings=True\"\n                )\n            emphasis = self._headings_style.emphasis\n            if emphasis is not None:\n                family = self._headings_style.family or self._fpdf.font_family\n                font_key = family.lower() + emphasis.style.replace(\"U\", \"\")\n                if font_key not in CORE_FONTS and font_key not in self._fpdf.fonts:\n                    # Raising a more explicit error than the one from set_font():\n                    raise FPDFException(\n                        f\"Using font '{family}' with emphasis '{emphasis.style}'\"\n                        \" in table headings require the corresponding font style\"\n                        \" to be added using add_font()\"\n                    )\n\n        # Defining table global horizontal position:\n        prev_x, prev_y, prev_l_margin = self._fpdf.x, self._fpdf.y, self._fpdf.l_margin\n        if self._table_align == Align.C:\n            self._fpdf.l_margin = (self._fpdf.w - float(self._width)) / 2\n            self._fpdf.x = self._fpdf.l_margin\n        elif self._table_align == Align.R:\n            self._fpdf.l_margin = (\n                self._fpdf.w - self._fpdf.r_margin - float(self._width)\n            )\n            self._fpdf.x = self._fpdf.l_margin\n        elif self._fpdf.x != self._fpdf.l_margin:\n            self._fpdf.l_margin = self._fpdf.x\n\n        # Pre-Compute the relative x-positions of the individual columns:\n        xx = self._fpdf.l_margin + self._outer_border_margin[0]\n        cell_x_positions = [xx]\n        if self.rows:\n            for i in range(self._cols_count):\n                xx += self._get_col_width(0, i)\n                xx += self._gutter_width\n                cell_x_positions.append(xx)\n\n        # Process any rowspans\n        rows_info = list(self._compute_rows_info())\n\n        # actually render the cells\n        repeat_headings = (\n            self._repeat_headings is TableHeadingsDisplay.ON_TOP_OF_EVERY_PAGE\n        )\n        self._fpdf.y += self._outer_border_margin[1]\n        if len(self.rows) > self._num_heading_rows > 0:\n            # We avoid having the heading rows alone on a page - issue #1391\n            # pylint: disable=protected-access\n            self._fpdf._perform_page_break_if_need_be(  # pyright: ignore[reportPrivateUsage]\n                sum(\n                    rows_info[i].pagebreak_height\n                    for i in range(self._num_heading_rows + 1)\n                )\n            )\n        for i in range(len(self.rows)):\n            pagebreak_height = rows_info[i].pagebreak_height\n            # pylint: disable=protected-access\n            page_break = self._fpdf._perform_page_break_if_need_be(  # pyright: ignore[reportPrivateUsage]\n                pagebreak_height\n            )\n            if (\n                page_break\n                and self._fpdf.y + pagebreak_height > self._fpdf.page_break_trigger\n            ):\n                # Restoring original position on page:\n                self._fpdf.x = prev_x\n                self._fpdf.y = prev_y\n                self._fpdf.l_margin = prev_l_margin\n                raise ValueError(\n                    f\"The row with index {i} is too high and cannot be rendered on a single page\"\n                )\n            if page_break and repeat_headings and i >= self._num_heading_rows:\n                # repeat headings on top:\n                self._fpdf.y += self._outer_border_margin[1]\n                for row_idx in range(self._num_heading_rows):\n                    self._render_table_row(\n                        row_idx,\n                        rows_info[row_idx],\n                        cell_x_positions=cell_x_positions,\n                    )\n            if i > 0:\n                self._fpdf.y += self._gutter_height\n            self._render_table_row(i, rows_info[i], cell_x_positions)\n\n        # Restoring altered FPDF settings:\n        self._fpdf.l_margin = prev_l_margin\n        self._fpdf.x = self._fpdf.l_margin\n\n    def _render_table_row(\n        self,\n        i: int,\n        row_layout_info: \"RowLayoutInfo\",\n        cell_x_positions: Optional[Sequence[float]],\n        **kwargs: Any,\n    ) -> None:\n        row = self.rows[i]\n        y = self._fpdf.y  # remember current y position, reset after each cell\n\n        for j, cell in enumerate(row.cells):\n            if not isinstance(cell, Cell):\n                continue\n            self._render_table_cell(\n                i,\n                j,\n                cell,\n                row_height=self._line_height,\n                cell_height_info=row_layout_info,\n                cell_x_positions=cell_x_positions,\n                **kwargs,\n            )\n            self._fpdf.set_y(y)  # restore y position after each cell\n\n        self._fpdf.ln(row_layout_info.height)\n\n    def _render_table_cell(\n        self,\n        i: int,\n        j: int,\n        cell: \"Cell\",\n        row_height: float,  # height of a row of text including line spacing\n        cell_height_info: Optional[\n            \"RowLayoutInfo\"\n        ] = None,  # full height of a cell, including padding, used to render borders and images\n        cell_x_positions: Optional[\n            Sequence[float]\n        ] = None,  # x-positions of the individual columns, pre-calculated for speed. Only relevant when rendering\n        **kwargs: Any,\n    ) -> Tuple[bool, float, float]:\n        # If cell_height_info is provided then we are rendering a cell\n        # If cell_height_info is not provided then we are only here to figure out the height of the cell\n        #\n        # So this function is first called without cell_height_info to figure out the heights of all cells in a row\n        # and then called again with cell_height to actually render the cells\n        cell_height: Optional[float]\n        if cell_height_info is None:\n            cell_height = None\n            height_query_only = True\n        elif cell.rowspan > 1:\n            cell_height = cell_height_info.merged_heights[cell.rowspan]\n            height_query_only = False\n        else:\n            cell_height = cell_height_info.height\n            height_query_only = False\n\n        page_break_text = False\n        page_break_image = False\n\n        # Get style and cell content:\n\n        row = self.rows[i]\n        col_width = self._get_col_width(i, j, cell.colspan)\n        img_height: float = 0\n\n        text_align = cell.align or self._text_align\n        if not isinstance(text_align, (Align, str)):\n            text_align = text_align[j]\n\n        style = self._initial_style\n        assert style is not None\n        cell_mode_fill = self._cell_fill_mode.should_fill_cell(i, j)\n        if cell_mode_fill and self._cell_fill_color:\n            style = style.replace(fill_color=self._cell_fill_color)\n        if i < self._num_heading_rows:\n            style = FontFace.combine(style, self._headings_style)\n        style = FontFace.combine(style, row.style)\n        style = FontFace.combine(style, cell.style)\n\n        padding = Padding.new(cell.padding) if cell.padding else self._padding\n\n        v_align = cell.v_align\n        if not v_align:\n            v_align = row.v_align\n        if not v_align:\n            v_align = self._v_align\n\n        # We can not rely on the actual x position of the cell. Notably in case of\n        # empty cells or cells with an image only the actual x position is incorrect.\n        # Instead, we calculate the x position based on the column widths of the previous columns\n\n        # place cursor (required for images after images)\n\n        # not rendering, cell_x_positions is not relevant (and probably not provided):\n        cell_x: float\n        if height_query_only:\n            cell_x = 0\n        else:\n            assert cell_x_positions is not None\n            cell_x = cell_x_positions[j]\n        self._fpdf.set_x(cell_x)\n\n        # render cell border and background\n        # if cell_height is defined, that means that we already know the size at which the cell will be rendered\n        # so we can draw the borders now\n        #\n        # If cell_height is None then we're still in the phase of calculating the height of the cell meaning that\n        # we do not need to set fonts & draw borders yet.\n        if not height_query_only:\n            assert cell_height is not None\n            x1 = self._fpdf.x\n            y1 = self._fpdf.y\n            x2 = (\n                x1 + col_width\n            )  # already includes gutter for cells spanning multiple columns\n            y2 = y1 + cell_height\n\n            cell_idx = next(\n                i for i, row_cell in enumerate(row.cells) if row_cell is cell\n            )\n            (\n                self._borders_layout.cell_style_getter(\n                    row_idx=i,\n                    col_idx=sum(1 for cell in row.cells[:cell_idx] if cell is not None),\n                    col_pos=j,\n                    num_heading_rows=self._num_heading_rows,\n                    num_rows=len(self.rows),\n                    num_col_idx=sum(1 for cell in row.cells if cell is not None),\n                    num_col_pos=row.cols_count,\n                )\n                .override_cell_border(cell.border)\n                .draw_cell_border(\n                    self._fpdf,\n                    x1,\n                    y1,\n                    x2,\n                    y2,\n                    fill_color=style.fill_color if style else None,\n                )\n            )\n\n            # draw outer box if needed:\n            if self._outer_border_width is not None:\n                assert self._width is not None\n                _remember_linewidth = self._fpdf.line_width\n                self._fpdf.set_line_width(float(self._outer_border_width))\n\n                # draw the outer box separated by the gutter dimensions\n                # the top and bottom borders are one continuous line\n                # whereas the left and right borders are segments because of possible pagebreaks\n                x1 = self._fpdf.l_margin\n                x2 = x1 + float(self._width)\n                y1 = y1 - self._outer_border_margin[1]\n                y2 = y2 + self._outer_border_margin[1]\n\n                if j == 0:\n                    # lhs border\n                    self._fpdf.line(x1, y1, x1, y2)\n                if j + cell.colspan == self._cols_count:\n                    # rhs border\n                    self._fpdf.line(x2, y1, x2, y2)\n                    # continuous top line border\n                    if i == 0:\n                        self._fpdf.line(x1, y1, x2, y1)\n                    # continuous bottom line border\n                    if i + cell.rowspan == len(self.rows):\n                        self._fpdf.line(x1, y2, x2, y2)\n\n                self._fpdf.set_line_width(_remember_linewidth)\n\n        if cell.img:\n            x, y = self._fpdf.x, self._fpdf.y\n\n            # if cell_height is None or width is given then call image with h=0\n            # calling with h=0 means that the image will be rendered with an auto determined height\n            cell_border_line_width = self._fpdf.line_width\n            if cell.img_fill_width or cell_height is None:\n                img_height = 0\n            else:\n                img_height = (\n                    cell_height - padding.top - padding.bottom - cell_border_line_width\n                )\n\n            # apply padding\n            self._fpdf.x += padding.left + cell_border_line_width / 2\n            self._fpdf.y += padding.top + cell_border_line_width / 2\n\n            image = self._fpdf.image(\n                cell.img,\n                w=col_width - padding.left - padding.right - cell_border_line_width,\n                h=img_height,\n                keep_aspect_ratio=True,\n                link=cell.link,\n            )\n\n            img_height = (\n                image.rendered_height\n                + padding.top\n                + padding.bottom\n                + cell_border_line_width\n            )\n\n            if img_height + y > self._fpdf.page_break_trigger:\n                page_break_image = True\n\n            self._fpdf.set_xy(x, y)\n\n        # render text\n\n        if cell.text:\n            dy: float = 0\n\n            if cell_height is not None:\n                assert cell_height_info is not None\n                actual_text_height = cell_height_info.rendered_heights[j]\n\n                if v_align == VAlign.M:\n                    dy = (cell_height - actual_text_height) / 2\n                elif v_align == VAlign.B:\n                    dy = cell_height - actual_text_height\n\n            self._fpdf.y += dy\n            assert style is not None\n            with self._fpdf.use_font_face(style):\n                page_break_text, cell_height = self._fpdf.multi_cell(  # type: ignore[assignment,misc]\n                    w=col_width,\n                    h=row_height,\n                    text=cell.text,\n                    max_line_height=self._line_height,\n                    border=0,\n                    align=text_align,\n                    new_x=\"RIGHT\",\n                    new_y=\"TOP\",\n                    fill=False,  # fill is already done above\n                    markdown=self._markdown,\n                    output=MethodReturnValue.PAGE_BREAK | MethodReturnValue.HEIGHT,\n                    wrapmode=self._wrapmode,\n                    padding=padding,\n                    link=cell.link,\n                    **kwargs,\n                )\n                assert isinstance(page_break_text, bool)\n                assert isinstance(cell_height, float)\n\n            self._fpdf.y -= dy\n        else:\n            cell_height = 0\n\n        do_pagebreak: bool = page_break_text or page_break_image\n        assert cell_height is not None\n        return do_pagebreak, img_height, cell_height\n\n    def _get_col_width(self, i: int, j: int, colspan: int = 1) -> float:\n        \"\"\"Gets width of a column in a table, this excludes the outer gutter (outside the table) but includes the inner gutter\n        between columns if the cell spans multiple columns.\"\"\"\n\n        cols_count = self._cols_count\n        assert self._width is not None\n        width: float = (\n            float(self._width)\n            - (cols_count - 1) * self._gutter_width\n            - 2 * float(self._outer_border_margin[0])\n        )\n        gutter_within_cell = max((colspan - 1) * self._gutter_width, 0)\n\n        if not self._col_widths:\n            return float(colspan * (width / cols_count) + gutter_within_cell)\n        if isinstance(self._col_widths, NumberClass):\n            return colspan * self._col_widths + gutter_within_cell\n        if j >= len(self._col_widths):\n            raise ValueError(\n                f\"Invalid .col_widths specified: missing width for table() column {j + 1} on row {i + 1}\"\n            )\n        col_width: float = 0\n        for k in range(j, j + colspan):\n            col_ratio = self._col_widths[k] / sum(self._col_widths)\n            col_width += col_ratio * width\n            if k != j:\n                col_width += self._gutter_width\n        return col_width\n\n    def _compute_rows_info(self) -> Iterator[\"RowLayoutInfo\"]:\n        # First pass: Regularise the table by processing the rowspan and colspan entries\n        active_rowspans: Dict[int, int] = {}\n        prev_row_in_col: Dict[int, Optional[Row]] = {}\n        for i, row in enumerate(self.rows):\n            # Link up rowspans\n            active_rowspans, prior_rowspans = row.convert_spans(active_rowspans)\n            for col_idx in prior_rowspans:\n                # This cell is TableSpan.ROW, so accumulate to the previous row\n                prev_row = prev_row_in_col[col_idx]\n                if prev_row is not None:\n                    # Since Cell objects are frozen, we need to recreate them to update the rowspan\n                    cell = prev_row.cells[col_idx]\n                    assert isinstance(cell, Cell)\n                    prev_row.cells[col_idx] = replace(cell, rowspan=cell.rowspan + 1)\n            for j, cell in enumerate(row.cells):\n                if isinstance(cell, Cell):\n                    # Keep track of the non-span cells\n                    prev_row_in_col[j] = row\n                    for k in range(j + 1, j + cell.colspan):\n                        prev_row_in_col[k] = None\n        if len(active_rowspans) != 0:\n            raise FPDFException(\"Rowspan extends beyond end of table\")\n\n        # Second pass: Estimate the cell sizes\n        rowspan_list: List[RowSpanLayoutInfo] = []\n        row_min_heights: List[Number] = []\n        row_span_max: List[int] = []\n        rendered_heights: List[Dict[int, float]] = []\n        # pylint: disable=protected-access\n        with self._fpdf._disable_writing():  # pyright: ignore[reportPrivateUsage]\n            for i, row in enumerate(self.rows):\n                dictated_heights: list[float] = []\n                img_heights: list[float] = []\n                rendered_heights.append({})\n\n                for j, cell in enumerate(row.cells):\n                    if not isinstance(cell, Cell):  # placeholder cell\n                        continue\n\n                    # NB: ignore page_break since we might need to assign rowspan padding\n                    _, img_height, text_height = self._render_table_cell(\n                        i,\n                        j,\n                        cell,\n                        row_height=self._line_height,\n                    )\n                    if cell.img_fill_width:\n                        dictated_height = img_height\n                    else:\n                        dictated_height = text_height\n\n                    # Store the dictated heights in a dict (not list) because of span elements\n                    rendered_heights[i][j] = dictated_height\n\n                    if cell.rowspan > 1:\n                        # For spanned rows, use img_height if dictated_height is zero\n                        rowspan_list.append(\n                            RowSpanLayoutInfo(\n                                j, i, cell.rowspan, dictated_height or img_height\n                            )\n                        )\n                        # Often we want rowspans in headings, but issues arise if the span crosses outside the heading\n                        is_heading = i < self._num_heading_rows\n                        span_outside_heading = i + cell.rowspan > self._num_heading_rows\n                        if is_heading and span_outside_heading:\n                            raise FPDFException(\n                                \"Heading includes rowspan beyond the number of heading rows\"\n                            )\n                    else:\n                        dictated_heights.append(dictated_height)\n                        img_heights.append(img_height)\n\n                # The height of the rows is chosen as follows:\n                # The \"dictated height\" is the space required for text/image, so pick the largest in the row\n                # If this is zero, we will fill the space with images, so pick the largest image height\n                # If this is still zero (e.g. empty/fully spanned row), use a sensible default\n                min_height: float = 0\n                if dictated_heights:\n                    min_height = max(dictated_heights)\n                    if min_height == 0:\n                        min_height = max(img_heights)\n                if min_height == 0:\n                    min_height = self._line_height\n                if row.min_height:\n                    if min_height < row.min_height:\n                        min_height = row.min_height\n                elif self._min_row_height:\n                    if min_height < self._min_row_height:\n                        min_height = float(self._min_row_height)\n\n                row_min_heights.append(min_height)\n                row_span_max.append(row.max_rowspan)\n\n        # Sort the spans so we allocate padding to the smallest spans first\n        rowspan_list = sorted(rowspan_list, key=lambda span: span.length)\n\n        # Third pass: allocate space required for the rowspans\n        row_span_padding: List[float] = [0 for _ in self.rows]\n        for span in rowspan_list:\n            # accumulate already assigned properties\n            max_padding: float = 0\n            assigned_height = self._gutter_height * (span.length - 1)\n            assigned_padding: float = 0\n            for i in span.row_range():\n                max_padding = max(max_padding, row_span_padding[i])\n                assigned_height += float(row_min_heights[i])\n                assigned_padding += row_span_padding[i]\n\n            # does additional padding need to be distributed?\n            if assigned_height + assigned_padding < span.contents_height:\n                # when there are overlapping rowspans, can we stretch the cells to be evenly padded?\n                if span.contents_height > assigned_height + span.length * max_padding:\n                    # stretch all cells to have the same padding, for aesthetic reasons\n                    padding = (span.contents_height - assigned_height) / span.length\n                    for i in span.row_range():\n                        row_span_padding[i] = padding\n                else:\n                    # add proportional padding to the rows\n                    extra = span.contents_height - assigned_height - assigned_padding\n                    for i in span.row_range():\n                        row_span_padding[i] += extra / span.length\n\n        # Fourth pass: compute the final element sizes\n        for i, row in enumerate(self.rows):\n            row_height: float = float(row_min_heights[i]) + row_span_padding[i]\n            # Compute the size of merged cells\n            merged_sizes: List[float] = [0, row_height]\n            for j in range(i + 1, i + row_span_max[i]):\n                merged_sizes.append(\n                    merged_sizes[-1]\n                    + self._gutter_height\n                    + float(row_min_heights[j])\n                    + row_span_padding[j]\n                )\n            # Pagebreak should not occur within ANY rowspan, so validate ACCUMULATED rowspans\n            # This gets complicated because of overlapping rowspans (see `test_table_with_rowspan_and_pgbreak()`)\n            # Eventually, this should be refactored to rearrange cells to permit breaks within spans\n            pagebreak_height = row_height\n            pagebreak_row = i + row_span_max[i]\n            j = i + 1\n            while j < pagebreak_row:\n                # NB: this can't be a for loop because the upper limit might keep changing\n                pagebreak_row = max(pagebreak_row, j + row_span_max[j])\n                pagebreak_height += (\n                    self._gutter_height\n                    + float(row_min_heights[j])\n                    + row_span_padding[j]\n                )\n                j += 1\n\n            yield RowLayoutInfo(\n                merged_sizes[1], pagebreak_height, rendered_heights[i], merged_sizes\n            )",
      "language": "python"
    },
    {
      "code": "def render(self) -> None:\n    \"This is an internal method called by `fpdf.FPDF.table()` once the table is finished\"\n    # Starting with some sanity checks:\n    self._cols_count = max(row.cols_count for row in self.rows) if self.rows else 0\n    if self._width is None:\n        if self._col_widths and isinstance(self._col_widths, NumberClass):\n            self._width = self._cols_count * self._col_widths\n        else:\n            self._width = self._fpdf.epw\n    elif self._col_widths and isinstance(self._col_widths, NumberClass):\n        if self._cols_count * self._col_widths != self._width:\n            raise ValueError(\n                f\"Invalid value provided width={self._width} should be a multiple of col_widths={self._col_widths}\"\n            )\n    if self._width > self._fpdf.epw:\n        raise ValueError(\n            f\"Invalid value provided width={self._width}: effective page width is {self._fpdf.epw}\"\n        )\n    if self._table_align == Align.J:\n        raise ValueError(\n            \"JUSTIFY is an invalid value for FPDF.table() 'align' parameter\"\n        )\n    if self._num_heading_rows > 0:\n        if not self._headings_style:\n            raise ValueError(\n                \"headings_style must be provided to FPDF.table() if num_heading_rows>1 or first_row_as_headings=True\"\n            )\n        emphasis = self._headings_style.emphasis\n        if emphasis is not None:\n            family = self._headings_style.family or self._fpdf.font_family\n            font_key = family.lower() + emphasis.style.replace(\"U\", \"\")\n            if font_key not in CORE_FONTS and font_key not in self._fpdf.fonts:\n                # Raising a more explicit error than the one from set_font():\n                raise FPDFException(\n                    f\"Using font '{family}' with emphasis '{emphasis.style}'\"\n                    \" in table headings require the corresponding font style\"\n                    \" to be added using add_font()\"\n                )\n\n    # Defining table global horizontal position:\n    prev_x, prev_y, prev_l_margin = self._fpdf.x, self._fpdf.y, self._fpdf.l_margin\n    if self._table_align == Align.C:\n        self._fpdf.l_margin = (self._fpdf.w - float(self._width)) / 2\n        self._fpdf.x = self._fpdf.l_margin\n    elif self._table_align == Align.R:\n        self._fpdf.l_margin = (\n            self._fpdf.w - self._fpdf.r_margin - float(self._width)\n        )\n        self._fpdf.x = self._fpdf.l_margin\n    elif self._fpdf.x != self._fpdf.l_margin:\n        self._fpdf.l_margin = self._fpdf.x\n\n    # Pre-Compute the relative x-positions of the individual columns:\n    xx = self._fpdf.l_margin + self._outer_border_margin[0]\n    cell_x_positions = [xx]\n    if self.rows:\n        for i in range(self._cols_count):\n            xx += self._get_col_width(0, i)\n            xx += self._gutter_width\n            cell_x_positions.append(xx)\n\n    # Process any rowspans\n    rows_info = list(self._compute_rows_info())\n\n    # actually render the cells\n    repeat_headings = (\n        self._repeat_headings is TableHeadingsDisplay.ON_TOP_OF_EVERY_PAGE\n    )\n    self._fpdf.y += self._outer_border_margin[1]\n    if len(self.rows) > self._num_heading_rows > 0:\n        # We avoid having the heading rows alone on a page - issue #1391\n        # pylint: disable=protected-access\n        self._fpdf._perform_page_break_if_need_be(  # pyright: ignore[reportPrivateUsage]\n            sum(\n                rows_info[i].pagebreak_height\n                for i in range(self._num_heading_rows + 1)\n            )\n        )\n    for i in range(len(self.rows)):\n        pagebreak_height = rows_info[i].pagebreak_height\n        # pylint: disable=protected-access\n        page_break = self._fpdf._perform_page_break_if_need_be(  # pyright: ignore[reportPrivateUsage]\n            pagebreak_height\n        )\n        if (\n            page_break\n            and self._fpdf.y + pagebreak_height > self._fpdf.page_break_trigger\n        ):\n            # Restoring original position on page:\n            self._fpdf.x = prev_x\n            self._fpdf.y = prev_y\n            self._fpdf.l_margin = prev_l_margin\n            raise ValueError(\n                f\"The row with index {i} is too high and cannot be rendered on a single page\"\n            )\n        if page_break and repeat_headings and i >= self._num_heading_rows:\n            # repeat headings on top:\n            self._fpdf.y += self._outer_border_margin[1]\n            for row_idx in range(self._num_heading_rows):\n                self._render_table_row(\n                    row_idx,\n                    rows_info[row_idx],\n                    cell_x_positions=cell_x_positions,\n                )\n        if i > 0:\n            self._fpdf.y += self._gutter_height\n        self._render_table_row(i, rows_info[i], cell_x_positions)\n\n    # Restoring altered FPDF settings:\n    self._fpdf.l_margin = prev_l_margin\n    self._fpdf.x = self._fpdf.l_margin",
      "language": "python"
    },
    {
      "code": "def row(\n    self,\n    cells: Sequence[str] = (),\n    style: Optional[FontFace] = None,\n    v_align: Optional[str | VAlign] = None,\n    min_height: Optional[float] = None,\n) -> \"Row\":\n    \"Adds a row to the table. Returns a `Row` object.\"\n    if self._initial_style is None:\n        self._initial_style = self._fpdf.font_face()\n    row = Row(self, style=style, v_align=v_align, min_height=min_height)\n    self.rows.append(row)\n    for cell in cells:\n        if isinstance(cell, dict):\n            row.cell(**cell)  # pyright: ignore[reportArgumentType]\n        else:\n            row.cell(cell)\n    return row",
      "language": "python"
    }
  ],
  "patterns": [],
  "links": [
    "https://py-pdf.github.io/fpdf2/Tables.html",
    "https://py-pdf.github.io/fpdf2/fpdf/drawing_primitives.html",
    "https://py-pdf.github.io/fpdf2/fpdf/enums.html",
    "https://py-pdf.github.io/fpdf2/fpdf/fonts.html",
    "https://py-pdf.github.io/fpdf2/fpdf/util.html",
    "https://py-pdf.github.io/fpdf2/fpdf/table.html",
    "https://py-pdf.github.io/fpdf2/fpdf/fpdf.html",
    "https://py-pdf.github.io/fpdf2/fpdf/index.html"
  ]
}