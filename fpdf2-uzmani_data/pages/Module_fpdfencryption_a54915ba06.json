{
  "url": "https://py-pdf.github.io/fpdf2/fpdf/encryption.html",
  "title": "Module fpdf.encryption",
  "content": "Utilities to perform encryption following the PDF standards.\n\nThe contents of this module are internal to fpdf2, and not part of the public API. They may change at any time without prior warning or any deprecation period, in non-backward-compatible ways.\n\nUsage documentation at: https://py-pdf.github.io/fpdf2/Encryption.html\n\nconvert long to signed 32 bit integer\n\nThis is a simplified version of the ARC4 (alleged RC4) algorithm, created based on the following sources: * Wikipedia article on RC4 * github.com/manojpandey/rc4 (MIT License) * http://people.csail.mit.edu/rivest/pubs/RS14.pdf\n\nHaving this ARC4 implementation makes it possible to have basic encryption functions without additional dependencies\n\nThe type of the None singleton.\n\nRepresents one crypt filter, listed under CF inside the encryption dictionary\n\nThis class represents an encryption dictionary PDF 32000 reference - Table 20 The PDF trailer must reference this object (/Encrypt)\n\nInherited from: PDFObject.content_stream\n\nSubclasses can override this method to indicate the presence of a content stream\n\nInherited from: PDFObject.serialize\n\nSerialize the PDF object as an obj<</>>endobj text block\n\nThis class is referenced in the main PDF class and is used to handle all encryption functions * Calculate password and hashes * Provide encrypt method to be called by stream and strings * Set the access permissions on the document\n\nThe type of the None singleton.\n\nAlgorithm 2B - section 7.6.4.3.4 of the ISO 32000-2:2020 Applied on Security handlers revision 6\n\nhttps://docs.python.org/3/library/os.html#os.urandom os.urandom will use OS-specific sources to generate random bytes suitable for cryptographic use\n\nPDF2.0 - ISO 32000-2:2020 All passwords for revision 6 shall be based on Unicode. Preprocessing of a user-provided password consists first of normalizing its representation by applying the \"SASLPrep\" profile (Internet RFC 4013) of the \"stringprep\" algorithm (Internet RFC 3454) to the supplied password using the Normalize and BiDi options. Next, the password string shall be converted to UTF-8 encoding, and then truncated to the first 127 bytes if the string is longer than 127 bytes\n\nPython offers a stringprep module with the tables mapped in methods\n\nMethod invoked by PDFObject and PDFContentStream to encrypt strings and streams\n\nEncrypts an array of bytes using AES algorithms (AES 128 or AES 256)\n\nPDF32000 reference - Algorithm 1: Encryption of data using the RC4 or AES algorithms Append object ID and generation ID to the key and encrypt the data Generation ID is fixed as 0. Will need to revisit if the application start changing generation ID\n\nPDF32000 reference Algorithm 2: Computing an encryption key\n\nPDF32000 reference - Algorithm 3: Computing the encryption dictionary's O (owner password) value The security handler is only using revision 3 or 4, so the legacy r2 version is not implemented here\n\nGenerating the O (owner password) and OE (owner encryption) for security handlers of revision 6 Algorithm 9 - Section 7.6.4.4.8 of the ISO 32000-2:2020\n\nFile_id is the first hash of the PDF file id\n\n7.6.4.4.9 Algorithm 10: Computing the encryption dictionary’s Perms (permissions) value (Security handlers of revision 6) of the ISO 32000-2:2020\n\nPDF32000 reference - Algorithm 5: Computing the encryption dictionary's U (user password) value The security handler is only using revision 3 or 4, so the legacy r2 version is not implemented here\n\nGenerating the U (user password) and UE (user encryption) for security handlers of revision 6 Algorithm 8 - Section 7.6.4.4.7 of the ISO 32000-2:2020\n\nReturn an encryption dictionary\n\nPDF32000 reference - Algorithm 2: Computing an encryption key Step (a) - Add the default padding at the end of provided password to make it 32 bit long",
  "headings": [
    {
      "level": "h1",
      "text": "Module fpdf.encryption",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Functions",
      "id": "header-functions"
    },
    {
      "level": "h2",
      "text": "Classes",
      "id": "header-classes"
    },
    {
      "level": "h3",
      "text": "Class variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Class variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Static methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    }
  ],
  "code_samples": [
    {
      "code": "def int32(n: int) -> int:\n    \"\"\"convert long to signed 32 bit integer\"\"\"\n    n = n & 0xFFFFFFFF\n    return (n ^ 0x80000000) - 0x80000000",
      "language": "python"
    },
    {
      "code": "def md5(data: Union[bytes, bytearray]) -> bytes:\n    h = hashlib.new(\"md5\", usedforsecurity=False)\n    h.update(data)\n    return h.digest()",
      "language": "python"
    },
    {
      "code": "class ARC4:\n    \"\"\"\n    This is a simplified version of the ARC4 (alleged RC4) algorithm,\n    created based on the following sources:\n    * Wikipedia article on RC4\n    * github.com/manojpandey/rc4 (MIT License)\n    * http://people.csail.mit.edu/rivest/pubs/RS14.pdf\n\n    Having this ARC4 implementation makes it possible to have basic\n    encryption functions without additional dependencies\n    \"\"\"\n\n    MOD = 256\n\n    def KSA(self, key: bytes) -> list[int]:\n        key_length = len(key)\n        S = list(range(self.MOD))\n        j = 0\n        for i in range(self.MOD):\n            j = (j + S[i] + key[i % key_length]) % self.MOD\n            S[i], S[j] = S[j], S[i]\n        return S\n\n    def PRGA(self, S: list[int]) -> Iterator[int]:\n        i = 0\n        j = 0\n        while True:\n            i = (i + 1) % self.MOD\n            j = (j + S[i]) % self.MOD\n            S[i], S[j] = S[j], S[i]\n            K = S[(S[i] + S[j]) % self.MOD]\n            yield K\n\n    def encrypt(self, key: bytes, text: bytes | bytearray) -> list[int]:\n        keystream = self.PRGA(self.KSA(key))\n        res: list[int] = []\n        for c in text:\n            res.append(c ^ next(keystream))\n        return res",
      "language": "python"
    },
    {
      "code": "def KSA(self, key: bytes) -> list[int]:\n    key_length = len(key)\n    S = list(range(self.MOD))\n    j = 0\n    for i in range(self.MOD):\n        j = (j + S[i] + key[i % key_length]) % self.MOD\n        S[i], S[j] = S[j], S[i]\n    return S",
      "language": "python"
    },
    {
      "code": "def PRGA(self, S: list[int]) -> Iterator[int]:\n    i = 0\n    j = 0\n    while True:\n        i = (i + 1) % self.MOD\n        j = (j + S[i]) % self.MOD\n        S[i], S[j] = S[j], S[i]\n        K = S[(S[i] + S[j]) % self.MOD]\n        yield K",
      "language": "python"
    },
    {
      "code": "def encrypt(self, key: bytes, text: bytes | bytearray) -> list[int]:\n    keystream = self.PRGA(self.KSA(key))\n    res: list[int] = []\n    for c in text:\n        res.append(c ^ next(keystream))\n    return res",
      "language": "python"
    },
    {
      "code": "class CryptFilter:\n    \"\"\"Represents one crypt filter, listed under CF inside the encryption dictionary\"\"\"\n\n    def __init__(self, mode: str, length: int) -> None:\n        super().__init__()\n        self.type = Name(\"CryptFilter\")\n        self.c_f_m = Name(mode)\n        self.length = int(length / 8)\n\n    def serialize(self) -> str:\n        obj_dict = build_obj_dict({key: getattr(self, key) for key in dir(self)})\n        return pdf_dict(obj_dict)",
      "language": "python"
    },
    {
      "code": "def serialize(self) -> str:\n    obj_dict = build_obj_dict({key: getattr(self, key) for key in dir(self)})\n    return pdf_dict(obj_dict)",
      "language": "python"
    },
    {
      "code": "class EncryptionDictionary(PDFObject):\n    \"\"\"\n    This class represents an encryption dictionary\n    PDF 32000 reference - Table 20\n    The PDF trailer must reference this object (/Encrypt)\n    \"\"\"\n\n    def __init__(self, security_handler: \"StandardSecurityHandler\") -> None:\n        super().__init__()\n        self.filter = Name(\"Standard\")\n        self.length = security_handler.key_length\n        self.r = security_handler.revision\n        self.o = f\"<{security_handler.o.upper()}>\"\n        self.u = f\"<{security_handler.u.upper()}>\"\n        if security_handler.revision == 6:\n            self.o_e = f\"<{security_handler.oe.upper()}>\"\n            self.u_e = f\"<{security_handler.ue.upper()}>\"\n            self.perms = f\"<{security_handler.perms.upper()}>\"\n        self.v = security_handler.version\n        self.p = int32(security_handler.access_permission)\n        if not security_handler.encrypt_metadata:\n            self.encrypt_metadata = \"false\"\n        if security_handler.cf:\n            self.c_f = pdf_dict({\"/StdCF\": security_handler.cf.serialize()})\n        if security_handler.encryption_method == EncryptionMethod.NO_ENCRYPTION:\n            self.stm_f = Name(\"Identity\")  # crypt filter for streams\n            self.str_f = Name(\"Identity\")  # crypt filter for strings\n        else:\n            self.stm_f = Name(\"StdCF\")  # crypt filter for streams\n            self.str_f = Name(\"StdCF\")  # crypt filter for strings",
      "language": "python"
    },
    {
      "code": "class StandardSecurityHandler:\n    \"\"\"\n    This class is referenced in the main PDF class and is used to handle all encryption functions\n        * Calculate password and hashes\n        * Provide encrypt method to be called by stream and strings\n        * Set the access permissions on the document\n    \"\"\"\n\n    DEFAULT_PADDING = (\n        b\"(\\xbfN^Nu\\x8aAd\\x00NV\\xff\\xfa\\x01\\x08..\\x00\\xb6\\xd0h>\\x80/\\x0c\\xa9\\xfedSiz\"\n    )\n\n    def __init__(\n        self,\n        fpdf: \"FPDF\",\n        owner_password: str,\n        user_password: Optional[str] = None,\n        permission: int | AccessPermission = AccessPermission.all(),\n        encryption_method: EncryptionMethod = EncryptionMethod.RC4,\n        encrypt_metadata: bool = False,\n    ):\n        self.fpdf = fpdf\n        self.access_permission = 0b11111111111111111111000011000000 | permission\n        self.owner_password = owner_password\n        self.user_password = user_password if user_password else \"\"\n        self.encryption_method = encryption_method\n        self.cf = None\n        self.key_length = 128\n\n        if import_error and self.encryption_method in (\n            EncryptionMethod.AES_128,\n            EncryptionMethod.AES_256,\n        ):\n            raise EnvironmentError(\n                \"cryptography module not available\"\n                \" - Try: 'pip install cryptography' or use RC4 encryption method\"\n                f\" - Import error was: {import_error}\"\n            )\n        if self.encryption_method == EncryptionMethod.AES_128:\n            self.version = 4\n            self.revision = 4\n            fpdf._set_min_pdf_version(\"1.6\")  # pyright: ignore[reportPrivateUsage]\n            self.cf = CryptFilter(mode=\"AESV2\", length=self.key_length)\n        elif self.encryption_method == EncryptionMethod.AES_256:\n            self.version = 5\n            self.revision = 6\n            fpdf._set_min_pdf_version(\"2.0\")  # pyright: ignore[reportPrivateUsage]\n            self.key_length = 256\n            self.cf = CryptFilter(mode=\"AESV3\", length=self.key_length)\n        elif self.encryption_method == EncryptionMethod.NO_ENCRYPTION:\n            self.version = 4\n            self.revision = 4\n            fpdf._set_min_pdf_version(\"1.6\")  # pyright: ignore[reportPrivateUsage]\n            self.cf = CryptFilter(mode=\"V2\", length=self.key_length)\n        else:\n            self.version = 2\n            self.revision = 3\n            fpdf._set_min_pdf_version(\"1.5\")  # pyright: ignore[reportPrivateUsage]\n            # not including crypt filter because it's only required on V=4\n            # if needed, it would be CryptFilter(mode=V2)\n\n        self.encrypt_metadata = encrypt_metadata\n\n    def generate_passwords(self, file_id: str) -> None:\n        \"\"\"File_id is the first hash of the PDF file id\"\"\"\n        self.file_id = file_id\n        self.info_id = file_id[1:33]\n        if self.revision == 6:\n            self.k = self.get_random_bytes(32)\n            self.generate_user_password_rev6()\n            self.generate_owner_password_rev6()\n            self.generate_perms_rev6()\n        else:\n            self.o = self.generate_owner_password()\n            self.k = self.generate_encryption_key()\n            self.u = self.generate_user_password()\n\n    def get_encryption_obj(self) -> EncryptionDictionary:\n        \"\"\"Return an encryption dictionary\"\"\"\n        return EncryptionDictionary(self)\n\n    def encrypt(\n        self, text: Union[str, bytearray, bytes], obj_id: int\n    ) -> Union[str, bytes]:\n        \"\"\"Method invoked by PDFObject and PDFContentStream to encrypt strings and streams\"\"\"\n        LOGGER.debug(\"Encrypting %s\", text)\n        return (\n            self.encrypt_stream(text, obj_id)\n            if isinstance(text, (bytes, bytearray))\n            else self.encrypt_string(text, obj_id)\n        )\n\n    def encrypt_string(self, string: str, obj_id: int) -> str:\n        if self.encryption_method == EncryptionMethod.NO_ENCRYPTION:\n            return PDFString(string, encrypt=False).serialize()\n        LOGGER.debug(\"Encrypting string: %s\", string)\n        try:\n            string.encode(\"latin-1\")\n            return f\"<{bytes(self.encrypt_bytes(string.encode('latin-1'), obj_id)).hex().upper()}>\"\n        except UnicodeEncodeError:\n            return f'<{hexlify(bytearray(self.encrypt_bytes(BOM_UTF16_BE + string.encode(\"utf-16-be\"), obj_id))).decode(\"latin-1\")}>'\n\n    def encrypt_stream(self, stream: bytes | bytearray, obj_id: int) -> bytes:\n        if self.encryption_method == EncryptionMethod.NO_ENCRYPTION:\n            return bytes(stream)\n        return bytes(self.encrypt_bytes(stream, obj_id))\n\n    def is_aes_algorithm(self) -> bool:\n        return self.encryption_method in (\n            EncryptionMethod.AES_128,\n            EncryptionMethod.AES_256,\n        )\n\n    def encrypt_bytes(self, data: bytes | bytearray, obj_id: int) -> Sequence[int]:\n        \"\"\"\n        PDF32000 reference - Algorithm 1: Encryption of data using the RC4 or AES algorithms\n        Append object ID and generation ID to the key and encrypt the data\n        Generation ID is fixed as 0. Will need to revisit if the application start changing generation ID\n        \"\"\"\n        h = hashlib.new(\"md5\", usedforsecurity=False)\n        h.update(self.k)\n        h.update(\n            (obj_id & 0xFFFFFF).to_bytes(3, byteorder=\"little\", signed=False)\n        )  # object id\n        h.update(\n            (0 & 0xFFFF).to_bytes(2, byteorder=\"little\", signed=False)\n        )  # generation id\n        if self.is_aes_algorithm():\n            h.update(bytes([0x73, 0x41, 0x6C, 0x54]))  # add salt (sAlT) for AES\n        key = h.digest()\n\n        if self.is_aes_algorithm():\n            return self.encrypt_AES_cryptography(key, data)\n        return ARC4().encrypt(key, data)\n\n    def encrypt_AES_cryptography(\n        self, key: bytes, data: bytes | bytearray\n    ) -> bytearray:\n        \"\"\"Encrypts an array of bytes using AES algorithms (AES 128 or AES 256)\"\"\"\n        iv = bytearray(self.get_random_bytes(16))\n        padder = PKCS7(128).padder()\n        padded_data = padder.update(data)\n        padded_data += padder.finalize()\n        cipher = (\n            Cipher(AES128(key), modes.CBC(iv))\n            if self.encryption_method == EncryptionMethod.AES_128\n            else Cipher(AES256(self.k), modes.CBC(iv))\n        )\n        encryptor = cipher.encryptor()\n        data = encryptor.update(padded_data) + encryptor.finalize()\n        iv.extend(data)\n        return iv\n\n    @classmethod\n    def get_random_bytes(cls: Type[\"StandardSecurityHandler\"], size: int) -> bytes:\n        \"\"\"\n        https://docs.python.org/3/library/os.html#os.urandom\n        os.urandom will use OS-specific sources to generate random bytes\n        suitable for cryptographic use\n        \"\"\"\n        return urandom(size)\n\n    @classmethod\n    def prepare_string(cls: Type[\"StandardSecurityHandler\"], string: str) -> bytes:\n        \"\"\"\n        PDF2.0 - ISO 32000-2:2020\n        All passwords for revision 6 shall be based on Unicode. Preprocessing of a user-provided password\n        consists first of normalizing its representation by applying the \"SASLPrep\" profile (Internet RFC 4013)\n        of the \"stringprep\" algorithm (Internet RFC 3454) to the supplied password using the Normalize and BiDi\n        options. Next, the password string shall be converted to UTF-8 encoding, and then truncated to the\n        first 127 bytes if the string is longer than 127 bytes\n\n        Python offers a stringprep module with the tables mapped in methods\n        \"\"\"\n\n        # Mapping\n        def char_map(char: str) -> str:\n            if not char:\n                return \"\"\n            # Commonly mapped to nothing\n            if stringprep.in_table_b1(char):\n                return \"\"\n            # Map non-ascii space characters to space\n            if stringprep.in_table_c12(char):\n                return \"\\u0020\"\n            return char\n\n        if len(string) < 1:\n            return bytes()\n\n        prepared_string = \"\".join(char_map(c) for c in string)\n\n        # Normalization - applies Unicode normalization form KC\n        prepared_string = unicodedata.ucd_3_2_0.normalize(\"NFKC\", prepared_string)\n\n        # Prohibited output - RCF4013 2.3\n        def is_prohibited(char: str) -> bool:\n            return (\n                stringprep.in_table_c12(char)  # Non-ASCII space characters\n                or stringprep.in_table_c21_c22(char)  # Control characters\n                or stringprep.in_table_c3(char)  # Private use\n                or stringprep.in_table_c4(char)  # Non-character code points\n                or stringprep.in_table_c5(char)  # Surrogate codes\n                or stringprep.in_table_c6(char)  # Inappropriate for plain text\n                or stringprep.in_table_c7(\n                    char\n                )  # Inappropriate for canonical representation\n                or stringprep.in_table_c8(\n                    char\n                )  # Change display properties or are deprecated\n                or stringprep.in_table_c9(char)  # Tagging characters\n            )\n\n        for char in prepared_string:\n            if is_prohibited(char):\n                raise FPDFException(\n                    f\"The password {string} contains prohibited characters\"\n                )\n\n        # Bidirectional characters\n        def has_character(string: str, fun: Callable[[str], bool]) -> bool:\n            return any(fun(char) for char in string)\n\n        if has_character(prepared_string, stringprep.in_table_d1):\n            # If a string contains any RandALCat character, the string MUST NOT contain any LCat character.\n            if has_character(prepared_string, stringprep.in_table_d2):\n                raise FPDFException(\n                    f\"The password {string} contains invalid bidirectional characters.\"\n                )\n            # If a string contains any RandALCat character, a RandALCat character MUST be the first character\n            # of the string, and a RandALCat character MUST be the last character of the string.\n            if not (\n                stringprep.in_table_d1(prepared_string[0])\n                and stringprep.in_table_d1(prepared_string[-1])\n            ):\n                raise FPDFException(\n                    f\"The password {string} contains invalid bidirectional characters.\"\n                )\n\n        if len(prepared_string) > 127:\n            prepared_string = prepared_string[:127]\n\n        return prepared_string.encode(\"UTF-8\")\n\n    def padded_password(self, password: str) -> bytearray:\n        \"\"\"\n        PDF32000 reference - Algorithm 2: Computing an encryption key\n        Step (a) - Add the default padding at the end of provided password to make it 32 bit long\n        \"\"\"\n        if len(password) > 32:\n            password = password[:32]\n        p = bytearray(password.encode(\"latin1\"))\n        p.extend(self.DEFAULT_PADDING[: (32 - len(p))])\n        return p\n\n    def generate_owner_password(self) -> str:\n        \"\"\"\n        PDF32000 reference - Algorithm 3: Computing the encryption dictionary's O (owner password) value\n        The security handler is only using revision 3 or 4, so the legacy r2 version is not implemented here\n        \"\"\"\n        m = bytes(self.padded_password(self.owner_password))\n        for _ in range(51):\n            m = md5(m)\n        rc4key = m[: (math.ceil(self.key_length / 8))]\n        result = self.padded_password(self.user_password)\n        for i in range(20):\n            new_key: list[int] = []\n            for k in rc4key:\n                new_key.append(k ^ i)\n            result = bytearray(ARC4().encrypt(bytes(new_key), result))\n        return bytes(result).hex()\n\n    def generate_user_password(self) -> str:\n        \"\"\"\n        PDF32000 reference - Algorithm 5: Computing the encryption dictionary's U (user password) value\n        The security handler is only using revision 3 or 4, so the legacy r2 version is not implemented here\n        \"\"\"\n        m = hashlib.new(\"md5\", usedforsecurity=False)\n        m.update(bytearray(self.DEFAULT_PADDING))\n        m.update(bytes.fromhex(self.info_id))\n        result = bytearray(m.digest())\n        key = self.k\n        for i in range(20):\n            new_key: list[int] = []\n            for k in key:\n                new_key.append(k ^ i)\n            result = bytearray(ARC4().encrypt(bytes(new_key), result))\n        result.extend(\n            (result[x] ^ self.DEFAULT_PADDING[x]) for x in range(16)\n        )  # add 16 bytes of random padding\n        return bytes(result).hex()\n\n    @classmethod\n    def compute_hash(\n        cls: Type[\"StandardSecurityHandler\"],\n        input_password: bytes | bytearray,\n        salt: bytes,\n        user_key: bytes | bytearray = bytearray(),\n    ) -> bytes:\n        \"\"\"\n        Algorithm 2B - section 7.6.4.3.4 of the ISO 32000-2:2020\n        Applied on Security handlers revision 6\n        \"\"\"\n        k = hashlib.sha256(input_password + salt + user_key).digest()\n        round_number = 0\n        while True:\n            round_number += 1\n            k1 = input_password + k + user_key\n            # Step (a + b)\n            cipher = Cipher(AES128(k[:16]), modes.CBC(k[16:32]))\n            encryptor = cipher.encryptor()\n            e = encryptor.update(k1 * 64) + encryptor.finalize()\n            # Step (c)\n            # remainder = int.from_bytes(e[:16], byteorder=\"big\") % 3\n            remainder = sum(e[:16]) % 3\n            # Step (d)\n            if remainder == 0:\n                k = hashlib.sha256(e).digest()\n            elif remainder == 1:\n                k = hashlib.sha384(e).digest()\n            else:\n                k = hashlib.sha512(e).digest()\n            # Step (e)\n            if round_number >= 64 and e[-1] <= round_number - 32:\n                break\n\n        return k[:32]\n\n    def generate_user_password_rev6(self) -> None:\n        \"\"\"\n        Generating the U (user password) and UE (user encryption)\n        for security handlers of revision 6\n        Algorithm 8 - Section 7.6.4.4.7 of the ISO 32000-2:2020\n        \"\"\"\n        user_password: bytes | bytearray = self.prepare_string(self.user_password)\n        if not user_password:\n            user_password = bytearray()\n        user_validation_salt = self.get_random_bytes(8)\n        user_key_salt = self.get_random_bytes(8)\n        u = (\n            self.compute_hash(input_password=user_password, salt=user_validation_salt)\n            + user_validation_salt\n            + user_key_salt\n        )\n        self.u = u.hex()\n\n        key = self.compute_hash(input_password=user_password, salt=user_key_salt)\n        cipher = Cipher(AES256(key), modes.CBC(b\"\\x00\" * 16))\n        encryptor = cipher.encryptor()\n        ue = encryptor.update(self.k) + encryptor.finalize()\n        self.ue = ue.hex()\n\n    def generate_owner_password_rev6(self) -> None:\n        \"\"\"\n        Generating the O (owner password) and OE (owner encryption)\n        for security handlers of revision 6\n        Algorithm 9 - Section 7.6.4.4.8 of the ISO 32000-2:2020\n        \"\"\"\n        owner_password = self.prepare_string(self.owner_password)\n        if not owner_password:\n            raise FPDFException(f\"Invalid owner password {self.owner_password}\")\n        owner_validation_salt = self.get_random_bytes(8)\n        owner_key_salt = self.get_random_bytes(8)\n        o = (\n            self.compute_hash(\n                input_password=owner_password,\n                salt=owner_validation_salt,\n                user_key=bytes.fromhex(self.u),\n            )\n            + owner_validation_salt\n            + owner_key_salt\n        )\n        self.o = o.hex()\n\n        key = self.compute_hash(\n            input_password=owner_password,\n            salt=owner_key_salt,\n            user_key=bytes.fromhex(self.u),\n        )\n\n        cipher = Cipher(AES256(key), modes.CBC(b\"\\x00\" * 16))\n        encryptor = cipher.encryptor()\n        oe = encryptor.update(self.k) + encryptor.finalize()\n        self.oe = oe.hex()\n\n    def generate_perms_rev6(self) -> None:\n        \"\"\"\n        7.6.4.4.9 Algorithm 10: Computing the encryption dictionary’s Perms (permissions) value\n        (Security handlers of revision 6) of the ISO 32000-2:2020\n        \"\"\"\n        perms64b = 0xFFFFFFFF00000000 | self.access_permission\n        encrypt_metadata = b\"T\" if self.encrypt_metadata else b\"F\"\n        perms_input = (\n            perms64b.to_bytes(8, byteorder=\"little\", signed=False)\n            + encrypt_metadata\n            + b\"adb\"\n            + self.get_random_bytes(4)\n        )\n        # nosemgrep: python.cryptography.security.insecure-cipher-mode-ecb.insecure-cipher-mode-ecb\n        cipher = Cipher(AES256(self.k), modes.ECB())\n        encryptor = cipher.encryptor()\n        perms = encryptor.update(perms_input) + encryptor.finalize()\n        self.perms = perms.hex()\n\n    def generate_encryption_key(self) -> bytes:\n        \"\"\"\n        PDF32000 reference\n        Algorithm 2: Computing an encryption key\n        \"\"\"\n        m = hashlib.new(\"md5\", usedforsecurity=False)\n        m.update(self.padded_password(self.user_password))\n        m.update(bytes.fromhex(self.o))\n        m.update(\n            (self.access_permission & 0xFFFFFFFF).to_bytes(\n                4, byteorder=\"little\", signed=False\n            )\n        )\n        m.update(bytes.fromhex(self.info_id))\n        if self.encrypt_metadata is False and self.version == 4:\n            m.update(bytes([0xFF, 0xFF, 0xFF, 0xFF]))\n        result = m.digest()[: (math.ceil(self.key_length / 8))]\n        for _ in range(50):\n            result = md5(result)[: (math.ceil(self.key_length / 8))]\n        return result",
      "language": "python"
    },
    {
      "code": "def encrypt(\n    self, text: Union[str, bytearray, bytes], obj_id: int\n) -> Union[str, bytes]:\n    \"\"\"Method invoked by PDFObject and PDFContentStream to encrypt strings and streams\"\"\"\n    LOGGER.debug(\"Encrypting %s\", text)\n    return (\n        self.encrypt_stream(text, obj_id)\n        if isinstance(text, (bytes, bytearray))\n        else self.encrypt_string(text, obj_id)\n    )",
      "language": "python"
    },
    {
      "code": "def encrypt_AES_cryptography(\n    self, key: bytes, data: bytes | bytearray\n) -> bytearray:\n    \"\"\"Encrypts an array of bytes using AES algorithms (AES 128 or AES 256)\"\"\"\n    iv = bytearray(self.get_random_bytes(16))\n    padder = PKCS7(128).padder()\n    padded_data = padder.update(data)\n    padded_data += padder.finalize()\n    cipher = (\n        Cipher(AES128(key), modes.CBC(iv))\n        if self.encryption_method == EncryptionMethod.AES_128\n        else Cipher(AES256(self.k), modes.CBC(iv))\n    )\n    encryptor = cipher.encryptor()\n    data = encryptor.update(padded_data) + encryptor.finalize()\n    iv.extend(data)\n    return iv",
      "language": "python"
    },
    {
      "code": "def encrypt_bytes(self, data: bytes | bytearray, obj_id: int) -> Sequence[int]:\n    \"\"\"\n    PDF32000 reference - Algorithm 1: Encryption of data using the RC4 or AES algorithms\n    Append object ID and generation ID to the key and encrypt the data\n    Generation ID is fixed as 0. Will need to revisit if the application start changing generation ID\n    \"\"\"\n    h = hashlib.new(\"md5\", usedforsecurity=False)\n    h.update(self.k)\n    h.update(\n        (obj_id & 0xFFFFFF).to_bytes(3, byteorder=\"little\", signed=False)\n    )  # object id\n    h.update(\n        (0 & 0xFFFF).to_bytes(2, byteorder=\"little\", signed=False)\n    )  # generation id\n    if self.is_aes_algorithm():\n        h.update(bytes([0x73, 0x41, 0x6C, 0x54]))  # add salt (sAlT) for AES\n    key = h.digest()\n\n    if self.is_aes_algorithm():\n        return self.encrypt_AES_cryptography(key, data)\n    return ARC4().encrypt(key, data)",
      "language": "python"
    },
    {
      "code": "def encrypt_stream(self, stream: bytes | bytearray, obj_id: int) -> bytes:\n    if self.encryption_method == EncryptionMethod.NO_ENCRYPTION:\n        return bytes(stream)\n    return bytes(self.encrypt_bytes(stream, obj_id))",
      "language": "python"
    },
    {
      "code": "def encrypt_string(self, string: str, obj_id: int) -> str:\n    if self.encryption_method == EncryptionMethod.NO_ENCRYPTION:\n        return PDFString(string, encrypt=False).serialize()\n    LOGGER.debug(\"Encrypting string: %s\", string)\n    try:\n        string.encode(\"latin-1\")\n        return f\"<{bytes(self.encrypt_bytes(string.encode('latin-1'), obj_id)).hex().upper()}>\"\n    except UnicodeEncodeError:\n        return f'<{hexlify(bytearray(self.encrypt_bytes(BOM_UTF16_BE + string.encode(\"utf-16-be\"), obj_id))).decode(\"latin-1\")}>'",
      "language": "python"
    },
    {
      "code": "def generate_encryption_key(self) -> bytes:\n    \"\"\"\n    PDF32000 reference\n    Algorithm 2: Computing an encryption key\n    \"\"\"\n    m = hashlib.new(\"md5\", usedforsecurity=False)\n    m.update(self.padded_password(self.user_password))\n    m.update(bytes.fromhex(self.o))\n    m.update(\n        (self.access_permission & 0xFFFFFFFF).to_bytes(\n            4, byteorder=\"little\", signed=False\n        )\n    )\n    m.update(bytes.fromhex(self.info_id))\n    if self.encrypt_metadata is False and self.version == 4:\n        m.update(bytes([0xFF, 0xFF, 0xFF, 0xFF]))\n    result = m.digest()[: (math.ceil(self.key_length / 8))]\n    for _ in range(50):\n        result = md5(result)[: (math.ceil(self.key_length / 8))]\n    return result",
      "language": "python"
    },
    {
      "code": "def generate_owner_password(self) -> str:\n    \"\"\"\n    PDF32000 reference - Algorithm 3: Computing the encryption dictionary's O (owner password) value\n    The security handler is only using revision 3 or 4, so the legacy r2 version is not implemented here\n    \"\"\"\n    m = bytes(self.padded_password(self.owner_password))\n    for _ in range(51):\n        m = md5(m)\n    rc4key = m[: (math.ceil(self.key_length / 8))]\n    result = self.padded_password(self.user_password)\n    for i in range(20):\n        new_key: list[int] = []\n        for k in rc4key:\n            new_key.append(k ^ i)\n        result = bytearray(ARC4().encrypt(bytes(new_key), result))\n    return bytes(result).hex()",
      "language": "python"
    },
    {
      "code": "def generate_owner_password_rev6(self) -> None:\n    \"\"\"\n    Generating the O (owner password) and OE (owner encryption)\n    for security handlers of revision 6\n    Algorithm 9 - Section 7.6.4.4.8 of the ISO 32000-2:2020\n    \"\"\"\n    owner_password = self.prepare_string(self.owner_password)\n    if not owner_password:\n        raise FPDFException(f\"Invalid owner password {self.owner_password}\")\n    owner_validation_salt = self.get_random_bytes(8)\n    owner_key_salt = self.get_random_bytes(8)\n    o = (\n        self.compute_hash(\n            input_password=owner_password,\n            salt=owner_validation_salt,\n            user_key=bytes.fromhex(self.u),\n        )\n        + owner_validation_salt\n        + owner_key_salt\n    )\n    self.o = o.hex()\n\n    key = self.compute_hash(\n        input_password=owner_password,\n        salt=owner_key_salt,\n        user_key=bytes.fromhex(self.u),\n    )\n\n    cipher = Cipher(AES256(key), modes.CBC(b\"\\x00\" * 16))\n    encryptor = cipher.encryptor()\n    oe = encryptor.update(self.k) + encryptor.finalize()\n    self.oe = oe.hex()",
      "language": "python"
    },
    {
      "code": "def generate_passwords(self, file_id: str) -> None:\n    \"\"\"File_id is the first hash of the PDF file id\"\"\"\n    self.file_id = file_id\n    self.info_id = file_id[1:33]\n    if self.revision == 6:\n        self.k = self.get_random_bytes(32)\n        self.generate_user_password_rev6()\n        self.generate_owner_password_rev6()\n        self.generate_perms_rev6()\n    else:\n        self.o = self.generate_owner_password()\n        self.k = self.generate_encryption_key()\n        self.u = self.generate_user_password()",
      "language": "python"
    },
    {
      "code": "def generate_perms_rev6(self) -> None:\n    \"\"\"\n    7.6.4.4.9 Algorithm 10: Computing the encryption dictionary’s Perms (permissions) value\n    (Security handlers of revision 6) of the ISO 32000-2:2020\n    \"\"\"\n    perms64b = 0xFFFFFFFF00000000 | self.access_permission\n    encrypt_metadata = b\"T\" if self.encrypt_metadata else b\"F\"\n    perms_input = (\n        perms64b.to_bytes(8, byteorder=\"little\", signed=False)\n        + encrypt_metadata\n        + b\"adb\"\n        + self.get_random_bytes(4)\n    )\n    # nosemgrep: python.cryptography.security.insecure-cipher-mode-ecb.insecure-cipher-mode-ecb\n    cipher = Cipher(AES256(self.k), modes.ECB())\n    encryptor = cipher.encryptor()\n    perms = encryptor.update(perms_input) + encryptor.finalize()\n    self.perms = perms.hex()",
      "language": "python"
    },
    {
      "code": "def generate_user_password(self) -> str:\n    \"\"\"\n    PDF32000 reference - Algorithm 5: Computing the encryption dictionary's U (user password) value\n    The security handler is only using revision 3 or 4, so the legacy r2 version is not implemented here\n    \"\"\"\n    m = hashlib.new(\"md5\", usedforsecurity=False)\n    m.update(bytearray(self.DEFAULT_PADDING))\n    m.update(bytes.fromhex(self.info_id))\n    result = bytearray(m.digest())\n    key = self.k\n    for i in range(20):\n        new_key: list[int] = []\n        for k in key:\n            new_key.append(k ^ i)\n        result = bytearray(ARC4().encrypt(bytes(new_key), result))\n    result.extend(\n        (result[x] ^ self.DEFAULT_PADDING[x]) for x in range(16)\n    )  # add 16 bytes of random padding\n    return bytes(result).hex()",
      "language": "python"
    },
    {
      "code": "def generate_user_password_rev6(self) -> None:\n    \"\"\"\n    Generating the U (user password) and UE (user encryption)\n    for security handlers of revision 6\n    Algorithm 8 - Section 7.6.4.4.7 of the ISO 32000-2:2020\n    \"\"\"\n    user_password: bytes | bytearray = self.prepare_string(self.user_password)\n    if not user_password:\n        user_password = bytearray()\n    user_validation_salt = self.get_random_bytes(8)\n    user_key_salt = self.get_random_bytes(8)\n    u = (\n        self.compute_hash(input_password=user_password, salt=user_validation_salt)\n        + user_validation_salt\n        + user_key_salt\n    )\n    self.u = u.hex()\n\n    key = self.compute_hash(input_password=user_password, salt=user_key_salt)\n    cipher = Cipher(AES256(key), modes.CBC(b\"\\x00\" * 16))\n    encryptor = cipher.encryptor()\n    ue = encryptor.update(self.k) + encryptor.finalize()\n    self.ue = ue.hex()",
      "language": "python"
    },
    {
      "code": "def get_encryption_obj(self) -> EncryptionDictionary:\n    \"\"\"Return an encryption dictionary\"\"\"\n    return EncryptionDictionary(self)",
      "language": "python"
    },
    {
      "code": "def is_aes_algorithm(self) -> bool:\n    return self.encryption_method in (\n        EncryptionMethod.AES_128,\n        EncryptionMethod.AES_256,\n    )",
      "language": "python"
    },
    {
      "code": "def padded_password(self, password: str) -> bytearray:\n    \"\"\"\n    PDF32000 reference - Algorithm 2: Computing an encryption key\n    Step (a) - Add the default padding at the end of provided password to make it 32 bit long\n    \"\"\"\n    if len(password) > 32:\n        password = password[:32]\n    p = bytearray(password.encode(\"latin1\"))\n    p.extend(self.DEFAULT_PADDING[: (32 - len(p))])\n    return p",
      "language": "python"
    }
  ],
  "patterns": [],
  "links": [
    "https://py-pdf.github.io/fpdf2/Encryption.html",
    "https://py-pdf.github.io/fpdf2/fpdf/encryption.html",
    "https://py-pdf.github.io/fpdf2/fpdf/syntax.html",
    "https://py-pdf.github.io/fpdf2/fpdf/enums.html",
    "https://py-pdf.github.io/fpdf2/fpdf/index.html"
  ]
}