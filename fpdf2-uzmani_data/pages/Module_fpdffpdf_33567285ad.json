{
  "url": "https://py-pdf.github.io/fpdf2/fpdf/fpdf.html",
  "title": "Module fpdf.fpdf",
  "content": "Supported page format names & dimensions\n\nReturn page width and height size in points.\n\nThrows FPDFPageFormatException\n\nformat can be either a 2-tuple or one of 'a3', 'a4', 'a5', 'letter', or 'legal'.\n\nIf format is a tuple, then the return value is the tuple's values given in the units specified on this document in the constructor, multiplied by the corresponding scale factor k, taken from instance variable self.k.\n\nIf format is a string, the (width, height) tuple returned is in points. For a width and height of 8.5 * 11, 72 dpi is assumed, so the value returned is (8.5 * 72, 11 * 72), or (612, 792). Additional formats can be added by adding fields to the PAGE_FORMATS dictionary with a case insensitive key (the name of the new format) and 2-tuple value of (width, height) in dots per inch with a 72 dpi resolution.\n\nInherited from: GraphicsStateMixin.DEFAULT_DRAW_COLOR\n\nThe type of the None singleton.\n\nInherited from: GraphicsStateMixin.DEFAULT_FILL_COLOR\n\nThe type of the None singleton.\n\nInherited from: GraphicsStateMixin.DEFAULT_TEXT_COLOR\n\nThe type of the None singleton.\n\nRender basic HTML to FPDF\n\nThe type of the None singleton.\n\nThe type of the None singleton.\n\nThe type of the None singleton.\n\nThe type of the None singleton.\n\nThe type of the None singleton.\n\nThe type of the None singleton.\n\nThe type of the None singleton.\n\nThe type of the None singleton.\n\nConvert a string or number to a floating-point number, if possible.\n\nThe type of the None singleton.\n\nReturns True when the argument is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.\n\nThe type of the None singleton.\n\nWhenever a page break condition is met, this @property method is called, and the break is issued or not depending on the returned value.\n\nThe default implementation returns self.auto_page_break, a value according to the mode selected by FPDF.set_auto_page_break().\n\nThis method is called automatically and should not be called directly by the application.\n\nDetailed documentation on page breaks: https://py-pdf.github.io/fpdf2/PageBreaks.html\n\nInherited from: GraphicsStateMixin.char_vpos\n\nReturn vertical character position relative to line. (docs)\n\nFont encoding, Latin-1 by default\n\nReturn a pair (width, height) in points units (1/72 of inch)\n\nInherited from: GraphicsStateMixin.denom_lift\n\nReturn lift factor for denominator text. (docs)\n\nInherited from: GraphicsStateMixin.denom_scale\n\nReturn scale factor for denominator text. (docs)\n\nThe current text emphasis: bold, italics, underline and/or strikethrough.\n\nEffective page height: the page height minus its vertical margins.\n\nEffective page width: the page width minus its horizontal margins.\n\nInherited from: GraphicsStateMixin.nom_lift\n\nReturn lift factor for nominator text. (docs)\n\nInherited from: GraphicsStateMixin.nom_scale\n\nReturn scale factor for nominator text. (docs)\n\nNote: Setting the page manually may result in unexpected behavior. pdf.add_page() takes special care to ensure the page's content stream matches FPDF's instance attributes. Manually setting the page does not.\n\nReturns the total pages of the document, at the time it is called.\n\nDo not use this in FPDF.header() or FPDF.footer(), as its value will not be the total page count. Uses {nb} instead, cf. FPDF.alias_nb_pages().\n\nSetting this to True restore the old behaviour before 2.7.9. Using a single /Resources object makes the resulting PDF document smaller, but is less compatible with the PDF spec.\n\nInherited from: GraphicsStateMixin.sub_lift\n\nReturn lift factor for subscript text. (docs)\n\nInherited from: GraphicsStateMixin.sub_scale\n\nReturn scale factor for subscript text. (docs)\n\nInherited from: GraphicsStateMixin.sup_lift\n\nReturn lift factor for superscript text. (docs)\n\nInherited from: GraphicsStateMixin.sup_scale\n\nReturn scale factor for superscript text. (docs)\n\nInherited from: GraphicsStateMixin._get_current_graphics_state\n\nRetrieve the current graphics state\n\nInherited from: GraphicsStateMixin._is_current_graphics_state_nested\n\nIndicate if a nested graphics state is active\n\nInherited from: GraphicsStateMixin._pop_local_stack\n\nPop the last graphics state on the stack\n\nInherited from: GraphicsStateMixin._push_local_stack\n\nPush a graphics state on the stack\n\nPuts an Action annotation on a rectangular area of the page.\n\nImports a TrueType or OpenType font and makes it available for later calls to the FPDF.set_font() method.\n\nYou will find more information on the \"Unicode\" documentation page.\n\nCreates a new internal link and returns its identifier. An internal link is a clickable area which directs to another place within the document.\n\nThe identifier can then be passed to the FPDF.cell(), FPDF.write(), FPDF.image() or FPDF.link() methods.\n\nIf a name is provided, creates a named destination that can be referenced later. Named destinations are more stable than plain links when pages are added or removed.\n\nAdds desired Output Intent to the Output Intents array:\n\ndest_output_profile (PDFICCProfile, required/optional): PDFICCProfile | None # (required if output_condition_identifier does not specify a standard production condition; optional otherwise) info (str, required/optional see dest_output_profile): human readable description of profile\n\nAdds a new page to the document. If a page is already present, the FPDF.footer() method is called first. Then the page is added, the current position is set to the top-left corner, with respect to the left and top margins, and the FPDF.header() method is called.\n\nAdds a text markup annotation on some quadrilateral areas of the page.\n\nDefines an alias for the total number of pages. It will be substituted as the document is closed.\n\nThis is useful to insert the number of pages of the document at a time when this number is not known by the program.\n\nThis substitution can be disabled for performances reasons, by calling alias_nb_pages(None).\n\nWhen using this feature with the FPDF.cell() / FPDF.multi_cell() methods, or the .underline / .strikethrough attributes of FPDF class, the width of the text rendered will take into account the alias length, not the length of the \"actual number of pages\" string, which can causes slight positioning differences.\n\nOutputs an arc. It can be drawn (border only), filled (with no border) or both.\n\nOutputs a quadratic or cubic Bézier curve, defined by three or four coordinates.\n\nPrints a cell (rectangular area) with optional borders, background color and character string. The upper-left corner of the cell corresponds to the current position. The text can be aligned or centered. After the call, the current position moves to the selected new_x/new_y position. It is possible to put a link on the text. A cell has an horizontal padding, on the left & right sides, defined by the.c_margin property.\n\nIf automatic page breaking is enabled and the cell goes beyond the limit, a page break is performed before outputting.\n\nReturns: a boolean indicating if page break was triggered\n\nOutputs a circle. It can be drawn (border only), filled (with no border) or both.\n\nWARNING: This method changed parameters in release 2.8.0\n\nDraw a dashed line between two points.\n\nDeprecated since version: 2.4.6\n\nUse FPDF.set_dash_pattern() and the normal drawing operations instead.\n\nAdd a pre-constructed path to the document.\n\nAdd a pre-constructed path to the document.\n\nCreate a context for drawing paths on the current page.\n\nIf this context manager is called again inside of an active context, it will raise an exception, as base drawing contexts cannot be nested.\n\nOutputs an ellipse. It can be drawn (border only), filled (with no border) or both.\n\nContext manager that defines an elliptic crop zone, useful to render only part of an image.\n\nEmbed a file into the PDF as an attachment (and, for PDF/A-3 or PDF/A-4f, as an Associated File).\n\nReturns: a PDFEmbeddedFile instance, with a .basename string attribute representing the internal file name\n\nPuts a file attachment annotation on a rectangular area of the page.\n\nThis method can be overridden in inherited classes in order to define a custom file identifier. Its output must have the format \"\". If this method returns a falsy value (None, empty string), no /ID will be inserted in the generated PDF document.\n\nInherited from: GraphicsStateMixin.font_face\n\nReturn a FontFace instance representing a subset of properties of this GraphicsState.\n\nFooter to be implemented in your own inherited class.\n\nThis is automatically called by FPDF.add_page() and FPDF.output() and should not be called directly by the user application. The default implementation performs nothing: you have to override this method in a subclass to implement your own rendering logic.\n\nPuts a free text annotation on a rectangular area of the page.\n\nReturns which fallback font has the requested glyph. This method can be overridden to provide more control than the select_mode parameter of FPDF.set_fallback_fonts() provides.\n\nRetrieves a named destination by its name and creates a link to it.\n\nReturn the current page PDFPageLabel. This will be displayed by some PDF readers to identify pages. FPDF.set_page_label() needs to be called first for those to be inserted.\n\nReturns the length of a string in user unit. A font must be selected. The value is calculated with stretching and spacing.\n\nNote that the width of a cell has some extra padding added to this width, on the left & right sides, equal to the .c_margin property.\n\nReturns the abscissa of the current position.\n\nReturns the ordinate of the current position.\n\nCreate a context for drawing paths for type 3 font glyphs, without writing on the current page.\n\nHeader to be implemented in your own inherited class\n\nThis is automatically called by FPDF.add_page() and should not be called directly by the user application. The default implementation performs nothing: you have to override this method in a subclass to implement your own rendering logic.\n\nNote that header rendering can have an impact on the initial (x,y) position when starting to render the page content.\n\nContext manager that adds a single highlight annotation based on the text lines inserted inside its indented block.\n\nPut an image on the page.\n\nThe size of the image on the page can be specified in different ways: * explicit width and height (expressed in user units) * one explicit dimension, the other being calculated automatically in order to keep the original proportions * no explicit dimension, in which case the image is put at 72 dpi. * explicit width and height (expressed in user units) and keep_aspect_ratio=True\n\nRemarks: * if an image is used several times, only one copy is embedded in the file. * when using an animated GIF, only the first frame is used.\n\nIf y is provided, this method will not trigger any page break; otherwise, auto page break detection will be performed.\n\nReturns: an instance of a subclass of ImageInfo.\n\nAdds add an ink annotation on the page.\n\nConfigure Table Of Contents rendering at the end of the document generation, and reserve some vertical space right now in order to insert it. At least one page break is triggered by this method.\n\nBarcode I2of5 (numeric), adds a 0 if odd length\n\nDraw a line between two points.\n\nPuts a link annotation on a rectangular area of the page. Text or image links are generally put via FPDF.cell(), FPDF.write() or FPDF.image(), but this method can be useful for instance to define a clickable area inside an image.\n\nLine Feed. The current abscissa goes back to the left margin and the ordinate increases by the amount passed as parameter.\n\nCreates a local graphics state, which won't affect the surrounding code. This method must be used as a context manager using with:\n\nThe affected settings are those controlled by GraphicsStateMixin and drawing.GraphicsStyle:\n\nFont size can be specified in document units with font_size or in points with font_size_pt.\n\nMethod to perform a reflection transformation over a given mirror line. It must be used as a context-manager using with:\n\nThe mirror transformation affects all elements which are rendered inside the indented context (with the exception of clickable areas).\n\nThis method allows printing text with line breaks. They can be automatic (breaking at the most recent space or soft-hyphen character) as soon as the text reaches the right border of the cell, or explicit (via the \\n character). As many cells as necessary are stacked, one below the other. Text can be aligned, centered or justified. The cell block can be framed and the background painted. A cell has an horizontal padding, on the left & right sides, defined by the.c_margin property.\n\nCenter overrides values for horizontal padding\n\nUsing new_x=XPos.RIGHT, new_y=XPos.TOP, maximum height=pdf.font_size is useful to build tables with multiline text in cells.\n\nReturns: a single value or a tuple, depending on the output parameter value\n\nCreate a path for appending lines and curves to.\n\nCheck that text input is in the correct format/encoding\n\nAll rendering performed in this context is made on a dummy FPDF object. This allows to test the results of some operations on the global layout before performing them \"for real\".\n\nOutput PDF to some destination. The method first calls close if necessary to terminate the document. After calling this method, content cannot be added to the document anymore.\n\nBy default the bytearray buffer is returned. If a name is given, the PDF is written to a new file.\n\nGet the current page number\n\nOutputs a polygon defined by three or more points.\n\nDraws lines between two or more points.\n\nRead an image and load it into memory.\n\nDeprecated since version: 2.7.7\n\nUse preload_image() instead.\n\nOutputs a rectangle. It can be drawn (border only), filled (with no border) or both.\n\nTOP_LEFT: a rectangle with round top left corner TOP_RIGHT: a rectangle with round top right corner BOTTOM_LEFT: a rectangle with round bottom left corner BOTTOM_RIGHT: a rectangle with round bottom right corner True: a rectangle with all round corners False: a rectangle with no round corners\n\nContext manager that defines a rectangular crop zone, useful to render only part of an image.\n\nOutputs a regular polygon with n sides It can be rotated Style can also be applied (fill, border…)\n\nDeprecated since version: 2.1.0\n\nUse FPDF.rotation() instead.\n\nMethod to perform a rotation around a given center. It must be used as a context-manager using with:\n\nThe rotation affects all elements which are printed inside the indented context (with the exception of clickable areas).\n\nOnly the rendering is altered. The FPDF.get_x() and FPDF.get_y() methods are not affected, nor the automatic page break mechanism. The rotation also establishes a local graphics state, so that any graphics state settings changed within will not affect the operations invoked after it has finished.\n\nContext manager that defines a circular crop zone, useful to render only part of an image.\n\nDefines the author of the document.\n\nauthor(str): the name of the author\n\nSet auto page break mode, and optionally the bottom margin that triggers it. By default, the mode is on and the bottom margin is 2 cm.\n\nDetailed documentation on page breaks: https://py-pdf.github.io/fpdf2/PageBreaks.html\n\nSets horizontal character spacing. A positive value increases the space between characters, a negative value reduces it (which may result in glyph overlap). By default, no spacing is set (which is equivalent to a value of 0).\n\nActivates or deactivates page compression.\n\nWhen activated, the internal representation of each page is compressed using the zlib/deflate method (FlateDecode), which leads to a compression ratio of about 2 for the resulting document.\n\nPage compression is enabled by default.\n\nSets Creation of Date time, or current time if None given.\n\nDefines the creator of the document. This is typically the name of the application that generates the PDF.\n\nSet the current dash pattern for lines and curves.\n\nOmitting 'dash' (= 0) resets the pattern to a solid line.\n\nDefines the way the document is to be displayed by the viewer.\n\nIt allows to set the zoom level: pages can be displayed entirely on screen, occupy the full width of the window, use the real size, be scaled by a specific zooming factor or use the viewer default (configured in its Preferences menu).\n\nThe page layout can also be specified: single page at a time, continuous display, two columns or viewer default.\n\nDefines a document option.\n\nvalue (str) option value\n\nDeprecated since version: 2.4.0\n\nSimply set the FPDF.core_fonts_encoding property as a replacement.\n\nDefines the color used for all stroking operations (lines, rectangles and cell borders). Accepts either a single greyscale value, 3 values as RGB components, a single #abc or #abcdef hexadecimal color string, or an instance of fpdf.drawing.DeviceCMYK, fpdf.drawing.DeviceRGB or fpdf.drawing.DeviceGray. The method can be called before the first page is created and the value is retained from page to page.\n\nActivate encryption of the document content.\n\nAllows you to specify a list of fonts to be used if any character is not available on the font currently set. Detailed documentation: https://py-pdf.github.io/fpdf2/Unicode.html#fallback-fonts\n\nDefines the color used for all filling operations (filled rectangles and cell backgrounds). Accepts either a single greyscale value, 3 values as RGB components, a single #abc or #abcdef hexadecimal color string, or an instance of fpdf.drawing.DeviceCMYK, fpdf.drawing.DeviceRGB or fpdf.drawing.DeviceGray. The method can be called before the first page is created and the value is retained from page to page.\n\nSets the font used to print character strings. It is mandatory to call this method at least once before printing text.\n\nDefault encoding is not specified, but all text writing methods accept only unicode for external fonts and one byte encoding for standard.\n\nStandard fonts use Latin-1 encoding by default, but Windows encoding cp1252 (Western Europe) can be used with self.core_fonts_encoding = encoding.\n\nThe font specified is retained from page to page. The method can be called before the first page is created.\n\nConfigure the font size in points\n\n[NEW in 2.8.4] Note that, when using LZWDecode, having NumPy installed will improve performances, reducing execution time.\n\nAssociate keywords with the document\n\nA language identifier specifying the natural language for all text in the document except where overridden by language specifications for structure elements or marked content. A language identifier can either be the empty text string, to indicate that the language is unknown, or a Language-Tag as defined in RFC 3066, \"Tags for the Identification of Languages\".\n\nSets the document left margin. Also sets the current FPDF.x on the page to this minimum horizontal position.\n\nDefines the line width of all stroking operations (lines, rectangles and cell borders). By default, the value equals 0.2 mm. The method can be called before the first page is created and the value is retained from page to page.\n\nDefines the page and position a link points to.\n\nSets the document right, left, top & bottom margins to the same value.\n\nSets the document left, top & optionally right margins to the same value. By default, they equal 1 cm. Also sets the current FPDF.y on the page to this minimum vertical position.\n\nSets a background color or image to be drawn every time FPDF.add_page() is called, or removes a previously set background. The method can be called before the first page is created and the value is retained from page to page.\n\nEnable PDFPageLabel to be inserted on every page. This will be displayed by some PDF readers to identify pages.\n\nSets the document right margin.\n\nDefines a style for section titles. After calling this method, calls to FPDF.start_section() will render section names visually.\n\nSets horizontal font stretching. By default, no stretching is set (which is equivalent to a value of 100).\n\nDefines the subject of the document.\n\nDefines the color used for text. Accepts either a single greyscale value, 3 values as RGB components, a single #abc or #abcdef hexadecimal color string, or an instance of fpdf.drawing.DeviceCMYK, fpdf.drawing.DeviceRGB or fpdf.drawing.DeviceGray. The method can be called before the first page is created and the value is retained from page to page.\n\nEnable or disable text shaping engine when rendering text. If features, direction, script or language are not specified the shaping engine will try to guess the values based on the input text.\n\nDefines the title of the document.\n\nMost PDF readers will display it when viewing the document. There is also a related ViewerPreferences entry:\n\nSets the document top margin.\n\nDefines the abscissa of the current position. If the value provided is negative, it is relative to the right of the page.\n\nDefines the abscissa and ordinate of the current position. If the values provided are negative, they are relative respectively to the right and bottom of the page.\n\nMoves the current abscissa back to the left margin and sets the ordinate. If the value provided is negative, it is relative to the bottom of the page.\n\nMethod to perform a skew transformation originating from a given center. It must be used as a context-manager using with:\n\nThe skew transformation affects all elements which are printed inside the indented context (with the exception of clickable areas).\n\nOutputs a solid arc. A solid arc combines an arc and a triangle to form a pie slice It can be drawn (border only), filled (with no border) or both.\n\nOutputs a regular star with n corners. It can be rotated. It can be drawn (border only), filled (with no border) or both.\n\nStart a section in the document outline. If section_title_styles have been configured, render the section name visually as a title.\n\nInserts a table, that can be built using the Table object yield. Detailed usage documentation: https://py-pdf.github.io/fpdf2/Tables.html\n\nPrints a character string. The origin is on the left of the first character, on the baseline. This method allows placing a string precisely on the page, but it is usually easier to use the FPDF.cell(), FPDF.multi_cell() or FPDF.write()` methods.\n\ntext() lacks many of the features available in FPDF.write(), FPDF.cell() and FPDF.multi_cell() like markdown and text shaping.\n\nPuts a text annotation on a rectangular area of the page.\n\nEstablish a layout with multiple columns to fill with text.\n\nEnsures that all rendering performed in this context appear on a single page by performing page break beforehand if need be.\n\nDetailed documentation on page breaks: https://py-pdf.github.io/fpdf2/PageBreaks.html\n\nUsing this method means to duplicate the FPDF bytearray buffer: when generating large PDFs, doubling memory usage may be troublesome.\n\nSets the provided FontFace in a local context, then restore font settings back to they were initially. This method must be used as a context manager using with:\n\nKnown limitation: in case of a page jump in this local context, the temporary style may \"leak\" in the header() & footer().\n\nCreate a context for using a shading pattern on the current page.\n\nLet you know if adding an element will trigger a page break, based on its height and the current ordinate (y position).\n\nDetailed documentation on page breaks: https://py-pdf.github.io/fpdf2/PageBreaks.html\n\nReturns: a boolean indicating if a page break would occur\n\nPrints text from the current position. When the right margin is reached, a line break occurs at the most recent space or soft-hyphen character, and text continues from the left margin. A manual break happens any time the \\n character is met, Upon method exit, the current position is left just at the end of the text.\n\nParse HTML and convert it to PDF. cf. https://py-pdf.github.io/fpdf2/HTML.html\n\nInformation about an image used in the PDF document (base class). We subclass this to distinguish between raster and vector images.\n\nIntrinsic image height\n\nOnly available if the image has been placed on the document\n\nOnly available if the image has been placed on the document\n\nIntrinsic image width\n\nMake an image fit within a bounding box, maintaining its proportions. In the reduced dimension it will be centered within the available space.\n\nInformation about a raster image used in the PDF document\n\nInherited from: ImageInfo.height\n\nIntrinsic image height\n\nInherited from: ImageInfo.rendered_height\n\nOnly available if the image has been placed on the document\n\nInherited from: ImageInfo.rendered_width\n\nOnly available if the image has been placed on the document\n\nInherited from: ImageInfo.width\n\nIntrinsic image width\n\nInherited from: ImageInfo.scale_inside_box\n\nMake an image fit within a bounding box, maintaining its proportions. In the reduced dimension it will be centered within the available space.\n\nValues described in PDF spec section 'Text Rendering Mode'\n\nThe type of the None singleton.\n\nThe type of the None singleton.\n\nThe type of the None singleton.\n\nThe type of the None singleton.\n\nThe type of the None singleton.\n\nThe type of the None singleton.\n\nThe type of the None singleton.\n\nThe type of the None singleton.\n\nInherited from: CoerciveIntEnum.coerce\n\nAttempt to coerce value into a member of this enumeration …\n\nSubclass of FontFace that allows to specify vertical & horizontal spacing\n\nInherited from: TextStyle.combine\n\nCreate a combined FontFace with all the supplied features of the two styles. When both the default and override styles provide a feature, prefer the …\n\nInherited from: TextStyle.replace\n\nCreate a new TextStyle instance, with new values for some attributes. Same as dataclasses.replace()\n\nInformation about a vector image used in the PDF document\n\nInherited from: ImageInfo.height\n\nIntrinsic image height\n\nInherited from: ImageInfo.rendered_height\n\nOnly available if the image has been placed on the document\n\nInherited from: ImageInfo.rendered_width\n\nOnly available if the image has been placed on the document\n\nInherited from: ImageInfo.width\n\nIntrinsic image width\n\nInherited from: ImageInfo.scale_inside_box\n\nMake an image fit within a bounding box, maintaining its proportions. In the reduced dimension it will be centered within the available space.\n\nPositional values in horizontal direction for use after printing text.\n\ncenter of actual text\n\nright end of actual text\n\nleft page margin (start of printable area)\n\nright end of the cell (default)\n\nright page margin (end of printable area)\n\nleft start of actual text\n\nfor write() to continue next (slightly left of END)\n\nInherited from: CoerciveEnum.coerce\n\nAttempt to coerce value into a member of this enumeration …\n\nPositional values in vertical direction for use after printing text\n\nbottom page margin (end of printable area)\n\ntop of the last line (same as TOP for single-line text)\n\ntop of next line (bottom of current text)\n\ntop page margin (start of printable area)\n\ntop of the first line (default)\n\nInherited from: CoerciveEnum.coerce\n\nAttempt to coerce value into a member of this enumeration …",
  "headings": [
    {
      "level": "h1",
      "text": "Module fpdf.fpdf",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Global variables",
      "id": "header-variables"
    },
    {
      "level": "h2",
      "text": "Functions",
      "id": "header-functions"
    },
    {
      "level": "h2",
      "text": "Classes",
      "id": "header-classes"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Class variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Notes",
      "id": "notes"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Returns",
      "id": "returns"
    },
    {
      "level": "h2",
      "text": "Raises",
      "id": "raises"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Notes",
      "id": "notes"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Notes",
      "id": "notes"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Notes",
      "id": "notes"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Subclasses",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Class variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Static methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Static methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Class variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Static methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Class variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Static methods",
      "id": ""
    }
  ],
  "code_samples": [
    {
      "code": "def get_page_format(\n    format: str | tuple[float, float], k: Optional[float] = None\n) -> tuple[float, float]:\n    \"\"\"Return page width and height size in points.\n\n    Throws FPDFPageFormatException\n\n    `format` can be either a 2-tuple or one of 'a3', 'a4', 'a5', 'letter', or\n    'legal'.\n\n    If format is a tuple, then the return value is the tuple's values\n    given in the units specified on this document in the constructor,\n    multiplied by the corresponding scale factor `k`, taken from instance\n    variable `self.k`.\n\n    If format is a string, the (width, height) tuple returned is in points.\n    For a width and height of 8.5 * 11, 72 dpi is assumed, so the value\n    returned is (8.5 * 72, 11 * 72), or (612, 792). Additional formats can be\n    added by adding fields to the `PAGE_FORMATS` dictionary with a\n    case insensitive key (the name of the new format) and 2-tuple value of\n    (width, height) in dots per inch with a 72 dpi resolution.\n    \"\"\"\n    if isinstance(format, str):\n        format = format.lower()\n        if format in PAGE_FORMATS:\n            if format == \"a5\":\n                warnings.warn(\n                    # This warning should be removed in the next release:\n                    \"Dimensions for page format A5 were fixed in release 2.8.5\"\n                )\n            return PAGE_FORMATS[format]\n        raise FPDFPageFormatException(format, unknown=True)\n\n    if k is None:\n        raise FPDFPageFormatException(str(format), one=True)\n\n    try:\n        return format[0] * k, format[1] * k\n    except Exception as e:\n        args = f\"{format}, {k}\"\n        raise FPDFPageFormatException(f\"Arguments must be numbers: {args}\") from e",
      "language": "python"
    },
    {
      "code": "class FPDF(GraphicsStateMixin, TextRegionMixin):\n    \"PDF Generation class\"\n\n    MARKDOWN_BOLD_MARKER = \"**\"\n    MARKDOWN_ITALICS_MARKER = \"__\"\n    MARKDOWN_STRIKETHROUGH_MARKER = \"~~\"\n    MARKDOWN_UNDERLINE_MARKER = \"--\"\n    MARKDOWN_ESCAPE_CHARACTER = \"\\\\\"\n    MARKDOWN_LINK_REGEX = re.compile(r\"^\\[([^][]+)\\]\\(([^()]+)\\)(.*)$\", re.DOTALL)\n    MARKDOWN_LINK_COLOR = None\n    MARKDOWN_LINK_UNDERLINE = True\n\n    HTML2FPDF_CLASS = HTML2FPDF\n\n    def __init__(\n        self,\n        orientation: Union[str, PageOrientation] = PageOrientation.PORTRAIT,\n        unit: Union[str, float] = \"mm\",\n        format: Union[str, tuple[float, float]] = \"A4\",\n        font_cache_dir: Literal[\"DEPRECATED\"] = \"DEPRECATED\",\n        *,\n        enforce_compliance: Optional[Union[str, DocumentCompliance]] = None,\n    ) -> None:\n        \"\"\"\n        Args:\n            orientation (str): possible values are \"portrait\" (can be abbreviated \"P\")\n                or \"landscape\" (can be abbreviated \"L\"). Default to \"portrait\".\n            unit (str, int, float): possible values are \"pt\", \"mm\", \"cm\", \"in\", or a number.\n                A point equals 1/72 of an inch, that is to say about 0.35 mm (an inch being 2.54 cm).\n                This is a very common unit in typography; font sizes are expressed in this unit.\n                If given a number, then it will be treated as the number of points per unit.  (eg. 72 = 1 in)\n                Default to \"mm\".\n            format (str): possible values are \"a3\", \"a4\", \"a5\", \"letter\", \"legal\" or a tuple\n                (width, height) expressed in the given unit. Default to \"a4\".\n            font_cache_dir (Path or str): [**DEPRECATED since v2.5.1**] unused\n        \"\"\"\n        if font_cache_dir != \"DEPRECATED\":\n            warnings.warn(\n                (\n                    '\"font_cache_dir\" parameter is deprecated since v2.5.1, '\n                    \"unused and will soon be removed\"\n                ),\n                DeprecationWarning,\n                stacklevel=get_stack_level(),\n            )\n        super().__init__()\n        self.single_resources_object = False\n        \"\"\"\n        Setting this to True restore the old behaviour before 2.7.9.\n        Using a single /Resources object makes the resulting PDF document smaller,\n        but is less compatible with the PDF spec.\n        \"\"\"\n        self.page = 0  # current page number\n        \"\"\"\n        Note: Setting the page manually may result in unexpected behavior.\n        `pdf.add_page()` takes special care to ensure the page's content stream\n        matches FPDF's instance attributes. Manually setting the page does not.\n        \"\"\"\n        # array of PDFPage objects starting at index 1:\n        self.pages: dict[int, PDFPage] = {}\n        # map page numbers to a set of font indices:\n        self.links: dict[int, DestinationXYZ] = (\n            {}\n        )  # Destination objects starting at index 1\n        self.named_destinations: dict[str, DestinationXYZ] = (\n            {}\n        )  # map names to Destination objects\n        self.embedded_files: list[PDFEmbeddedFile] = []  # array of PDFEmbeddedFile\n        self.image_cache = ImageCache()\n        self.in_footer = False  # flag set while rendering footer\n        # indicates that we are inside an .unbreakable() code block:\n        self._in_unbreakable = False\n        self._lasth: float = 0  # height of last cell printed\n        self.alias_nb_pages()  # enable alias by default\n\n        self._angle: float = 0  # used by deprecated method: rotate()\n        self.xmp_metadata = None\n        # Define the compression algorithm used when embedding images:\n        self.page_duration = 0  # optional pages display duration, cf. add_page()\n        self.page_transition = None  # optional pages transition, cf. add_page()\n        self.allow_images_transparency = True\n        # Do nothing by default. Allowed values: 'WARN', 'DOWNSCALE':\n        self.oversized_images: Optional[Literal[\"WARN\", \"DOWNSCALE\"]] = None\n        self.oversized_images_ratio = 2  # number of pixels per UserSpace point\n        self.struct_builder = StructureTreeBuilder()\n\n        self.toc_placeholder: Optional[ToCPlaceholder] = None\n        self._outline: list[OutlineSection] = []\n        # flag set true while rendering the table of contents\n        self.in_toc_rendering = False\n        # allow page insertion when writing the table of contents\n        self._toc_allow_page_insertion = False\n        self._toc_inserted_pages = 0  # number of pages inserted\n        # dict of Output Intents, with keys beings their subtypes:\n        self._output_intents: dict[Name, OutputIntentDictionary] = {}\n\n        self._sign_key = None\n        self.title = None\n        self.section_title_styles: dict[int, TextStyle] = {}  # level -> TextStyle\n\n        self.core_fonts_encoding = \"latin-1\"\n        \"Font encoding, Latin-1 by default\"\n        # Replace these fonts with these core fonts\n        self.font_aliases = {\n            \"arial\": \"helvetica\",\n            \"couriernew\": \"courier\",\n            \"timesnewroman\": \"times\",\n        }\n        # Scale factor\n        self.k = get_scale_factor(unit)\n\n        # Graphics state variables defined as properties by GraphicsStateMixin.\n        # We set their default values here.\n        self.font_family = \"\"  # current font family\n        # current font style (BOLD/ITALICS - does not handle UNDERLINE nor STRIKETHROUGH):\n        self.font_style = \"\"\n        self.underline = False\n        self.strikethrough = False\n        self.font_size_pt: float = 12  # current font size in points\n        self.font_stretching = 100  # current font stretching\n        self.char_spacing = 0  # current character spacing\n        self.current_font: Optional[CoreFont | TTFFont] = (\n            None  # None or an instance of CoreFont or TTFFont\n        )\n        self.current_font_is_set_on_page = False  # current font and size are already added to current page contents with _out\n        self.draw_color = self.DEFAULT_DRAW_COLOR\n        self.fill_color = self.DEFAULT_FILL_COLOR\n        self.text_color = self.DEFAULT_TEXT_COLOR\n        self.page_background = None\n        self.dash_pattern = dict(dash=0, gap=0, phase=0)\n        self.line_width = 0.567 / self.k  # line width (0.2 mm)\n        self.text_mode = TextMode.FILL\n        # end of graphics state variables\n\n        self.dw_pt, self.dh_pt = get_page_format(format, self.k)\n        self._set_orientation(orientation, self.dw_pt, self.dh_pt)\n        self.def_orientation = self.cur_orientation\n        # Page spacing\n        # Page margins (1 cm)\n        margin: float = (7200 / 254) / self.k\n        self.x: float = 0\n        self.y: float = 0\n        self.l_margin: float = 0\n        self.t_margin: float = 0\n        self.set_margins(margin, margin)\n        self.x, self.y = self.l_margin, self.t_margin\n        self.c_margin: float = margin / 10.0  # Interior cell margin (1 mm)\n        # sets self.auto_page_break, self.b_margin & self.page_break_trigger:\n        self.set_auto_page_break(True, 2 * margin)\n        self.set_display_mode(\"fullwidth\")  # Full width display mode\n        self._page_mode: Optional[PageMode] = None\n        self.viewer_preferences: Optional[\"ViewerPreferences\"] = (\n            None  # optional instance of ViewerPreferences\n        )\n        self.compress: bool = True  # switch enabling pages content compression\n        self.pdf_version: str = \"1.3\"  # Set default PDF version No.\n        self.creation_date: datetime = datetime.now(timezone.utc)\n        self._security_handler: Optional[StandardSecurityHandler] = None\n        self._fallback_font_ids: list[str] = []\n        self._fallback_font_exact_match = False\n        self.render_color_fonts: bool = True\n        self._compliance: Optional[DocumentCompliance] = (\n            DocumentCompliance.coerce(enforce_compliance)\n            if enforce_compliance\n            else None\n        )\n        if self._compliance:\n            if self._compliance.profile == \"PDFA\" and self._compliance.part == 1:\n                self._set_min_pdf_version(\"1.4\")\n                self.allow_images_transparency = False\n            if self._compliance.profile == \"PDFA\" and self._compliance.part in (2, 3):\n                self._set_min_pdf_version(\"1.7\")\n            if self._compliance.profile == \"PDFA\" and self._compliance.part == 4:\n                self._set_min_pdf_version(\"2.0\")\n\n        self._current_draw_context: Optional[DrawingContext] = None\n        # map page numbers to a set of GraphicsState names:\n        self._record_text_quad_points = False\n        self._resource_catalog: ResourceCatalog = ResourceCatalog()\n\n        # page number -> array of 8 × n numbers:\n        self._text_quad_points: dict[int, list[float]] = defaultdict(list)\n\n        # final buffer holding the PDF document in-memory - defined only after calling output():\n        self.buffer: Optional[bytearray] = None\n\n    @property\n    def fonts(self) -> dict[str, CoreFont | TTFFont]:\n        return self._resource_catalog.font_registry\n\n    def set_encryption(\n        self,\n        owner_password: str,\n        user_password: Optional[str] = None,\n        encryption_method: EncryptionMethod = EncryptionMethod.RC4,\n        permissions: int = AccessPermission.all(),\n        encrypt_metadata: bool = False,\n    ) -> None:\n        \"\"\"\n        Activate encryption of the document content.\n\n        Args:\n            owner_password (str): mandatory. The owner password allows to perform any change on the document,\n                including removing all encryption and access permissions.\n            user_password (str): optional. If a user password is set, the content of the document will be encrypted\n                and a password prompt displayed when a user opens the document.\n                The document will only be displayed after either the user or owner password is entered.\n            encryption_method (fpdf.enums.EncryptionMethod, str): algorithm to be used to encrypt the document.\n                Defaults to RC4.\n            permissions (fpdf.enums.AccessPermission): specify access permissions granted\n                when the document is opened with user access. Defaults to ALL.\n            encrypt_metadata (bool): whether to also encrypt document metadata (author, creation date, etc.).\n                Defaults to False.\n        \"\"\"\n        if self._compliance and self._compliance.profile == \"PDFA\":\n            raise PDFAComplianceError(\n                f\"Encryption is now allowed for documents compliant with {self._compliance.label}\"\n            )\n\n        self._security_handler = StandardSecurityHandler(\n            self,\n            owner_password=owner_password,\n            user_password=user_password,\n            permission=permissions,\n            encryption_method=encryption_method,\n            encrypt_metadata=encrypt_metadata,\n        )\n\n    def write_html(self, text: str, *args: Any, **kwargs: Any) -> None:\n        \"\"\"\n        Parse HTML and convert it to PDF.\n        cf. https://py-pdf.github.io/fpdf2/HTML.html\n\n        Args:\n            text (str): HTML content to render\n            image_map (function): an optional one-argument function that map `<img>` \"src\" to new image URLs\n            li_tag_indent (int): [**DEPRECATED since v2.7.9**]\n                numeric indentation of `<li>` elements - Set `tag_styles` instead\n            dd_tag_indent (int): [**DEPRECATED since v2.7.9**]\n                numeric indentation of `<dd>` elements - Set `tag_styles` instead\n            table_line_separators (bool): enable horizontal line separators in `<table>`. Defaults to `False`.\n            ul_bullet_char (str): bullet character preceding `<li>` items in `<ul>` lists.\n                Can also be configured using the HTML `type` attribute of `<ul>` tags.\n            li_prefix_color (tuple, str, fpdf.drawing.DeviceCMYK, fpdf.drawing.DeviceGray, fpdf.drawing.DeviceRGB): color for bullets\n                or numbers preceding `<li>` tags. This applies to both `<ul>` & `<ol>` lists.\n            heading_sizes (dict): [**DEPRECATED since v2.7.9**]\n                font size per heading level names (\"h1\", \"h2\"...) - Set `tag_styles` instead\n            pre_code_font (str): [**DEPRECATED since v2.7.9**]\n                font to use for `<pre>` & `<code>` blocks - Set `tag_styles` instead\n            warn_on_tags_not_matching (bool): control warnings production for unmatched HTML tags. Defaults to `True`.\n            tag_indents (dict): [**DEPRECATED since v2.8.0**]\n                mapping of HTML tag names to numeric values representing their horizontal left indentation. - Set `tag_styles` instead\n            tag_styles (dict[str, fpdf.fonts.TextStyle]): mapping of HTML tag names to `fpdf.fonts.TextStyle` or `fpdf.fonts.FontFace` instances\n        \"\"\"\n        html2pdf = self.HTML2FPDF_CLASS(self, *args, **kwargs)\n        with self.local_context():\n            html2pdf.feed(text)\n\n    def _set_min_pdf_version(self, version: str) -> None:\n        self.pdf_version = max(self.pdf_version, version)\n\n    @property\n    def emphasis(self) -> TextEmphasis:\n        \"The current text emphasis: bold, italics, underline and/or strikethrough.\"\n        font_style = self.font_style\n        if self.strikethrough:\n            font_style += \"S\"\n        if self.underline:\n            font_style += \"U\"\n        return TextEmphasis.coerce(font_style)\n\n    @property\n    def is_ttf_font(self) -> bool:\n        return self.current_font is not None and self.current_font.type == \"TTF\"\n\n    @property\n    def page_mode(self) -> Optional[PageMode]:\n        return self._page_mode\n\n    @page_mode.setter\n    def page_mode(self, page_mode: PageMode | str) -> None:\n        self._page_mode = PageMode.coerce(page_mode)\n        if self._page_mode == PageMode.USE_ATTACHMENTS:\n            self._set_min_pdf_version(\"1.6\")\n        elif self._page_mode == PageMode.USE_OC:\n            self._set_min_pdf_version(\"1.5\")\n\n    @property\n    def output_intents(self) -> ValuesView[OutputIntentDictionary]:\n        return self._output_intents.values()\n\n    def add_output_intent(\n        self,\n        subtype: OutputIntentSubType,\n        output_condition_identifier: Optional[str] = None,\n        output_condition: Optional[str] = None,\n        registry_name: Optional[str] = None,\n        dest_output_profile: Optional[PDFICCProfile] = None,\n        info: Optional[str] = None,\n    ) -> None:\n        \"\"\"\n        Adds desired Output Intent to the Output Intents array:\n\n        Args:\n            subtype (OutputIntentSubType, required): PDFA, PDFX or ISOPDF\n            output_condition_identifier (str, required): see the Name in\n                https://www.color.org/registry.xalter\n            output_condition (str, optional): see the Definition in\n                https://www.color.org/registry.xalter\n            registry_name (str, optional): \"https://www.color.org\"\n            dest_output_profile (PDFICCProfile, required/optional):\n                PDFICCProfile | None # (required  if\n                output_condition_identifier does not specify a standard\n                production condition; optional otherwise)\n            info (str, required/optional see dest_output_profile): human\n                readable description of profile\n        \"\"\"\n        if subtype.value in self._output_intents:\n            raise ValueError(\n                \"add_output_intent: subtype '\" + subtype.value + \"' already exists.\"\n            )\n        self._output_intents[subtype.value] = OutputIntentDictionary(\n            subtype,\n            output_condition_identifier,\n            output_condition,\n            registry_name,\n            dest_output_profile,\n            info,\n        )\n        self._set_min_pdf_version(\"1.4\")\n\n    @property\n    def epw(self) -> float:\n        \"\"\"\n        Effective page width: the page width minus its horizontal margins.\n        \"\"\"\n        return self.w - self.l_margin - self.r_margin\n\n    @property\n    def eph(self) -> float:\n        \"\"\"\n        Effective page height: the page height minus its vertical margins.\n        \"\"\"\n        return self.h - self.t_margin - self.b_margin\n\n    @property\n    def pages_count(self) -> int:\n        \"\"\"\n        Returns the total pages of the document, at the time it is called.\n\n        Do not use this in `fpdf.fpdf.FPDF.header()` or `fpdf.fpdf.FPDF.footer()`,\n        as its value will not be the total page count.\n        Uses `{nb}` instead, _cf._ `fpdf.fpdf.FPDF.alias_nb_pages()`.\n        \"\"\"\n        return len(self.pages)\n\n    def set_margin(self, margin: float) -> None:\n        \"\"\"\n        Sets the document right, left, top & bottom margins to the same value.\n\n        Args:\n            margin (float): margin in the unit specified to FPDF constructor\n        \"\"\"\n        self.set_margins(margin, margin)\n        self.set_auto_page_break(self.auto_page_break, margin)\n\n    def set_margins(self, left: float, top: float, right: float = -1) -> None:\n        \"\"\"\n        Sets the document left, top & optionally right margins to the same value.\n        By default, they equal 1 cm.\n        Also sets the current FPDF.y on the page to this minimum vertical position.\n\n        Args:\n            left (float): left margin in the unit specified to FPDF constructor\n            top (float): top margin in the unit specified to FPDF constructor\n            right (float): optional right margin in the unit specified to FPDF constructor\n        \"\"\"\n        self.set_left_margin(left)\n        if self.y < top or self.y == self.t_margin:\n            self.y = top\n        self.t_margin = top\n        if right == -1:\n            right = left\n        self.r_margin = right\n\n    def set_left_margin(self, margin: float) -> None:\n        \"\"\"\n        Sets the document left margin.\n        Also sets the current FPDF.x on the page to this minimum horizontal position.\n\n        Args:\n            margin (float): margin in the unit specified to FPDF constructor\n        \"\"\"\n        if self.x < margin or self.x == self.l_margin:\n            self.x = margin\n        self.l_margin = margin\n\n    def set_top_margin(self, margin: float) -> None:\n        \"\"\"\n        Sets the document top margin.\n\n        Args:\n            margin (float): margin in the unit specified to FPDF constructor\n        \"\"\"\n        self.t_margin = margin\n\n    def set_right_margin(self, margin: float) -> None:\n        \"\"\"\n        Sets the document right margin.\n\n        Args:\n            margin (float): margin in the unit specified to FPDF constructor\n        \"\"\"\n        self.r_margin = margin\n\n    def set_auto_page_break(self, auto: bool, margin: float = 0) -> None:\n        \"\"\"\n        Set auto page break mode, and optionally the bottom margin that triggers it.\n        By default, the mode is on and the bottom margin is 2 cm.\n\n        Detailed documentation on page breaks: https://py-pdf.github.io/fpdf2/PageBreaks.html\n\n        Args:\n            auto (bool): enable or disable this mode\n            margin (float): optional bottom margin (distance from the bottom of the page)\n                in the unit specified to FPDF constructor\n        \"\"\"\n        self.auto_page_break: bool = auto\n        self.b_margin: float = margin\n        self.page_break_trigger: float = self.h - self.b_margin\n\n    @property\n    def default_page_dimensions(self) -> tuple[float, float]:\n        \"Return a pair (width, height) in points units (1/72 of inch)\"\n        return (\n            (self.dw_pt, self.dh_pt)\n            if self.def_orientation == PageOrientation.PORTRAIT\n            else (self.dh_pt, self.dw_pt)\n        )\n\n    def _set_orientation(\n        self,\n        orientation: str | PageOrientation,\n        page_width_pt: float,\n        page_height_pt: float,\n    ) -> None:\n        self.cur_orientation = PageOrientation.coerce(orientation)\n        if self.cur_orientation is PageOrientation.PORTRAIT:\n            self.w_pt = page_width_pt\n            self.h_pt = page_height_pt\n        else:\n            self.w_pt = page_height_pt\n            self.h_pt = page_width_pt\n        self.w = self.w_pt / self.k\n        self.h = self.h_pt / self.k\n        if hasattr(self, \"auto_page_break\"):  # not set when called from constructor\n            # When self.h is modified, the .page_break_trigger must be re-computed:\n            self.set_auto_page_break(self.auto_page_break, self.b_margin)\n\n    def set_display_mode(\n        self,\n        zoom: str | float,\n        layout: str = \"continuous\",\n    ) -> None:\n        \"\"\"\n        Defines the way the document is to be displayed by the viewer.\n\n        It allows to set the zoom level: pages can be displayed entirely on screen,\n        occupy the full width of the window, use the real size,\n        be scaled by a specific zooming factor or use the viewer default (configured in its Preferences menu).\n\n        The page layout can also be specified: single page at a time, continuous display, two columns or viewer default.\n\n        Args:\n            zoom: either \"fullpage\", \"fullwidth\", \"real\", \"default\",\n                or a number indicating the zooming factor to use, interpreted as a percentage.\n                The zoom level set by default is \"default\".\n            layout (fpdf.enums.PageLayout, str): allowed layout aliases are \"single\", \"continuous\", \"two\" or \"default\",\n                meaning to use the viewer default mode.\n                The layout set by default is \"continuous\".\n        \"\"\"\n        if zoom in ZOOM_CONFIGS or not isinstance(zoom, str):\n            self.zoom_mode = zoom\n        elif zoom != \"default\":\n            raise FPDFException(f\"Incorrect zoom display mode: {zoom}\")\n        if isinstance(layout, PageLayout):\n            self.page_layout = layout\n        else:\n            # First support legacy aliases like \"continuous\"/\"single\"/\"default\"\n            alias_layout = LAYOUT_ALIASES.get(str(layout))\n            if alias_layout is not None or str(layout) in LAYOUT_ALIASES:\n                self.page_layout = alias_layout\n            else:\n                try:\n                    self.page_layout = PageLayout.coerce(str(layout))\n                except (ValueError, TypeError) as exc:\n                    raise FPDFException(\n                        f\"Incorrect layout display mode: {layout}\"\n                    ) from exc\n\n    def set_text_shaping(\n        self,\n        use_shaping_engine: bool = True,\n        features: Optional[dict[str, Any]] = None,\n        direction: Optional[str | TextDirection] = None,\n        script: Optional[str] = None,\n        language: Optional[str] = None,\n    ) -> None:\n        \"\"\"\n        Enable or disable text shaping engine when rendering text.\n        If features, direction, script or language are not specified the shaping engine will try\n        to guess the values based on the input text.\n\n        Args:\n            use_shaping_engine: enable or disable the use of the shaping engine to process the text\n            features: a dictionary containing 4 digit OpenType features and whether each feature\n                should be enabled or disabled\n                example: features={\"kern\": False, \"liga\": False}\n            direction: the direction the text should be rendered, either \"ltr\" (left to right)\n                or \"rtl\" (right to left).\n            script: a valid OpenType script tag like \"arab\" or \"latn\"\n            language: a valid OpenType language tag like \"eng\" or \"fra\"\n        \"\"\"\n        if not use_shaping_engine:\n            self.text_shaping = None\n            return\n\n        try:\n            # pylint: disable=import-outside-toplevel, unused-import\n            import uharfbuzz  # pyright: ignore[reportUnusedImport]\n        except ImportError as exc:\n            raise FPDFException(\n                \"The uharfbuzz package could not be imported, but is required for text shaping. Try: pip install uharfbuzz\"\n            ) from exc\n\n        #\n        # Features must be a dictionary containing opentype features and a boolean flag\n        # stating whether the feature should be enabled or disabled.\n        #\n        # e.g. features={\"liga\": True, \"kern\": False}\n        #\n        # https://harfbuzz.github.io/shaping-opentype-features.html\n        #\n\n        if features and not isinstance(features, dict):\n            raise FPDFException(\n                \"Features must be a dictionary. See text shaping documentation\"\n            )\n        if not features:\n            features = {}\n\n        # Buffer properties (direction, script and language)\n        # if the properties are not provided, Harfbuzz \"guessing\" logic is used.\n        # https://harfbuzz.github.io/setting-buffer-properties.html\n        # Valid harfbuzz directions are ltr (left to right), rtl (right to left),\n        # ttb (top to bottom) or btt (bottom to top)\n\n        text_direction = None\n        if direction:\n            text_direction = (\n                direction\n                if isinstance(direction, TextDirection)\n                else TextDirection.coerce(direction)\n            )\n            if text_direction not in [TextDirection.LTR, TextDirection.RTL]:\n                raise FPDFException(\n                    \"FPDF2 only accept ltr (left to right) or rtl (right to left) directions for now.\"\n                )\n\n        self.text_shaping = {\n            \"use_shaping_engine\": True,\n            \"features\": features,\n            \"direction\": text_direction,\n            \"script\": script,\n            \"language\": language,\n            \"fragment_direction\": None,\n            \"paragraph_direction\": None,\n        }\n\n    @property\n    def page_layout(self) -> Optional[PageLayout]:\n        return self._page_layout\n\n    @page_layout.setter\n    def page_layout(self, page_layout: Optional[str | PageLayout]) -> None:\n        self._page_layout = PageLayout.coerce(page_layout) if page_layout else None\n        if self._page_layout in (PageLayout.TWO_PAGE_LEFT, PageLayout.TWO_PAGE_RIGHT):\n            self._set_min_pdf_version(\"1.5\")\n\n    def set_compression(self, compress: bool) -> None:\n        \"\"\"\n        Activates or deactivates page compression.\n\n        When activated, the internal representation of each page is compressed\n        using the zlib/deflate method (FlateDecode), which leads to a compression ratio\n        of about 2 for the resulting document.\n\n        Page compression is enabled by default.\n\n        Args:\n            compress (bool): indicates if compression should be enabled\n        \"\"\"\n        self.compress = compress\n\n    def set_title(self, title: str) -> None:\n        \"\"\"\n        Defines the title of the document.\n\n        Most PDF readers will display it when viewing the document.\n        There is also a related `fpdf.prefs.ViewerPreferences` entry:\n\n            pdf.viewer_preferences = ViewerPreferences(display_doc_title=True)\n\n        Args:\n            title (str): the title\n        \"\"\"\n        self.title = title\n\n    def set_lang(self, lang: str) -> None:\n        \"\"\"\n        A language identifier specifying the natural language for all text in the document\n        except where overridden by language specifications for structure elements or marked content.\n        A language identifier can either be the empty text string, to indicate that the language is unknown,\n        or a Language-Tag as defined in RFC 3066, \"Tags for the Identification of Languages\".\n\n        Args:\n            lang (str): the document main language\n        \"\"\"\n        self.lang = lang\n        if lang:\n            self._set_min_pdf_version(\"1.4\")\n\n    def set_subject(self, subject: str) -> None:\n        \"\"\"\n        Defines the subject of the document.\n\n        Args:\n            subject (str): the document main subject\n        \"\"\"\n        self.subject = subject\n\n    def set_author(self, author: str | Sequence[str]) -> None:\n        \"\"\"\n        Defines the author of the document.\n\n        Args:\n            author(str): the name of the author\n        \"\"\"\n        self.author = author\n\n    def set_keywords(self, keywords: str | Sequence[str]) -> None:\n        \"\"\"\n        Associate keywords with the document\n\n        Args:\n            keywords (str): a space-separated list of words\n        \"\"\"\n        self.keywords = keywords\n\n    def set_creator(self, creator: str) -> None:\n        \"\"\"\n        Defines the creator of the document.\n        This is typically the name of the application that generates the PDF.\n\n        Args:\n            creator (str): name of the PDF creator\n        \"\"\"\n        self.creator = creator\n\n    def set_producer(self, producer: str) -> None:\n        \"\"\"Producer of document\"\"\"\n        self.producer = producer\n\n    def set_creation_date(self, date: Optional[datetime] = None) -> None:\n        \"\"\"Sets Creation of Date time, or current time if None given.\"\"\"\n        if self._sign_key:\n            raise FPDFException(\n                \".set_creation_date() must always be called before .sign*() methods\"\n            )\n        if not isinstance(date, datetime):\n            raise TypeError(f\"date should be a datetime but is a {type(date)}\")\n        if not date.tzinfo:\n            date = date.astimezone()\n        self.creation_date = date\n\n    def set_xmp_metadata(self, xmp_metadata: str) -> None:\n        if \"<?xpacket\" in xmp_metadata[:50]:\n            raise ValueError(\n                \"fpdf2 already performs XMP metadata wrapping in a <?xpacket> tag\"\n            )\n        self.xmp_metadata = xmp_metadata\n        if xmp_metadata:\n            self._set_min_pdf_version(\"1.4\")\n\n    def set_doc_option(self, opt: Literal[\"core_fonts_encoding\"], value: str) -> None:\n        \"\"\"\n        Defines a document option.\n\n        Args:\n            opt (str): name of the option to set\n            value (str) option value\n\n        .. deprecated:: 2.4.0\n            Simply set the `FPDF.core_fonts_encoding` property as a replacement.\n        \"\"\"\n        warnings.warn(\n            (\n                \"set_doc_option() is deprecated since v2.4.0 \"\n                \"and will be removed in a future release. \"\n                \"Simply set the `.core_fonts_encoding` property as a replacement.\"\n            ),\n            DeprecationWarning,\n            stacklevel=get_stack_level(),\n        )\n        if opt != \"core_fonts_encoding\":\n            raise FPDFException(f'Unknown document option \"{opt}\"')\n        self.core_fonts_encoding = value\n\n    def set_image_filter(self, image_filter: str) -> None:\n        \"\"\"\n        Args:\n            image_filter (str): name of a the image filter to use\n                when embedding images in the document, or \"AUTO\",\n                meaning to use the best image filter given the images provided.\n                Allowed values: `FlateDecode` (lossless zlib/deflate compression),\n                `DCTDecode` (lossy compression with JPEG)\n                `LZWDecode` (Lempel-Ziv-Welch aka LZW compression)\n                and `JPXDecode` (lossy compression with JPEG2000).\n\n        [**NEW in 2.8.4**] Note that, when using `LZWDecode`, having NumPy installed\n        will improve performances, reducing execution time.\n        \"\"\"\n        if image_filter not in SUPPORTED_IMAGE_FILTERS:\n            raise ValueError(\n                f\"'{image_filter}' is not a supported image filter\"\n                f\" - Allowed values: {''.join(SUPPORTED_IMAGE_FILTERS)}\"\n            )\n        self.image_cache.image_filter = cast(ImageFilter, image_filter)\n        if image_filter == \"JPXDecode\":\n            self._set_min_pdf_version(\"1.5\")\n\n    def alias_nb_pages(self, alias: str = \"{nb}\") -> None:\n        \"\"\"\n        Defines an alias for the total number of pages.\n        It will be substituted as the document is closed.\n\n        This is useful to insert the number of pages of the document\n        at a time when this number is not known by the program.\n\n        This substitution can be disabled for performances reasons, by calling `alias_nb_pages(None)`.\n\n        Args:\n            alias (str): the alias. Defaults to `\"{nb}\"`.\n\n        Notes\n        -----\n\n        When using this feature with the `FPDF.cell` / `FPDF.multi_cell` methods,\n        or the `.underline` / `.strikethrough` attributes of `FPDF` class,\n        the width of the text rendered will take into account the alias length,\n        not the length of the \"actual number of pages\" string,\n        which can causes slight positioning differences.\n        \"\"\"\n        self.str_alias_nb_pages = alias\n\n    @check_page\n    def set_page_label(\n        self,\n        label_style: Optional[str | PageLabelStyle] = None,\n        label_prefix: Optional[str] = None,\n        label_start: Optional[int] = None,\n    ) -> None:\n        \"\"\"\n        Enable `fpdf.output.PDFPageLabel` to be inserted on every page.\n        This will be displayed by some PDF readers to identify pages.\n        \"\"\"\n        current_page_label = None\n        if self.page in self.pages:\n            current_page_label = self.pages[self.page].get_page_label()\n        elif self.page > 1:\n            current_page_label = self.pages[self.page - 1].get_page_label()\n        new_page_label = None\n        if label_style or label_prefix or label_start:\n            if current_page_label:\n                if label_style is None:\n                    label_style = current_page_label.get_style()\n                if label_prefix is None:\n                    label_prefix = current_page_label.get_prefix()\n                if label_start is None and not (\n                    self.toc_placeholder and self.toc_placeholder.reset_page_indices\n                ):\n                    label_start = current_page_label.get_start()\n            label_style = (\n                PageLabelStyle.coerce(label_style, case_sensitive=True)\n                if label_style\n                else None\n            )\n            new_page_label = PDFPageLabel(label_style, label_prefix, label_start)\n        self.pages[self.page].set_page_label(current_page_label, new_page_label)\n\n    def add_page(\n        self,\n        orientation: str = \"\",\n        format: str = \"\",\n        same: bool = False,\n        duration: float = 0,\n        transition: Optional[Transition] = None,\n        label_style: Optional[str | PageLabelStyle] = None,\n        label_prefix: Optional[str] = None,\n        label_start: Optional[int] = None,\n    ) -> None:\n        \"\"\"\n        Adds a new page to the document.\n        If a page is already present, the `FPDF.footer()` method is called first.\n        Then the page  is added, the current position is set to the top-left corner,\n        with respect to the left and top margins, and the `FPDF.header()` method is called.\n\n        Args:\n            orientation (str): \"portrait\" (can be abbreviated \"P\")\n                or \"landscape\" (can be abbreviated \"L\"). Default to \"portrait\".\n            format (str): \"a3\", \"a4\", \"a5\", \"letter\", \"legal\" or a tuple\n                (width, height). Default to \"a4\".\n            same (bool): indicates to use the same page format as the previous page.\n                Default to False.\n            duration (float): optional page’s display duration, i.e. the maximum length of time,\n                in seconds, that the page is displayed in presentation mode,\n                before the viewer application automatically advances to the next page.\n                Can be configured globally through the `.page_duration` FPDF property.\n                As of june 2021, onored by Adobe Acrobat reader, but ignored by Sumatra PDF reader.\n            transition (Transition child class): optional visual transition to use when moving\n                from another page to the given page during a presentation.\n                Can be configured globally through the `.page_transition` FPDF property.\n                As of june 2021, onored by Adobe Acrobat reader, but ignored by Sumatra PDF reader.\n            label_style (str or PageLabelStyle): Defines the numbering style for the numeric portion of each\n                page label. Possible values are:\n                - \"D\": Decimal Arabic numerals.\n                - \"R\": Uppercase Roman numerals.\n                - \"r\": Lowercase Roman numerals.\n                - \"A\": Uppercase letters (A to Z for the first 26 pages, followed by AA to ZZ, etc.).\n                - \"a\": Lowercase letters (a to z for the first 26 pages, followed by aa to zz, etc.).\n            label_prefix (str): Prefix string applied to the page label, preceding the numeric portion.\n            label_start (int): Starting number for the first page of a page label range.\n        \"\"\"\n        if self.buffer:\n            raise FPDFException(\n                \"A page cannot be added on a closed document, after calling output()\"\n            )\n\n        self.current_font_is_set_on_page = False\n\n        family = self.font_family\n        emphasis = self.emphasis\n        size = self.font_size_pt\n        lw = self.line_width\n        dc = self.draw_color\n        fc = self.fill_color\n        tc = self.text_color\n        stretching = self.font_stretching\n        char_spacing = self.char_spacing\n        dash_pattern = self.dash_pattern\n\n        in_toc_extra_page = (\n            self.in_toc_rendering\n            and self._toc_allow_page_insertion\n            and self.page > self.toc_placeholder.start_page  # type: ignore[union-attr]\n        )\n        if self.page > 0 and (not self.in_toc_rendering or in_toc_extra_page):\n            # Page footer\n            self._render_footer()\n\n        current_page_label = (\n            None if self.page == 0 else self.pages[self.page].get_page_label()\n        )\n        new_page_label = None\n        if label_style or label_prefix or label_start:\n            label_style = (\n                PageLabelStyle.coerce(label_style, case_sensitive=True)\n                if label_style\n                else None\n            )\n            new_page_label = PDFPageLabel(label_style, label_prefix, label_start)\n\n        # Start new page\n        self._beginpage(\n            orientation,\n            format,\n            same,\n            duration or self.page_duration,\n            transition or self.page_transition,\n            new_page=not self._has_next_page(),\n        )\n\n        self.pages[self.page].set_page_label(current_page_label, new_page_label)\n\n        if self.page_background:\n            if isinstance(self.page_background, tuple):\n                self.set_fill_color(*self.page_background)\n                self.rect(0, 0, self.w, self.h, style=\"F\")\n                assert isinstance(fc, (DeviceRGB, DeviceGray))\n                self.set_fill_color(*fc.colors255)\n            else:\n                self.image(\n                    self.page_background,  # pyright: ignore[reportArgumentType]\n                    0,\n                    0,\n                    self.w,\n                    self.h,\n                )\n\n        self._out(\"2 J\")  # Set line cap style to square\n        self.line_width = lw  # Set line width\n        self._out(f\"{lw * self.k:.2f} w\")\n\n        # Set font\n        if family:\n            self.set_font(family, emphasis, size)\n\n        # Set colors\n        self.draw_color = dc\n        if dc != self.DEFAULT_DRAW_COLOR and dc is not None:\n            self._out(dc.serialize().upper())\n        self.fill_color = fc\n        if fc != self.DEFAULT_FILL_COLOR and fc is not None:\n            self._out(fc.serialize().lower())\n        self.text_color = tc\n\n        # BEGIN Page header\n        if (not self.in_toc_rendering) or self._toc_allow_page_insertion:\n            self.header()\n\n        if self.line_width != lw:  # Restore line width\n            self.line_width = lw\n            self._out(f\"{lw * self.k:.2f} w\")\n\n        if family:\n            self.set_font(family, emphasis, size)  # Restore font\n\n        if self.draw_color != dc and dc is not None:  # Restore colors\n            self.draw_color = dc\n            self._out(dc.serialize().upper())\n        if self.fill_color != fc and fc is not None:\n            self.fill_color = fc\n            self._out(fc.serialize().lower())\n        self.text_color = tc\n\n        if stretching != 100:  # Restore stretching\n            self.set_stretching(stretching)\n        if char_spacing != 0:\n            self.set_char_spacing(char_spacing)\n        if dash_pattern != dict(dash=0, gap=0, phase=0):\n            self._write_dash_pattern(\n                dash_pattern[\"dash\"], dash_pattern[\"gap\"], dash_pattern[\"phase\"]\n            )\n        # END Page header\n\n    def _render_footer(self) -> None:\n        self.in_footer = True\n        if self.toc_placeholder:\n            # The ToC is rendered AFTER the footer,\n            # so we must ensure there is no \"style leak\":\n            self._push_local_stack()\n            self._start_local_context()\n        self.footer()\n        if self.toc_placeholder:\n            self._end_local_context()\n            self._pop_local_stack()\n        self.in_footer = False\n\n    def _beginpage(\n        self,\n        orientation: str | PageOrientation,\n        format: str | tuple[float, float],\n        same: bool,\n        duration: Optional[float],\n        transition: Optional[Transition],\n        new_page: bool = True,\n    ) -> None:\n        self.page += 1\n        if self.in_toc_rendering and self._toc_allow_page_insertion:\n            self._toc_inserted_pages += 1\n            self.page = len(self.pages) + 1\n            new_page = True\n        if new_page:\n            page = PDFPage(\n                contents=bytearray(),\n                duration=duration,\n                transition=transition,\n                index=self.page,\n            )\n            self.pages[self.page] = page\n            if transition:\n                self._set_min_pdf_version(\"1.5\")\n        else:\n            page = self.pages[self.page]\n        self.x = self.l_margin\n        self.y = self.t_margin\n        self.font_family = \"\"\n        self.font_stretching = 100\n        self.char_spacing = 0\n        if same:\n            if orientation or format:\n                raise ValueError(\n                    f\"Inconsistent parameters: same={same} but orientation={orientation} format={format}\"\n                )\n        else:\n            # Set page format if provided, else use default value:\n            page_width_pt, page_height_pt = (\n                get_page_format(format, self.k) if format else (self.dw_pt, self.dh_pt)\n            )\n            self._set_orientation(\n                orientation or self.def_orientation, page_width_pt, page_height_pt\n            )\n        page.set_dimensions(self.w_pt, self.h_pt)\n\n    def header(self) -> None:\n        \"\"\"\n        Header to be implemented in your own inherited class\n\n        This is automatically called by `FPDF.add_page()`\n        and should not be called directly by the user application.\n        The default implementation performs nothing: you have to override this method\n        in a subclass to implement your own rendering logic.\n\n        Note that header rendering can have an impact on the initial\n        (x,y) position when starting to render the page content.\n        \"\"\"\n\n    def footer(self) -> None:\n        \"\"\"\n        Footer to be implemented in your own inherited class.\n\n        This is automatically called by `FPDF.add_page()` and `FPDF.output()`\n        and should not be called directly by the user application.\n        The default implementation performs nothing: you have to override this method\n        in a subclass to implement your own rendering logic.\n        \"\"\"\n\n    def page_no(self) -> int:\n        \"\"\"Get the current page number\"\"\"\n        return self.page\n\n    def get_page_label(self) -> str:\n        \"\"\"\n        Return the current page `fpdf.output.PDFPageLabel`.\n        This will be displayed by some PDF readers to identify pages.\n        `FPDF.set_page_label()` needs to be called first for those to be inserted.\n        \"\"\"\n        return self.pages[self.page].get_label()\n\n    def set_draw_color(\n        self, r: Number | Color | str | Sequence[Number], g: Number = -1, b: Number = -1\n    ) -> None:\n        \"\"\"\n        Defines the color used for all stroking operations (lines, rectangles and cell borders).\n        Accepts either a single greyscale value, 3 values as RGB components, a single `#abc` or `#abcdef` hexadecimal color string,\n        or an instance of `fpdf.drawing.DeviceCMYK`, `fpdf.drawing.DeviceRGB` or `fpdf.drawing.DeviceGray`.\n        The method can be called before the first page is created and the value is retained from page to page.\n\n        Args:\n            r (int, tuple, fpdf.drawing.DeviceGray, fpdf.drawing.DeviceRGB): if `g` and `b` are given, this indicates the red component.\n                Else, this indicates the grey level. The value must be between 0 and 255.\n            g (int): green component (between 0 and 255)\n            b (int): blue component (between 0 and 255)\n        \"\"\"\n        draw_color = convert_to_device_color(r, g, b)\n        if draw_color != self.draw_color:\n            self.draw_color = draw_color\n            if self.page > 0:\n                self._out(\n                    self.draw_color.serialize().upper()  # pyright: ignore[reportOptionalMemberAccess]\n                )\n\n    def set_fill_color(\n        self, r: Number | Color | str | Sequence[Number], g: Number = -1, b: Number = -1\n    ) -> None:\n        \"\"\"\n        Defines the color used for all filling operations (filled rectangles and cell backgrounds).\n        Accepts either a single greyscale value, 3 values as RGB components, a single `#abc` or `#abcdef` hexadecimal color string,\n        or an instance of `fpdf.drawing.DeviceCMYK`, `fpdf.drawing.DeviceRGB` or `fpdf.drawing.DeviceGray`.\n        The method can be called before the first page is created and the value is retained from page to page.\n\n        Args:\n            r (int, tuple, fpdf.drawing.DeviceGray, fpdf.drawing.DeviceRGB): if `g` and `b` are given, this indicates the red component.\n                Else, this indicates the grey level. The value must be between 0 and 255.\n            g (int): green component (between 0 and 255)\n            b (int): blue component (between 0 and 255)\n        \"\"\"\n        fill_color = convert_to_device_color(r, g, b)\n        if fill_color != self.fill_color:\n            self.fill_color = fill_color\n            if self.page > 0:\n                self._out(\n                    self.fill_color.serialize().lower()  # pyright: ignore[reportOptionalMemberAccess]\n                )\n\n    def set_text_color(\n        self,\n        r: (\n            Number\n            | Color\n            | str\n            | Sequence[Number]\n            | DeviceCMYK\n            | DeviceGray\n            | DeviceRGB\n        ),\n        g: Number = -1,\n        b: Number = -1,\n    ) -> None:\n        \"\"\"\n        Defines the color used for text.\n        Accepts either a single greyscale value, 3 values as RGB components, a single `#abc` or `#abcdef` hexadecimal color string,\n        or an instance of `fpdf.drawing.DeviceCMYK`, `fpdf.drawing.DeviceRGB` or `fpdf.drawing.DeviceGray`.\n        The method can be called before the first page is created and the value is retained from page to page.\n\n        Args:\n            r (int, tuple, fpdf.drawing.DeviceGray, fpdf.drawing.DeviceRGB): if `g` and `b` are given, this indicates the red component.\n                Else, this indicates the grey level. The value must be between 0 and 255.\n            g (int): green component (between 0 and 255)\n            b (int): blue component (between 0 and 255)\n        \"\"\"\n        self.text_color = convert_to_device_color(r, g, b)\n\n    def get_string_width(\n        self, s: str, normalized: bool = False, markdown: bool = False\n    ) -> float:\n        \"\"\"\n        Returns the length of a string in user unit. A font must be selected.\n        The value is calculated with stretching and spacing.\n\n        Note that the width of a cell has some extra padding added to this width,\n        on the left & right sides, equal to the .c_margin property.\n\n        Args:\n            s (str): the string whose length is to be computed.\n            normalized (bool): whether normalization needs to be performed on the input string.\n            markdown (bool): indicates if basic markdown support is enabled\n        \"\"\"\n        if not self.font_family:\n            raise FPDFException(\"No font set, you need to call set_font() beforehand\")\n        # normalized is parameter for internal use\n        s = s if normalized else self.normalize_text(s)\n        return sum(\n            frag.get_width() for frag in self._preload_bidirectional_text(s, markdown)\n        )\n\n    def set_line_width(self, width: float) -> None:\n        \"\"\"\n        Defines the line width of all stroking operations (lines, rectangles and cell borders).\n        By default, the value equals 0.2 mm.\n        The method can be called before the first page is created and the value is retained from page to page.\n\n        Args:\n            width (float): the width in user unit\n        \"\"\"\n        if width != self.line_width:\n            self.line_width = width\n            if self.page > 0:\n                self._out(f\"{width * self.k:.2f} w\")\n\n    def set_page_background(\n        self, background: Optional[str | BinaryIO | Image | DeviceRGB | tuple[float]]\n    ) -> None:\n        \"\"\"\n        Sets a background color or image to be drawn every time `FPDF.add_page()` is called, or removes a previously set background.\n        The method can be called before the first page is created and the value is retained from page to page.\n\n        Args:\n            background: either a string representing a file path or URL to an image,\n                an io.BytesIO containing an image as bytes, an instance of `PIL.Image.Image`, drawing.DeviceRGB\n                or a RGB tuple representing a color to fill the background with or `None` to remove the background\n        \"\"\"\n\n        if isinstance(\n            background, (str, io.BytesIO, Image, DeviceRGB, tuple, type(None))\n        ):\n            if isinstance(background, DeviceRGB):\n                self.page_background = background.colors255\n            else:\n                self.page_background = background\n        else:\n            raise TypeError(\n                f\"\"\"background must be of type str, io.BytesIO, PIL.Image.Image, drawing.DeviceRGB, tuple or None\n        got: {type(background)}\"\"\"\n            )\n\n    @contextmanager\n    @check_page\n    def drawing_context(\n        self, debug_stream: Optional[bool] = None  # pylint: disable=unused-argument\n    ) -> Iterator[DrawingContext]:\n        \"\"\"\n        Create a context for drawing paths on the current page.\n\n        If this context manager is called again inside of an active context, it will\n        raise an exception, as base drawing contexts cannot be nested.\n        \"\"\"\n\n        if self._current_draw_context is not None:\n            raise FPDFException(\n                \"cannot create a drawing context while one is already open\"\n            )\n\n        context = DrawingContext()\n        self._current_draw_context = context\n        try:\n            yield context\n        finally:\n            self._current_draw_context = None\n\n        starting_style = self._current_graphic_style()\n        render_args = (\n            self._resource_catalog,\n            Point(self.x, self.y),\n            self.k,\n            self.h,\n            starting_style,\n        )\n\n        rendered = context.render(*render_args)\n\n        # Let the catalog scan & register resources used by this drawing:\n        self._resource_catalog.index_stream_resources(rendered, self.page)\n        # Once we handle text-rendering SVG tags (cf. PR #1029),\n        # we should also detect fonts used and add them to the resource catalog\n\n        self._out(rendered)\n        # The drawing API makes use of features (notably transparency and blending modes) that were introduced in PDF 1.4:\n        self._set_min_pdf_version(\"1.4\")\n\n    @contextmanager\n    @check_page\n    def use_pattern(self, shading: Gradient) -> Iterator[None]:\n        \"\"\"\n        Create a context for using a shading pattern on the current page.\n        \"\"\"\n        self._resource_catalog.add(PDFResourceType.SHADING, shading, self.page)\n        pattern = shading.get_pattern()\n        pattern_name = self._resource_catalog.add(\n            PDFResourceType.PATTERN, pattern, self.page\n        )\n        self._out(f\"/Pattern cs /{pattern_name} scn\")\n        try:\n            yield\n        finally:\n            assert self.draw_color is not None\n            self._out(self.draw_color.serialize().lower())\n\n    def _current_graphic_style(self) -> GraphicsStyle:\n        gs = GraphicsStyle()\n        gs.allow_transparency = self.allow_images_transparency\n\n        # This initial stroke_width is ignored when embedding SVGs,\n        # as the value in SVGObject.convert_graphics() takes precedence,\n        # so this probably creates an unnecessary PDF dict entry:\n        gs.stroke_width = self.line_width\n\n        if self.draw_color != self.DEFAULT_DRAW_COLOR:\n            gs.stroke_color = self.draw_color\n        if self.fill_color != self.DEFAULT_FILL_COLOR:\n            gs.fill_color = self.fill_color\n\n        dash_info = self.dash_pattern\n        dash_pattern: Optional[tuple[float, float]] = (\n            (dash_info[\"dash\"], dash_info[\"gap\"])\n            if dash_info[\"dash\"] != 0 and dash_info[\"gap\"] != 0\n            else None\n        )\n\n        gs.stroke_dash_pattern = dash_pattern\n        gs.stroke_dash_phase = dash_info[\"phase\"]\n\n        return gs\n\n    @contextmanager\n    def new_path(\n        self,\n        x: float = 0,\n        y: float = 0,\n        paint_rule: PathPaintRule = PathPaintRule.AUTO,\n        debug_stream: Optional[bool] = None,  # pylint: disable=unused-argument\n    ) -> Iterator[PaintedPath]:\n        \"\"\"\n        Create a path for appending lines and curves to.\n\n        Args:\n            x (float): Abscissa of the path starting point\n            y (float): Ordinate of the path starting point\n            paint_rule (PathPaintRule): Optional choice of how the path should\n                be painted. The default (AUTO) automatically selects stroke/fill based\n                on the path style settings.\n        \"\"\"\n        with self.drawing_context() as ctxt:\n            path = PaintedPath(x=x, y=y)\n            path.style.paint_rule = paint_rule\n            yield path\n            ctxt.add_item(path)\n\n    def draw_path(\n        self,\n        path: GraphicsContext,\n        debug_stream: Optional[bool] = None,  # pylint: disable=unused-argument\n        copy: bool = True,\n    ) -> None:\n        \"\"\"\n        Add a pre-constructed path to the document.\n\n        Args:\n            path (drawing.PaintedPath): the path to be drawn.\n            copy (bool): if true (the default), the path will be copied before being\n                added. This prevents modifications to a referenced object from\n                \"retroactively\" altering its style/shape and should be disabled with\n                caution.\n        \"\"\"\n        with self.drawing_context() as ctxt:\n            ctxt.add_item(path, copy)\n\n    def set_dash_pattern(\n        self, dash: float = 0, gap: float = 0, phase: float = 0\n    ) -> None:\n        \"\"\"\n        Set the current dash pattern for lines and curves.\n\n        Args:\n            dash (float): The length of the dashes in current units.\n\n            gap (float): The length of the gaps between dashes in current units.\n                If omitted, the dash length will be used.\n\n            phase (float): Where in the sequence to start drawing.\n\n        Omitting 'dash' (= 0) resets the pattern to a solid line.\n        \"\"\"\n        if not (isinstance(dash, (int, float)) and dash >= 0):\n            raise ValueError(\"Dash length must be zero or a positive number.\")\n        if not (isinstance(gap, (int, float)) and gap >= 0):\n            raise ValueError(\"gap length must be zero or a positive number.\")\n        if not (isinstance(phase, (int, float)) and phase >= 0):\n            raise ValueError(\"Phase must be zero or a positive number.\")\n\n        pattern: dict[str, float] = dict(\n            dash=float(dash), gap=float(gap), phase=float(phase)\n        )\n\n        if pattern != self.dash_pattern:\n            self.dash_pattern = pattern\n            self._write_dash_pattern(dash, gap, phase)\n\n    def _write_dash_pattern(self, dash: float, gap: float, phase: float) -> None:\n        if dash:\n            if gap:\n                dstr = f\"[{dash * self.k:.3f} {gap * self.k:.3f}] {phase *self.k:.3f} d\"\n            else:\n                dstr = f\"[{dash * self.k:.3f}] {phase *self.k:.3f} d\"\n        else:\n            dstr = \"[] 0 d\"\n        self._out(dstr)\n\n    @contextmanager\n    def glyph_drawing_context(self) -> Iterator[DrawingContext]:\n        \"\"\"\n        Create a context for drawing paths for type 3 font glyphs, without writing on the current page.\n        \"\"\"\n\n        if self._current_draw_context is not None:\n            raise FPDFException(\n                \"cannot create a drawing context while one is already open\"\n            )\n\n        context = DrawingContext()\n        self._current_draw_context = context\n        try:\n            yield context\n        finally:\n            self._current_draw_context = None\n\n        self._set_min_pdf_version(\"1.4\")\n\n    def draw_vector_glyph(\n        self, path: Union[PaintedPath, GraphicsContext], font: \"Type3Font\"\n    ) -> str:\n        \"\"\"\n        Add a pre-constructed path to the document.\n        \"\"\"\n        output_stream: str = \"\"\n        with self.glyph_drawing_context() as ctxt:\n            ctxt.add_item(path)\n\n            starting_style = GraphicsStyle()\n            render_args = (\n                self._resource_catalog,\n                Point(0, 0),\n                1,\n                0,\n                starting_style,\n            )\n\n            output_stream = ctxt.render(*render_args)\n            # Registering raster images embedded in the vector graphics:\n            for resource_type, resource_id in self._resource_catalog.scan_stream(\n                output_stream\n            ):\n                if resource_type == PDFResourceType.X_OBJECT:\n                    font.images_used.add(int(resource_id))\n                if resource_type == PDFResourceType.EXT_G_STATE:\n                    font.graphics_style_used.add(resource_id)\n                if resource_type == PDFResourceType.PATTERN:\n                    font.patterns_used.add(resource_id)\n\n        return output_stream\n\n    @check_page\n    def line(self, x1: float, y1: float, x2: float, y2: float) -> None:\n        \"\"\"\n        Draw a line between two points.\n\n        Args:\n            x1 (float): Abscissa of first point\n            y1 (float): Ordinate of first point\n            x2 (float): Abscissa of second point\n            y2 (float): Ordinate of second point\n        \"\"\"\n        self._out(\n            f\"{x1 * self.k:.2f} {(self.h - y1) * self.k:.2f} m {x2 * self.k:.2f} \"\n            f\"{(self.h - y2) * self.k:.2f} l S\"\n        )\n\n    @check_page\n    def polyline(\n        self,\n        point_list: Sequence[tuple[float, float]],\n        fill: bool = False,\n        polygon: bool = False,\n        style: Optional[RenderStyle | str] = None,\n    ) -> None:\n        \"\"\"\n        Draws lines between two or more points.\n\n        Args:\n            point_list (list of tuples): List of Abscissa and Ordinate of\n                                        segments that should be drawn\n            fill (bool): [**DEPRECATED since v2.5.4**] Use `style=\"F\"` or `style=\"DF\"` instead\n            polygon (bool): If true, close path before stroking, to fill the inside of the polyline\n            style (fpdf.enums.RenderStyle, str): Optional style of rendering. Possible values are:\n\n            * `D` or None: draw border. This is the default value.\n            * `F`: fill\n            * `DF` or `FD`: draw and fill\n        \"\"\"\n        if fill:\n            warnings.warn(\n                (\n                    '\"fill\" parameter is deprecated since v2.5.4, '\n                    'use style=\"F\" or style=\"DF\" instead'\n                ),\n                DeprecationWarning,\n                stacklevel=get_stack_level(),\n            )\n        if fill and style is None:\n            style = RenderStyle.DF\n        else:\n            style = RenderStyle.coerce(style) if style is not None else RenderStyle.D\n            if fill and style == RenderStyle.D:\n                raise ValueError(\n                    f\"Conflicting values provided: fill={fill} & style={style}\"\n                )\n        operator = \"m\"\n        for point in point_list:\n            self._out(\n                f\"{point[0] * self.k:.2f} {(self.h - point[1]) * self.k:.2f} {operator}\"\n            )\n            operator = \"l\"\n        if polygon:\n            self._out(\" h\")\n        self._out(f\" {style.operator}\")\n\n    @check_page\n    def polygon(\n        self,\n        point_list: Sequence[tuple[float, float]],\n        fill: bool = False,\n        style: Optional[RenderStyle | str] = None,\n    ) -> None:\n        \"\"\"\n        Outputs a polygon defined by three or more points.\n\n        Args:\n            point_list (list of tuples): List of coordinates defining the polygon to draw\n            fill (bool): [**DEPRECATED since v2.5.4**] Use `style=\"F\"` or `style=\"DF\"` instead\n            style (fpdf.enums.RenderStyle, str): Optional style of rendering. Possible values are:\n\n            * `D` or None: draw border. This is the default value.\n            * `F`: fill\n            * `DF` or `FD`: draw and fill\n        \"\"\"\n        self.polyline(point_list, fill=fill, polygon=True, style=style)\n\n    @check_page\n    def dashed_line(\n        self,\n        x1: float,\n        y1: float,\n        x2: float,\n        y2: float,\n        dash_length: float = 1,\n        space_length: float = 1,\n    ) -> None:\n        \"\"\"\n        Draw a dashed line between two points.\n\n        Args:\n            x1 (float): Abscissa of first point\n            y1 (float): Ordinate of first point\n            x2 (float): Abscissa of second point\n            y2 (float): Ordinate of second point\n            dash_length (float): Length of the dash\n            space_length (float): Length of the space between 2 dashes\n\n        .. deprecated:: 2.4.6\n            Use `FPDF.set_dash_pattern()` and the normal drawing operations instead.\n        \"\"\"\n        warnings.warn(\n            (\n                \"dashed_line() is deprecated since v2.4.6, \"\n                \"and will be removed in a future release. \"\n                \"Use set_dash_pattern() and the normal drawing operations instead.\"\n            ),\n            DeprecationWarning,\n            stacklevel=get_stack_level(),\n        )\n        self.set_dash_pattern(dash_length, space_length)\n        self.line(x1, y1, x2, y2)\n        self.set_dash_pattern()\n\n    @check_page\n    def rect(\n        self,\n        x: float,\n        y: float,\n        w: float,\n        h: float,\n        style: Optional[RenderStyle | str] = None,\n        round_corners: bool = False,\n        corner_radius: float = 0,\n    ) -> None:\n        \"\"\"\n        Outputs a rectangle.\n        It can be drawn (border only), filled (with no border) or both.\n\n        Args:\n            x (float): Abscissa of upper-left bounding box.\n            y (float): Ordinate of upper-left bounding box.\n            w (float): Width.\n            h (float): Height.\n            style (fpdf.enums.RenderStyle, str): Optional style of rendering. Possible values are:\n\n            * `D` or empty string: draw border. This is the default value.\n            * `F`: fill\n            * `DF` or `FD`: draw and fill\n\n            round_corners (tuple of str, tuple of fpdf.enums.Corner, bool): Optional draw a rectangle with round corners.\n            Possible values are:\n\n            *`TOP_LEFT`: a rectangle with round top left corner\n            *`TOP_RIGHT`: a rectangle with round top right corner\n            *`BOTTOM_LEFT`: a rectangle with round bottom left corner\n            *`BOTTOM_RIGHT`: a rectangle with round bottom right corner\n            *`True`: a rectangle with all round corners\n            *`False`: a rectangle with no round corners\n\n            corner_radius: Optional radius of the corners\n        \"\"\"\n\n        style = RenderStyle.coerce(style) if style is not None else RenderStyle.D\n        if round_corners is not False:\n            self._draw_rounded_rect(x, y, w, h, style, round_corners, corner_radius)\n        else:\n            self._out(\n                f\"{x * self.k:.2f} {(self.h - y) * self.k:.2f} {w * self.k:.2f} \"\n                f\"{-h * self.k:.2f} re {style.operator}\"\n            )\n\n    def _draw_rounded_rect(\n        self,\n        x: float,\n        y: float,\n        w: float,\n        h: float,\n        style: RenderStyle,\n        round_corners: bool | tuple[Corner | str, ...],\n        r: float,\n    ) -> None:\n        min = h\n        if w < h:\n            min = w\n\n        if r == 0:\n            r = min / 5\n\n        if r >= min / 2:\n            r /= min\n\n        # Calculate corner points\n        point_1 = point_8 = (x, y)\n        point_2 = (x + w, y)\n        point_4 = (x + w, y + h)\n        point_6 = (x, y + h)\n\n        if round_corners is True:\n            round_corners = (\n                Corner.TOP_RIGHT.value,\n                Corner.TOP_LEFT.value,\n                Corner.BOTTOM_RIGHT.value,\n                Corner.BOTTOM_LEFT.value,\n            )\n        assert not isinstance(round_corners, bool)\n        round_corners_list: tuple[Corner, ...] = tuple(\n            Corner.coerce(rc) for rc in round_corners\n        )\n\n        # Update points based on which corners are rounded\n        if Corner.TOP_RIGHT in round_corners_list:\n            point_1 = (x + r, y)\n            point_8 = (x, y + r)\n\n        if Corner.TOP_LEFT in round_corners_list:\n            point_2 = (x + w - r, y)\n            _point_3 = (x + w, y + r)\n\n        if Corner.BOTTOM_LEFT in round_corners_list:\n            point_4 = (x + w, y + h - r)\n            _point_5 = (x + w - r, y + h)\n\n        if Corner.BOTTOM_RIGHT in round_corners_list:\n            point_6 = (x + r, y + h)\n            _point_7 = (x, y + h - r)\n\n        # Build a single continuous path\n        # Start at point_1\n        self._out(f\"{point_1[0] * self.k:.2f} {(self.h - point_1[1]) * self.k:.2f} m\")\n\n        # Top edge: point_1 to point_2\n        self._out(f\"{point_2[0] * self.k:.2f} {(self.h - point_2[1]) * self.k:.2f} l\")\n\n        # Top-left corner arc\n        if Corner.TOP_LEFT in round_corners_list:\n            self._draw_arc_segment(x + w - 2 * r, y, 2 * r, 270, 0)\n\n        # Right edge: point_3 to point_4\n        self._out(f\"{point_4[0] * self.k:.2f} {(self.h - point_4[1]) * self.k:.2f} l\")\n\n        # Bottom-left corner arc\n        if Corner.BOTTOM_LEFT in round_corners_list:\n            self._draw_arc_segment(x + w - 2 * r, y + h - 2 * r, 2 * r, 0, 90)\n\n        # Bottom edge: point_5 to point_6\n        self._out(f\"{point_6[0] * self.k:.2f} {(self.h - point_6[1]) * self.k:.2f} l\")\n\n        # Bottom-right corner arc\n        if Corner.BOTTOM_RIGHT in round_corners_list:\n            self._draw_arc_segment(x, y + h - 2 * r, 2 * r, 90, 180)\n\n        # Left edge: point_7 to point_8\n        self._out(f\"{point_8[0] * self.k:.2f} {(self.h - point_8[1]) * self.k:.2f} l\")\n\n        # Top-right corner arc\n        if Corner.TOP_RIGHT in round_corners_list:\n            self._draw_arc_segment(x, y, 2 * r, 180, 270)\n\n        # Close path and apply style\n        self._out(f\"h {style.operator}\")\n\n    def _draw_arc_segment(\n        self,\n        x: float,\n        y: float,\n        a: float,\n        start_angle: float,\n        end_angle: float,\n        b: Optional[float] = None,\n    ) -> None:\n        \"\"\"\n        Draw an arc segment as part of an existing path (no move, no style application).\n        Used internally for building complex shapes like rounded rectangles.\n        \"\"\"\n        if b is None:\n            b = a\n\n        a /= 2\n        b /= 2\n\n        cx = x + a\n        cy = y + b\n\n        def deg_to_rad(deg: float) -> float:\n            return deg * math.pi / 180\n\n        def angle_to_param(angle: float) -> float:\n            angle = deg_to_rad(angle % 360)\n            eta = math.atan2(math.sin(angle) / b, math.cos(angle) / a)\n            if eta < 0:\n                eta += 2 * math.pi\n            return eta\n\n        def evaluate(eta: float) -> list[float]:\n            a_cos_eta = a * math.cos(eta)\n            b_sin_eta = b * math.sin(eta)\n            return [cx + a_cos_eta, cy + b_sin_eta]\n\n        def derivative_evaluate(eta: float) -> list[float]:\n            a_sin_eta = a * math.sin(eta)\n            b_cos_eta = b * math.cos(eta)\n            return [-a_sin_eta, b_cos_eta]\n\n        start_eta = angle_to_param(start_angle)\n        end_eta = angle_to_param(end_angle)\n\n        if end_eta <= start_eta:\n            end_eta += 2 * math.pi\n\n        max_curves = 4\n        n = min(\n            max_curves, math.ceil(abs(end_eta - start_eta) / (2 * math.pi / max_curves))\n        )\n        d_eta = (end_eta - start_eta) / n\n\n        alpha = math.sin(d_eta) * (math.sqrt(4 + 3 * math.tan(d_eta / 2) ** 2) - 1) / 3\n\n        eta2 = start_eta\n        p2 = evaluate(eta2)\n        p2_prime = derivative_evaluate(eta2)\n\n        for _ in range(n):\n            p1 = p2\n            p1_prime = p2_prime\n\n            eta2 += d_eta\n            p2 = evaluate(eta2)\n            p2_prime = derivative_evaluate(eta2)\n\n            control_point_1 = [p1[0] + alpha * p1_prime[0], p1[1] + alpha * p1_prime[1]]\n            control_point_2 = [p2[0] - alpha * p2_prime[0], p2[1] - alpha * p2_prime[1]]\n\n            self._out(\n                f\"{control_point_1[0] * self.k:.2f} {(self.h - control_point_1[1]) * self.k:.2f} \"\n                f\"{control_point_2[0] * self.k:.2f} {(self.h - control_point_2[1]) * self.k:.2f} \"\n                f\"{p2[0] * self.k:.2f} {(self.h - p2[1]) * self.k:.2f} c\"\n            )\n\n    @check_page\n    def ellipse(\n        self,\n        x: float,\n        y: float,\n        w: float,\n        h: float,\n        style: Optional[RenderStyle | str] = None,\n    ) -> None:\n        \"\"\"\n        Outputs an ellipse.\n        It can be drawn (border only), filled (with no border) or both.\n\n        Args:\n            x (float): Abscissa of upper-left bounding box.\n            y (float): Ordinate of upper-left bounding box.\n            w (float): Width\n            h (float): Height\n            style (fpdf.enums.RenderStyle, str): Optional style of rendering. Possible values are:\n\n            * `D` or empty string: draw border. This is the default value.\n            * `F`: fill\n            * `DF` or `FD`: draw and fill\n        \"\"\"\n        style = RenderStyle.coerce(style) if style is not None else RenderStyle.D\n        self._draw_ellipse(x, y, w, h, style.operator)\n\n    def _draw_ellipse(\n        self, x: float, y: float, w: float, h: float, operator: str\n    ) -> None:\n        cx = x + w / 2\n        cy = y + h / 2\n        rx = w / 2\n        ry = h / 2\n\n        lx = 4 / 3 * (math.sqrt(2) - 1) * rx\n        ly = 4 / 3 * (math.sqrt(2) - 1) * ry\n\n        self._out(\n            (\n                f\"{(cx + rx) * self.k:.2f} {(self.h - cy) * self.k:.2f} m \"\n                f\"{(cx + rx) * self.k:.2f} {(self.h - cy + ly) * self.k:.2f} \"\n                f\"{(cx + lx) * self.k:.2f} {(self.h - cy + ry) * self.k:.2f} \"\n                f\"{cx * self.k:.2f} {(self.h - cy + ry) * self.k:.2f} c\"\n            )\n        )\n        self._out(\n            (\n                f\"{(cx - lx) * self.k:.2f} {(self.h - cy + ry) * self.k:.2f} \"\n                f\"{(cx - rx) * self.k:.2f} {(self.h - cy + ly) * self.k:.2f} \"\n                f\"{(cx - rx) * self.k:.2f} {(self.h - cy) * self.k:.2f} c\"\n            )\n        )\n        self._out(\n            (\n                f\"{(cx - rx) * self.k:.2f} {(self.h - cy - ly) * self.k:.2f} \"\n                f\"{(cx - lx) * self.k:.2f} {(self.h - cy - ry) * self.k:.2f} \"\n                f\"{cx * self.k:.2f} {(self.h - cy - ry) * self.k:.2f} c\"\n            )\n        )\n        self._out(\n            (\n                f\"{(cx + lx) * self.k:.2f} {(self.h - cy - ry) * self.k:.2f} \"\n                f\"{(cx + rx) * self.k:.2f} {(self.h - cy - ly) * self.k:.2f} \"\n                f\"{(cx + rx) * self.k:.2f} {(self.h - cy) * self.k:.2f} c {operator}\"\n            )\n        )\n\n    @check_page\n    def circle(\n        self,\n        x: float,\n        y: float,\n        radius: float,\n        style: Optional[RenderStyle | str] = None,\n    ) -> None:\n        \"\"\"\n        Outputs a circle.\n        It can be drawn (border only), filled (with no border) or both.\n\n        WARNING: This method changed parameters in [release 2.8.0](https://github.com/py-pdf/fpdf2/releases/tag/2.8.0)\n\n        Args:\n            x (float): Abscissa of upper-left bounding box.\n            y (float): Ordinate of upper-left bounding box.\n            radius (float): Radius of the circle.\n            style (str): Style of rendering. Possible values are:\n\n            * `D` or None: draw border. This is the default value.\n            * `F`: fill\n            * `DF` or `FD`: draw and fill\n        \"\"\"\n        self.ellipse(x - radius, y - radius, 2 * radius, 2 * radius, style)\n\n    @check_page\n    def regular_polygon(\n        self,\n        x: float,\n        y: float,\n        numSides: int,\n        polyWidth: float,\n        rotateDegrees: float = 0,\n        style: Optional[RenderStyle | str] = None,\n    ) -> None:\n        \"\"\"\n        Outputs a regular polygon with n sides\n        It can be rotated\n        Style can also be applied (fill, border...)\n\n        Args:\n            x (float): Abscissa of upper-left bounding box.\n            y (float): Ordinate of upper-left bounding box.\n            numSides (int): Number of sides for polygon.\n            polyWidth (float): Width of the polygon.\n            rotateDegrees (float): Optional degree amount to rotate polygon.\n            style (fpdf.enums.RenderStyle, str): Optional style of rendering. Possible values are:\n\n            * `D` or None: draw border. This is the default value.\n            * `F`: fill\n            * `DF` or `FD`: draw and fill\n        \"\"\"\n        radius = polyWidth / 2\n        centerX = x + radius\n        centerY = y - radius\n        # center point is (centerX, centerY)\n        points: list[tuple[float, float]] = []\n        for i in range(1, numSides + 1):\n            point = centerX + radius * math.cos(\n                math.radians((360 / numSides) * i) + math.radians(rotateDegrees)\n            ), centerY + radius * math.sin(\n                math.radians((360 / numSides) * i) + math.radians(rotateDegrees)\n            )\n            points.append(point)\n        # creates list of tuples containing coordinate points of vertices\n\n        self.polygon(points, style=style)\n        # passes points through polygon function\n\n    @check_page\n    def star(\n        self,\n        x: float,\n        y: float,\n        r_in: float,\n        r_out: float,\n        corners: int,\n        rotate_degrees: float = 0,\n        style: Optional[RenderStyle | str] = None,\n    ) -> None:\n        \"\"\"\n        Outputs a regular star with n corners.\n        It can be rotated.\n        It can be drawn (border only), filled (with no border) or both.\n\n        Args:\n            x (float): Abscissa of star's centre.\n            y (float): Ordinate of star's centre.\n            r_in (float): radius of internal circle.\n            r_out (float): radius of external circle.\n            corners (int): number of star's corners.\n            rotate_degrees (float): Optional degree amount to rotate star clockwise.\n\n            style (fpdf.enums.RenderStyle, str): Optional style of rendering. Possible values are:\n            * `D`: draw border. This is the default value.\n            * `F`: fill.\n            * `DF` or `FD`: draw and fill.\n        \"\"\"\n        th = math.radians(rotate_degrees)\n        point_list: list[tuple[float, float]] = []\n        for i in range(0, (corners * 2) + 1):\n            corner_x = x + (r_out if i % 2 == 0 else r_in) * math.sin(th)\n            corner_y = y + (r_out if i % 2 == 0 else r_in) * math.cos(th)\n            point_list.append((corner_x, corner_y))\n\n            th += math.radians(180 / corners)\n\n        self.polyline(point_list, polygon=True, style=style)\n\n    @check_page\n    def arc(\n        self,\n        x: float,\n        y: float,\n        a: float,\n        start_angle: float,\n        end_angle: float,\n        b: Optional[float] = None,\n        inclination: float = 0,\n        clockwise: bool = False,\n        start_from_center: bool = False,\n        end_at_center: bool = False,\n        style: Optional[RenderStyle | str] = None,\n    ) -> None:\n        \"\"\"\n        Outputs an arc.\n        It can be drawn (border only), filled (with no border) or both.\n\n        Args:\n            x (float): Abscissa of upper-left corner of the bounding box of the full ellipse.\n            y (float): Ordinate of upper-left corner of the bounding box of the full ellipse.\n            a (float): Major axis diameter (width of bounding box).\n            b (float): Minor axis diameter (height of bounding box), if None, equals to a (default: None).\n            start_angle (float): Start angle of the arc (in degrees).\n            end_angle (float): End angle of the arc (in degrees).\n            inclination (float): Inclination of the arc in respect of the x-axis (default: 0).\n            clockwise (bool): Way of drawing the arc (True: clockwise, False: counterclockwise) (default: False).\n            start_from_center (bool): Start drawing from the center of the ellipse (default: False).\n            end_at_center (bool): End drawing at the center of the ellipse (default: False).\n            style (fpdf.enums.RenderStyle, str): Optional style of rendering. Allowed values are:\n\n            * `D` or None: draw border. This is the default value.\n            * `F`: fill\n            * `DF` or `FD`: draw and fill\n        \"\"\"\n        style = RenderStyle.coerce(style) if style is not None else RenderStyle.D\n\n        if b is None:\n            b = a\n\n        a /= 2\n        b /= 2\n\n        cx = x + a\n        cy = y + b\n\n        # Functions used only to construct other points of the bezier curve\n        def deg_to_rad(deg: float) -> float:\n            return deg * math.pi / 180\n\n        def angle_to_param(angle: float) -> float:\n            angle = deg_to_rad(angle % 360)\n            eta = math.atan2(math.sin(angle) / b, math.cos(angle) / a)\n\n            if eta < 0:\n                eta += 2 * math.pi\n            return eta\n\n        theta = deg_to_rad(inclination)\n        cos_theta = math.cos(theta)\n        sin_theta = math.sin(theta)\n\n        def evaluate(eta: float) -> list[float]:\n            a_cos_eta = a * math.cos(eta)\n            b_sin_eta = b * math.sin(eta)\n\n            return [\n                cx + a_cos_eta * cos_theta - b_sin_eta * sin_theta,\n                cy + a_cos_eta * sin_theta + b_sin_eta * cos_theta,\n            ]\n\n        def derivative_evaluate(eta: float) -> list[float]:\n            a_sin_eta = a * math.sin(eta)\n            b_cos_eta = b * math.cos(eta)\n\n            return [\n                -a_sin_eta * cos_theta - b_cos_eta * sin_theta,\n                -a_sin_eta * sin_theta + b_cos_eta * cos_theta,\n            ]\n\n        # Calculating start_eta and end_eta so that\n        #   start_eta < end_eta   <= start_eta + 2*PI if counterclockwise\n        #   end_eta   < start_eta <= end_eta + 2*PI   if clockwise\n        start_eta = angle_to_param(start_angle)\n        end_eta = angle_to_param(end_angle)\n\n        if not clockwise and end_eta <= start_eta:\n            end_eta += 2 * math.pi\n        elif clockwise and end_eta >= start_eta:\n            start_eta += 2 * math.pi\n\n        start_point = evaluate(start_eta)\n\n        # Move to the start point\n        if start_from_center:\n            self._out(f\"{cx * self.k:.2f} {(self.h - cy) * self.k:.2f} m\")\n            self._out(\n                f\"{start_point[0] * self.k:.2f} {(self.h - start_point[1]) * self.k:.2f} l\"\n            )\n        else:\n            self._out(\n                f\"{start_point[0] * self.k:.2f} {(self.h - start_point[1]) * self.k:.2f} m\"\n            )\n\n        # Number of curves to use, maximal segment angle is 2*PI/max_curves\n        max_curves = 4\n        n = min(\n            max_curves, math.ceil(abs(end_eta - start_eta) / (2 * math.pi / max_curves))\n        )\n        d_eta = (end_eta - start_eta) / n\n\n        alpha = math.sin(d_eta) * (math.sqrt(4 + 3 * math.tan(d_eta / 2) ** 2) - 1) / 3\n\n        eta2 = start_eta\n        p2 = evaluate(eta2)\n        p2_prime = derivative_evaluate(eta2)\n\n        for i in range(n):\n            p1 = p2\n            p1_prime = p2_prime\n\n            eta2 += d_eta\n            p2 = evaluate(eta2)\n            p2_prime = derivative_evaluate(eta2)\n\n            control_point_1 = [p1[0] + alpha * p1_prime[0], p1[1] + alpha * p1_prime[1]]\n            control_point_2 = [p2[0] - alpha * p2_prime[0], p2[1] - alpha * p2_prime[1]]\n\n            end = \"\"\n            if i == n - 1 and not end_at_center:\n                end = f\" {style.operator}\"\n\n            self._out(\n                (\n                    f\"{control_point_1[0] * self.k:.2f} {(self.h - control_point_1[1]) * self.k:.2f} \"\n                    f\"{control_point_2[0] * self.k:.2f} {(self.h - control_point_2[1]) * self.k:.2f} \"\n                    f\"{p2[0] * self.k:.2f} {(self.h - p2[1]) * self.k:.2f} c\" + end\n                )\n            )\n\n        if end_at_center:\n            if start_from_center:\n                self._out(f\"h {style.operator}\")\n            else:\n                self._out(\n                    f\"{cx * self.k:.2f} {(self.h - cy) * self.k:.2f} l {style.operator}\"\n                )\n\n    def solid_arc(\n        self,\n        x: float,\n        y: float,\n        a: float,\n        start_angle: float,\n        end_angle: float,\n        b: Optional[float] = None,\n        inclination: float = 0,\n        clockwise: bool = False,\n        style: Optional[RenderStyle | str] = None,\n    ) -> None:\n        \"\"\"\n        Outputs a solid arc. A solid arc combines an arc and a triangle to form a pie slice\n        It can be drawn (border only), filled (with no border) or both.\n\n        Args:\n            x (float): Abscissa of upper-left bounding box.\n            y (float): Ordinate of upper-left bounding box.\n            a (float): Semi-major axis.\n            b (float): Semi-minor axis, if None, equals to a (default: None).\n            start_angle (float): Start angle of the arc (in degrees).\n            end_angle (float): End angle of the arc (in degrees).\n            inclination (float): Inclination of the arc in respect of the x-axis (default: 0).\n            clockwise (bool): Way of drawing the arc (True: clockwise, False: counterclockwise) (default: False).\n            style (str): Style of rendering. Possible values are:\n\n            * `D` or None: draw border. This is the default value.\n            * `F`: fill\n            * `DF` or `FD`: draw and fill\n        \"\"\"\n        self.arc(\n            x,\n            y,\n            a,\n            start_angle,\n            end_angle,\n            b,\n            inclination,\n            clockwise,\n            True,\n            True,\n            style,\n        )\n\n    def bezier(\n        self,\n        point_list: Sequence[tuple[float, float]],\n        closed: bool = False,\n        style: Optional[RenderStyle | str] = None,\n    ) -> None:\n        \"\"\"\n        Outputs a quadratic or cubic Bézier curve, defined by three or four coordinates.\n\n        Args:\n            point_list (list of tuples): List of Abscissa and Ordinate of\n                                        segments that should be drawn. Should be\n                                        three or four tuples. The first and last\n                                        points are the start and end point. The\n                                        middle point(s) are the control point(s).\n            closed (bool): True to draw the curve as a closed path, False (default)\n                                        for it to be drawn as an open path.\n            style (fpdf.enums.RenderStyle, str): Optional style of rendering. Allowed values are:\n            * `D` or None: draw border. This is the default value.\n            * `F`: fill\n            * `DF` or `FD`: draw and fill\n        \"\"\"\n        points = len(point_list)\n        if points not in (3, 4):\n            raise ValueError(\n                \"point_list should contain 3 tuples for a quadratic curve\"\n                \" or 4 tuples for a cubic curve.\"\n            )\n        style = RenderStyle.coerce(style) if style is not None else RenderStyle.D\n\n        # QuadraticBezierCurve and BezierCurve make use of `initial_point` when instantiated.\n        # If we want to define all 3 (quad.) or 4 (cubic) points, we can set `initial_point`\n        # to be the first point given in `point_list` by creating a separate dummy path at that pos.\n        with self.drawing_context() as ctxt:\n            p1 = point_list[0]\n            x1, y1 = p1[0], p1[1]\n\n            dummy_path = PaintedPath(x1, y1)\n            ctxt.add_item(dummy_path)\n\n            p2 = point_list[1]\n            x2, y2 = p2[0], p2[1]\n\n            p3 = point_list[2]\n            x3, y3 = p3[0], p3[1]\n\n            if points == 4:\n                p4 = point_list[3]\n                x4, y4 = p4[0], p4[1]\n\n            path = PaintedPath(x1, y1)\n\n            # Translate enum style (RenderStyle) into rule (PathPaintRule)\n            rule = PathPaintRule.STROKE_FILL_NONZERO\n            if style.is_draw and not style.is_fill:\n                rule = PathPaintRule.STROKE\n            elif style.is_fill and not style.is_draw:\n                rule = PathPaintRule.FILL_NONZERO\n\n            path.style.paint_rule = rule\n            path.style.auto_close = closed\n\n            if points == 4:\n                path.curve_to(\n                    x2,\n                    y2,\n                    x3,\n                    y3,\n                    x4,  # pyright: ignore[reportPossiblyUnboundVariable]\n                    y4,  # pyright: ignore[reportPossiblyUnboundVariable]\n                )\n            elif points == 3:\n                path.curve_to(x2, y2, x2, y2, x3, y3)\n\n            ctxt.add_item(path)\n\n    @deprecated_parameter([(\"uni\", \"2.5.1\")])\n    def add_font(\n        self,\n        family: Optional[str] = None,\n        style: str = \"\",\n        fname: Optional[str] = None,\n        *,\n        unicode_range: Optional[str | Sequence[str | int | tuple[int, int]]] = None,\n        variations: Optional[dict[str, dict[str, float]] | dict[str, float]] = None,\n        palette: Optional[int] = None,\n    ) -> None:\n        \"\"\"\n        Imports a TrueType or OpenType font and makes it available\n        for later calls to the `FPDF.set_font()` method.\n\n        You will find more information on the \"Unicode\" documentation page.\n\n        Args:\n            family (str): optional name of the font family. Used as a reference for `FPDF.set_font()`.\n                If not provided, use the base name of the `fname` font path, without extension.\n            style (str): font style. \"\" for regular, include 'B' for bold, and/or 'I' for italic.\n            fname (str): font file name. You can specify a relative or full path.\n                If the file is not found, it will be searched in `FPDF_FONT_DIR`.\n            unicode_range (Optional[Union[str, int, tuple, list]]): subset of Unicode codepoints to embed.\n                Accepts CSS-style strings (e.g. \"U+1F600-1F64F, U+2600\"), integers, tuples, or lists.\n                Defaults to None, which embeds the full cmap.\n            variations (dict[style, dict]): maps style to limits of axes for the variable font.\n            palette (int): optional palette index for color fonts (COLR/CPAL). Defaults to 0 (first palette).\n                Only applicable to fonts with CPAL table (color fonts).\n        \"\"\"\n        if not fname:\n            raise ValueError('\"fname\" parameter is required')\n\n        ext = splitext(str(fname))[1].lower()\n        if ext not in (\".otf\", \".otc\", \".ttf\", \".ttc\", \".woff\", \".woff2\"):\n            raise ValueError(\n                f\"Unsupported font file extension: {ext}.\"\n                \" add_font() used to accept .pkl file as input, but for security reasons\"\n                \" this feature is deprecated since v2.5.1 and has been removed in v2.5.3.\"\n            )\n\n        for parent in (Path(\".\"), FPDF_FONT_DIR):\n            if (parent / fname).exists():\n                font_file_path = parent / fname\n                break\n        else:\n            raise FileNotFoundError(f\"TTF Font file not found: {fname}\")\n\n        if family is None:\n            family = font_file_path.stem\n\n        parsed_unicode_range = None\n        if unicode_range is not None:\n            parsed_unicode_range = get_parsed_unicode_range(unicode_range)\n\n        style = \"\".join(sorted(style.upper()))\n        if any(letter not in \"BI\" for letter in style):\n            raise ValueError(\n                f\"Unknown style provided (only B & I letters are allowed): {style}\"\n            )\n\n        # Handle variable font.\n        if variations is not None:\n            if not isinstance(variations, dict):\n                raise TypeError(\"Variations, if specified, must be a dictionary\")\n\n            # Check variations dictionary\n            if all(\n                key.upper() in (\"\", \"B\", \"I\", \"BI\") and isinstance(value, dict)\n                for key, value in variations.items()\n            ):\n                for var_style, axes_dict in variations.items():\n                    self.add_font(\n                        family=family,\n                        style=var_style,\n                        fname=fname,\n                        unicode_range=unicode_range,\n                        variations=axes_dict,  # type: ignore[arg-type]\n                        palette=palette,\n                    )\n                return\n        fontkey = f\"{family.lower()}{style}\"\n\n        if fontkey in self.fonts or fontkey in CORE_FONTS:\n            warnings.warn(\n                f\"Core font or font already added '{fontkey}': doing nothing\",\n                stacklevel=get_stack_level(),\n            )\n            return\n\n        self.fonts[fontkey] = TTFFont(\n            self,\n            font_file_path,\n            fontkey,\n            style,\n            parsed_unicode_range,\n            variations,  # type: ignore[arg-type]\n            palette,\n        )\n\n    def set_font(\n        self,\n        family: Optional[str] = None,\n        style: Union[str, TextEmphasis] = \"\",\n        size: float = 0,\n    ) -> None:\n        \"\"\"\n        Sets the font used to print character strings.\n        It is mandatory to call this method at least once before printing text.\n\n        Default encoding is not specified, but all text writing methods accept only\n        unicode for external fonts and one byte encoding for standard.\n\n        Standard fonts use `Latin-1` encoding by default, but Windows\n        encoding `cp1252` (Western Europe) can be used with\n        `self.core_fonts_encoding = encoding`.\n\n        The font specified is retained from page to page.\n        The method can be called before the first page is created.\n\n        Args:\n            family (str): name of a font added with `FPDF.add_font`,\n                or name of one of the 14 standard \"PostScript\" fonts:\n                Courier (fixed-width), Helvetica (sans serif), Times (serif),\n                Symbol (symbolic) or ZapfDingbats (symbolic)\n                If an empty string is provided, the current family is retained.\n            style (str, fpdf.enums.TextEmphasis): empty string (by default) or a combination\n                of one or several letters among B (bold), I (italic), S (strikethrough) and U (underline).\n                Bold and italic styles do not apply to Symbol and ZapfDingbats fonts.\n            size (float): in points. The default value is the current size.\n        \"\"\"\n        if not family:\n            family = self.font_family\n\n        family = family.lower()\n        if isinstance(style, TextEmphasis):\n            style = style.style\n        style = \"\".join(sorted(style.upper()))\n        if any(letter not in \"BISU\" for letter in style):\n            raise ValueError(\n                f\"Unknown style provided (only B/I/S/U letters are allowed): {style}\"\n            )\n        if \"U\" in style:\n            self.underline = True\n            style = style.replace(\"U\", \"\")\n        else:\n            self.underline = False\n        if \"S\" in style:\n            self.strikethrough = True\n            style = style.replace(\"S\", \"\")\n        else:\n            self.strikethrough = False\n\n        if family in self.font_aliases and family + style not in self.fonts:\n            warnings.warn(\n                f\"Substituting font {family} by core font {self.font_aliases[family]}\"\n                \" - This is deprecated since v2.7.8, and will soon be removed\",\n                DeprecationWarning,\n                stacklevel=get_stack_level(),\n            )\n            family = self.font_aliases[family]\n        elif family in (\"symbol\", \"zapfdingbats\") and style:\n            warnings.warn(\n                f\"Built-in font {family} only has a single 'style' \"\n                \"and can't be bold or italic\",\n                stacklevel=get_stack_level(),\n            )\n            style = \"\"\n\n        if not size:\n            size = self.font_size_pt\n\n        # Test if font is already selected\n        if (\n            self.font_family == family\n            and self.font_style == style\n            and isclose(self.font_size_pt, size)\n        ):\n            return\n\n        # Test if used for the first time\n        fontkey = family + style\n        if fontkey not in self.fonts:\n            if fontkey not in CORE_FONTS:\n                raise FPDFException(\n                    f\"Undefined font: {fontkey} - \"\n                    f\"Use built-in fonts or FPDF.add_font() beforehand\"\n                )\n            # If it's one of the core fonts, add it to self.fonts\n            if self._compliance and self._compliance.profile == \"PDFA\":\n                raise PDFAComplianceError(\n                    f\"Usage of base fonts is now allowed for documents compliant with {self._compliance.label}. Use add_font() to embed a font file\"\n                )\n\n            self.fonts[fontkey] = CoreFont(len(self.fonts) + 1, fontkey, style)\n\n        # Select it\n        self.font_family = family\n        self.font_style = style\n        self.font_size_pt = size\n        self.current_font = self.fonts[fontkey]\n        self.current_font_is_set_on_page = False\n\n    def set_font_size(self, size: float) -> None:\n        \"\"\"\n        Configure the font size in points\n\n        Args:\n            size (float): font size in points\n        \"\"\"\n        if isclose(self.font_size_pt, size):\n            return\n        self.font_size_pt = size\n        self.current_font_is_set_on_page = False\n\n    def _set_font_for_page(\n        self,\n        font: CoreFont | TTFFont,\n        font_size_pt: float,\n        wrap_in_text_object: bool = True,\n    ) -> str:\n        \"\"\"\n        Set font and size for current page.\n        This step is needed before adding text into page and not needed in set_font and set_font_size.\n        \"\"\"\n        sl = f\"/F{font.i} {font_size_pt:.2f} Tf\"\n        if wrap_in_text_object:\n            sl = f\"BT {sl} ET\"\n        self._resource_catalog.add(PDFResourceType.FONT, font.i, self.page)\n        self.current_font_is_set_on_page = True\n        return sl\n\n    def set_char_spacing(self, spacing: float) -> None:\n        \"\"\"\n        Sets horizontal character spacing.\n        A positive value increases the space between characters, a negative value\n        reduces it (which may result in glyph overlap).\n        By default, no spacing is set (which is equivalent to a value of 0).\n\n        Args:\n            spacing (float): horizontal spacing in document units\n        \"\"\"\n        if self.char_spacing == spacing:\n            return\n        self.char_spacing = spacing\n        if self.page > 0:\n            self._out(f\"BT {spacing:.2f} Tc ET\")\n\n    def set_stretching(self, stretching: float) -> None:\n        \"\"\"\n        Sets horizontal font stretching.\n        By default, no stretching is set (which is equivalent to a value of 100).\n\n        Args:\n            stretching (float): horizontal stretching (scaling) in percents.\n        \"\"\"\n        if self.font_stretching == stretching:\n            return\n        self.font_stretching = stretching\n        if self.page > 0:\n            self._out(f\"BT {stretching:.2f} Tz ET\")\n\n    def set_fallback_fonts(\n        self, fallback_fonts: Sequence[str], exact_match: bool = True\n    ) -> None:\n        \"\"\"\n        Allows you to specify a list of fonts to be used if any character is not available on the font currently set.\n        Detailed documentation: https://py-pdf.github.io/fpdf2/Unicode.html#fallback-fonts\n\n        Args:\n            fallback_fonts: sequence of fallback font IDs\n            exact_match (bool): when a glyph cannot be rendered uing the current font,\n                fpdf2 will look for a fallback font matching the current character emphasis (bold/italics).\n                If it does not find such matching font, and `exact_match` is True, no fallback font will be used.\n                If it does not find such matching font, and `exact_match` is False, a fallback font will still be used.\n                To get even more control over this logic, you can also override `FPDF.get_fallback_font()`\n        \"\"\"\n        fallback_font_ids: list[str] = []\n        for fallback_font in fallback_fonts:\n            found = False\n            for fontkey in self.fonts:\n                # will add all font styles on the same family\n                if fontkey.replace(\"B\", \"\").replace(\"I\", \"\") == fallback_font.lower():\n                    if fontkey not in fallback_font_ids:\n                        fallback_font_ids.append(fontkey)\n                    found = True\n            if not found:\n                raise FPDFException(\n                    f\"Undefined fallback font: {fallback_font} - Use FPDF.add_font() beforehand\"\n                )\n        self._fallback_font_ids = fallback_font_ids\n        self._fallback_font_exact_match = exact_match\n\n    def add_link(\n        self,\n        y: float = 0,\n        x: float = 0,\n        page: int = -1,\n        zoom: str | float = \"null\",\n        name: Optional[str] = None,\n    ) -> int:\n        \"\"\"\n        Creates a new internal link and returns its identifier.\n        An internal link is a clickable area which directs to another place within the document.\n\n        The identifier can then be passed to the `FPDF.cell()`, `FPDF.write()`, `FPDF.image()`\n        or `FPDF.link()` methods.\n\n        If a name is provided, creates a named destination that can be referenced later.\n        Named destinations are more stable than plain links when pages are added or removed.\n\n        Args:\n            y (float): optional ordinate of target position.\n                The default value is 0 (top of page).\n            x (float): optional abscissa of target position.\n                The default value is 0 (top of page).\n            page (int): optional number of target page.\n                -1 indicates the current page, which is the default value.\n            zoom (float): optional new zoom level after following the link.\n                Currently ignored by Sumatra PDF Reader, but observed by Adobe Acrobat reader.\n            name (str, optional): Name for the destination. If provided, creates a named\n                destination in the PDF that can be referenced from other parts of the document\n                or from external documents.\n        \"\"\"\n        # Create destination\n        link = DestinationXYZ(\n            self.page if page == -1 else page,\n            top=self.h_pt - y * self.k,\n            left=x * self.k,\n            zoom=zoom,\n        )\n\n        # Handle named destinations\n        if name is not None:\n            if not name or name.isspace():\n                raise ValueError(\"Destination name cannot be empty or whitespace\")\n            self.named_destinations[name] = link\n\n        # Store link and return index\n        link_index = len(self.links) + 1\n        self.links[link_index] = link\n        return link_index\n\n    def get_named_destination(self, name: str) -> str:\n        \"\"\"\n        Retrieves a named destination by its name and creates a link to it.\n\n        Args:\n            name (str): The name of the destination to retrieve.\n\n        Returns:\n            str: A string with format \"#name\" that can be used with cell(), write(), image(), or link()\n\n        Raises:\n            KeyError: If no destination exists with the given name\n        \"\"\"\n        if name not in self.named_destinations:\n            # Create a placeholder named destination pointing to page 0\n            # This will be caught during output if never set properly\n            self.named_destinations[name] = DestinationXYZ(0, top=self.h_pt * self.k)\n\n        # Return the name prefixed with # to indicate it's a named destination\n        # This way, the link() method will use the named destination string\n        return f\"#{name}\"\n\n    def set_link(\n        self,\n        link: Optional[int] = None,\n        y: float = 0,\n        x: float = 0,\n        page: int = -1,\n        zoom: float | str = \"null\",\n        name: Optional[str] = None,\n    ) -> DestinationXYZ | str:\n        \"\"\"\n        Defines the page and position a link points to.\n\n        Args:\n            link (int, optional): a link identifier returned by `FPDF.add_link()`.\n                If None and name is provided, will create or update a named destination.\n            y (float): optional ordinate of target position.\n                The default value is 0 (top of page).\n            x (float): optional abscissa of target position.\n                The default value is 0 (top of page).\n            page (int): optional number of target page.\n                -1 indicates the current page, which is the default value.\n            zoom (float): optional new zoom level after following the link.\n                Currently ignored by Sumatra PDF Reader, but observed by Adobe Acrobat reader.\n            name (str, optional): Name for the destination. If provided, creates or updates a named\n                destination in the PDF that can be referenced from other parts of the document\n                or from external documents.\n        \"\"\"\n        # Handle named destination case\n        if name and link is None:\n            # Create the destination\n            dest = DestinationXYZ(\n                self.page if page == -1 else page,\n                top=self.h_pt - y * self.k,\n                left=x * self.k,\n                zoom=zoom,\n            )\n            # Store it in the named destinations dictionary\n            self.named_destinations[name] = dest\n            # Return the name for reference\n            return name\n\n        # Regular link handling (backward compatibility)\n        # We must take care to update the existing DestinationXYZ,\n        # and NOT re-assign self.links[link] to a new instance,\n        # as a reference to self.links[link] is kept in self.pages[].annots:\n        assert link is not None\n        destination = self.links[link]\n        destination.page_number = self.page if page == -1 else page\n        destination.top = self.h_pt - y * self.k\n        destination.left = x * self.k\n        destination.zoom = zoom\n\n        # If a name is provided with an existing link, associate the name with this link\n        if name:\n            self.named_destinations[name] = destination\n            return name\n\n        # Return link index for backward compatibility\n        return destination\n\n    def link(\n        self,\n        x: float,\n        y: float,\n        w: float,\n        h: float,\n        link: str | int,\n        alt_text: Optional[str] = None,\n        **kwargs: Any,\n    ) -> AnnotationDict:\n        \"\"\"\n        Puts a link annotation on a rectangular area of the page.\n        Text or image links are generally put via `FPDF.cell`,\n        `FPDF.write` or `FPDF.image`,\n        but this method can be useful for instance to define a clickable area inside an image.\n\n        Args:\n            x (float): horizontal position (from the left) to the left side of the link rectangle\n            y (float): vertical position (from the top) to the bottom side of the link rectangle\n            w (float): width of the link rectangle\n            h (float): height of the link rectangle\n            link: can be one of the following:\n                - a URL string to create an external link\n                - an integer returned by `FPDF.add_link`, defining an internal link to a page\n                - a named destination string prefixed with '#' (e.g., '#chapter1')\n            alt_text (str): optional textual description of the link, for accessibility purposes\n            border_width (int): thickness of an optional black border surrounding the link.\n                Not all PDF readers honor this: Acrobat renders it but not Sumatra.\n        \"\"\"\n        action: Optional[URIAction] = None\n        dest: Optional[PDFString | DestinationXYZ] = None\n        if link:\n            if isinstance(link, str):\n                # Check if this is a named destination (prefixed with '#')\n                if link.startswith(\"#\"):\n                    dest_name = link[1:]  # Remove the '#' prefix\n                    # If the named destination doesn't exist yet, create a placeholder\n                    # destination pointing to page 0 (which doesn't exist)\n                    # This will be caught during output if never set properly\n                    if dest_name not in self.named_destinations:\n                        self.named_destinations[dest_name] = DestinationXYZ(\n                            0, top=self.h_pt * self.k\n                        )\n                    # Use destination name instead of destination object for named destinations\n                    dest = PDFString(dest_name, encrypt=True)\n                else:\n                    # Regular URL\n                    action = URIAction(link)\n            else:  # Dest type ending of annotation entry\n                assert (\n                    link in self.links\n                ), f\"Link with an invalid index: {link} (doc #links={len(self.links)})\"\n                dest = self.links[link]\n                if not dest.page_number:\n                    raise ValueError(\n                        f\"Cannot insert link {link} with no page number assigned\"\n                    )\n        link_annot = AnnotationDict(\n            \"Link\",\n            x=x * self.k,\n            y=self.h_pt - y * self.k,\n            width=w * self.k,\n            height=h * self.k,\n            action=action,\n            dest=dest,\n            **kwargs,\n        )\n        self.pages[self.page].add_annotation(link_annot)\n        if alt_text is not None:\n            # Note: the spec indicates that a /StructParent could be added **inside* this /Annot,\n            # but tests with Adobe Acrobat Reader reveal that the page /StructParents inserted below\n            # is enough to link the marked content in the hierarchy tree with this annotation link.\n            self._add_marked_content(struct_type=\"/Link\", alt_text=alt_text)\n        return link_annot\n\n    def embed_file(\n        self,\n        file_path: Optional[Union[str, Path]] = None,\n        bytes: Optional[bytes] = None,\n        basename: Optional[str] = None,\n        modification_date: Optional[datetime] = None,\n        mime_type: Optional[str] = None,\n        associated_file_relationship: Optional[str] = None,\n        **kwargs: Any,\n    ) -> PDFEmbeddedFile:\n        \"\"\"\n        Embed a file into the PDF as an attachment (and, for PDF/A-3 or PDF/A-4f, as an\n        Associated File).\n\n        Args:\n            file_path (str or Path): filesystem path to the existing file to embed\n            bytes (bytes): optional, as an alternative to file_path, bytes content of the file to embed\n            basename (str): optional, required if bytes is provided, file base name\n            creation_date (datetime): date and time when the file was created\n            modification_date (datetime): date and time when the file was last modified\n            desc (str): optional description of the file\n            mime_type: MIME type of the embedded content (e.g., \"application/pdf\", \"text/csv\", \"image/png\")\n            associated_file_relationship: For PDF/A-3/A-4f, the AF relationship to declare in the FileSpec\n                (e.g., \"Data\", \"Source\", \"Alternative\", \"Supplement\", or \"Unspecified\").\n\n            **kwargs:\n            desc (str): Optional human-readable description for the FileSpec.\n            creation_date (datetime): Original creation time of the file.\n            compress (bool): enabled zlib compression of the file - False by default\n            checksum (bool): insert a MD5 checksum of the file content - False by default\n\n        Returns: a PDFEmbeddedFile instance, with a .basename string attribute representing the internal file name\n        \"\"\"\n        if file_path:\n            if bytes:\n                raise ValueError(\"'bytes' cannot be provided with 'file_path'\")\n            if basename:\n                raise ValueError(\"'basename' cannot be provided with 'file_path'\")\n            file_path = Path(file_path)\n            with file_path.open(\"rb\") as input_file:\n                bytes = input_file.read()\n            basename = file_path.name\n            stats = file_path.stat()\n            if modification_date is None:\n                modification_date = datetime.fromtimestamp(stats.st_mtime).astimezone()\n        else:\n            if not bytes:\n                raise ValueError(\"'bytes' is required if 'file_path' is not provided\")\n            if not basename:\n                raise ValueError(\n                    \"'basename' is required if 'file_path' is not provided\"\n                )\n        if mime_type is None:\n            mime_type = mimetypes.guess_type(basename)[0] or \"application/octet-stream\"\n        mime_type = mime_type.lower()\n        af_relationship = (\n            AssociatedFileRelationship.coerce(associated_file_relationship)\n            if associated_file_relationship is not None\n            else None\n        )\n        already_embedded_basenames = set(\n            file.basename() for file in self.embedded_files\n        )\n        if basename in already_embedded_basenames:\n            raise ValueError(f\"{basename} has already been embedded in this file\")\n\n        if self._compliance and self._compliance.profile == \"PDFA\":\n            if self._compliance.part == 1:\n                raise PDFAComplianceError(\n                    f\"Embedding files is not allowed for documents compliant with {self._compliance.label}\"\n                )\n            if self._compliance.part == 2 or (\n                self._compliance.part == 4 and self._compliance.conformance is None\n            ):\n                if (mime_type == \"application/pdf\") or basename.lower().endswith(\n                    \".pdf\"\n                ):\n                    LOGGER.warning(\n                        \"%s: ensure the embedded PDF '%s' is itself PDF/A to remain compliant.\",\n                        self._compliance.label,\n                        basename,\n                    )\n                else:\n                    raise PDFAComplianceError(\n                        f\"{self._compliance.label} permits embedding only PDF files, which must themselves be PDF/A.\"\n                    )\n            if self._compliance.part in (3, 4):\n                if af_relationship is None:\n                    af_relationship = AssociatedFileRelationship.UNSPECIFIED\n\n        embedded_file = PDFEmbeddedFile(\n            basename=basename,\n            contents=bytes,\n            modification_date=modification_date,\n            mime_type=mime_type,\n            af_relationship=af_relationship,\n            **kwargs,\n        )\n        self.embedded_files.append(embedded_file)\n        self._set_min_pdf_version(\"1.4\")\n        return embedded_file\n\n    @check_page\n    def file_attachment_annotation(\n        self,\n        file_path: str | Path,\n        x: float,\n        y: float,\n        w: float = 1,\n        h: float = 1,\n        name: Optional[FileAttachmentAnnotationName | str] = None,\n        flags: tuple[AnnotationFlag | str, ...] = DEFAULT_ANNOT_FLAGS,\n        **kwargs: Any,\n    ) -> AnnotationDict:\n        \"\"\"\n        Puts a file attachment annotation on a rectangular area of the page.\n\n        Args:\n            file_path (str or Path): filesystem path to the existing file to embed\n            x (float): horizontal position (from the left) to the left side of the link rectangle\n            y (float): vertical position (from the top) to the bottom side of the link rectangle\n            w (float): optional width of the link rectangle\n            h (float): optional height of the link rectangle\n            name (fpdf.enums.FileAttachmentAnnotationName, str): optional icon that shall be used in displaying the annotation\n            flags (Tuple[fpdf.enums.AnnotationFlag], Tuple[str]): optional list of flags defining annotation properties\n            bytes (bytes): optional, as an alternative to file_path, bytes content of the file to embed\n            basename (str): optional, required if bytes is provided, file base name\n            creation_date (datetime): date and time when the file was created\n            modification_date (datetime): date and time when the file was last modified\n            desc (str): optional description of the file\n            compress (bool): enabled zlib compression of the file - False by default\n            checksum (bool): insert a MD5 checksum of the file content - False by default\n        \"\"\"\n        embedded_file = self.embed_file(file_path, **kwargs)\n        # Attachment annotations should not be listed in the document-level AF entry\n        # (they are reachable through the annotation itself), so keep them out of AF:\n        embedded_file.set_globally_enclosed(False)\n        annotation = AnnotationDict(\n            \"FileAttachment\",\n            x * self.k,\n            self.h_pt - y * self.k,\n            w * self.k,\n            h * self.k,\n            file_spec=embedded_file.file_spec(),\n            name=FileAttachmentAnnotationName.coerce(name) if name else None,\n            flags=flags,\n        )\n        self.pages[self.page].add_annotation(annotation)\n        return annotation\n\n    @check_page\n    def text_annotation(\n        self,\n        x: float,\n        y: float,\n        text: str,\n        w: float = 1,\n        h: float = 1,\n        name: Optional[AnnotationName | str] = None,\n        **kwargs: Any,\n    ) -> AnnotationDict:\n        \"\"\"\n        Puts a text annotation on a rectangular area of the page.\n\n        Args:\n            x (float): horizontal position (from the left) to the left side of the link rectangle\n            y (float): vertical position (from the top) to the bottom side of the link rectangle\n            text (str): text to display\n            w (float): optional width of the link rectangle\n            h (float): optional height of the link rectangle\n            name (fpdf.enums.AnnotationName, str): optional icon that shall be used in displaying the annotation\n            flags (Tuple[fpdf.enums.AnnotationFlag], Tuple[str]): optional list of flags defining annotation properties\n            title (str): the text label that shall be displayed in the title bar of the annotation’s\n                pop-up window when open and active. This entry shall identify the user who added the annotation.\n        \"\"\"\n        annotation = AnnotationDict(\n            \"Text\",\n            x * self.k,\n            self.h_pt - y * self.k,\n            w * self.k,\n            h * self.k,\n            contents=text,\n            name=AnnotationName.coerce(name) if name else None,\n            **kwargs,\n        )\n        self.pages[self.page].add_annotation(annotation)\n        return annotation\n\n    @check_page\n    def free_text_annotation(\n        self,\n        text: str,\n        x: Optional[float] = None,\n        y: Optional[float] = None,\n        w: Optional[float] = None,\n        h: Optional[float] = None,\n        **kwargs: Any,\n    ) -> AnnotationDict:\n        \"\"\"\n        Puts a free text annotation on a rectangular area of the page.\n\n        Args:\n            text (str): text to display\n            x (float): optional horizontal position (from the left) to the left side of the link rectangle.\n                Default value: None, meaning the current abscissa is used\n            y (float): vertical position (from the top) to the bottom side of the link rectangle.\n                Default value: None, meaning the current ordinate is used\n            w (float): optional width of the link rectangle. Default value: None, meaning the length of text in user unit\n            h (float): optional height of the link rectangle. Default value: None, meaning an height equal\n                to the current font size\n            flags (Tuple[fpdf.enums.AnnotationFlag], Tuple[str]): optional list of flags defining annotation properties\n            color (tuple): a tuple of numbers in the range 0.0 to 1.0, representing a colour used for the annotation background\n            border_width (float): width of the annotation border\n        \"\"\"\n        if not self.font_family:\n            raise FPDFException(\"No font set, you need to call set_font() beforehand\")\n        if not self.current_font_is_set_on_page:\n            assert self.current_font is not None\n            self._out(self._set_font_for_page(self.current_font, self.font_size_pt))\n        if x is None:\n            x = self.x\n        if y is None:\n            y = self.y\n        if h is None:\n            h = self.font_size\n        if w is None:\n            w = self.get_string_width(text, normalized=True, markdown=False)\n\n        assert self.draw_color is not None and self.current_font is not None\n        annotation = AnnotationDict(\n            \"FreeText\",\n            x * self.k,\n            self.h_pt - y * self.k,\n            w * self.k,\n            h * self.k,\n            contents=text,\n            default_appearance=f\"({self.draw_color.serialize()} /F{self.current_font.i} {self.font_size_pt:.2f} Tf)\",\n            **kwargs,\n        )\n        self.pages[self.page].add_annotation(annotation)\n        return annotation\n\n    @check_page\n    def add_action(\n        self, action: Action, x: float, y: float, w: float, h: float, **kwargs: Any\n    ) -> AnnotationDict:\n        \"\"\"\n        Puts an Action annotation on a rectangular area of the page.\n\n        Args:\n            action (fpdf.actions.Action): the action to add\n            x (float): horizontal position (from the left) to the left side of the link rectangle\n            y (float): vertical position (from the top) to the bottom side of the link rectangle\n            w (float): width of the link rectangle\n            h (float): height of the link rectangle\n        \"\"\"\n        annotation_action_type = \"Action\"\n        if isinstance(action, GoToAction):\n            annotation_action_type = \"Link\"\n        annotation = AnnotationDict(\n            annotation_action_type,\n            x * self.k,\n            self.h_pt - y * self.k,\n            w * self.k,\n            h * self.k,\n            action=action,\n            **kwargs,\n        )\n        self.pages[self.page].add_annotation(annotation)\n        return annotation\n\n    @contextmanager\n    def highlight(\n        self,\n        text: str,\n        type: TextMarkupType | str = \"Highlight\",\n        color: tuple[float, float, float] = (1, 1, 0),\n        modification_time: Optional[datetime] = None,\n        **kwargs: Any,\n    ) -> Iterator[None]:\n        \"\"\"\n        Context manager that adds a single highlight annotation based on the text lines inserted\n        inside its indented block.\n\n        Args:\n            text (str): text of the annotation\n            title (str): the text label that shall be displayed in the title bar of the annotation’s\n                pop-up window when open and active. This entry shall identify the user who added the annotation.\n            type (fpdf.enums.TextMarkupType, str): \"Highlight\", \"Underline\", \"Squiggly\" or \"StrikeOut\".\n            color (tuple): a tuple of numbers in the range 0.0 to 1.0, representing a colour used for\n                the title bar of the annotation’s pop-up window. Defaults to yellow.\n            modification_time (datetime): date and time when the annotation was most recently modified\n        \"\"\"\n        if self._record_text_quad_points:\n            raise FPDFException(\"highlight() cannot be nested\")\n        self._record_text_quad_points = True\n        yield\n        for page, quad_points in self._text_quad_points.items():\n            self.add_text_markup_annotation(\n                type,\n                text,\n                quad_points=quad_points,\n                modification_time=modification_time,\n                page=page,\n                color=color,\n                **kwargs,\n            )\n        self._text_quad_points = defaultdict(list)\n        self._record_text_quad_points = False\n\n    @contextmanager\n    def add_highlight(self, *args: Any, **kwargs: Any) -> Iterator[None]:\n        warnings.warn(\n            \"add_highlight() has been renamed to highlight() in v2.5.5.\",\n            DeprecationWarning,\n            stacklevel=get_stack_level(),\n        )\n        with self.highlight(*args, **kwargs):\n            yield\n\n    @check_page\n    def add_text_markup_annotation(\n        self,\n        type: TextMarkupType | str,\n        text: str,\n        quad_points: Sequence[float],\n        color: tuple[float, float, float] = (1, 1, 0),\n        modification_time: Optional[datetime] = None,\n        page: Optional[int] = None,\n        **kwargs: Any,\n    ) -> AnnotationDict:\n        \"\"\"\n        Adds a text markup annotation on some quadrilateral areas of the page.\n\n        Args:\n            type (fpdf.enums.TextMarkupType, str): \"Highlight\", \"Underline\", \"Squiggly\" or \"StrikeOut\"\n            text (str): text of the annotation\n            quad_points (tuple): array of 8 × n numbers specifying the coordinates of n quadrilaterals\n                in default user space that comprise the region in which the link should be activated.\n                The coordinates for each quadrilateral are given in the order: x1 y1 x2 y2 x3 y3 x4 y4\n                specifying the four vertices of the quadrilateral in counterclockwise order\n            title (str): the text label that shall be displayed in the title bar of the annotation’s\n                pop-up window when open and active. This entry shall identify the user who added the annotation.\n            color (tuple): a tuple of numbers in the range 0.0 to 1.0, representing a colour used for\n                the title bar of the annotation’s pop-up window. Defaults to yellow.\n            modification_time (datetime): date and time when the annotation was most recently modified\n            page (int): index of the page where this annotation is added\n        \"\"\"\n        self._set_min_pdf_version(\"1.6\")\n        type = TextMarkupType.coerce(type).value\n        if modification_time is None:\n            modification_time = self.creation_date\n        if page is None:\n            page = self.page\n        x_min = min(quad_points[0::2])\n        y_min = min(quad_points[1::2])\n        x_max = max(quad_points[0::2])\n        y_max = max(quad_points[1::2])\n        annotation = AnnotationDict(\n            type,\n            contents=text,\n            x=y_min,\n            y=y_max,\n            width=x_max - x_min,\n            height=y_max - y_min,\n            modification_time=modification_time,\n            quad_points=quad_points,\n            color=color,\n            **kwargs,\n        )\n        self.pages[page].add_annotation(annotation)\n        return annotation\n\n    @check_page\n    def ink_annotation(\n        self,\n        coords: Sequence[tuple[float, float]],\n        text: str = \"\",\n        color: tuple[float, float, float] = (1, 1, 0),\n        border_width: float = 1,\n        **kwargs: Any,\n    ) -> AnnotationDict:\n        \"\"\"\n        Adds add an ink annotation on the page.\n\n        Args:\n            coords (tuple): an iterable of coordinates (pairs of numbers) defining a path\n            text (str): textual description\n            title (str): the text label that shall be displayed in the title bar of the annotation’s\n                pop-up window when open and active. This entry shall identify the user who added the annotation.\n            color (tuple): a tuple of numbers in the range 0.0 to 1.0, representing a colour used for\n                the title bar of the annotation’s pop-up window. Defaults to yellow.\n            border_width (float): thickness of the path stroke.\n        \"\"\"\n        ink_list = sum(((x * self.k, (self.h - y) * self.k) for (x, y) in coords), ())\n        x_min = min(ink_list[0::2])\n        y_min = min(ink_list[1::2])\n        x_max = max(ink_list[0::2])\n        y_max = max(ink_list[1::2])\n        annotation = AnnotationDict(\n            \"Ink\",\n            x=y_min,\n            y=y_max,\n            width=x_max - x_min,\n            height=y_max - y_min,\n            ink_list=ink_list,\n            contents=text,\n            border_width=border_width,\n            color=color,\n            **kwargs,\n        )\n        self.pages[self.page].add_annotation(annotation)\n        return annotation\n\n    @check_page\n    @support_deprecated_txt_arg\n    def text(self, x: float, y: float, text: str = \"\") -> None:\n        \"\"\"\n        Prints a character string. The origin is on the left of the first character,\n        on the baseline. This method allows placing a string precisely on the page,\n        but it is usually easier to use the `FPDF.cell()`, `FPDF.multi_cell() or `FPDF.write()` methods.\n\n        Args:\n            x (float): abscissa of the origin\n            y (float): ordinate of the origin\n            text (str): string to print\n            txt (str): [**DEPRECATED since v2.7.6**] string to print\n\n        Notes\n        -----\n\n        `text()` lacks many of the features available in `FPDF.write()`,\n        `FPDF.cell()` and `FPDF.multi_cell()` like markdown and text shaping.\n        \"\"\"\n        if not self.font_family:\n            raise FPDFException(\"No font set, you need to call set_font() beforehand\")\n        text = self.normalize_text(text)\n        assert self.current_font is not None\n        if not self.current_font_is_set_on_page:\n            self._out(self._set_font_for_page(self.current_font, self.font_size_pt))\n        sl = [f\"BT {x * self.k:.2f} {(self.h - y) * self.k:.2f} Td\"]\n        if self.text_mode != TextMode.FILL:\n            sl.append(f\" {self.text_mode} Tr {self.line_width:.2f} w\")\n        sl.append(f\"{self.current_font.encode_text(text)} ET\")\n        if (\n            text != \"\" and (self.underline or self.strikethrough)\n        ) or self._record_text_quad_points:\n            w = self.get_string_width(text, normalized=True, markdown=False)\n            if text != \"\":\n                if self.underline:\n                    sl.append(self._do_underline(x, y, w))\n                if self.strikethrough:\n                    sl.append(self._do_strikethrough(x, y, w))\n            if self._record_text_quad_points:\n                h = self.font_size\n                y -= 0.8 * h  # same coefficient as in _render_styled_text_line()\n                self._add_quad_points(x, y, w, h)\n        attr_l: list[str] = []\n        if self.fill_color != self.text_color:\n            assert self.text_color is not None\n            attr_l.append(f\"{self.text_color.serialize().lower()}\")\n        if attr_l:\n            sl = [\"q\"] + attr_l + sl + [\"Q\"]\n        self._out(\" \".join(sl))\n\n    @check_page\n    def rotate(\n        self, angle: float, x: Optional[float] = None, y: Optional[float] = None\n    ) -> None:\n        \"\"\"\n        .. deprecated:: 2.1.0\n            Use `FPDF.rotation()` instead.\n        \"\"\"\n        warnings.warn(\n            (\n                \"rotate() can produces malformed PDFs and is deprecated since v2.1.0. \"\n                \"It will be removed in a future release. \"\n                \"Use the rotation() context manager instead.\"\n            ),\n            DeprecationWarning,\n            stacklevel=get_stack_level(),\n        )\n        if x is None:\n            x = self.x\n        if y is None:\n            y = self.y\n\n        if self._angle != 0:\n            self._out(\"Q\")\n        self._angle = angle\n        if angle != 0:\n            angle *= math.pi / 180\n            c = math.cos(angle)\n            s = math.sin(angle)\n            cx = x * self.k\n            cy = (self.h - y) * self.k\n            output = (\n                f\"q {c:.5F} {s:.5F} {-s:.5F} {c:.5F} {cx:.2F} {cy:.2F} cm \"\n                f\"1 0 0 1 {-cx:.2F} {-cy:.2F} cm\"\n            )\n            self._out(output)\n\n    @check_page\n    @contextmanager\n    def rotation(\n        self, angle: float, x: Optional[float] = None, y: Optional[float] = None\n    ) -> Iterator[None]:\n        \"\"\"\n        Method to perform a rotation around a given center.\n        It must be used as a context-manager using `with`:\n\n            with rotation(angle=90, x=x, y=y):\n                pdf.something()\n\n        The rotation affects all elements which are printed inside the indented\n        context (with the exception of clickable areas).\n\n        Args:\n            angle (float): angle in degrees\n            x (float): abscissa of the center of the rotation\n            y (float): ordinate of the center of the rotation\n\n        Notes\n        -----\n\n        Only the rendering is altered. The `FPDF.get_x()` and `FPDF.get_y()` methods are\n        not affected, nor the automatic page break mechanism.\n        The rotation also establishes a local graphics state, so that any\n        graphics state settings changed within will not affect the operations\n        invoked after it has finished.\n        \"\"\"\n        if x is None:\n            x = self.x\n        if y is None:\n            y = self.y\n        angle *= math.pi / 180\n        c, s = math.cos(angle), math.sin(angle)\n        cx, cy = x * self.k, (self.h - y) * self.k\n        with self.local_context():\n            self._out(\n                f\"{c:.5F} {s:.5F} {-s:.5F} {c:.5F} {cx:.2F} {cy:.2F} cm \"\n                f\"1 0 0 1 {-cx:.2F} {-cy:.2F} cm\"\n            )\n            yield\n\n    @check_page\n    @contextmanager\n    def skew(\n        self,\n        ax: float = 0,\n        ay: float = 0,\n        x: Optional[float] = None,\n        y: Optional[float] = None,\n    ) -> Iterator[None]:\n        \"\"\"\n        Method to perform a skew transformation originating from a given center.\n        It must be used as a context-manager using `with`:\n\n            with skew(ax=15, ay=15, x=x, y=y):\n                pdf.something()\n\n        The skew transformation affects all elements which are printed inside the indented\n        context (with the exception of clickable areas).\n\n        Args:\n            ax (float): angle of skew in the horizontal direction in degrees\n            ay (float): angle of skew in the vertical direction in degrees\n            x (float): abscissa of the center of the skew transformation\n            y (float): ordinate of the center of the skew transformation\n        \"\"\"\n        lim_val = 2**32\n        if x is None:\n            x = self.x\n        if y is None:\n            y = self.y\n        ax = max(min(math.tan(ax * (math.pi / 180)), lim_val), -lim_val)\n        ay = max(min(math.tan(ay * (math.pi / 180)), lim_val), -lim_val)\n        cx, cy = x * self.k, (self.h - y) * self.k\n        with self.local_context():\n            self._out(\n                f\"1 {ay:.5f} {ax:.5f} 1 {cx:.2f} {cy:.2f} cm \"\n                f\"1 0 0 1 -{cx:.2f} -{cy:.2f} cm\"\n            )\n            yield\n\n    @check_page\n    @contextmanager\n    def mirror(\n        self, origin: tuple[float, float], angle: Angle | str | float\n    ) -> Iterator[None]:\n        \"\"\"\n        Method to perform a reflection transformation over a given mirror line.\n        It must be used as a context-manager using `with`:\n\n            with mirror(origin=(15,15), angle=\"SOUTH\"):\n                pdf.something()\n\n        The mirror transformation affects all elements which are rendered inside the indented\n        context (with the exception of clickable areas).\n\n        Args:\n            origin (float, Sequence(float, float)): a point on the mirror line\n            angle: (fpdf.enums.Angle): the direction of the mirror line\n        \"\"\"\n        x, y = origin\n\n        try:\n            if isinstance(angle, (str, Angle)):\n                theta = float(Angle.coerce(angle).value)\n            else:\n                theta = float(angle)\n        except ValueError:\n            theta = float(angle)\n\n        a = math.cos(math.radians(theta * 2))\n        b = math.sin(math.radians(theta * 2))\n        cx, cy = x * self.k, (self.h - y) * self.k\n\n        with self.local_context():\n            self._out(\n                f\"{a:.5f} {b:.5f} {b:.5f} {a*-1:.5f} {cx:.2f} {cy:.2f} cm \"\n                f\"1 0 0 1 -{cx:.2f} -{cy:.2f} cm\"\n            )\n            yield\n\n    @check_page\n    @contextmanager\n    def local_context(self, **kwargs: Any) -> Iterator[None]:\n        \"\"\"\n        Creates a local graphics state, which won't affect the surrounding code.\n        This method must be used as a context manager using `with`:\n\n            with pdf.local_context():\n                set_some_state()\n                draw_some_stuff()\n\n        The affected settings are those controlled by GraphicsStateMixin and drawing.GraphicsStyle:\n\n        * allow_transparency\n        * auto_close\n        * blend_mode\n        * char_vpos\n        * char_spacing\n        * dash_pattern\n        * denom_lift\n        * denom_scale\n        * draw_color\n        * fill_color\n        * fill_opacity\n        * font_family\n        * font_size\n        * font_size_pt\n        * font_style\n        * font_stretching\n        * intersection_rule\n        * line_width\n        * nom_lift\n        * nom_scale\n        * paint_rule\n        * strikethrough\n        * stroke_cap_style\n        * stroke_join_style\n        * stroke_miter_limit\n        * stroke_opacity\n        * sub_lift\n        * sub_scale\n        * sup_lift\n        * sup_scale\n        * text_color\n        * text_mode\n        * text_shaping\n        * underline\n\n        Font size can be specified in document units with `font_size` or in points with `font_size_pt`.\n\n        Args:\n            **kwargs: key-values settings to set at the beginning of this context.\n        \"\"\"\n        if self._in_unbreakable:\n            raise FPDFException(\n                \"cannot create a local context inside an unbreakable() code block\"\n            )\n        self._push_local_stack()\n        self._start_local_context(**kwargs)\n        yield\n        self._end_local_context()\n        self._pop_local_stack()\n\n    def _start_local_context(\n        self,\n        font_family: Optional[str] = None,\n        font_style: Optional[str] = None,\n        font_size_pt: Optional[float] = None,\n        line_width: Optional[float] = None,\n        draw_color: Optional[ColorInput] = None,\n        fill_color: Optional[ColorInput] = None,\n        text_color: Optional[ColorInput] = None,\n        dash_pattern: Optional[\n            Union[tuple[float, float, float], dict[str, float]]\n        ] = None,\n        **kwargs: Any,\n    ) -> None:\n        \"\"\"\n        This method starts a \"q/Q\" context in the page content stream,\n        and inserts operators in it to initialize all the PDF settings specified.\n        \"\"\"\n        if \"font_size\" in kwargs:\n            # At some point we may want to deprecate font_size here in favour of font_size_pt,\n            # and raise a warning if font_size is provided:\n            # * font_size_pt is more consistent with the size parameter of .set_font(), provided in points.\n            # * font_size can be misused, as users may not be aware of the difference between the 2 properties,\n            #   and may erroneously provide a value in points as font_size.\n            if font_size_pt is not None:\n                raise ValueError(\"font_size & font_size_pt cannot be both provided\")\n            font_size_pt = kwargs[\"font_size\"] * self.k\n            del kwargs[\"font_size\"]\n        gs = None\n        for key, value in kwargs.items():\n            if key in (\n                \"stroke_color\",\n                \"stroke_dash_phase\",\n                \"stroke_dash_pattern\",\n                \"stroke_width\",\n            ):\n                raise ValueError(\n                    f\"Unsupported setting: {key} - This can be controlled through dash_pattern / draw_color / line_width\"\n                )\n            if key in GraphicsStyle.MERGE_PROPERTIES:\n                if gs is None:\n                    gs = GraphicsStyle()\n                setattr(gs, key, value)\n                if key == \"blend_mode\":\n                    self._set_min_pdf_version(\"1.4\")\n            elif key in (\n                \"char_vpos\",\n                \"char_spacing\",\n                \"current_font\",\n                \"denom_lift\",\n                \"denom_scale\",\n                \"font_stretching\",\n                \"nom_lift\",\n                \"nom_scale\",\n                \"strikethrough\",\n                \"sub_lift\",\n                \"sub_scale\",\n                \"sup_lift\",\n                \"sup_scale\",\n                \"text_mode\",\n                \"text_shaping\",\n                \"underline\",\n                \"current_font_is_set_on_page\",\n            ):\n                setattr(self, key, value)\n            else:\n                raise ValueError(f\"Unsupported setting: {key}\")\n        if gs:\n            gs_name = self._resource_catalog.register_graphics_style(gs)\n            assert gs_name is not None\n            self._resource_catalog.add(PDFResourceType.EXT_G_STATE, gs_name, self.page)\n            self._out(f\"q /{gs_name} gs\")\n        else:\n            self._out(\"q\")\n        # All the following calls to .set*() methods invoke .out() and write to the stream buffer:\n        if (\n            font_family is not None\n            or font_style is not None\n            or font_size_pt is not None\n        ):\n            self.set_font(\n                font_family or self.font_family,\n                # Beware: font_style='' must be handled distinctly from font_style=None\n                self.font_style if font_style is None else font_style,\n                font_size_pt or self.font_size_pt,\n            )\n        if line_width is not None:\n            self.set_line_width(line_width)\n        if draw_color is not None:\n            self.set_draw_color(draw_color)\n        if fill_color is not None:\n            self.set_fill_color(fill_color)\n        if text_color is not None:\n            self.set_text_color(text_color)\n        if dash_pattern is not None:\n            if isinstance(dash_pattern, dict):\n                self.set_dash_pattern(\n                    dash_pattern.get(\"dash\", 0),\n                    dash_pattern.get(\"gap\", 0),\n                    dash_pattern.get(\"phase\", 0),\n                )\n            else:\n                self.set_dash_pattern(dash_pattern[0], dash_pattern[1], dash_pattern[2])\n\n    def _end_local_context(self) -> None:\n        \"\"\"\n        This method ends a \"q/Q\" context in the page content stream.\n        \"\"\"\n        self._out(\"Q\")\n\n    @property\n    def accept_page_break(self) -> bool:\n        \"\"\"\n        Whenever a page break condition is met, this `@property` method is called,\n        and the break is issued or not depending on the returned value.\n\n        The default implementation returns `self.auto_page_break`,\n        a value according to the mode selected by `FPDF.set_auto_page_break()`.\n\n        This method is called automatically and should not be called directly by the application.\n\n        Detailed documentation on page breaks: https://py-pdf.github.io/fpdf2/PageBreaks.html\n        \"\"\"\n        return self.auto_page_break\n\n    @check_page\n    @support_deprecated_txt_arg\n    def cell(\n        self,\n        w: Optional[float] = None,\n        h: Optional[float] = None,\n        text: str = \"\",\n        border: Literal[0, 1] | str = 0,\n        ln: Literal[\"DEPRECATED\"] = \"DEPRECATED\",\n        align: str | Align = Align.L,\n        fill: bool = False,\n        link: Optional[str | int] = \"\",\n        center: bool = False,\n        markdown: bool = False,\n        new_x: str | XPos = XPos.RIGHT,\n        new_y: str | YPos = YPos.TOP,\n    ) -> bool:\n        \"\"\"\n        Prints a cell (rectangular area) with optional borders, background color and\n        character string. The upper-left corner of the cell corresponds to the current\n        position. The text can be aligned or centered. After the call, the current\n        position moves to the selected `new_x`/`new_y` position. It is possible to put a link\n        on the text. A cell has an horizontal padding, on the left & right sides, defined by\n        the.c_margin property.\n\n        If automatic page breaking is enabled and the cell goes beyond the limit, a\n        page break is performed before outputting.\n\n        Args:\n            w (float): Cell width. Default value: None, meaning to fit text width.\n                If 0, the cell extends up to the right margin.\n            h (float): Cell height. Default value: None, meaning an height equal\n                to the current font size.\n            text (str): String to print. Default value: empty string.\n            border: Indicates if borders must be drawn around the cell.\n                The value can be either a number (`0`: no border ; `1`: frame)\n                or a string containing some or all of the following characters\n                (in any order):\n                `L`: left ; `T`: top ; `R`: right ; `B`: bottom. Default value: 0.\n            new_x (fpdf.enums.XPos, str): New current position in x after the call. Default: RIGHT\n            new_y (fpdf.enums.YPos, str): New current position in y after the call. Default: TOP\n            ln (int): **DEPRECATED since 2.5.1**: Use `new_x` and `new_y` instead.\n            align (fpdf.enums.Align, str): Set text alignment inside the cell.\n                Possible values are: `L` or empty string: left align (default value) ;\n                `C`: center; `X`: center around current x position; `R`: right align\n            fill (bool): Indicates if the cell background must be painted (`True`)\n                or transparent (`False`). Default value: False.\n            link (str): optional link to add on the cell, internal\n                (identifier returned by `FPDF.add_link`) or external URL.\n            center (bool): center the cell horizontally on the page.\n            markdown (bool): enable minimal markdown-like markup to render part\n                of text as bold / italics / strikethrough / underlined.\n                Supports `\\\\` as escape character. Default to False.\n            txt (str): [**DEPRECATED since v2.7.6**] String to print. Default value: empty string.\n\n        Returns: a boolean indicating if page break was triggered\n        \"\"\"\n        if not self.font_family:\n            raise FPDFException(\"No font set, you need to call set_font() beforehand\")\n        if isinstance(w, str) or isinstance(h, str):\n            raise ValueError(\n                \"Parameter 'w' and 'h' must be numbers, not strings.\"\n                \" You can omit them by passing string content with text=\"\n            )\n        if isinstance(border, int) and border not in (0, 1):\n            warnings.warn(\n                'Integer values for \"border\" parameter other than 1 are currently ignored',\n                stacklevel=get_stack_level(),\n            )\n            border = 1\n        new_x = XPos.coerce(new_x)\n        new_y = YPos.coerce(new_y)\n        align = Align.coerce(align)\n        if align == Align.J:\n            raise ValueError(\n                \"cell() only produces one text line, justified alignment is not possible\"\n            )\n        if ln != \"DEPRECATED\":\n            # For backwards compatibility, if \"ln\" is used we overwrite \"new_[xy]\".\n            if ln == 0:\n                new_x = XPos.RIGHT\n                new_y = YPos.TOP\n            elif ln == 1:\n                new_x = XPos.LMARGIN\n                new_y = YPos.NEXT\n            elif ln == 2:\n                new_x = XPos.LEFT\n                new_y = YPos.NEXT\n            else:\n                raise ValueError(\n                    f'Invalid value for parameter \"ln\" ({ln}),'\n                    \" must be an int between 0 and 2.\"\n                )\n            warnings.warn(\n                (\n                    'The parameter \"ln\" is deprecated since v2.5.2.'\n                    f\" Instead of ln={ln} use new_x=XPos.{new_x.name}, new_y=YPos.{new_y.name}.\"\n                ),\n                DeprecationWarning,\n                stacklevel=get_stack_level(),\n            )\n        # Font styles preloading must be performed before any call to FPDF.get_string_width:\n        text = self.normalize_text(text)\n        styled_txt_frags = (\n            self._preload_bidirectional_text(text, markdown)\n            if self.text_shaping\n            else self._preload_font_styles(text, markdown)\n        )\n        line_height = self.font_size if h is None else h\n        return self._render_styled_text_line(\n            TextLine(\n                styled_txt_frags,\n                text_width=0,\n                number_of_spaces=0,\n                align=align,\n                height=line_height,\n                max_width=w,\n                trailing_nl=False,\n            ),\n            line_height,\n            border,\n            new_x=new_x,\n            new_y=new_y,\n            fill=fill,\n            link=link,\n            center=center,\n            prevent_font_change=markdown,\n        )\n\n    def _render_styled_text_line(\n        self,\n        text_line: TextLine,\n        h: Optional[float] = None,\n        border: Union[str, int] = 0,\n        new_x: XPos = XPos.RIGHT,\n        new_y: YPos = YPos.TOP,\n        fill: bool = False,\n        link: Optional[str | int] = \"\",\n        center: bool = False,\n        padding: Optional[Padding] = None,\n        prevent_font_change: bool = False,\n    ) -> bool:\n        \"\"\"\n        Prints a cell (rectangular area) with optional borders, background color and\n        character string. The upper-left corner of the cell corresponds to the current\n        position. The text can be aligned, centered or justified. After the call, the\n        current position moves to the requested new position. It is possible to put a\n        link on the text.\n\n        If automatic page breaking is enabled and the cell goes beyond the limit, a\n        page break is performed before outputting.\n\n        Args:\n            text_line (TextLine instance): Contains the (possibly empty) tuple of\n                fragments to render.\n            h (float): Cell height. Default value: None, meaning an height equal\n                to the current font size.\n            border: Indicates if borders must be drawn around the cell.\n                The value can be either a number (`0`: no border ; `1`: frame)\n                or a string containing some or all of the following characters\n                (in any order):\n                `L`: left ; `T`: top ; `R`: right ; `B`: bottom. Default value: 0.\n            new_x (fpdf.enums.XPos): New current position in x after the call.\n            new_y (fpdf.enums.YPos): New current position in y after the call.\n            fill (bool): Indicates if the cell background must be painted (`True`)\n                or transparent (`False`). Default value: False.\n            link (str): optional link to add on the cell, internal\n                (identifier returned by `FPDF.add_link`) or external URL.\n            center (bool): center the cell horizontally on the page.\n            padding (Padding or None): optional padding to apply to the cell content.\n                If padding for left and right is non-zero then c_margin is ignored.\n            prevent_font_change (bool): ensure no font settings (family / size / style)\n                change during this call.\n\n        Returns: a boolean indicating if page break was triggered\n        \"\"\"\n        if isinstance(border, int) and border not in (0, 1):\n            warnings.warn(\n                'Integer values for \"border\" parameter other than 1 are currently ignored',\n                stacklevel=get_stack_level(),\n            )\n            border = 1\n        elif isinstance(border, str) and set(border).issuperset(\"LTRB\"):\n            border = 1\n\n        if padding is None:\n            padding = Padding(0, 0, 0, 0)\n        l_c_margin = r_c_margin = float(0)\n        if padding.left == 0:\n            l_c_margin = self.c_margin\n        if padding.right == 0:\n            r_c_margin = self.c_margin\n\n        styled_txt_width = text_line.text_width\n        if not styled_txt_width:\n            for i, frag in enumerate(text_line.fragments):\n                unscaled_width = frag.get_width(initial_cs=i != 0)\n                styled_txt_width += unscaled_width\n\n        w = text_line.max_width\n        if w is None:\n            if not text_line.fragments:\n                raise ValueError(\n                    \"'text_line' must have fragments if 'text_line.text_width' is None\"\n                )\n            w = styled_txt_width + l_c_margin + r_c_margin\n        elif w == 0:\n            w = self.w - self.r_margin - self.x\n        if center:\n            self.x = self.l_margin + (self.epw - w) / 2\n        elif text_line.align == Align.X:\n            self.x -= w / 2\n\n        max_font_size: float = 0  # how much height we need to accommodate.\n        # currently all font sizes within a line are vertically aligned on the baseline.\n        fragments = text_line.get_ordered_fragments()\n        for frag in fragments:\n            if frag.font_size > max_font_size:\n                max_font_size = frag.font_size\n        if h is None:\n            h = max_font_size\n        page_break_triggered = self._perform_page_break_if_need_be(h)\n        sl: list[str] = []\n\n        k = self.k\n\n        # pre-calc border edges with padding\n\n        left = (self.x - padding.left) * k\n        right = (self.x + w + padding.right) * k\n        top = (self.h - self.y + padding.top) * k\n        bottom = (self.h - (self.y + h) - padding.bottom) * k\n\n        if fill:\n            op = \"B\" if border == 1 else \"f\"\n            sl.append(f\"{left:.2f} {top:.2f} {right-left:.2f} {bottom-top:.2f} re {op}\")\n        elif border == 1:\n            sl.append(f\"{left:.2f} {top:.2f} {right-left:.2f} {bottom-top:.2f} re S\")\n        # pylint: enable=invalid-unary-operand-type\n\n        if isinstance(border, str):\n            if \"L\" in border:\n                sl.append(f\"{left:.2f} {top:.2f} m {left:.2f} {bottom:.2f} l S\")\n            if \"T\" in border:\n                sl.append(f\"{left:.2f} {top:.2f} m {right:.2f} {top:.2f} l S\")\n            if \"R\" in border:\n                sl.append(f\"{right:.2f} {top:.2f} m {right:.2f} {bottom:.2f} l S\")\n            if \"B\" in border:\n                sl.append(f\"{left:.2f} {bottom:.2f} m {right:.2f} {bottom:.2f} l S\")\n\n        if self._record_text_quad_points:\n            self._add_quad_points(self.x, self.y, w, h)\n\n        s_start = self.x\n        s_width: float = 0\n        # We try to avoid modifying global settings for temporary changes.\n        current_ws = frag_ws = 0.0\n        current_lift = 0.0\n        current_char_vpos = CharVPos.LINE\n        current_font = self.current_font\n        current_font_size_pt = self.font_size_pt\n        current_font_style = self.font_style\n        current_text_mode = self.text_mode\n        current_font_stretching = self.font_stretching\n        current_char_spacing = self.char_spacing\n        fill_color_changed = False\n        last_used_color = self.fill_color\n        if fragments:\n            if text_line.align == Align.R:\n                dx = w - l_c_margin - styled_txt_width\n            elif text_line.align in [Align.C, Align.X]:\n                dx = (w - styled_txt_width) / 2\n            else:\n                dx = l_c_margin\n            s_start += dx\n            word_spacing: float = 0\n            if text_line.align == Align.J and text_line.number_of_spaces:\n                word_spacing = (\n                    w - l_c_margin - r_c_margin - styled_txt_width\n                ) / text_line.number_of_spaces\n            sl.append(\n                f\"BT {(self.x + dx) * k:.2f} \"\n                f\"{(self.h - self.y - 0.5 * h - 0.3 * max_font_size) * k:.2f} Td\"\n            )\n            underlines: list[tuple[float, float, CoreFont | TTFFont, float]] = []\n            strikethroughs: list[tuple[float, float, CoreFont | TTFFont, float]] = []\n            for i, frag in enumerate(fragments):\n                if isinstance(frag, TotalPagesSubstitutionFragment):\n                    self.pages[self.page].add_text_substitution(frag)\n                if frag.text_color != last_used_color:\n                    # allow to change color within the line of text.\n                    last_used_color = frag.text_color\n                    assert last_used_color is not None\n                    sl.append(last_used_color.serialize().lower())\n                    fill_color_changed = True\n                if word_spacing and frag.font_stretching != 100:\n                    # Space character is already stretched, extra spacing is absolute.\n                    frag_ws = word_spacing * 100 / frag.font_stretching\n                else:\n                    frag_ws = word_spacing\n                if current_font_stretching != frag.font_stretching:\n                    current_font_stretching = frag.font_stretching\n                    sl.append(f\"{frag.font_stretching:.2f} Tz\")\n                if current_char_spacing != frag.char_spacing:\n                    current_char_spacing = frag.char_spacing\n                    sl.append(f\"{frag.char_spacing:.2f} Tc\")\n                if not self.current_font_is_set_on_page:\n                    if prevent_font_change:\n                        # This is \"local\" to the current BT / ET context:\n                        current_font = frag.font\n                        current_font_size_pt = frag.font_size_pt\n                        current_font_style = frag.font_style\n                        sl.append(f\"/F{current_font.i} {current_font_size_pt:.2f} Tf\")\n                        self._resource_catalog.add(\n                            PDFResourceType.FONT, current_font.i, self.page\n                        )\n                        current_char_vpos = frag.char_vpos\n                    else:\n                        # This is \"global\" to the page,\n                        # as it is rendered in the content stream\n                        # BEFORE the text_lines /fragments,\n                        # wrapped into BT / ET operators:\n                        current_font = self.current_font = frag.font\n                        current_font_size_pt = self.font_size_pt = frag.font_size_pt\n                        current_font_style = self.font_style = frag.font_style\n                        self._out(\n                            self._set_font_for_page(\n                                current_font,\n                                current_font_size_pt,\n                            )\n                        )\n                        current_char_vpos = frag.char_vpos\n                elif (\n                    current_font != frag.font\n                    or current_font_size_pt != frag.font_size_pt\n                    or current_font_style != frag.font_style\n                    or current_char_vpos != frag.char_vpos\n                ):\n                    # This is \"local\" to the current BT / ET context:\n                    current_font = frag.font\n                    current_font_size_pt = frag.font_size_pt\n                    current_font_style = frag.font_style\n                    sl.append(\n                        self._set_font_for_page(\n                            current_font,\n                            current_font_size_pt,\n                            wrap_in_text_object=False,\n                        )\n                    )\n                    current_char_vpos = frag.char_vpos\n                lift = frag.lift\n                if lift != current_lift:\n                    # Use text rise operator:\n                    sl.append(f\"{lift:.2f} Ts\")\n                    current_lift = lift\n                if (\n                    frag.text_mode != TextMode.FILL\n                    or frag.text_mode != current_text_mode\n                ):\n                    current_text_mode = frag.text_mode\n                    sl.append(f\"{frag.text_mode} Tr {frag.line_width:.2f} w\")\n\n                r_text = frag.render_pdf_text(\n                    frag_ws,\n                    current_ws,\n                    word_spacing,\n                    self.x + dx + s_width,\n                    self.y + (0.5 * h + 0.3 * max_font_size),\n                    self.h,\n                )\n                if r_text:\n                    sl.append(r_text)\n\n                frag_width = frag.get_width(\n                    initial_cs=i != 0\n                ) + word_spacing * frag.characters.count(\" \")\n                if frag.underline:\n                    underlines.append(\n                        (self.x + dx + s_width, frag_width, frag.font, frag.font_size)\n                    )\n                if frag.strikethrough:\n                    strikethroughs.append(\n                        (self.x + dx + s_width, frag_width, frag.font, frag.font_size)\n                    )\n                if frag.link:\n                    self.link(\n                        x=self.x + dx + s_width,\n                        y=self.y + (0.5 * h) - (0.5 * frag.font_size),\n                        w=frag_width,\n                        h=frag.font_size,\n                        link=frag.link,\n                    )\n                if not frag.is_ttf_font:\n                    current_ws = frag_ws\n                s_width += frag_width\n\n            sl.append(\"ET\")\n\n            # Underlines & strikethrough must be rendred OUTSIDE BT/ET contexts,\n            # cf. https://github.com/py-pdf/fpdf2/issues/1456\n            if underlines:\n                for start_x, width, font, font_size in underlines:\n                    sl.append(\n                        self._do_underline(\n                            start_x, self.y + (0.5 * h) + (0.3 * font_size), width, font\n                        )\n                    )\n            if strikethroughs:\n                for start_x, width, font, font_size in strikethroughs:\n                    sl.append(\n                        self._do_strikethrough(\n                            start_x, self.y + (0.5 * h) + (0.3 * font_size), width, font\n                        )\n                    )\n            if link:\n                self.link(\n                    self.x + dx,\n                    self.y\n                    + (0.5 * h)\n                    - (\n                        0.5\n                        * frag.font_size  # pyright: ignore[reportPossiblyUnboundVariable]\n                    ),\n                    styled_txt_width,\n                    frag.font_size,  # pyright: ignore[reportPossiblyUnboundVariable]\n                    link,\n                )\n\n        if sl:\n            # If any PDF settings have been left modified, wrap the line\n            # in a local context.\n            # pylint: disable=too-many-boolean-expressions\n            if (\n                current_ws != 0.0\n                or current_lift != 0.0\n                or current_char_vpos != CharVPos.LINE\n                or current_font != self.current_font\n                or current_font_size_pt != self.font_size_pt\n                or current_font_style != self.font_style\n                or current_text_mode != self.text_mode\n                or fill_color_changed\n                or current_font_stretching != self.font_stretching\n                or current_char_spacing != self.char_spacing\n            ):\n                s = f\"q {' '.join(sl)} Q\"\n            else:\n                s = \" \".join(sl)\n            # pylint: enable=too-many-boolean-expressions\n            self._out(s)\n        # If the text is empty, h = max_font_size ends up as 0.\n        # We still need a valid default height for self.ln() (issue #601).\n        self._lasth = h or self.font_size\n\n        # XPos.LEFT -> self.x stays the same\n        if new_x == XPos.RIGHT:\n            self.x += w\n        elif new_x == XPos.START:\n            self.x = s_start\n        elif new_x == XPos.END:\n            self.x = s_start + s_width\n        elif new_x == XPos.WCONT:\n            if s_width:\n                self.x = s_start + s_width - r_c_margin\n            else:\n                self.x = s_start\n        elif new_x == XPos.CENTER:\n            self.x = s_start + s_width / 2.0\n        elif new_x == XPos.LMARGIN:\n            self.x = self.l_margin\n        elif new_x == XPos.RMARGIN:\n            self.x = self.w - self.r_margin\n\n        # YPos.TOP:  -> self.y stays the same\n        # YPos.LAST: -> self.y stays the same (single line)\n        if new_y == YPos.NEXT:\n            self.y += h\n        if new_y == YPos.TMARGIN:\n            self.y = self.t_margin\n        if new_y == YPos.BMARGIN:\n            self.y = self.h - self.b_margin\n\n        return page_break_triggered\n\n    def _add_quad_points(self, x: float, y: float, w: float, h: float) -> None:\n        self._text_quad_points[self.page].extend(\n            [\n                x * self.k,\n                (self.h - y) * self.k,\n                (x + w) * self.k,\n                (self.h - y) * self.k,\n                x * self.k,\n                (self.h - y - h) * self.k,\n                (x + w) * self.k,\n                (self.h - y - h) * self.k,\n            ]\n        )\n\n    def _preload_bidirectional_text(\n        self, text: str, markdown: bool\n    ) -> Sequence[Fragment]:\n        \"\"\" \"\n        Break the text into bidirectional segments and preload font styles for each fragment\n        \"\"\"\n        if not self.text_shaping:\n            return self._preload_font_styles(text, markdown)\n        paragraph_direction = (\n            self.text_shaping[\"direction\"]\n            if self.text_shaping[\"direction\"]\n            else auto_detect_base_direction(text)\n        )\n\n        paragraph = BidiParagraph(text=text, base_direction=paragraph_direction)\n        directional_segments = paragraph.get_bidi_fragments()\n        self.text_shaping[\"paragraph_direction\"] = paragraph.base_direction\n\n        fragments: list[Fragment] = []\n        for bidi_text, bidi_direction in directional_segments:\n            self.text_shaping[\"fragment_direction\"] = bidi_direction\n            fragments += self._preload_font_styles(bidi_text, markdown)\n        return tuple(fragments)\n\n    def _preload_font_styles(\n        self, text: Optional[str], markdown: bool\n    ) -> Sequence[Fragment]:\n        \"\"\"\n        When Markdown styling is enabled, we require secondary fonts\n        to ender text in bold & italics.\n        This function ensure that those fonts are available.\n        It needs to perform Markdown parsing,\n        so we return the resulting `styled_txt_frags` tuple\n        to avoid repeating this processing later on.\n        \"\"\"\n        if not text:\n            return tuple()\n        prev_font_style = self.font_style\n        if self.underline:\n            prev_font_style += \"U\"\n        if self.strikethrough:\n            prev_font_style += \"S\"\n        styled_txt_frags = tuple(self._parse_chars(text, markdown))\n        if markdown:\n            page = self.page\n            # We set the current to page to zero so that\n            # set_font() does not produce any text object on the stream buffer:\n            self.page = 0\n            if any(frag.font_style == \"B\" for frag in styled_txt_frags):\n                # Ensuring bold font is supported:\n                self.set_font(style=\"B\")\n            if any(frag.font_style == \"I\" for frag in styled_txt_frags):\n                # Ensuring italics font is supported:\n                self.set_font(style=\"I\")\n            if any(frag.font_style == \"BI\" for frag in styled_txt_frags):\n                # Ensuring bold italics font is supported:\n                self.set_font(style=\"BI\")\n            if any(frag.font_style == \"\" for frag in styled_txt_frags):\n                # Ensuring base font is supported:\n                self.set_font(style=\"\")\n            for frag in styled_txt_frags:\n                frag.font = self.fonts[frag.font_family + frag.font_style]\n            # Restoring initial style:\n            self.set_font(style=prev_font_style)\n            self.page = page\n        return styled_txt_frags\n\n    def get_fallback_font(self, char: str, style: str = \"\") -> Optional[str]:\n        \"\"\"\n        Returns which fallback font has the requested glyph.\n        This method can be overridden to provide more control than the `select_mode` parameter\n        of `FPDF.set_fallback_fonts()` provides.\n        \"\"\"\n        emphasis = TextEmphasis.coerce(style)\n        fonts_with_char = [\n            font_id\n            for font_id in self._fallback_font_ids\n            if ord(char) in self.fonts[font_id].cmap  # type: ignore[union-attr]\n        ]\n        if not fonts_with_char:\n            return None\n        font_with_matching_emphasis = next(\n            (font for font in fonts_with_char if self.fonts[font].emphasis == emphasis),\n            None,\n        )\n        if font_with_matching_emphasis:\n            return font_with_matching_emphasis\n        if self._fallback_font_exact_match:\n            return None\n        return fonts_with_char[0]\n\n    def _parse_chars(self, text: str, markdown: bool) -> Iterator[Fragment]:\n        \"Split text into fragments\"\n        if not markdown and not self.text_shaping and not self._fallback_font_ids:\n            if self.str_alias_nb_pages:\n                for seq, fragment_text in enumerate(\n                    text.split(self.str_alias_nb_pages)\n                ):\n                    if seq > 0:\n                        yield TotalPagesSubstitutionFragment(\n                            self.str_alias_nb_pages,\n                            self._get_current_graphics_state(),\n                            self.k,\n                        )\n                    if fragment_text:\n                        yield Fragment(\n                            fragment_text, self._get_current_graphics_state(), self.k\n                        )\n                return\n\n            yield Fragment(text, self._get_current_graphics_state(), self.k)\n            return\n        txt_frag: list[str] = []\n        in_bold: bool = \"B\" in self.font_style\n        in_italics: bool = \"I\" in self.font_style\n        in_strikethrough: bool = bool(self.strikethrough)\n        in_underline: bool = bool(self.underline)\n        current_fallback_font = None\n        current_text_script = None\n\n        def frag() -> Fragment:\n            nonlocal txt_frag, current_fallback_font, current_text_script\n            gstate = self._get_current_graphics_state()\n            gstate.font_style = (\"B\" if in_bold else \"\") + (\"I\" if in_italics else \"\")\n            gstate.strikethrough = in_strikethrough\n            gstate.underline = in_underline\n            if current_fallback_font:\n                style = \"\".join(c for c in current_fallback_font if c in (\"BI\"))\n                family = current_fallback_font.replace(\"B\", \"\").replace(\"I\", \"\")\n                gstate.font_family = family\n                gstate.font_style = style\n                gstate.current_font = self.fonts[current_fallback_font]\n                current_fallback_font = None\n                current_text_script = None\n            fragment = Fragment(\n                txt_frag,\n                gstate,\n                self.k,\n            )\n            txt_frag = []\n            return fragment\n\n        if self.is_ttf_font:\n            font_glyphs = self.current_font.cmap  # type: ignore[union-attr]\n        else:\n            font_glyphs = []\n        num_escape_chars = 0\n\n        while text:\n            is_marker = text[:2] in (\n                self.MARKDOWN_BOLD_MARKER,\n                self.MARKDOWN_ITALICS_MARKER,\n                self.MARKDOWN_STRIKETHROUGH_MARKER,\n                self.MARKDOWN_UNDERLINE_MARKER,\n            )\n            half_marker = text[0]\n            text_script = get_unicode_script(text[0])\n            if text_script not in (\n                UnicodeScript.COMMON,\n                UnicodeScript.UNKNOWN,\n                current_text_script,\n            ):\n                if txt_frag and current_text_script:\n                    yield frag()\n                current_text_script = text_script\n\n            if self.str_alias_nb_pages:\n                if text[: len(self.str_alias_nb_pages)] == self.str_alias_nb_pages:\n                    if txt_frag:\n                        yield frag()\n                    gstate = self._get_current_graphics_state()\n                    gstate.font_style = (\"B\" if in_bold else \"\") + (\n                        \"I\" if in_italics else \"\"\n                    )\n                    gstate.strikethrough = in_strikethrough\n                    gstate.underline = in_underline\n                    yield TotalPagesSubstitutionFragment(\n                        self.str_alias_nb_pages,\n                        gstate,\n                        self.k,\n                    )\n                    text = text[len(self.str_alias_nb_pages) :]\n                    continue\n\n            # Check that previous & next characters are not identical to the marker:\n            if markdown:\n                if (\n                    is_marker\n                    and (not txt_frag or txt_frag[-1] != half_marker)\n                    and (len(text) < 3 or text[2] != half_marker)\n                ):\n                    txt_frag = (\n                        txt_frag[: -((num_escape_chars + 1) // 2)]\n                        if num_escape_chars > 0\n                        else txt_frag\n                    )\n                    if num_escape_chars % 2 == 0:\n                        if txt_frag:\n                            yield frag()\n                        if text[:2] == self.MARKDOWN_BOLD_MARKER:\n                            in_bold = not in_bold\n                        if text[:2] == self.MARKDOWN_ITALICS_MARKER:\n                            in_italics = not in_italics\n                        if text[:2] == self.MARKDOWN_STRIKETHROUGH_MARKER:\n                            in_strikethrough = not in_strikethrough\n                        if text[:2] == self.MARKDOWN_UNDERLINE_MARKER:\n                            in_underline = not in_underline\n                        text = text[2:]\n                        continue\n                num_escape_chars = (\n                    num_escape_chars + 1\n                    if text[0] == self.MARKDOWN_ESCAPE_CHARACTER\n                    else 0\n                )\n                is_link = self.MARKDOWN_LINK_REGEX.match(text)\n                if is_link:\n                    link_text, link_dest, text = is_link.groups()\n                    if txt_frag:\n                        yield frag()\n                    gstate = self._get_current_graphics_state()\n                    gstate.underline = self.MARKDOWN_LINK_UNDERLINE\n                    if self.MARKDOWN_LINK_COLOR:\n                        gstate.text_color = convert_to_device_color(\n                            self.MARKDOWN_LINK_COLOR\n                        )\n                    try:\n                        page = int(link_dest)\n                        link_dest = self.add_link(page=page)\n                    except ValueError:\n                        pass\n                    yield Fragment(\n                        list(link_text),\n                        gstate,\n                        self.k,\n                        link=link_dest,\n                    )\n                    continue\n            if self.is_ttf_font and text[0] != \"\\n\" and not ord(text[0]) in font_glyphs:\n                style = (\"B\" if in_bold else \"\") + (\"I\" if in_italics else \"\")\n                fallback_font = self.get_fallback_font(text[0], style)\n                if fallback_font:\n                    if fallback_font == current_fallback_font:\n                        txt_frag.append(text[0])\n                        text = text[1:]\n                        continue\n                    if txt_frag:\n                        yield frag()\n                    current_fallback_font = fallback_font\n                    txt_frag.append(text[0])\n                    text = text[1:]\n                    continue\n            if current_fallback_font:\n                if txt_frag:\n                    yield frag()\n                current_fallback_font = None\n            txt_frag.append(text[0])\n            text = text[1:]\n        if txt_frag:\n            yield frag()\n\n    def will_page_break(self, height: float) -> bool:\n        \"\"\"\n        Let you know if adding an element will trigger a page break,\n        based on its height and the current ordinate (`y` position).\n\n        Detailed documentation on page breaks: https://py-pdf.github.io/fpdf2/PageBreaks.html\n\n        Args:\n            height (float): height of the section that would be added, e.g. a cell\n\n        Returns: a boolean indicating if a page break would occur\n        \"\"\"\n        return (\n            self.y + height > self.page_break_trigger\n            and not self.in_footer\n            and self.accept_page_break\n        )\n\n    def _perform_page_break_if_need_be(self, h: float) -> bool:\n        if self.will_page_break(h):\n            LOGGER.debug(\n                \"Page break on page %d at y=%d for element of height %d > %d\",\n                self.page,\n                self.y,\n                h,\n                self.page_break_trigger,\n            )\n            self._perform_page_break()\n            return True\n        return False\n\n    def _perform_page_break(self) -> None:\n        \"\"\"\n        Performs a page break, taking care to preserve self.x\n        and a potential existing `fpdf.fpdf.FPDF.local_context()`.\n        A call to `fpdf.fpdf.FPDF.will_page_break()` should be performed beforehand.\n        \"\"\"\n        x = self.x\n        # If we are in a .local_context(), we need to temporarily leave it,\n        # by popping out every GraphicsState:\n        gs_stack: list[StateStackType] = []\n        while self._is_current_graphics_state_nested():\n            gs_stack.append(self._get_current_graphics_state())\n            self._pop_local_stack()\n            # This code assumes that every Graphics State in the stack\n            # has been pushed in it while adding a \"q\" in the PDF stream\n            # (which is what FPDF.local_context() does):\n            self._end_local_context()\n        # Using a temporary GS to render header & footer:\n        self.current_font_is_set_on_page = False\n        self._push_local_stack()\n        self.add_page(same=True)\n        self._pop_local_stack()\n        for prev_gs in reversed(gs_stack):\n            self._push_local_stack()\n            prev_gs.current_font_is_set_on_page = False\n            self._start_local_context(**prev_gs.as_kwargs())\n        self.x = x  # restore x but not y after drawing header\n\n    def _has_next_page(self) -> bool:\n        return self.pages_count > self.page\n\n    @contextmanager\n    def _disable_writing(self) -> Iterator[None]:\n        if not isinstance(self._out, types.MethodType):\n            # This mean that self._out has already been redefined.\n            # This is the case of a nested call to this method: we do nothing\n            yield\n            return\n        self._out = lambda *args, **kwargs: None  # type: ignore[method-assign]\n        prev_page, prev_pages_count, prev_x, prev_y = (\n            self.page,\n            self.pages_count,\n            self.x,\n            self.y,\n        )\n        annots = self.pages[self.page].annots or PDFArray()\n        self._push_local_stack()\n        try:\n            yield\n        finally:\n            self._pop_local_stack()\n            # restore location:\n            for p in range(prev_pages_count + 1, self.pages_count + 1):\n                del self.pages[p]\n            self.page = prev_page\n            self.pages[self.page].annots = annots\n            self.set_xy(prev_x, prev_y)\n            # restore writing function:\n            del self._out\n\n    # multi_cell has dynamic results depending on the `output` parameter\n    MultiCellPageBreakResult: TypeAlias = bool\n    MultiCellLinesResult: TypeAlias = list[str]\n    MultiCellHeightResult: TypeAlias = float\n\n    MultiCellResult: TypeAlias = (\n        MultiCellPageBreakResult\n        | MultiCellLinesResult\n        | MultiCellHeightResult\n        | tuple[MultiCellPageBreakResult, MultiCellLinesResult]\n        | tuple[MultiCellPageBreakResult, MultiCellHeightResult]\n        | tuple[MultiCellLinesResult, MultiCellHeightResult]\n        | tuple[MultiCellPageBreakResult, MultiCellLinesResult, MultiCellHeightResult]\n    )\n\n    @check_page\n    @support_deprecated_txt_arg\n    def multi_cell(\n        self,\n        w: float,\n        h: Optional[float] = None,\n        text: str = \"\",\n        border: Literal[0, 1] | str = 0,\n        align: str | Align = Align.J,\n        fill: bool = False,\n        split_only: bool = False,  # DEPRECATED\n        link: Optional[int | str] = None,\n        ln: Literal[\"DEPRECATED\"] = \"DEPRECATED\",\n        max_line_height: Optional[float] = None,\n        markdown: bool = False,\n        print_sh: bool = False,\n        new_x: str | XPos = XPos.RIGHT,\n        new_y: str | YPos = YPos.NEXT,\n        wrapmode: WrapMode = WrapMode.WORD,\n        dry_run: bool = False,\n        output: str | MethodReturnValue = MethodReturnValue.PAGE_BREAK,\n        center: bool = False,\n        padding: int | Sequence[int] | Padding = 0,\n    ) -> MultiCellResult:\n        \"\"\"\n        This method allows printing text with line breaks. They can be automatic\n        (breaking at the most recent space or soft-hyphen character) as soon as the text\n        reaches the right border of the cell, or explicit (via the `\\\\n` character).\n        As many cells as necessary are stacked, one below the other.\n        Text can be aligned, centered or justified. The cell block can be framed and\n        the background painted. A cell has an horizontal padding, on the left & right sides,\n        defined by the.c_margin property.\n\n        Args:\n            w (float): cell width. If 0, they extend up to the right margin of the page.\n            h (float): height of a single line of text.  Default value: None, meaning to use the current font size.\n            text (str): string to print.\n            border: Indicates if borders must be drawn around the cell.\n                The value can be either a number (`0`: no border ; `1`: frame)\n                or a string containing some or all of the following characters\n                (in any order):\n                `L`: left ; `T`: top ; `R`: right ; `B`: bottom. Default value: 0.\n            align (fpdf.enums.Align, str): Set text alignment inside the cell.\n                Possible values are:\n                `J`: justify (default value); `L` or empty string: left align;\n                `C`: center; `X`: center around current x position; `R`: right align\n            fill (bool): Indicates if the cell background must be painted (`True`)\n                or transparent (`False`). Default value: False.\n            split_only (bool): **DEPRECATED since 2.7.4**:\n                Use `dry_run=True` and `output=(\"LINES\",)` instead.\n            link (str): optional link to add on the cell, internal\n                (identifier returned by `add_link`) or external URL.\n            new_x (fpdf.enums.XPos, str): New current position in x after the call. Default: RIGHT\n            new_y (fpdf.enums.YPos, str): New current position in y after the call. Default: NEXT\n            ln (int): **DEPRECATED since 2.5.1**: Use `new_x` and `new_y` instead.\n            max_line_height (float): optional maximum height of each sub-cell generated\n            markdown (bool): enable minimal markdown-like markup to render part\n                of text as bold / italics / strikethrough / underlined.\n                Supports `\\\\` as escape character. Default to False.\n            print_sh (bool): Treat a soft-hyphen (\\\\u00ad) as a normal printable\n                character, instead of a line breaking opportunity. Default value: False\n            wrapmode (fpdf.enums.WrapMode): \"WORD\" for word based line wrapping (default),\n                \"CHAR\" for character based line wrapping.\n            dry_run (bool): if `True`, does not output anything in the document.\n                Can be useful when combined with `output`.\n            output (fpdf.enums.MethodReturnValue): defines what this method returns.\n                If several enum values are joined, the result will be a tuple.\n            txt (str): [**DEPRECATED since v2.7.6**] string to print.\n            center (bool): center the cell horizontally on the page.\n            padding (float or Sequence): padding to apply around the text. Default value: 0.\n                When one value is specified, it applies the same padding to all four sides.\n                When two values are specified, the first padding applies to the top and bottom, the second to\n                the left and right. When three values are specified, the first padding applies to the top,\n                the second to the right and left, the third to the bottom. When four values are specified,\n                the paddings apply to the top, right, bottom, and left in that order (clockwise)\n                If padding for left or right ends up being non-zero then respective c_margin is ignored.\n\n        Center overrides values for horizontal padding\n\n        Using `new_x=XPos.RIGHT, new_y=XPos.TOP, maximum height=pdf.font_size` is\n        useful to build tables with multiline text in cells.\n\n        Returns: a single value or a tuple, depending on the `output` parameter value\n        \"\"\"\n\n        padding = Padding.new(padding)\n        wrapmode = WrapMode.coerce(wrapmode)\n\n        if split_only:\n            warnings.warn(\n                (\n                    'The parameter \"split_only\" is deprecated since v2.7.4.'\n                    ' Use instead dry_run=True and output=\"LINES\".'\n                ),\n                DeprecationWarning,\n                stacklevel=get_stack_level(),\n            )\n        if dry_run or split_only:\n            with self._disable_writing():\n                return self.multi_cell(\n                    w=w,\n                    h=h,\n                    text=text,\n                    border=border,\n                    align=align,\n                    fill=fill,\n                    link=link,\n                    ln=ln,\n                    max_line_height=max_line_height,\n                    markdown=markdown,\n                    print_sh=print_sh,\n                    new_x=new_x,\n                    new_y=new_y,\n                    wrapmode=wrapmode,\n                    dry_run=False,\n                    split_only=False,\n                    output=MethodReturnValue.LINES if split_only else output,\n                    center=center,\n                    padding=padding,\n                )\n        if not self.font_family:\n            raise FPDFException(\"No font set, you need to call set_font() beforehand\")\n        if isinstance(w, str) or isinstance(h, str):\n            raise ValueError(\n                \"Parameter 'w' and 'h' must be numbers, not strings.\"\n                \" You can omit them by passing string content with text=\"\n            )\n        new_x = XPos.coerce(new_x)\n        new_y = YPos.coerce(new_y)\n        if ln != \"DEPRECATED\":\n            # For backwards compatibility, if \"ln\" is used we overwrite \"new_[xy]\".\n            if ln == 0:\n                new_x = XPos.RIGHT\n                new_y = YPos.NEXT\n            elif ln == 1:\n                new_x = XPos.LMARGIN\n                new_y = YPos.NEXT\n            elif ln == 2:\n                new_x = XPos.LEFT\n                new_y = YPos.NEXT\n            elif ln == 3:\n                new_x = XPos.RIGHT\n                new_y = YPos.TOP\n            else:\n                raise ValueError(\n                    f'Invalid value for parameter \"ln\" ({ln}),'\n                    \" must be an int between 0 and 3.\"\n                )\n            warnings.warn(\n                (\n                    'The parameter \"ln\" is deprecated since v2.5.2.'\n                    f\" Instead of ln={ln} use new_x=XPos.{new_x.name}, new_y=YPos.{new_y.name}.\"\n                ),\n                DeprecationWarning,\n                stacklevel=get_stack_level(),\n            )\n        align = Align.coerce(align)\n\n        page_break_triggered = False\n\n        if h is None:\n            h = self.font_size\n\n        # If width is 0, set width to available width between margins\n        if w == 0:\n            w = self.w - self.r_margin - self.x\n\n        # Store the starting position before applying padding\n        prev_x, prev_y = self.x, self.y\n\n        # Apply padding to contents\n        # decrease maximum allowed width by padding\n        # shift the starting point by padding\n        maximum_allowed_width = w = w - padding.right - padding.left\n        clearance_margins: list[float] = []\n        # If we don't have padding on either side, we need a clearance margin.\n        if not padding.left:\n            clearance_margins.append(self.c_margin)\n        if not padding.right:\n            clearance_margins.append(self.c_margin)\n        if align != Align.X:\n            self.x += padding.left\n        self.y += padding.top\n\n        # Center overrides padding\n        if center:\n            self.x = (\n                self.w / 2 if align == Align.X else self.l_margin + (self.epw - w) / 2\n            )\n            prev_x = self.x\n\n        # Calculate text length\n        text = self.normalize_text(text)\n        normalized_string = text.replace(\"\\r\", \"\")\n        styled_text_fragments = (\n            self._preload_bidirectional_text(normalized_string, markdown)\n            if self.text_shaping\n            else self._preload_font_styles(normalized_string, markdown)\n        )\n\n        prev_current_font = self.current_font\n        prev_font_style = self.font_style\n        prev_underline = self.underline\n        total_height: float = 0\n\n        text_lines: list[TextLine] = []\n        multi_line_break = MultiLineBreak(\n            styled_text_fragments,\n            maximum_allowed_width,\n            clearance_margins,\n            align=align,\n            print_sh=print_sh,\n            wrapmode=wrapmode,\n        )\n        text_line = multi_line_break.get_line()\n        while (text_line) is not None:\n            text_lines.append(text_line)\n            text_line = multi_line_break.get_line()\n\n        if not text_lines:  # ensure we display at least one cell - cf. issue #349\n            text_lines = [\n                TextLine(\n                    [],\n                    text_width=0,\n                    number_of_spaces=0,\n                    align=align,\n                    height=h,\n                    max_width=w,\n                    trailing_nl=False,\n                )\n            ]\n\n        if max_line_height is None or len(text_lines) == 1:\n            line_height = h\n        else:\n            line_height = min(h, max_line_height)\n\n        box_required = fill or border\n        page_break_triggered = False\n\n        for text_line_index, text_line in enumerate(text_lines):\n            start_of_new_page = self._perform_page_break_if_need_be(h + padding.bottom)\n            if start_of_new_page:\n                page_break_triggered = True\n                self.y += padding.top\n\n            if box_required and (text_line_index == 0 or start_of_new_page):\n                # estimate how many cells can fit on this page\n                top_gap = self.y  # Top padding has already been added\n                bottom_gap = padding.bottom + self.b_margin\n                lines_before_break = int((self.h - top_gap - bottom_gap) // line_height)\n                # check how many cells should be rendered\n                num_lines = min(lines_before_break, len(text_lines) - text_line_index)\n                box_height = max(\n                    h - text_line_index * line_height, num_lines * line_height\n                )\n                # render the box\n                x = self.x - (w / 2 if align == Align.X else 0)\n                draw_box_borders(\n                    self,\n                    x - padding.left,\n                    self.y - padding.top,\n                    x + w + padding.right,\n                    self.y + box_height + padding.bottom,\n                    border,\n                    self.fill_color if fill else None,\n                )\n            is_last_line = text_line_index == len(text_lines) - 1\n            self._render_styled_text_line(\n                text_line,\n                h=line_height,\n                new_x=new_x if is_last_line else XPos.LEFT,\n                new_y=new_y if is_last_line else YPos.NEXT,\n                border=0,  # already rendered\n                fill=False,  # already rendered\n                link=link,\n                padding=Padding(0, padding.right, 0, padding.left),\n                prevent_font_change=markdown,\n            )\n            total_height += line_height\n            if not is_last_line and align == Align.X:\n                # prevent cumulative shift to the left\n                self.x = prev_x\n\n        if total_height < h:\n            # Move to the bottom of the multi_cell\n            if new_y == YPos.NEXT:\n                self.y += h - total_height\n            total_height = h\n\n        if page_break_triggered and new_y == YPos.TOP:\n            # When a page jump is performed and the requested y is TOP,\n            # pretend we started at the top of the text block on the new page.\n            # cf. test_multi_cell_table_with_automatic_page_break\n            prev_y = self.y\n\n        last_line = text_lines[-1]\n        if last_line and last_line.trailing_nl and new_y in (YPos.LAST, YPos.NEXT):\n            # The line renderer can't handle trailing newlines in the text.\n            self.ln()\n\n        if new_y == YPos.TOP:  # We may have jumped a few lines -> reset\n            self.y = prev_y\n        elif new_y == YPos.NEXT:  # move down by bottom padding\n            self.y += padding.bottom\n\n        if markdown:\n            self.font_style = prev_font_style\n            self.current_font = prev_current_font\n            self.underline = prev_underline\n\n        if new_x == XPos.RIGHT:  # move right by right padding to align outer RHS edge\n            self.x += padding.right\n        elif new_x == XPos.LEFT:  # move left by left padding to align outer LHS edge\n            self.x -= padding.left\n\n        output = MethodReturnValue.coerce(output)\n        return_value = ()\n        if output & MethodReturnValue.PAGE_BREAK:\n            return_value += (page_break_triggered,)  # type: ignore[assignment]\n        if output & MethodReturnValue.LINES:\n            output_lines: list[str] = []\n            for text_line in text_lines:\n                characters: list[str] = []\n                for frag in text_line.fragments:\n                    characters.extend(frag.characters)\n                output_lines.append(\"\".join(characters))\n            return_value += (output_lines,)  # type: ignore[assignment]\n        if output & MethodReturnValue.HEIGHT:\n            return_value += (total_height + padding.top + padding.bottom,)  # type: ignore[assignment]\n        if len(return_value) == 1:\n            return return_value[0]\n        return return_value  # type: ignore[return-value]\n\n    @check_page\n    @support_deprecated_txt_arg\n    def write(\n        self,\n        h: Optional[float] = None,\n        text: str = \"\",\n        link: Optional[str | int] = \"\",\n        print_sh: bool = False,\n        wrapmode: WrapMode = WrapMode.WORD,\n    ) -> bool:\n        \"\"\"\n        Prints text from the current position.\n        When the right margin is reached, a line break occurs at the most recent\n        space or soft-hyphen character, and text continues from the left margin.\n        A manual break happens any time the \\\\n character is met,\n        Upon method exit, the current position is left just at the end of the text.\n\n        Args:\n            h (float): line height. Default value: None, meaning to use the current font size.\n            text (str): text content\n            link (str): optional link to add on the text, internal\n                (identifier returned by `FPDF.add_link`) or external URL.\n            print_sh (bool): Treat a soft-hyphen (\\\\u00ad) as a normal printable\n                character, instead of a line breaking opportunity. Default value: False\n            wrapmode (fpdf.enums.WrapMode): \"WORD\" for word based line wrapping (default),\n                \"CHAR\" for character based line wrapping.\n            txt (str): [**DEPRECATED since v2.7.6**] text content\n        \"\"\"\n        wrapmode = WrapMode.coerce(wrapmode)\n        if not self.font_family:\n            raise FPDFException(\"No font set, you need to call set_font() beforehand\")\n        if isinstance(h, str):\n            raise ValueError(\n                \"Parameter 'h' must be a number, not a string.\"\n                \" You can omit it by passing string content with text=\"\n            )\n        if h is None:\n            h = self.font_size\n\n        page_break_triggered = False\n        normalized_string = self.normalize_text(text).replace(\"\\r\", \"\")\n        styled_text_fragments = (\n            self._preload_bidirectional_text(normalized_string, False)\n            if self.text_shaping\n            else self._preload_font_styles(normalized_string, False)\n        )\n\n        text_lines: list[TextLine] = []\n        multi_line_break = MultiLineBreak(\n            styled_text_fragments,\n            lambda _height: max_width,  # pyright: ignore[reportUnknownLambdaType]\n            (self.c_margin, self.c_margin),\n            print_sh=print_sh,\n            wrapmode=wrapmode,\n        )\n        # first line from current x position to right margin\n        first_width = self.w - self.x - self.r_margin\n        max_width = first_width\n        text_line = multi_line_break.get_line()\n        # remaining lines fill between margins\n        full_width = self.w - self.l_margin - self.r_margin\n        max_width = full_width\n        while (text_line) is not None:\n            text_lines.append(text_line)\n            text_line = multi_line_break.get_line()\n        if not text_lines:\n            return False\n\n        for text_line_index, text_line in enumerate(text_lines):\n            if text_line_index > 0:\n                self.ln()\n            new_page = self._render_styled_text_line(\n                text_line,\n                h=h,\n                border=0,\n                new_x=XPos.WCONT,\n                new_y=YPos.TOP,\n                fill=False,\n                link=link,\n            )\n            page_break_triggered = page_break_triggered or new_page\n        if text_line is not None and text_line.trailing_nl:\n            # The line renderer can't handle trailing newlines in the text.\n            self.ln()\n        return page_break_triggered\n\n    @check_page\n    def text_columns(\n        self,\n        text: Optional[str] = None,\n        img: Optional[str] = None,\n        img_fill_width: bool = False,\n        ncols: int = 1,\n        gutter: Optional[float] = 10,\n        balance: bool = False,\n        text_align: Optional[Align | str] = \"LEFT\",\n        line_height: Optional[float] = 1,\n        l_margin: Optional[float] = None,\n        r_margin: Optional[float] = None,\n        print_sh: Optional[bool] = False,\n        wrapmode: Optional[WrapMode] = WrapMode.WORD,\n        skip_leading_spaces: Optional[bool] = False,\n    ) -> TextColumns:\n        \"\"\"Establish a layout with multiple columns to fill with text.\n        Args:\n            text (str, optional): A first piece of text to insert.\n            ncols (int, optional): the number of columns to create. (Default: 1).\n            gutter (float, optional): The distance between the columns. (Default: 10).\n            balance: (bool, optional): Specify whether multiple columns should end at approximately\n                the same height, if they don't fill the page. (Default: False)\n            text_align (Align or str, optional): The alignment of the text within the region.\n                (Default: \"LEFT\")\n            line_height (float, optional): A multiplier relative to the font size changing the\n                vertical space occupied by a line of text. (Default: 1.0).\n            l_margin (float, optional): Override the current left page margin.\n            r_margin (float, optional): Override the current right page margin.\n            print_sh (bool, optional): Treat a soft-hyphen (\\\\u00ad) as a printable character,\n                instead of a line breaking opportunity. (Default: False)\n            wrapmode (fpdf.enums.WrapMode, optional): \"WORD\" for word based line wrapping,\n                \"CHAR\" for character based line wrapping. (Default: \"WORD\")\n            skip_leading_spaces (bool, optional): On each line, any space characters at the\n                beginning will be skipped if True. (Default: False)\n        \"\"\"\n        return TextColumns(\n            self,\n            text=text,\n            img=img,\n            img_fill_width=img_fill_width,\n            ncols=ncols,\n            gutter=gutter or 10,\n            balance=balance,\n            text_align=text_align,\n            line_height=line_height,\n            l_margin=l_margin,\n            r_margin=r_margin,\n            print_sh=print_sh,\n            wrapmode=wrapmode,\n            skip_leading_spaces=skip_leading_spaces,\n        )\n\n    def image(\n        self,\n        name: ImageType,\n        x: Optional[float | Align] = None,\n        y: Optional[float] = None,\n        w: float = 0,\n        h: float = 0,\n        type: str | Literal[\"DEPRECATED\"] | None = \"\",\n        link: Optional[str | int] = \"\",\n        title: Optional[str] = None,\n        alt_text: Optional[str] = None,\n        dims: Optional[tuple[float, float]] = None,\n        keep_aspect_ratio: bool = False,\n    ) -> RasterImageInfo | VectorImageInfo:\n        \"\"\"\n        Put an image on the page.\n\n        The size of the image on the page can be specified in different ways:\n        * explicit width and height (expressed in user units)\n        * one explicit dimension, the other being calculated automatically\n          in order to keep the original proportions\n        * no explicit dimension, in which case the image is put at 72 dpi.\n        * explicit width and height (expressed in user units) and `keep_aspect_ratio=True`\n\n        **Remarks**:\n        * if an image is used several times, only one copy is embedded in the file.\n        * when using an animated GIF, only the first frame is used.\n\n        Args:\n            name: either a string representing a file path to an image, an URL to an image,\n                bytes, an io.BytesIO, or a instance of `PIL.Image.Image`\n            x (float, fpdf.enums.Align): optional horizontal position where to put the image on the page.\n                If not specified or equal to None, the current abscissa is used.\n                `fpdf.enums.Align.C` can also be passed to center the image horizontally;\n                and `fpdf.enums.Align.R` to place it along the right page margin\n            y (float): optional vertical position where to put the image on the page.\n                If not specified or equal to None, the current ordinate is used.\n                After the call, the current ordinate is moved to the bottom of the image\n            w (float): optional width of the image. If not specified or equal to zero,\n                it is automatically calculated from the image size.\n                Pass `pdf.epw` to scale horizontally to the full page width.\n            h (float): optional height of the image. If not specified or equal to zero,\n                it is automatically calculated from the image size.\n                Pass `pdf.eph` to scale horizontally to the full page height.\n            type (str): [**DEPRECATED since 2.2.0**] unused, will be removed in a later version.\n            link (str): optional link to add on the image, internal\n                (identifier returned by `FPDF.add_link`) or external URL.\n            title (str): optional. Currently, never seem rendered by PDF readers.\n            alt_text (str): optional alternative text describing the image,\n                for accessibility purposes. Displayed by some PDF readers on hover.\n            dims (Tuple[float]): optional dimensions as a tuple (width, height) to resize the image\n                before storing it in the PDF. Note that those are the **intrinsic** image dimensions,\n                but the image will still be rendered on the page with the width (`w`) and height (`h`)\n                provided as parameters. Note also that the `.oversized_images` attribute of FPDF\n                provides an automated way to auto-adjust those intrinsic image dimensions.\n            keep_aspect_ratio (bool): ensure the image fits in the rectangle defined by `x`, `y`, `w` & `h`\n                while preserving its original aspect ratio. Defaults to False.\n                Only meaningful if both `w` & `h` are provided.\n\n        If `y` is provided, this method will not trigger any page break;\n        otherwise, auto page break detection will be performed.\n\n        Returns: an instance of a subclass of `ImageInfo`.\n        \"\"\"\n        if not self.page:\n            raise FPDFException(\"No page open, you need to call add_page() first\")\n        if type:\n            warnings.warn(\n                (\n                    '\"type\" parameter is deprecated since v2.2.0, '\n                    \"unused and will soon be removed\"\n                ),\n                DeprecationWarning,\n                stacklevel=get_stack_level(),\n            )\n\n        name, img, info = preload_image(self.image_cache, name, dims)\n        if isinstance(info, VectorImageInfo):\n            return self._vector_image(\n                name,\n                cast(SVGObject, img),\n                info,\n                x,\n                y,\n                w,\n                h,\n                link,\n                title,\n                alt_text,\n                keep_aspect_ratio,\n            )\n        if TYPE_CHECKING:\n            assert not isinstance(img, SVGObject)\n        return self._raster_image(\n            name,\n            img,\n            info,\n            x,\n            y,\n            w,\n            h,\n            link,\n            title,\n            alt_text,\n            dims,\n            keep_aspect_ratio,\n        )\n\n    def _raster_image(\n        self,\n        name: str,\n        img: ImageType,\n        info: RasterImageInfo,\n        x: Optional[float | Align] = None,\n        y: Optional[float] = None,\n        w: float = 0,\n        h: float = 0,\n        link: Optional[str | int] = \"\",\n        title: Optional[str] = None,\n        alt_text: Optional[str] = None,\n        dims: Optional[tuple[float, float]] = None,\n        keep_aspect_ratio: bool = False,\n    ) -> RasterImageInfo:\n        if \"smask\" in info:\n            self._set_min_pdf_version(\"1.4\")\n\n        # Automatic width and height calculation if needed\n        w, h = info.size_in_document_units(w, h, scale=self.k)\n\n        # Flowing mode\n        if y is None:\n            self._perform_page_break_if_need_be(h)\n            y = self.y\n            self.y += h\n        if x is None:\n            x = self.x\n\n        if not isinstance(x, NumberClass):\n            x = self.x_by_align(x, w, h, info, keep_aspect_ratio)\n        if TYPE_CHECKING:\n            x = float(x)\n        if keep_aspect_ratio:\n            x, y, w, h = info.scale_inside_box(x, y, w, h)\n        if self.oversized_images and info[\"usages\"] == 1 and not dims:\n            info = self._downscale_image(name, img, info, w, h, scale=self.k)\n\n        stream_content = stream_content_for_raster_image(\n            info, x, y, w, h, keep_aspect_ratio, scale=self.k, pdf_height_to_flip=self.h\n        )\n\n        if title or alt_text:\n            with self._marked_sequence(title=title, alt_text=alt_text):\n                self._out(stream_content)\n        else:\n            self._out(stream_content)\n        if link:\n            self.link(x, y, w, h, link)\n\n        self._resource_catalog.add(\n            PDFResourceType.X_OBJECT, info[\"i\"], self.page  # type: ignore\n        )\n        info[\"rendered_width\"] = w\n        info[\"rendered_height\"] = h\n        return info\n\n    def x_by_align(\n        self,\n        x: Align | str,\n        w: float,\n        h: float,\n        img_info: RasterImageInfo | VectorImageInfo,\n        keep_aspect_ratio: bool,\n    ) -> float:\n        if keep_aspect_ratio:\n            _, _, w, h = img_info.scale_inside_box(0, 0, w, h)\n        x = Align.coerce(x)\n        if x == Align.C:\n            return (self.w - w) / 2\n        if x == Align.R:\n            return self.w - w - self.r_margin\n        if x == Align.L:\n            return self.l_margin\n        raise ValueError(f\"Unsupported 'x' value passed to .image(): {x}\")\n\n    def _vector_image(\n        self,\n        name: str,\n        svg: SVGObject,\n        info: VectorImageInfo,\n        x: Optional[float | Align] = None,\n        y: Optional[float] = None,\n        w: float = 0,\n        h: float = 0,\n        link: Optional[str | int] = \"\",\n        title: Optional[str] = None,\n        alt_text: Optional[str] = None,\n        keep_aspect_ratio: bool = False,\n    ) -> VectorImageInfo:\n        if not svg.viewbox and svg.width and svg.height:\n            warnings.warn(\n                '<svg> has no \"viewBox\", using its \"width\" & \"height\" as default \"viewBox\"',\n                stacklevel=get_stack_level(),\n            )\n            svg.viewbox = [float(0), float(0), svg.width, svg.height]\n        if w == 0 and h == 0:\n            if svg.width and svg.height:\n                w = (\n                    svg.width * self.epw / 100\n                    if isinstance(svg.width, Percent)\n                    else svg.width\n                )\n                h = (\n                    svg.height * self.eph / 100\n                    if isinstance(svg.height, Percent)\n                    else svg.height\n                )\n            elif svg.viewbox:\n                _, _, w, h = svg.viewbox\n            else:\n                svg_id = \"<svg>\" if isinstance(name, bytes) else name\n                raise ValueError(\n                    f'{svg_id} has no \"viewBox\" nor \"height\" / \"width\": w= and h= must be provided to FPDF.image()'\n                )\n        elif w == 0 or h == 0:\n            if svg.width and svg.height:\n                svg_width, svg_height = svg.width, svg.height\n            elif svg.viewbox:\n                _, _, svg_width, svg_height = svg.viewbox\n            else:\n                raise ValueError(\n                    '<svg> has no \"viewBox\" nor \"height\" / \"width\": w= and h= must be provided to FPDF.image()'\n                )\n            if w == 0:\n                w = h * svg_width / svg_height\n            else:  # h == 0\n                h = w * svg_height / svg_width\n\n        # Flowing mode\n        if y is None:\n            self._perform_page_break_if_need_be(h)\n            y = self.y\n            self.y += h\n        if x is None:\n            x = self.x\n\n        if not isinstance(x, NumberClass):\n            x = self.x_by_align(x, w, h, info, keep_aspect_ratio)\n        x = float(x)\n        if keep_aspect_ratio:\n            x, y, w, h = info.scale_inside_box(x, y, w, h)\n\n        _, _, path = svg.transform_to_rect_viewport(\n            scale=1, width=w, height=h, ignore_svg_top_attrs=True\n        )\n        assert path.transform is not None\n        path.transform = path.transform @ Transform.translation(x, y)\n\n        old_x, old_y = self.x, self.y\n        try:\n            self.set_xy(0, 0)\n            if title or alt_text:\n                # Alt text of vector graphics does NOT show as tool-tip in viewers, but should\n                # be processed by screen readers.\n                with self._marked_sequence(title=title, alt_text=alt_text):\n                    self.draw_path(path, copy=False)\n            else:\n                self.draw_path(path, copy=False)\n        finally:\n            self.set_xy(old_x, old_y)\n        if link:\n            self.link(x, y, w, h, link)\n\n        return VectorImageInfo(rendered_width=w, rendered_height=h)\n\n    def _downscale_image(\n        self,\n        name: str,\n        img: ImageType,\n        info: RasterImageInfo,\n        w: float,\n        h: float,\n        scale: float,\n    ) -> RasterImageInfo:\n        images = self.image_cache.images\n        width_in_pt, height_in_pt = w * scale, h * scale\n        lowres_name = f\"lowres-{name}\"\n        w = float(info[\"w\"])  # type: ignore[arg-type]\n        h = float(info[\"h\"])  # type: ignore[arg-type]\n        assert self.oversized_images is not None\n        if (\n            w > width_in_pt * self.oversized_images_ratio\n            and h > height_in_pt * self.oversized_images_ratio\n        ):\n            factor = (\n                min(w / width_in_pt, h / height_in_pt) / self.oversized_images_ratio\n            )\n            if self.oversized_images.lower().startswith(\"warn\"):\n                LOGGER.warning(\n                    (\n                        \"OVERSIZED: Image %s with size %.1fx%.1fpx is rendered at size %.1fx%.1fpt.\"\n                        \" Set pdf.oversized_images = 'DOWNSCALE' to reduce embedded image size by a factor %.1f\"\n                    ),\n                    name,\n                    w,\n                    h,\n                    width_in_pt,\n                    height_in_pt,\n                    factor,\n                )\n            elif self.oversized_images.lower() == \"downscale\":\n                dims = (\n                    round(width_in_pt * self.oversized_images_ratio),\n                    round(height_in_pt * self.oversized_images_ratio),\n                )\n                info[\"usages\"] -= 1  # type: ignore[operator] # no need to embed highres version\n                if info[\"usages\"] == 0:\n                    resources_per_page = self._resource_catalog.resources_per_page\n                    for (_, rtype), resource in resources_per_page.items():\n                        if rtype == PDFResourceType.X_OBJECT and info[\"i\"] in resource:\n                            resource.remove(cast(int, info[\"i\"]))\n                lowres_info = images.get(lowres_name)\n                if lowres_info:  # Great, we've already done the job!\n                    info = cast(RasterImageInfo, lowres_info)\n                    lowres_w = float(info[\"w\"])  # type: ignore[arg-type]\n                    lowres_h = float(info[\"h\"])  # type: ignore[arg-type]\n                    if lowres_w * lowres_h < dims[0] * dims[1]:\n                        # The existing low-res image is too small, we need a bigger low-res image:\n                        info.update(\n                            get_img_info(\n                                name,\n                                img or load_image(name),\n                                self.image_cache.image_filter,\n                                dims,\n                            )\n                        )\n                        LOGGER.debug(\n                            \"OVERSIZED: Updated low-res image with name=%s id=%d to dims=%s\",\n                            lowres_name,\n                            info[\"i\"],\n                            dims,\n                        )\n                    info[\"usages\"] += 1  # type: ignore[operator]\n                else:\n                    info = RasterImageInfo(\n                        get_img_info(\n                            name,\n                            img or load_image(name),\n                            self.image_cache.image_filter,\n                            dims,\n                        )\n                    )\n                    info[\"i\"] = len(images) + 1\n                    info[\"usages\"] = 1\n                    images[lowres_name] = info\n                    LOGGER.debug(\n                        \"OVERSIZED: Generated new low-res image with name=%s dims=%s id=%d\",\n                        lowres_name,\n                        dims,\n                        info[\"i\"],\n                    )\n            else:\n                raise ValueError(\n                    f\"Invalid value for attribute .oversized_images: {self.oversized_images}\"\n                )\n        return info\n\n    def preload_image(\n        self,\n        name: str | bytes | BinaryIO | Image | Path,\n        dims: tuple[float, float] | None = None,\n    ) -> tuple[\n        str,\n        SVGObject | Image | bytes | BinaryIO | Path | None,\n        RasterImageInfo | VectorImageInfo,\n    ]:\n        \"\"\"\n        Read an image and load it into memory.\n\n        .. deprecated:: 2.7.7\n            Use `fpdf.image_parsing.preload_image` instead.\n        \"\"\"\n        warnings.warn(\n            (\n                \"FPDF.preload_image() is deprecated since v2.7.7 \"\n                \"and will be removed in a future release. \"\n                \"Use `fpdf.image_parsing.preload_image` instead.\"\n            ),\n            DeprecationWarning,\n            stacklevel=get_stack_level(),\n        )\n        return preload_image(\n            self.image_cache,\n            name,  # pyright: ignore[reportArgumentType, reportReturnType]\n            dims,\n        )\n\n    def preload_glyph_image(self, glyph_image_bytes: bytes | BinaryIO) -> tuple[\n        str,\n        SVGObject | Image | bytes | BinaryIO | Path | None,\n        RasterImageInfo | VectorImageInfo,\n    ]:\n        return preload_image(\n            image_cache=self.image_cache,\n            name=glyph_image_bytes,\n            dims=None,  # pyright: ignore[reportArgumentType, reportReturnType]\n        )\n\n    @contextmanager\n    def _marked_sequence(self, **kwargs: Any) -> Iterator[StructElem]:\n        \"\"\"\n        Can receive as named arguments any of the entries described in section 14.7.2 'Structure Hierarchy'\n        of the PDF spec: iD, a, c, r, lang, e, actualText\n        \"\"\"\n        mcid = self.struct_builder.next_mcid_for_page(self.page)\n        struct_elem = self._add_marked_content(\n            struct_type=\"/Figure\", mcid=mcid, **kwargs\n        )\n        start_page = self.page\n        self._out(f\"/P <</MCID {mcid}>> BDC\")\n        yield struct_elem\n        if self.page != start_page:\n            raise FPDFException(\"A page jump occurred inside a marked sequence\")\n        self._out(\"EMC\")\n\n    def _add_marked_content(self, **kwargs: Any) -> StructElem:\n        \"\"\"\n        Can receive as named arguments any of the entries described in section 14.7.2 'Structure Hierarchy'\n        of the PDF spec: iD, a, c, r, lang, e, actualText\n        \"\"\"\n        struct_elem, spid = self.struct_builder.add_marked_content(\n            page_number=self.page, **kwargs\n        )\n        self.pages[self.page].struct_parents = spid\n        self._set_min_pdf_version(\"1.4\")  # due to using /MarkInfo\n        return struct_elem\n\n    @check_page\n    def ln(self, h: Optional[float] = None) -> None:\n        \"\"\"\n        Line Feed.\n        The current abscissa goes back to the left margin and the ordinate increases by\n        the amount passed as parameter.\n\n        Args:\n            h (float): The height of the break.\n                By default, the value equals the height of the last printed text line\n                (except when written by `.text()`). If no text has been written yet to\n                the document, then the current font height is used.\n        \"\"\"\n        self.x = self.l_margin\n        if h is not None:\n            self.y += h\n        elif self._lasth:\n            self.y += self._lasth\n        else:\n            self.y += self.font_size\n\n    def get_x(self) -> float:\n        \"\"\"Returns the abscissa of the current position.\"\"\"\n        return self.x\n\n    def set_x(self, x: float) -> None:\n        \"\"\"\n        Defines the abscissa of the current position.\n        If the value provided is negative, it is relative to the right of the page.\n\n        Args:\n            x (float): the new current abscissa\n        \"\"\"\n        self.x = x if x >= 0 else self.w + x\n\n    def get_y(self) -> float:\n        \"\"\"Returns the ordinate of the current position.\"\"\"\n        if self._in_unbreakable:\n            raise FPDFException(\n                \"Using get_y() inside an unbreakable() code block is error-prone\"\n            )\n        return self.y\n\n    def set_y(self, y: float) -> None:\n        \"\"\"\n        Moves the current abscissa back to the left margin and sets the ordinate.\n        If the value provided is negative, it is relative to the bottom of the page.\n\n        Args:\n            y (float): the new current ordinate\n        \"\"\"\n        self.x = self.l_margin\n        self.y = y if y >= 0 else self.h + y\n\n    def set_xy(self, x: float, y: float) -> None:\n        \"\"\"\n        Defines the abscissa and ordinate of the current position.\n        If the values provided are negative, they are relative respectively to the right and bottom of the page.\n\n        Args:\n            x (float): the new current abscissa\n            y (float): the new current ordinate\n        \"\"\"\n        self.set_y(y)\n        self.set_x(x)\n\n    def normalize_text(self, text: str) -> str:\n        \"\"\"Check that text input is in the correct format/encoding\"\"\"\n        # - for TTF unicode fonts: unicode object (utf8 encoding)\n        # - for built-in fonts: string instances (encoding: latin-1, cp1252)\n        if not self.is_ttf_font and self.core_fonts_encoding:\n            try:\n                return text.encode(self.core_fonts_encoding).decode(\"latin-1\")\n            except UnicodeEncodeError as error:\n                raise FPDFUnicodeEncodingException(\n                    text_index=error.start,\n                    character=text[error.start],\n                    font_name=self.font_family + self.font_style,\n                ) from error\n        return text\n\n    def sign_pkcs12(\n        self,\n        pkcs_filepath: str | Path,\n        password: Optional[bytes] = None,\n        hashalgo: str = \"sha256\",\n        contact_info: Optional[str] = None,\n        location: Optional[str] = None,\n        signing_time: Optional[datetime] = None,\n        reason: Optional[str] = None,\n        flags: tuple[AnnotationFlag | str, ...] = (\n            AnnotationFlag.PRINT,\n            AnnotationFlag.LOCKED,\n        ),\n    ) -> None:\n        \"\"\"\n        Args:\n            pkcs_filepath (str): file path to a .pfx or .p12 PKCS12,\n                in the binary format described by RFC 7292\n            password (bytes-like): the password to use to decrypt the data.\n                `None` if the PKCS12 is not encrypted.\n            hashalgo (str): hashing algorithm used, passed to `hashlib.new`\n            contact_info (str): optional information provided by the signer to enable\n                a recipient to contact the signer to verify the signature\n            location (str): optional CPU host name or physical location of the signing\n            signing_time (datetime): optional time of signing\n            reason (str): optional signing reason\n            flags (Tuple[fpdf.enums.AnnotationFlag], Tuple[str]): optional list of flags defining annotation properties\n        \"\"\"\n        if not signer:\n            raise EnvironmentError(\n                \"endesive.signer not available - PDF cannot be signed - Try: pip install endesive\"\n            )\n        with open(pkcs_filepath, \"rb\") as pkcs_file:\n            key, cert, extra_certs = (\n                pkcs12.load_key_and_certificates(  # pyright: ignore[reportOptionalMemberAccess]\n                    pkcs_file.read(), password\n                )\n            )\n        assert cert is not None\n        self.sign(\n            key=key,\n            cert=cert,\n            extra_certs=extra_certs,\n            hashalgo=hashalgo,\n            contact_info=contact_info,\n            location=location,\n            signing_time=signing_time,\n            reason=reason,\n            flags=flags,\n        )\n\n    @check_page\n    def sign(\n        self,\n        key: Optional[\"PrivateKeyTypes\"],\n        cert: \"Certificate\",\n        extra_certs: Optional[list[\"Certificate\"]] = None,\n        hashalgo: str = \"sha256\",\n        contact_info: Optional[str] = None,\n        location: Optional[str] = None,\n        signing_time: Optional[datetime] = None,\n        reason: Optional[str] = None,\n        flags: tuple[AnnotationFlag | str, ...] = (\n            AnnotationFlag.PRINT,\n            AnnotationFlag.LOCKED,\n        ),\n    ) -> None:\n        \"\"\"\n        Args:\n            key: certificate private key\n            cert (cryptography.x509.Certificate): certificate\n            extra_certs (list[cryptography.x509.Certificate]): list of additional PKCS12 certificates\n            hashalgo (str): hashing algorithm used, passed to `hashlib.new`\n            contact_info (str): optional information provided by the signer to enable\n                a recipient to contact the signer to verify the signature\n            location (str): optional CPU host name or physical location of the signing\n            signing_time (datetime): optional time of signing\n            reason (str): optional signing reason\n            flags (Tuple[fpdf.enums.AnnotationFlag], Tuple[str]): optional list of flags defining annotation properties\n        \"\"\"\n        if not signer:\n            raise EnvironmentError(\n                \"endesive.signer not available - PDF cannot be signed - Try: pip install endesive\"\n            )\n        if self._sign_key:\n            raise FPDFException(\".sign* methods should be called only once\")\n\n        self._sign_key = key\n        self._sign_cert = cert\n        self._sign_extra_certs = extra_certs if extra_certs is not None else []\n        self._sign_hashalgo = hashalgo\n        self._sign_time: datetime = signing_time or self.creation_date\n\n        annotation = PDFAnnotation(\n            \"Widget\",\n            field_type=\"Sig\",\n            x=0,\n            y=0,\n            width=0,\n            height=0,\n            flags=flags,\n            title=\"signature\",\n            value=Signature(\n                contact_info=contact_info,\n                location=location,\n                m=PDFDate(self._sign_time),\n                reason=reason,\n            ),\n        )\n        self.pages[self.page].add_annotation(annotation)\n\n    def _insert_table_of_contents(self) -> None:\n        # Doc has been closed but we want to write to self.pages[self.page] instead of self.buffer:\n        tocp = self.toc_placeholder\n        assert tocp is not None\n        prev_page, prev_y = self.page, self.y\n        self.page, self.y = tocp.start_page, tocp.y\n        # flag rendering ToC for page breaking function\n        self.in_toc_rendering = True\n        self._set_orientation(tocp.page_orientation, self.dw_pt, self.dh_pt)\n        tocp.render_function(self, self._outline)\n        self.in_toc_rendering = False  # set ToC rendering flag off\n        expected_final_page = tocp.start_page + tocp.pages - 1\n        if self.page != expected_final_page and not self._toc_allow_page_insertion:\n            too = \"many\" if self.page > expected_final_page else \"few\"\n            error_msg = f\"The rendering function passed to FPDF.insert_toc_placeholder triggered too {too} page breaks: \"\n            error_msg += f\"ToC ended on page {self.page} while it was expected to span exactly {tocp.pages} pages\"\n            raise FPDFException(error_msg)\n        if self._toc_inserted_pages:\n            # Generating final page footer after more pages were inserted:\n            self._render_footer()\n            # We need to reorder the pages, because some new pages have been inserted in the ToC,\n            # but they have been inserted at the end of self.pages:\n            new_pages = [\n                self.pages.pop(len(self.pages)) for _ in range(self._toc_inserted_pages)\n            ]\n            new_pages = list(reversed(new_pages))\n            indices_remap: dict[int, int] = {}\n            for page_index in range(\n                tocp.start_page + 1, self.pages_count + len(new_pages) + 1\n            ):\n                if page_index in self.pages:\n                    new_pages.append(self.pages.pop(page_index))\n                page = self.pages[page_index] = new_pages.pop(0)\n                # Fix page indices:\n                indices_remap[page.index()] = page_index\n                page.set_index(page_index)\n                # Fix page labels:\n                if tocp.reset_page_indices is False:\n                    page.get_page_label().st = page_index  # type: ignore[union-attr]\n            assert len(new_pages) == 0, f\"#new_pages: {len(new_pages)}\"\n            # Fix links:\n            for dest in self.links.values():\n                assert dest.page_number is not None\n                new_index = indices_remap.get(dest.page_number)\n                if new_index is not None:\n                    dest.page_number = new_index\n            # Fix outline:\n            for section in self._outline:\n                new_index = indices_remap.get(section.page_number)\n                if new_index is not None:\n                    section.dest = section.dest.replace(page=new_index)\n                    section.page_number = new_index\n                    if section.struct_elem:\n                        # pylint: disable=protected-access\n                        section.struct_elem._page_number = (  # pyright: ignore[reportPrivateUsage]\n                            new_index\n                        )\n            # Fix resource catalog:\n            resources_per_page = self._resource_catalog.resources_per_page\n            new_resources_per_page: dict[\n                tuple[int, PDFResourceType], set[ResourceTypes]\n            ] = defaultdict(set)\n            for (page_number, resource_type), resource in resources_per_page.items():\n                key = (indices_remap.get(page_number, page_number), resource_type)\n                new_resources_per_page[key] = resource\n            self._resource_catalog.resources_per_page = new_resources_per_page\n        self.page, self.y = prev_page, prev_y\n\n    def file_id(self) -> Optional[str | Literal[-1]]:  # pylint: disable=no-self-use\n        \"\"\"\n        This method can be overridden in inherited classes\n        in order to define a custom file identifier.\n        Its output must have the format \"<hex_string1><hex_string2>\".\n        If this method returns a falsy value (None, empty string),\n        no /ID will be inserted in the generated PDF document.\n        \"\"\"\n        return -1\n\n    def _default_file_id(self, buffer: bytearray) -> str:\n        # Quoting the PDF 1.7 spec, section 14.4 File Identifiers:\n        # > The value of this entry shall be an array of two byte strings.\n        # > The first byte string shall be a permanent identifier\n        # > based on the contents of the file at the time it was originally created\n        # > and shall not change when the file is incrementally updated.\n        # > The second byte string shall be a changing identifier\n        # > based on the file’s contents at the time it was last updated.\n        # > When a file is first written, both identifiers shall be set to the same value.\n        id_hash = hashlib.new(\"md5\", usedforsecurity=False)  # nosec B324\n        id_hash.update(buffer)\n        if self.creation_date:\n            id_hash.update(self.creation_date.strftime(\"%Y%m%d%H%M%S\").encode(\"utf8\"))\n        hash_hex = id_hash.hexdigest().upper()\n        return f\"<{hash_hex}><{hash_hex}>\"\n\n    def _do_underline(\n        self, x: float, y: float, w: float, font: Optional[CoreFont | TTFFont] = None\n    ) -> str:\n        \"\"\"\n        Draw an horizontal line under some text,\n        starting from (x, y) with a length equal to 'w'\n        \"\"\"\n        if font is None:\n            font = self.current_font\n        assert font is not None\n        return (\n            f\"{x * self.k:.2f} \"\n            f\"{(self.h - y + font.up / 1000 * self.font_size) * self.k:.2f} \"  # pyright: ignore[reportUnknownMemberType]\n            f\"{w * self.k:.2f} \"\n            f\"{-font.ut / 1000 * self.font_size_pt:.2f} re f\"  # pyright: ignore[reportUnknownMemberType]\n        )\n\n    def _do_strikethrough(\n        self, x: float, y: float, w: float, font: Optional[CoreFont | TTFFont] = None\n    ) -> str:\n        \"\"\"\n        Draw an horizontal line through some text,\n        starting from (x, y) with a length equal to 'w'\n        \"\"\"\n        if font is None:\n            font = self.current_font\n        assert font is not None\n        return (\n            f\"{x * self.k:.2f} \"\n            f\"{(self.h - y + font.sp / 1000 * self.font_size) * self.k:.2f} \"  # pyright: ignore[reportUnknownMemberType]\n            f\"{w * self.k:.2f} \"\n            f\"{-font.ss / 1000 * self.font_size_pt:.2f} re f\"  # pyright: ignore[reportUnknownMemberType]\n        )\n\n    def _out(self, s: str | bytes) -> None:\n        if self.buffer:\n            raise FPDFException(\n                \"Content cannot be added on a finalized document, after calling output()\"\n            )\n        if not isinstance(s, bytes):\n            if not isinstance(s, str):\n                s = str(s)\n            s = s.encode(\"latin1\")\n        if not self.page:\n            raise FPDFException(\"No page open, you need to call add_page() first\")\n        page_contents = self.pages[self.page].contents\n        if isinstance(page_contents, bytearray):\n            page_contents.extend(s)\n            page_contents.append(0x0A)  # newline\n        else:\n            page_contents += s + b\"\\n\"  # type: ignore[operator]\n\n    @check_page\n    @support_deprecated_txt_arg\n    def interleaved2of5(\n        self, text: str, x: float, y: float, w: float = 1, h: float = 10\n    ) -> None:\n        \"\"\"Barcode I2of5 (numeric), adds a 0 if odd length\"\"\"\n        narrow = w / 3\n        wide = w\n\n        # wide/narrow codes for the digits\n        bar_char = {\n            \"0\": \"nnwwn\",\n            \"1\": \"wnnnw\",\n            \"2\": \"nwnnw\",\n            \"3\": \"wwnnn\",\n            \"4\": \"nnwnw\",\n            \"5\": \"wnwnn\",\n            \"6\": \"nwwnn\",\n            \"7\": \"nnnww\",\n            \"8\": \"wnnwn\",\n            \"9\": \"nwnwn\",\n            \"A\": \"nn\",\n            \"Z\": \"wn\",\n        }\n        # The caller should do this, or we can't rotate the thing.\n        # self.set_fill_color(0)\n        code = text\n        # add leading zero if code-length is odd\n        if len(code) % 2 != 0:\n            code = f\"0{code}\"\n\n        # add start and stop codes\n        code = f\"AA{code.lower()}ZA\"\n\n        for i in range(0, len(code), 2):\n            # choose next pair of digits\n            char_bar = code[i]\n            char_space = code[i + 1]\n            # check whether it is a valid digit\n            if char_bar not in bar_char:\n                raise RuntimeError(f'Char \"{char_bar}\" invalid for I25:')\n            if char_space not in bar_char:\n                raise RuntimeError(f'Char \"{char_space}\" invalid for I25: ')\n\n            # create a wide/narrow-seq (first digit=bars, second digit=spaces)\n            seq = \"\".join(\n                f\"{cb}{cs}\" for cb, cs in zip(bar_char[char_bar], bar_char[char_space])\n            )\n\n            for bar_index, char in enumerate(seq):\n                # set line_width depending on value\n                line_width = narrow if char == \"n\" else wide\n\n                # draw every second value, the other is represented by space\n                if bar_index % 2 == 0:\n                    self.rect(x, y, line_width, h, \"F\")\n\n                x += line_width\n\n    @check_page\n    @support_deprecated_txt_arg\n    def code39(\n        self, text: str, x: float, y: float, w: float = 1.5, h: float = 5\n    ) -> None:\n        \"\"\"Barcode 3of9\"\"\"\n        dim = {\"w\": w, \"n\": w / 3}\n        if not text.startswith(\"*\") or not text.endswith(\"*\"):\n            warnings.warn(\n                (\n                    \"Code 39 input must start and end with a '*' character to be valid.\"\n                    \" This method does not insert it automatically.\"\n                ),\n                stacklevel=get_stack_level(),\n            )\n        chars = {\n            \"0\": \"nnnwwnwnn\",\n            \"1\": \"wnnwnnnnw\",\n            \"2\": \"nnwwnnnnw\",\n            \"3\": \"wnwwnnnnn\",\n            \"4\": \"nnnwwnnnw\",\n            \"5\": \"wnnwwnnnn\",\n            \"6\": \"nnwwwnnnn\",\n            \"7\": \"nnnwnnwnw\",\n            \"8\": \"wnnwnnwnn\",\n            \"9\": \"nnwwnnwnn\",\n            \"A\": \"wnnnnwnnw\",\n            \"B\": \"nnwnnwnnw\",\n            \"C\": \"wnwnnwnnn\",\n            \"D\": \"nnnnwwnnw\",\n            \"E\": \"wnnnwwnnn\",\n            \"F\": \"nnwnwwnnn\",\n            \"G\": \"nnnnnwwnw\",\n            \"H\": \"wnnnnwwnn\",\n            \"I\": \"nnwnnwwnn\",\n            \"J\": \"nnnnwwwnn\",\n            \"K\": \"wnnnnnnww\",\n            \"L\": \"nnwnnnnww\",\n            \"M\": \"wnwnnnnwn\",\n            \"N\": \"nnnnwnnww\",\n            \"O\": \"wnnnwnnwn\",\n            \"P\": \"nnwnwnnwn\",\n            \"Q\": \"nnnnnnwww\",\n            \"R\": \"wnnnnnwwn\",\n            \"S\": \"nnwnnnwwn\",\n            \"T\": \"nnnnwnwwn\",\n            \"U\": \"wwnnnnnnw\",\n            \"V\": \"nwwnnnnnw\",\n            \"W\": \"wwwnnnnnn\",\n            \"X\": \"nwnnwnnnw\",\n            \"Y\": \"wwnnwnnnn\",\n            \"Z\": \"nwwnwnnnn\",\n            \"-\": \"nwnnnnwnw\",\n            \".\": \"wwnnnnwnn\",\n            \" \": \"nwwnnnwnn\",\n            \"*\": \"nwnnwnwnn\",\n            \"$\": \"nwnwnwnnn\",\n            \"/\": \"nwnwnnnwn\",\n            \"+\": \"nwnnnwnwn\",\n            \"%\": \"nnnwnwnwn\",\n        }\n        # The caller should do this, or we can't rotate the thing.\n        # self.set_fill_color(0)\n        for c in text.upper():\n            if c not in chars:\n                raise RuntimeError(f'Invalid char \"{c}\" for Code39')\n            for i, d in enumerate(chars[c]):\n                if i % 2 == 0:\n                    self.rect(x, y, dim[d], h, \"F\")\n                x += dim[d]\n            x += dim[\"n\"]\n\n    @check_page\n    @contextmanager\n    def rect_clip(self, x: float, y: float, w: float, h: float) -> Iterator[None]:\n        \"\"\"\n        Context manager that defines a rectangular crop zone,\n        useful to render only part of an image.\n\n        Args:\n            x (float): abscissa of the clipping region top left corner\n            y (float): ordinate of the clipping region top left corner\n            w (float): width of the clipping region\n            h (float): height of the clipping region\n        \"\"\"\n        self._out(\n            (\n                f\"q {x * self.k:.2f} {(self.h - y - h) * self.k:.2f} {w * self.k:.2f} \"\n                f\"{h * self.k:.2f} re W n\"\n            )\n        )\n        yield\n        self._out(\"Q\")\n\n    @check_page\n    @contextmanager\n    def elliptic_clip(self, x: float, y: float, w: float, h: float) -> Iterator[None]:\n        \"\"\"\n        Context manager that defines an elliptic crop zone,\n        useful to render only part of an image.\n\n        Args:\n            x (float): abscissa of the clipping region top left corner\n            y (float): ordinate of the clipping region top left corner\n            w (float): ellipse width\n            h (float): ellipse height\n        \"\"\"\n        self._out(\"q\")\n        self._draw_ellipse(x, y, w, h, \"W n\")\n        yield\n        self._out(\"Q\")\n\n    @check_page\n    @contextmanager\n    def round_clip(self, x: float, y: float, r: float) -> Iterator[None]:\n        \"\"\"\n        Context manager that defines a circular crop zone,\n        useful to render only part of an image.\n\n        Args:\n            x (float): abscissa of the clipping region top left corner\n            y (float): ordinate of the clipping region top left corner\n            r (float): radius of the clipping region\n        \"\"\"\n        with self.elliptic_clip(x, y, r, r):\n            yield\n\n    @contextmanager\n    def unbreakable(self) -> Iterator[FPDFRecorder]:\n        \"\"\"\n        Ensures that all rendering performed in this context appear on a single page\n        by performing page break beforehand if need be.\n\n        Detailed documentation on page breaks: https://py-pdf.github.io/fpdf2/PageBreaks.html\n\n        Notes\n        -----\n\n        Using this method means to duplicate the FPDF `bytearray` buffer:\n        when generating large PDFs, doubling memory usage may be troublesome.\n        \"\"\"\n        prev_page, prev_y = self.page, self.y\n        recorder = FPDFRecorder(self, accept_page_break=False)\n        recorder.page_break_triggered = False\n        self._in_unbreakable = True\n        LOGGER.debug(\"Starting unbreakable block\")\n        yield recorder\n        y_scroll = recorder.y - prev_y + (recorder.page - prev_page) * self.eph\n        if prev_y + y_scroll > self.page_break_trigger or recorder.page > prev_page:\n            LOGGER.debug(\"Performing page jump due to unbreakable height\")\n            recorder.rewind()\n            # pylint: disable=protected-access\n            # Performing this call through .pdf so that it does not get recorded & replayed:\n            recorder.pdf._perform_page_break()\n            recorder.replay()\n            recorder.page_break_triggered = True\n        self._in_unbreakable = False\n        LOGGER.debug(\"Ending unbreakable block\")\n\n    @contextmanager\n    def offset_rendering(self) -> Iterator[FPDFRecorder]:\n        \"\"\"\n        All rendering performed in this context is made on a dummy FPDF object.\n        This allows to test the results of some operations on the global layout\n        before performing them \"for real\".\n        \"\"\"\n        prev_page, prev_y = self.page, self.y\n        recorder = FPDFRecorder(self, accept_page_break=False)\n        recorder.page_break_triggered = False\n        yield recorder\n        y_scroll = recorder.y - prev_y + (recorder.page - prev_page) * self.eph\n        if prev_y + y_scroll > self.page_break_trigger or recorder.page > prev_page:\n            recorder.page_break_triggered = True\n        recorder.rewind()\n\n    @check_page\n    def insert_toc_placeholder(\n        self,\n        render_toc_function: Callable[[\"FPDF\", list[OutlineSection]], None],\n        pages: int = 1,\n        allow_extra_pages: bool = False,\n        reset_page_indices: bool = True,\n    ) -> None:\n        \"\"\"\n        Configure Table Of Contents rendering at the end of the document generation,\n        and reserve some vertical space right now in order to insert it.\n        At least one page break is triggered by this method.\n\n        Args:\n            render_toc_function (function): a function that will be invoked to render the ToC.\n                This function will receive 2 parameters: `pdf`, an instance of FPDF, and `outline`,\n                a list of `fpdf.outline.OutlineSection`.\n            pages (int): the number of pages that the Table of Contents will span,\n                including the current one that will. As many page breaks as the value of this argument\n                will occur immediately after calling this method.\n            allow_extra_pages (bool): If set to `True`, allows for an unlimited number of\n                extra pages in the ToC, which may cause discrepancies with pre-rendered\n                page numbers. For consistent numbering, using page labels to create a\n                separate numbering style for the ToC is recommended.\n            reset_page_indices (bool): Whether to reset the pages indices after the ToC. Default to True.\n        \"\"\"\n        if pages < 1:\n            raise ValueError(\n                f\"'pages' parameter must be equal or greater than 1: {pages}\"\n            )\n        if not callable(render_toc_function):\n            raise TypeError(\n                f\"The first argument must be a callable, got: {type(render_toc_function)}\"\n            )\n        if self.toc_placeholder:\n            raise FPDFException(\n                \"A placeholder for the table of contents has already been defined\"\n                f\" on page {self.toc_placeholder.start_page}\"\n            )\n        self.toc_placeholder = ToCPlaceholder(\n            render_toc_function,\n            self.page,\n            self.y,\n            self.cur_orientation,\n            pages,\n            reset_page_indices,\n        )\n        self._toc_allow_page_insertion = allow_extra_pages\n        for _ in range(pages):\n            self._perform_page_break()\n\n    def set_section_title_styles(\n        self,\n        level0: TextStyle,\n        level1: Optional[TextStyle] = None,\n        level2: Optional[TextStyle] = None,\n        level3: Optional[TextStyle] = None,\n        level4: Optional[TextStyle] = None,\n        level5: Optional[TextStyle] = None,\n        level6: Optional[TextStyle] = None,\n    ) -> None:\n        \"\"\"\n        Defines a style for section titles.\n        After calling this method, calls to `FPDF.start_section` will render section names visually.\n\n        Args:\n            level0 (TextStyle): style for the top level section titles\n            level1 (TextStyle): optional style for the level 1 section titles\n            level2 (TextStyle): optional style for the level 2 section titles\n            level3 (TextStyle): optional style for the level 3 section titles\n            level4 (TextStyle): optional style for the level 4 section titles\n            level5 (TextStyle): optional style for the level 5 section titles\n            level6 (TextStyle): optional style for the level 6 section titles\n        \"\"\"\n        index: int\n        level: Optional[TextStyle]\n        for index, level in enumerate(\n            [level0, level1, level2, level3, level4, level5, level6]\n        ):\n            if level is not None:\n                if not isinstance(level, TextStyle):\n                    raise TypeError(\n                        f\"Arguments must all be TextStyle instances, got: {type(level)}\"\n                    )\n                self.section_title_styles[index] = level\n\n    @check_page\n    def start_section(self, name: str, level: int = 0, strict: bool = True) -> None:\n        \"\"\"\n        Start a section in the document outline.\n        If section_title_styles have been configured,\n        render the section name visually as a title.\n\n        Args:\n            name (str): section name\n            level (int): section level in the document outline. 0 means top-level.\n            strict (bool): whether to raise an exception if levels increase incorrectly,\n                for example with a level-3 section following a level-1 section.\n        \"\"\"\n        if level < 0:\n            raise ValueError('\"level\" mut be equal or greater than zero')\n        if strict and self._outline and level > self._outline[-1].level + 1:\n            raise ValueError(\n                f\"Incoherent hierarchy: cannot start a level {level} section after a level {self._outline[-1].level} one\"\n            )\n        dest = DestinationXYZ(self.page, top=self.h_pt - self.y * self.k)\n        outline_struct_elem = None\n        if self.section_title_styles:\n            text_style = self.section_title_styles[level]\n            # We first check if adding this multi-cell will trigger a page break:\n            if text_style.size_pt is not None:\n                prev_font_size_pt = self.font_size_pt\n                self.font_size_pt = text_style.size_pt\n            # check if l_margin value is of type Align or string\n            align = Align.L\n            if isinstance(text_style.l_margin, (Align, str)):\n                align = Align.coerce(text_style.l_margin)\n            page_break_triggered = self.multi_cell(\n                w=self.epw,\n                h=self.font_size,\n                text=name,\n                new_x=XPos.LMARGIN,\n                new_y=YPos.NEXT,\n                dry_run=True,  # => does not produce any output\n                output=MethodReturnValue.PAGE_BREAK,\n                align=align,\n                padding=Padding(\n                    top=text_style.t_margin or 0,\n                    left=(\n                        text_style.l_margin\n                        if isinstance(text_style.l_margin, (int, float))\n                        else 0\n                    ),\n                    bottom=text_style.b_margin or 0,\n                ),\n            )\n            if text_style.size_pt is not None:\n                self.font_size_pt = (\n                    prev_font_size_pt  # pyright: ignore[reportPossiblyUnboundVariable]\n                )\n            if page_break_triggered:\n                # If so, we trigger a page break manually beforehand:\n                self.add_page()\n            with self._marked_sequence(title=name) as struct_elem:\n                outline_struct_elem = struct_elem\n                with self.use_text_style(text_style):\n                    self.multi_cell(\n                        w=self.epw,\n                        h=self.font_size,\n                        text=name,\n                        align=align,\n                        new_x=XPos.LMARGIN,\n                        new_y=YPos.NEXT,\n                        center=text_style.l_margin == Align.C,\n                    )\n        self._outline.append(\n            OutlineSection(name, level, self.page, dest, outline_struct_elem)\n        )\n\n    @contextmanager\n    def use_text_style(self, text_style: TextStyle) -> Iterator[None]:\n        prev_l_margin = None\n        if text_style:\n            if text_style.t_margin:\n                self.ln(text_style.t_margin)\n            if text_style.l_margin:\n                if isinstance(text_style.l_margin, (float, int)):\n                    prev_l_margin = self.l_margin\n                    self.l_margin = text_style.l_margin\n                    self.x = self.l_margin\n                else:\n                    LOGGER.debug(\n                        \"Unsupported '%s' value provided as l_margin to .use_text_style()\",\n                        text_style.l_margin,\n                    )\n        with self.use_font_face(text_style):\n            yield\n        if text_style and text_style.b_margin:\n            self.ln(text_style.b_margin)\n        if prev_l_margin is not None:\n            self.l_margin = prev_l_margin\n            self.x = self.l_margin\n\n    @contextmanager\n    def use_font_face(self, font_face: FontFace) -> Iterator[None]:\n        \"\"\"\n        Sets the provided `fpdf.fonts.FontFace` in a local context,\n        then restore font settings back to they were initially.\n        This method must be used as a context manager using `with`:\n\n            with pdf.use_font_face(FontFace(emphasis=\"BOLD\", color=255, size_pt=42)):\n                put_some_text()\n\n        Known limitation: in case of a page jump in this local context,\n        the temporary style may \"leak\" in the header() & footer().\n        \"\"\"\n        if not font_face:\n            yield\n            return\n        prev_font = (self.font_family, self.font_style, self.font_size_pt)\n        self.set_font(\n            font_face.family or self.font_family,\n            (\n                font_face.emphasis.style\n                if font_face.emphasis is not None\n                else self.font_style\n            ),\n            font_face.size_pt or self.font_size_pt,\n        )\n        self.current_font_is_set_on_page = False\n        prev_text_color = self.text_color\n        if font_face.color is not None and font_face.color != self.text_color:\n            self.set_text_color(font_face.color)\n        prev_fill_color = self.fill_color\n        if font_face.fill_color is not None:\n            self.set_fill_color(font_face.fill_color)\n        yield\n        if font_face.fill_color is not None:\n            assert prev_fill_color is not None\n            self.set_fill_color(prev_fill_color)\n        self.text_color = prev_text_color\n        self.set_font(*prev_font)\n\n    @check_page\n    @contextmanager\n    def table(self, *args: Any, **kwargs: Any) -> Iterator[Table]:\n        \"\"\"\n        Inserts a table, that can be built using the `fpdf.table.Table` object yield.\n        Detailed usage documentation: https://py-pdf.github.io/fpdf2/Tables.html\n\n        Args:\n            rows: optional. Sequence of rows (iterable) of str to initiate the table cells with text content.\n            align (str, fpdf.enums.Align): optional, default to CENTER. Sets the table horizontal position\n                relative to the page, when it's not using the full page width.\n            borders_layout (str, fpdf.enums.TableBordersLayout): optional, default to ALL. Control what cell\n                borders are drawn.\n            cell_fill_color (int, tuple, fpdf.drawing.DeviceCMYK, fpdf.drawing.DeviceGray, fpdf.drawing.DeviceRGB): optional.\n                Defines the cells background color.\n            cell_fill_mode (str, fpdf.enums.TableCellFillMode): optional. Defines which cells are filled\n                with color in the background.\n            col_widths (int, tuple): optional. Sets column width. Can be a single number or a sequence of numbers.\n            first_row_as_headings (bool): optional, default to True. If False, the first row of the table\n                is not styled differently from the others.\n            gutter_height (float): optional vertical space between rows.\n            gutter_width (float): optional horizontal space between columns.\n            headings_style (fpdf.fonts.FontFace): optional, default to bold.\n                Defines the visual style of the top headings row: size, color, emphasis...\n            line_height (number): optional. Defines how much vertical space a line of text will occupy.\n            markdown (bool): optional, default to False. Enable markdown interpretation of cells textual content.\n            text_align (str, fpdf.enums.Align): optional, default to JUSTIFY. Control text alignment inside cells.\n            v_align (str, fpdf.enums.VAlign): optional, default to CENTER. Control vertical alignment of cells content.\n            width (number): optional. Sets the table width.\n            wrapmode (fpdf.enums.WrapMode): \"WORD\" for word based line wrapping (default),\n                \"CHAR\" for character based line wrapping.\n            padding (number, tuple, Padding): optional. Sets the cell padding. Can be a single number or a sequence\n                of numbers, default:0\n                If padding for left or right ends up being non-zero then the respective c_margin is ignored.\n            outer_border_width (number): optional. The outer_border_width will trigger rendering of the outer\n                border of the table with the given width regardless of any other defined border styles.\n            num_heading_rows (number): optional. Sets the number of heading rows, default value is 1. If this value is not 1,\n                first_row_as_headings needs to be True if num_heading_rows>1 and False if num_heading_rows=0. For backwards compatibility,\n                first_row_as_headings is used in case num_heading_rows is 1.\n            repeat_headings (fpdf.enums.TableHeadingsDisplay): optional, indicates whether to print table headings on every page, default to 1.\n        \"\"\"\n        table = Table(self, *args, **kwargs)\n        yield table\n        table.render()\n\n    @deprecated_parameter([(\"dest\", \"2.2.0\")])\n    def output(\n        self,\n        name: str | os.PathLike[str] | BinaryIO = \"\",\n        *,\n        linearize: bool = False,\n        output_producer_class: Type[OutputProducer] = OutputProducer,\n    ) -> Optional[bytearray]:\n        \"\"\"\n        Output PDF to some destination.\n        The method first calls [close](close.md) if necessary to terminate the document.\n        After calling this method, content cannot be added to the document anymore.\n\n        By default the bytearray buffer is returned.\n        If a `name` is given, the PDF is written to a new file.\n\n        Args:\n            name (str): optional File object or file path where to save the PDF under\n            output_producer_class (class): use a custom class for PDF file generation\n        \"\"\"\n        # Clear cache of cached functions to free up memory after output\n        get_unicode_script.cache_clear()\n        # Finish document if necessary:\n        if not self.buffer:\n            if self.page == 0:\n                self.add_page()\n            # Generating final page footer:\n            self._render_footer()\n            # Generating .buffer based on .pages:\n            if self.toc_placeholder:\n                self._insert_table_of_contents()\n            if self.str_alias_nb_pages:\n                for page in self.pages.values():\n                    for substitution_item in page.get_text_substitutions():\n                        page.contents = page.contents.replace(  # type: ignore[union-attr]\n                            substitution_item.get_placeholder_string().encode(\n                                \"latin-1\"\n                            ),\n                            substitution_item.render_text_substitution(\n                                str(self.pages_count)\n                            ).encode(\"latin-1\"),\n                        )\n            for _, font in self.fonts.items():\n                if isinstance(font, TTFFont) and font.color_font:\n                    font.color_font.load_glyphs()\n            if self._compliance and self._compliance.profile == \"PDFA\":\n                if len(self._output_intents) == 0:\n                    self.add_output_intent(\n                        OutputIntentSubType.PDFA,\n                        output_condition_identifier=\"sRGB\",\n                        output_condition=\"IEC 61966-2-1:1999\",\n                        registry_name=\"http://www.color.org\",\n                        dest_output_profile=PDFICCProfile(\n                            contents=builtin_srgb2014_bytes(),\n                            n=3,\n                            alternate=\"DeviceRGB\",\n                        ),\n                        info=\"sRGB2014 (v2)\",\n                    )\n                if (\n                    self._compliance.part == 4\n                    and self._compliance.conformance == \"F\"\n                    and len(self.embedded_files) == 0\n                ):\n                    raise PDFAComplianceError(\n                        f\"{self._compliance.label} requires at least one embedded file\"\n                    )\n            if linearize:\n                output_producer_class = LinearizedOutputProducer\n            output_producer = output_producer_class(self)\n            self.buffer = output_producer.bufferize()\n        if name:\n            if isinstance(name, (str, os.PathLike)):\n                Path(name).write_bytes(self.buffer)\n            else:\n                name.write(self.buffer)\n            return None\n        return self.buffer",
      "language": "python"
    },
    {
      "code": "@property\ndef accept_page_break(self) -> bool:\n    \"\"\"\n    Whenever a page break condition is met, this `@property` method is called,\n    and the break is issued or not depending on the returned value.\n\n    The default implementation returns `self.auto_page_break`,\n    a value according to the mode selected by `FPDF.set_auto_page_break()`.\n\n    This method is called automatically and should not be called directly by the application.\n\n    Detailed documentation on page breaks: https://py-pdf.github.io/fpdf2/PageBreaks.html\n    \"\"\"\n    return self.auto_page_break",
      "language": "python"
    },
    {
      "code": "@property\ndef default_page_dimensions(self) -> tuple[float, float]:\n    \"Return a pair (width, height) in points units (1/72 of inch)\"\n    return (\n        (self.dw_pt, self.dh_pt)\n        if self.def_orientation == PageOrientation.PORTRAIT\n        else (self.dh_pt, self.dw_pt)\n    )",
      "language": "python"
    },
    {
      "code": "@property\ndef emphasis(self) -> TextEmphasis:\n    \"The current text emphasis: bold, italics, underline and/or strikethrough.\"\n    font_style = self.font_style\n    if self.strikethrough:\n        font_style += \"S\"\n    if self.underline:\n        font_style += \"U\"\n    return TextEmphasis.coerce(font_style)",
      "language": "python"
    },
    {
      "code": "@property\ndef eph(self) -> float:\n    \"\"\"\n    Effective page height: the page height minus its vertical margins.\n    \"\"\"\n    return self.h - self.t_margin - self.b_margin",
      "language": "python"
    },
    {
      "code": "@property\ndef epw(self) -> float:\n    \"\"\"\n    Effective page width: the page width minus its horizontal margins.\n    \"\"\"\n    return self.w - self.l_margin - self.r_margin",
      "language": "python"
    },
    {
      "code": "@property\ndef fonts(self) -> dict[str, CoreFont | TTFFont]:\n    return self._resource_catalog.font_registry",
      "language": "python"
    },
    {
      "code": "@property\ndef is_ttf_font(self) -> bool:\n    return self.current_font is not None and self.current_font.type == \"TTF\"",
      "language": "python"
    },
    {
      "code": "@property\ndef output_intents(self) -> ValuesView[OutputIntentDictionary]:\n    return self._output_intents.values()",
      "language": "python"
    },
    {
      "code": "@property\ndef page_layout(self) -> Optional[PageLayout]:\n    return self._page_layout",
      "language": "python"
    },
    {
      "code": "@property\ndef page_mode(self) -> Optional[PageMode]:\n    return self._page_mode",
      "language": "python"
    },
    {
      "code": "@property\ndef pages_count(self) -> int:\n    \"\"\"\n    Returns the total pages of the document, at the time it is called.\n\n    Do not use this in `fpdf.fpdf.FPDF.header()` or `fpdf.fpdf.FPDF.footer()`,\n    as its value will not be the total page count.\n    Uses `{nb}` instead, _cf._ `fpdf.fpdf.FPDF.alias_nb_pages()`.\n    \"\"\"\n    return len(self.pages)",
      "language": "python"
    },
    {
      "code": "@check_page\ndef add_action(\n    self, action: Action, x: float, y: float, w: float, h: float, **kwargs: Any\n) -> AnnotationDict:\n    \"\"\"\n    Puts an Action annotation on a rectangular area of the page.\n\n    Args:\n        action (fpdf.actions.Action): the action to add\n        x (float): horizontal position (from the left) to the left side of the link rectangle\n        y (float): vertical position (from the top) to the bottom side of the link rectangle\n        w (float): width of the link rectangle\n        h (float): height of the link rectangle\n    \"\"\"\n    annotation_action_type = \"Action\"\n    if isinstance(action, GoToAction):\n        annotation_action_type = \"Link\"\n    annotation = AnnotationDict(\n        annotation_action_type,\n        x * self.k,\n        self.h_pt - y * self.k,\n        w * self.k,\n        h * self.k,\n        action=action,\n        **kwargs,\n    )\n    self.pages[self.page].add_annotation(annotation)\n    return annotation",
      "language": "python"
    },
    {
      "code": "@deprecated_parameter([(\"uni\", \"2.5.1\")])\ndef add_font(\n    self,\n    family: Optional[str] = None,\n    style: str = \"\",\n    fname: Optional[str] = None,\n    *,\n    unicode_range: Optional[str | Sequence[str | int | tuple[int, int]]] = None,\n    variations: Optional[dict[str, dict[str, float]] | dict[str, float]] = None,\n    palette: Optional[int] = None,\n) -> None:\n    \"\"\"\n    Imports a TrueType or OpenType font and makes it available\n    for later calls to the `FPDF.set_font()` method.\n\n    You will find more information on the \"Unicode\" documentation page.\n\n    Args:\n        family (str): optional name of the font family. Used as a reference for `FPDF.set_font()`.\n            If not provided, use the base name of the `fname` font path, without extension.\n        style (str): font style. \"\" for regular, include 'B' for bold, and/or 'I' for italic.\n        fname (str): font file name. You can specify a relative or full path.\n            If the file is not found, it will be searched in `FPDF_FONT_DIR`.\n        unicode_range (Optional[Union[str, int, tuple, list]]): subset of Unicode codepoints to embed.\n            Accepts CSS-style strings (e.g. \"U+1F600-1F64F, U+2600\"), integers, tuples, or lists.\n            Defaults to None, which embeds the full cmap.\n        variations (dict[style, dict]): maps style to limits of axes for the variable font.\n        palette (int): optional palette index for color fonts (COLR/CPAL). Defaults to 0 (first palette).\n            Only applicable to fonts with CPAL table (color fonts).\n    \"\"\"\n    if not fname:\n        raise ValueError('\"fname\" parameter is required')\n\n    ext = splitext(str(fname))[1].lower()\n    if ext not in (\".otf\", \".otc\", \".ttf\", \".ttc\", \".woff\", \".woff2\"):\n        raise ValueError(\n            f\"Unsupported font file extension: {ext}.\"\n            \" add_font() used to accept .pkl file as input, but for security reasons\"\n            \" this feature is deprecated since v2.5.1 and has been removed in v2.5.3.\"\n        )\n\n    for parent in (Path(\".\"), FPDF_FONT_DIR):\n        if (parent / fname).exists():\n            font_file_path = parent / fname\n            break\n    else:\n        raise FileNotFoundError(f\"TTF Font file not found: {fname}\")\n\n    if family is None:\n        family = font_file_path.stem\n\n    parsed_unicode_range = None\n    if unicode_range is not None:\n        parsed_unicode_range = get_parsed_unicode_range(unicode_range)\n\n    style = \"\".join(sorted(style.upper()))\n    if any(letter not in \"BI\" for letter in style):\n        raise ValueError(\n            f\"Unknown style provided (only B & I letters are allowed): {style}\"\n        )\n\n    # Handle variable font.\n    if variations is not None:\n        if not isinstance(variations, dict):\n            raise TypeError(\"Variations, if specified, must be a dictionary\")\n\n        # Check variations dictionary\n        if all(\n            key.upper() in (\"\", \"B\", \"I\", \"BI\") and isinstance(value, dict)\n            for key, value in variations.items()\n        ):\n            for var_style, axes_dict in variations.items():\n                self.add_font(\n                    family=family,\n                    style=var_style,\n                    fname=fname,\n                    unicode_range=unicode_range,\n                    variations=axes_dict,  # type: ignore[arg-type]\n                    palette=palette,\n                )\n            return\n    fontkey = f\"{family.lower()}{style}\"\n\n    if fontkey in self.fonts or fontkey in CORE_FONTS:\n        warnings.warn(\n            f\"Core font or font already added '{fontkey}': doing nothing\",\n            stacklevel=get_stack_level(),\n        )\n        return\n\n    self.fonts[fontkey] = TTFFont(\n        self,\n        font_file_path,\n        fontkey,\n        style,\n        parsed_unicode_range,\n        variations,  # type: ignore[arg-type]\n        palette,\n    )",
      "language": "python"
    },
    {
      "code": "def add_link(\n    self,\n    y: float = 0,\n    x: float = 0,\n    page: int = -1,\n    zoom: str | float = \"null\",\n    name: Optional[str] = None,\n) -> int:\n    \"\"\"\n    Creates a new internal link and returns its identifier.\n    An internal link is a clickable area which directs to another place within the document.\n\n    The identifier can then be passed to the `FPDF.cell()`, `FPDF.write()`, `FPDF.image()`\n    or `FPDF.link()` methods.\n\n    If a name is provided, creates a named destination that can be referenced later.\n    Named destinations are more stable than plain links when pages are added or removed.\n\n    Args:\n        y (float): optional ordinate of target position.\n            The default value is 0 (top of page).\n        x (float): optional abscissa of target position.\n            The default value is 0 (top of page).\n        page (int): optional number of target page.\n            -1 indicates the current page, which is the default value.\n        zoom (float): optional new zoom level after following the link.\n            Currently ignored by Sumatra PDF Reader, but observed by Adobe Acrobat reader.\n        name (str, optional): Name for the destination. If provided, creates a named\n            destination in the PDF that can be referenced from other parts of the document\n            or from external documents.\n    \"\"\"\n    # Create destination\n    link = DestinationXYZ(\n        self.page if page == -1 else page,\n        top=self.h_pt - y * self.k,\n        left=x * self.k,\n        zoom=zoom,\n    )\n\n    # Handle named destinations\n    if name is not None:\n        if not name or name.isspace():\n            raise ValueError(\"Destination name cannot be empty or whitespace\")\n        self.named_destinations[name] = link\n\n    # Store link and return index\n    link_index = len(self.links) + 1\n    self.links[link_index] = link\n    return link_index",
      "language": "python"
    },
    {
      "code": "def add_output_intent(\n    self,\n    subtype: OutputIntentSubType,\n    output_condition_identifier: Optional[str] = None,\n    output_condition: Optional[str] = None,\n    registry_name: Optional[str] = None,\n    dest_output_profile: Optional[PDFICCProfile] = None,\n    info: Optional[str] = None,\n) -> None:\n    \"\"\"\n    Adds desired Output Intent to the Output Intents array:\n\n    Args:\n        subtype (OutputIntentSubType, required): PDFA, PDFX or ISOPDF\n        output_condition_identifier (str, required): see the Name in\n            https://www.color.org/registry.xalter\n        output_condition (str, optional): see the Definition in\n            https://www.color.org/registry.xalter\n        registry_name (str, optional): \"https://www.color.org\"\n        dest_output_profile (PDFICCProfile, required/optional):\n            PDFICCProfile | None # (required  if\n            output_condition_identifier does not specify a standard\n            production condition; optional otherwise)\n        info (str, required/optional see dest_output_profile): human\n            readable description of profile\n    \"\"\"\n    if subtype.value in self._output_intents:\n        raise ValueError(\n            \"add_output_intent: subtype '\" + subtype.value + \"' already exists.\"\n        )\n    self._output_intents[subtype.value] = OutputIntentDictionary(\n        subtype,\n        output_condition_identifier,\n        output_condition,\n        registry_name,\n        dest_output_profile,\n        info,\n    )\n    self._set_min_pdf_version(\"1.4\")",
      "language": "python"
    },
    {
      "code": "def add_page(\n    self,\n    orientation: str = \"\",\n    format: str = \"\",\n    same: bool = False,\n    duration: float = 0,\n    transition: Optional[Transition] = None,\n    label_style: Optional[str | PageLabelStyle] = None,\n    label_prefix: Optional[str] = None,\n    label_start: Optional[int] = None,\n) -> None:\n    \"\"\"\n    Adds a new page to the document.\n    If a page is already present, the `FPDF.footer()` method is called first.\n    Then the page  is added, the current position is set to the top-left corner,\n    with respect to the left and top margins, and the `FPDF.header()` method is called.\n\n    Args:\n        orientation (str): \"portrait\" (can be abbreviated \"P\")\n            or \"landscape\" (can be abbreviated \"L\"). Default to \"portrait\".\n        format (str): \"a3\", \"a4\", \"a5\", \"letter\", \"legal\" or a tuple\n            (width, height). Default to \"a4\".\n        same (bool): indicates to use the same page format as the previous page.\n            Default to False.\n        duration (float): optional page’s display duration, i.e. the maximum length of time,\n            in seconds, that the page is displayed in presentation mode,\n            before the viewer application automatically advances to the next page.\n            Can be configured globally through the `.page_duration` FPDF property.\n            As of june 2021, onored by Adobe Acrobat reader, but ignored by Sumatra PDF reader.\n        transition (Transition child class): optional visual transition to use when moving\n            from another page to the given page during a presentation.\n            Can be configured globally through the `.page_transition` FPDF property.\n            As of june 2021, onored by Adobe Acrobat reader, but ignored by Sumatra PDF reader.\n        label_style (str or PageLabelStyle): Defines the numbering style for the numeric portion of each\n            page label. Possible values are:\n            - \"D\": Decimal Arabic numerals.\n            - \"R\": Uppercase Roman numerals.\n            - \"r\": Lowercase Roman numerals.\n            - \"A\": Uppercase letters (A to Z for the first 26 pages, followed by AA to ZZ, etc.).\n            - \"a\": Lowercase letters (a to z for the first 26 pages, followed by aa to zz, etc.).\n        label_prefix (str): Prefix string applied to the page label, preceding the numeric portion.\n        label_start (int): Starting number for the first page of a page label range.\n    \"\"\"\n    if self.buffer:\n        raise FPDFException(\n            \"A page cannot be added on a closed document, after calling output()\"\n        )\n\n    self.current_font_is_set_on_page = False\n\n    family = self.font_family\n    emphasis = self.emphasis\n    size = self.font_size_pt\n    lw = self.line_width\n    dc = self.draw_color\n    fc = self.fill_color\n    tc = self.text_color\n    stretching = self.font_stretching\n    char_spacing = self.char_spacing\n    dash_pattern = self.dash_pattern\n\n    in_toc_extra_page = (\n        self.in_toc_rendering\n        and self._toc_allow_page_insertion\n        and self.page > self.toc_placeholder.start_page  # type: ignore[union-attr]\n    )\n    if self.page > 0 and (not self.in_toc_rendering or in_toc_extra_page):\n        # Page footer\n        self._render_footer()\n\n    current_page_label = (\n        None if self.page == 0 else self.pages[self.page].get_page_label()\n    )\n    new_page_label = None\n    if label_style or label_prefix or label_start:\n        label_style = (\n            PageLabelStyle.coerce(label_style, case_sensitive=True)\n            if label_style\n            else None\n        )\n        new_page_label = PDFPageLabel(label_style, label_prefix, label_start)\n\n    # Start new page\n    self._beginpage(\n        orientation,\n        format,\n        same,\n        duration or self.page_duration,\n        transition or self.page_transition,\n        new_page=not self._has_next_page(),\n    )\n\n    self.pages[self.page].set_page_label(current_page_label, new_page_label)\n\n    if self.page_background:\n        if isinstance(self.page_background, tuple):\n            self.set_fill_color(*self.page_background)\n            self.rect(0, 0, self.w, self.h, style=\"F\")\n            assert isinstance(fc, (DeviceRGB, DeviceGray))\n            self.set_fill_color(*fc.colors255)\n        else:\n            self.image(\n                self.page_background,  # pyright: ignore[reportArgumentType]\n                0,\n                0,\n                self.w,\n                self.h,\n            )\n\n    self._out(\"2 J\")  # Set line cap style to square\n    self.line_width = lw  # Set line width\n    self._out(f\"{lw * self.k:.2f} w\")\n\n    # Set font\n    if family:\n        self.set_font(family, emphasis, size)\n\n    # Set colors\n    self.draw_color = dc\n    if dc != self.DEFAULT_DRAW_COLOR and dc is not None:\n        self._out(dc.serialize().upper())\n    self.fill_color = fc\n    if fc != self.DEFAULT_FILL_COLOR and fc is not None:\n        self._out(fc.serialize().lower())\n    self.text_color = tc\n\n    # BEGIN Page header\n    if (not self.in_toc_rendering) or self._toc_allow_page_insertion:\n        self.header()\n\n    if self.line_width != lw:  # Restore line width\n        self.line_width = lw\n        self._out(f\"{lw * self.k:.2f} w\")\n\n    if family:\n        self.set_font(family, emphasis, size)  # Restore font\n\n    if self.draw_color != dc and dc is not None:  # Restore colors\n        self.draw_color = dc\n        self._out(dc.serialize().upper())\n    if self.fill_color != fc and fc is not None:\n        self.fill_color = fc\n        self._out(fc.serialize().lower())\n    self.text_color = tc\n\n    if stretching != 100:  # Restore stretching\n        self.set_stretching(stretching)\n    if char_spacing != 0:\n        self.set_char_spacing(char_spacing)\n    if dash_pattern != dict(dash=0, gap=0, phase=0):\n        self._write_dash_pattern(\n            dash_pattern[\"dash\"], dash_pattern[\"gap\"], dash_pattern[\"phase\"]\n        )\n    # END Page header",
      "language": "python"
    },
    {
      "code": "@check_page\ndef add_text_markup_annotation(\n    self,\n    type: TextMarkupType | str,\n    text: str,\n    quad_points: Sequence[float],\n    color: tuple[float, float, float] = (1, 1, 0),\n    modification_time: Optional[datetime] = None,\n    page: Optional[int] = None,\n    **kwargs: Any,\n) -> AnnotationDict:\n    \"\"\"\n    Adds a text markup annotation on some quadrilateral areas of the page.\n\n    Args:\n        type (fpdf.enums.TextMarkupType, str): \"Highlight\", \"Underline\", \"Squiggly\" or \"StrikeOut\"\n        text (str): text of the annotation\n        quad_points (tuple): array of 8 × n numbers specifying the coordinates of n quadrilaterals\n            in default user space that comprise the region in which the link should be activated.\n            The coordinates for each quadrilateral are given in the order: x1 y1 x2 y2 x3 y3 x4 y4\n            specifying the four vertices of the quadrilateral in counterclockwise order\n        title (str): the text label that shall be displayed in the title bar of the annotation’s\n            pop-up window when open and active. This entry shall identify the user who added the annotation.\n        color (tuple): a tuple of numbers in the range 0.0 to 1.0, representing a colour used for\n            the title bar of the annotation’s pop-up window. Defaults to yellow.\n        modification_time (datetime): date and time when the annotation was most recently modified\n        page (int): index of the page where this annotation is added\n    \"\"\"\n    self._set_min_pdf_version(\"1.6\")\n    type = TextMarkupType.coerce(type).value\n    if modification_time is None:\n        modification_time = self.creation_date\n    if page is None:\n        page = self.page\n    x_min = min(quad_points[0::2])\n    y_min = min(quad_points[1::2])\n    x_max = max(quad_points[0::2])\n    y_max = max(quad_points[1::2])\n    annotation = AnnotationDict(\n        type,\n        contents=text,\n        x=y_min,\n        y=y_max,\n        width=x_max - x_min,\n        height=y_max - y_min,\n        modification_time=modification_time,\n        quad_points=quad_points,\n        color=color,\n        **kwargs,\n    )\n    self.pages[page].add_annotation(annotation)\n    return annotation",
      "language": "python"
    },
    {
      "code": "def alias_nb_pages(self, alias: str = \"{nb}\") -> None:\n    \"\"\"\n    Defines an alias for the total number of pages.\n    It will be substituted as the document is closed.\n\n    This is useful to insert the number of pages of the document\n    at a time when this number is not known by the program.\n\n    This substitution can be disabled for performances reasons, by calling `alias_nb_pages(None)`.\n\n    Args:\n        alias (str): the alias. Defaults to `\"{nb}\"`.\n\n    Notes\n    -----\n\n    When using this feature with the `FPDF.cell` / `FPDF.multi_cell` methods,\n    or the `.underline` / `.strikethrough` attributes of `FPDF` class,\n    the width of the text rendered will take into account the alias length,\n    not the length of the \"actual number of pages\" string,\n    which can causes slight positioning differences.\n    \"\"\"\n    self.str_alias_nb_pages = alias",
      "language": "python"
    },
    {
      "code": "@check_page\ndef arc(\n    self,\n    x: float,\n    y: float,\n    a: float,\n    start_angle: float,\n    end_angle: float,\n    b: Optional[float] = None,\n    inclination: float = 0,\n    clockwise: bool = False,\n    start_from_center: bool = False,\n    end_at_center: bool = False,\n    style: Optional[RenderStyle | str] = None,\n) -> None:\n    \"\"\"\n    Outputs an arc.\n    It can be drawn (border only), filled (with no border) or both.\n\n    Args:\n        x (float): Abscissa of upper-left corner of the bounding box of the full ellipse.\n        y (float): Ordinate of upper-left corner of the bounding box of the full ellipse.\n        a (float): Major axis diameter (width of bounding box).\n        b (float): Minor axis diameter (height of bounding box), if None, equals to a (default: None).\n        start_angle (float): Start angle of the arc (in degrees).\n        end_angle (float): End angle of the arc (in degrees).\n        inclination (float): Inclination of the arc in respect of the x-axis (default: 0).\n        clockwise (bool): Way of drawing the arc (True: clockwise, False: counterclockwise) (default: False).\n        start_from_center (bool): Start drawing from the center of the ellipse (default: False).\n        end_at_center (bool): End drawing at the center of the ellipse (default: False).\n        style (fpdf.enums.RenderStyle, str): Optional style of rendering. Allowed values are:\n\n        * `D` or None: draw border. This is the default value.\n        * `F`: fill\n        * `DF` or `FD`: draw and fill\n    \"\"\"\n    style = RenderStyle.coerce(style) if style is not None else RenderStyle.D\n\n    if b is None:\n        b = a\n\n    a /= 2\n    b /= 2\n\n    cx = x + a\n    cy = y + b\n\n    # Functions used only to construct other points of the bezier curve\n    def deg_to_rad(deg: float) -> float:\n        return deg * math.pi / 180\n\n    def angle_to_param(angle: float) -> float:\n        angle = deg_to_rad(angle % 360)\n        eta = math.atan2(math.sin(angle) / b, math.cos(angle) / a)\n\n        if eta < 0:\n            eta += 2 * math.pi\n        return eta\n\n    theta = deg_to_rad(inclination)\n    cos_theta = math.cos(theta)\n    sin_theta = math.sin(theta)\n\n    def evaluate(eta: float) -> list[float]:\n        a_cos_eta = a * math.cos(eta)\n        b_sin_eta = b * math.sin(eta)\n\n        return [\n            cx + a_cos_eta * cos_theta - b_sin_eta * sin_theta,\n            cy + a_cos_eta * sin_theta + b_sin_eta * cos_theta,\n        ]\n\n    def derivative_evaluate(eta: float) -> list[float]:\n        a_sin_eta = a * math.sin(eta)\n        b_cos_eta = b * math.cos(eta)\n\n        return [\n            -a_sin_eta * cos_theta - b_cos_eta * sin_theta,\n            -a_sin_eta * sin_theta + b_cos_eta * cos_theta,\n        ]\n\n    # Calculating start_eta and end_eta so that\n    #   start_eta < end_eta   <= start_eta + 2*PI if counterclockwise\n    #   end_eta   < start_eta <= end_eta + 2*PI   if clockwise\n    start_eta = angle_to_param(start_angle)\n    end_eta = angle_to_param(end_angle)\n\n    if not clockwise and end_eta <= start_eta:\n        end_eta += 2 * math.pi\n    elif clockwise and end_eta >= start_eta:\n        start_eta += 2 * math.pi\n\n    start_point = evaluate(start_eta)\n\n    # Move to the start point\n    if start_from_center:\n        self._out(f\"{cx * self.k:.2f} {(self.h - cy) * self.k:.2f} m\")\n        self._out(\n            f\"{start_point[0] * self.k:.2f} {(self.h - start_point[1]) * self.k:.2f} l\"\n        )\n    else:\n        self._out(\n            f\"{start_point[0] * self.k:.2f} {(self.h - start_point[1]) * self.k:.2f} m\"\n        )\n\n    # Number of curves to use, maximal segment angle is 2*PI/max_curves\n    max_curves = 4\n    n = min(\n        max_curves, math.ceil(abs(end_eta - start_eta) / (2 * math.pi / max_curves))\n    )\n    d_eta = (end_eta - start_eta) / n\n\n    alpha = math.sin(d_eta) * (math.sqrt(4 + 3 * math.tan(d_eta / 2) ** 2) - 1) / 3\n\n    eta2 = start_eta\n    p2 = evaluate(eta2)\n    p2_prime = derivative_evaluate(eta2)\n\n    for i in range(n):\n        p1 = p2\n        p1_prime = p2_prime\n\n        eta2 += d_eta\n        p2 = evaluate(eta2)\n        p2_prime = derivative_evaluate(eta2)\n\n        control_point_1 = [p1[0] + alpha * p1_prime[0], p1[1] + alpha * p1_prime[1]]\n        control_point_2 = [p2[0] - alpha * p2_prime[0], p2[1] - alpha * p2_prime[1]]\n\n        end = \"\"\n        if i == n - 1 and not end_at_center:\n            end = f\" {style.operator}\"\n\n        self._out(\n            (\n                f\"{control_point_1[0] * self.k:.2f} {(self.h - control_point_1[1]) * self.k:.2f} \"\n                f\"{control_point_2[0] * self.k:.2f} {(self.h - control_point_2[1]) * self.k:.2f} \"\n                f\"{p2[0] * self.k:.2f} {(self.h - p2[1]) * self.k:.2f} c\" + end\n            )\n        )\n\n    if end_at_center:\n        if start_from_center:\n            self._out(f\"h {style.operator}\")\n        else:\n            self._out(\n                f\"{cx * self.k:.2f} {(self.h - cy) * self.k:.2f} l {style.operator}\"\n            )",
      "language": "python"
    },
    {
      "code": "def bezier(\n    self,\n    point_list: Sequence[tuple[float, float]],\n    closed: bool = False,\n    style: Optional[RenderStyle | str] = None,\n) -> None:\n    \"\"\"\n    Outputs a quadratic or cubic Bézier curve, defined by three or four coordinates.\n\n    Args:\n        point_list (list of tuples): List of Abscissa and Ordinate of\n                                    segments that should be drawn. Should be\n                                    three or four tuples. The first and last\n                                    points are the start and end point. The\n                                    middle point(s) are the control point(s).\n        closed (bool): True to draw the curve as a closed path, False (default)\n                                    for it to be drawn as an open path.\n        style (fpdf.enums.RenderStyle, str): Optional style of rendering. Allowed values are:\n        * `D` or None: draw border. This is the default value.\n        * `F`: fill\n        * `DF` or `FD`: draw and fill\n    \"\"\"\n    points = len(point_list)\n    if points not in (3, 4):\n        raise ValueError(\n            \"point_list should contain 3 tuples for a quadratic curve\"\n            \" or 4 tuples for a cubic curve.\"\n        )\n    style = RenderStyle.coerce(style) if style is not None else RenderStyle.D\n\n    # QuadraticBezierCurve and BezierCurve make use of `initial_point` when instantiated.\n    # If we want to define all 3 (quad.) or 4 (cubic) points, we can set `initial_point`\n    # to be the first point given in `point_list` by creating a separate dummy path at that pos.\n    with self.drawing_context() as ctxt:\n        p1 = point_list[0]\n        x1, y1 = p1[0], p1[1]\n\n        dummy_path = PaintedPath(x1, y1)\n        ctxt.add_item(dummy_path)\n\n        p2 = point_list[1]\n        x2, y2 = p2[0], p2[1]\n\n        p3 = point_list[2]\n        x3, y3 = p3[0], p3[1]\n\n        if points == 4:\n            p4 = point_list[3]\n            x4, y4 = p4[0], p4[1]\n\n        path = PaintedPath(x1, y1)\n\n        # Translate enum style (RenderStyle) into rule (PathPaintRule)\n        rule = PathPaintRule.STROKE_FILL_NONZERO\n        if style.is_draw and not style.is_fill:\n            rule = PathPaintRule.STROKE\n        elif style.is_fill and not style.is_draw:\n            rule = PathPaintRule.FILL_NONZERO\n\n        path.style.paint_rule = rule\n        path.style.auto_close = closed\n\n        if points == 4:\n            path.curve_to(\n                x2,\n                y2,\n                x3,\n                y3,\n                x4,  # pyright: ignore[reportPossiblyUnboundVariable]\n                y4,  # pyright: ignore[reportPossiblyUnboundVariable]\n            )\n        elif points == 3:\n            path.curve_to(x2, y2, x2, y2, x3, y3)\n\n        ctxt.add_item(path)",
      "language": "python"
    },
    {
      "code": "@check_page\n@support_deprecated_txt_arg\ndef cell(\n    self,\n    w: Optional[float] = None,\n    h: Optional[float] = None,\n    text: str = \"\",\n    border: Literal[0, 1] | str = 0,\n    ln: Literal[\"DEPRECATED\"] = \"DEPRECATED\",\n    align: str | Align = Align.L,\n    fill: bool = False,\n    link: Optional[str | int] = \"\",\n    center: bool = False,\n    markdown: bool = False,\n    new_x: str | XPos = XPos.RIGHT,\n    new_y: str | YPos = YPos.TOP,\n) -> bool:\n    \"\"\"\n    Prints a cell (rectangular area) with optional borders, background color and\n    character string. The upper-left corner of the cell corresponds to the current\n    position. The text can be aligned or centered. After the call, the current\n    position moves to the selected `new_x`/`new_y` position. It is possible to put a link\n    on the text. A cell has an horizontal padding, on the left & right sides, defined by\n    the.c_margin property.\n\n    If automatic page breaking is enabled and the cell goes beyond the limit, a\n    page break is performed before outputting.\n\n    Args:\n        w (float): Cell width. Default value: None, meaning to fit text width.\n            If 0, the cell extends up to the right margin.\n        h (float): Cell height. Default value: None, meaning an height equal\n            to the current font size.\n        text (str): String to print. Default value: empty string.\n        border: Indicates if borders must be drawn around the cell.\n            The value can be either a number (`0`: no border ; `1`: frame)\n            or a string containing some or all of the following characters\n            (in any order):\n            `L`: left ; `T`: top ; `R`: right ; `B`: bottom. Default value: 0.\n        new_x (fpdf.enums.XPos, str): New current position in x after the call. Default: RIGHT\n        new_y (fpdf.enums.YPos, str): New current position in y after the call. Default: TOP\n        ln (int): **DEPRECATED since 2.5.1**: Use `new_x` and `new_y` instead.\n        align (fpdf.enums.Align, str): Set text alignment inside the cell.\n            Possible values are: `L` or empty string: left align (default value) ;\n            `C`: center; `X`: center around current x position; `R`: right align\n        fill (bool): Indicates if the cell background must be painted (`True`)\n            or transparent (`False`). Default value: False.\n        link (str): optional link to add on the cell, internal\n            (identifier returned by `FPDF.add_link`) or external URL.\n        center (bool): center the cell horizontally on the page.\n        markdown (bool): enable minimal markdown-like markup to render part\n            of text as bold / italics / strikethrough / underlined.\n            Supports `\\\\` as escape character. Default to False.\n        txt (str): [**DEPRECATED since v2.7.6**] String to print. Default value: empty string.\n\n    Returns: a boolean indicating if page break was triggered\n    \"\"\"\n    if not self.font_family:\n        raise FPDFException(\"No font set, you need to call set_font() beforehand\")\n    if isinstance(w, str) or isinstance(h, str):\n        raise ValueError(\n            \"Parameter 'w' and 'h' must be numbers, not strings.\"\n            \" You can omit them by passing string content with text=\"\n        )\n    if isinstance(border, int) and border not in (0, 1):\n        warnings.warn(\n            'Integer values for \"border\" parameter other than 1 are currently ignored',\n            stacklevel=get_stack_level(),\n        )\n        border = 1\n    new_x = XPos.coerce(new_x)\n    new_y = YPos.coerce(new_y)\n    align = Align.coerce(align)\n    if align == Align.J:\n        raise ValueError(\n            \"cell() only produces one text line, justified alignment is not possible\"\n        )\n    if ln != \"DEPRECATED\":\n        # For backwards compatibility, if \"ln\" is used we overwrite \"new_[xy]\".\n        if ln == 0:\n            new_x = XPos.RIGHT\n            new_y = YPos.TOP\n        elif ln == 1:\n            new_x = XPos.LMARGIN\n            new_y = YPos.NEXT\n        elif ln == 2:\n            new_x = XPos.LEFT\n            new_y = YPos.NEXT\n        else:\n            raise ValueError(\n                f'Invalid value for parameter \"ln\" ({ln}),'\n                \" must be an int between 0 and 2.\"\n            )\n        warnings.warn(\n            (\n                'The parameter \"ln\" is deprecated since v2.5.2.'\n                f\" Instead of ln={ln} use new_x=XPos.{new_x.name}, new_y=YPos.{new_y.name}.\"\n            ),\n            DeprecationWarning,\n            stacklevel=get_stack_level(),\n        )\n    # Font styles preloading must be performed before any call to FPDF.get_string_width:\n    text = self.normalize_text(text)\n    styled_txt_frags = (\n        self._preload_bidirectional_text(text, markdown)\n        if self.text_shaping\n        else self._preload_font_styles(text, markdown)\n    )\n    line_height = self.font_size if h is None else h\n    return self._render_styled_text_line(\n        TextLine(\n            styled_txt_frags,\n            text_width=0,\n            number_of_spaces=0,\n            align=align,\n            height=line_height,\n            max_width=w,\n            trailing_nl=False,\n        ),\n        line_height,\n        border,\n        new_x=new_x,\n        new_y=new_y,\n        fill=fill,\n        link=link,\n        center=center,\n        prevent_font_change=markdown,\n    )",
      "language": "python"
    },
    {
      "code": "@check_page\ndef circle(\n    self,\n    x: float,\n    y: float,\n    radius: float,\n    style: Optional[RenderStyle | str] = None,\n) -> None:\n    \"\"\"\n    Outputs a circle.\n    It can be drawn (border only), filled (with no border) or both.\n\n    WARNING: This method changed parameters in [release 2.8.0](https://github.com/py-pdf/fpdf2/releases/tag/2.8.0)\n\n    Args:\n        x (float): Abscissa of upper-left bounding box.\n        y (float): Ordinate of upper-left bounding box.\n        radius (float): Radius of the circle.\n        style (str): Style of rendering. Possible values are:\n\n        * `D` or None: draw border. This is the default value.\n        * `F`: fill\n        * `DF` or `FD`: draw and fill\n    \"\"\"\n    self.ellipse(x - radius, y - radius, 2 * radius, 2 * radius, style)",
      "language": "python"
    },
    {
      "code": "@check_page\n@support_deprecated_txt_arg\ndef code39(\n    self, text: str, x: float, y: float, w: float = 1.5, h: float = 5\n) -> None:\n    \"\"\"Barcode 3of9\"\"\"\n    dim = {\"w\": w, \"n\": w / 3}\n    if not text.startswith(\"*\") or not text.endswith(\"*\"):\n        warnings.warn(\n            (\n                \"Code 39 input must start and end with a '*' character to be valid.\"\n                \" This method does not insert it automatically.\"\n            ),\n            stacklevel=get_stack_level(),\n        )\n    chars = {\n        \"0\": \"nnnwwnwnn\",\n        \"1\": \"wnnwnnnnw\",\n        \"2\": \"nnwwnnnnw\",\n        \"3\": \"wnwwnnnnn\",\n        \"4\": \"nnnwwnnnw\",\n        \"5\": \"wnnwwnnnn\",\n        \"6\": \"nnwwwnnnn\",\n        \"7\": \"nnnwnnwnw\",\n        \"8\": \"wnnwnnwnn\",\n        \"9\": \"nnwwnnwnn\",\n        \"A\": \"wnnnnwnnw\",\n        \"B\": \"nnwnnwnnw\",\n        \"C\": \"wnwnnwnnn\",\n        \"D\": \"nnnnwwnnw\",\n        \"E\": \"wnnnwwnnn\",\n        \"F\": \"nnwnwwnnn\",\n        \"G\": \"nnnnnwwnw\",\n        \"H\": \"wnnnnwwnn\",\n        \"I\": \"nnwnnwwnn\",\n        \"J\": \"nnnnwwwnn\",\n        \"K\": \"wnnnnnnww\",\n        \"L\": \"nnwnnnnww\",\n        \"M\": \"wnwnnnnwn\",\n        \"N\": \"nnnnwnnww\",\n        \"O\": \"wnnnwnnwn\",\n        \"P\": \"nnwnwnnwn\",\n        \"Q\": \"nnnnnnwww\",\n        \"R\": \"wnnnnnwwn\",\n        \"S\": \"nnwnnnwwn\",\n        \"T\": \"nnnnwnwwn\",\n        \"U\": \"wwnnnnnnw\",\n        \"V\": \"nwwnnnnnw\",\n        \"W\": \"wwwnnnnnn\",\n        \"X\": \"nwnnwnnnw\",\n        \"Y\": \"wwnnwnnnn\",\n        \"Z\": \"nwwnwnnnn\",\n        \"-\": \"nwnnnnwnw\",\n        \".\": \"wwnnnnwnn\",\n        \" \": \"nwwnnnwnn\",\n        \"*\": \"nwnnwnwnn\",\n        \"$\": \"nwnwnwnnn\",\n        \"/\": \"nwnwnnnwn\",\n        \"+\": \"nwnnnwnwn\",\n        \"%\": \"nnnwnwnwn\",\n    }\n    # The caller should do this, or we can't rotate the thing.\n    # self.set_fill_color(0)\n    for c in text.upper():\n        if c not in chars:\n            raise RuntimeError(f'Invalid char \"{c}\" for Code39')\n        for i, d in enumerate(chars[c]):\n            if i % 2 == 0:\n                self.rect(x, y, dim[d], h, \"F\")\n            x += dim[d]\n        x += dim[\"n\"]",
      "language": "python"
    },
    {
      "code": "@check_page\ndef dashed_line(\n    self,\n    x1: float,\n    y1: float,\n    x2: float,\n    y2: float,\n    dash_length: float = 1,\n    space_length: float = 1,\n) -> None:\n    \"\"\"\n    Draw a dashed line between two points.\n\n    Args:\n        x1 (float): Abscissa of first point\n        y1 (float): Ordinate of first point\n        x2 (float): Abscissa of second point\n        y2 (float): Ordinate of second point\n        dash_length (float): Length of the dash\n        space_length (float): Length of the space between 2 dashes\n\n    .. deprecated:: 2.4.6\n        Use `FPDF.set_dash_pattern()` and the normal drawing operations instead.\n    \"\"\"\n    warnings.warn(\n        (\n            \"dashed_line() is deprecated since v2.4.6, \"\n            \"and will be removed in a future release. \"\n            \"Use set_dash_pattern() and the normal drawing operations instead.\"\n        ),\n        DeprecationWarning,\n        stacklevel=get_stack_level(),\n    )\n    self.set_dash_pattern(dash_length, space_length)\n    self.line(x1, y1, x2, y2)\n    self.set_dash_pattern()",
      "language": "python"
    },
    {
      "code": "def draw_path(\n    self,\n    path: GraphicsContext,\n    debug_stream: Optional[bool] = None,  # pylint: disable=unused-argument\n    copy: bool = True,\n) -> None:\n    \"\"\"\n    Add a pre-constructed path to the document.\n\n    Args:\n        path (drawing.PaintedPath): the path to be drawn.\n        copy (bool): if true (the default), the path will be copied before being\n            added. This prevents modifications to a referenced object from\n            \"retroactively\" altering its style/shape and should be disabled with\n            caution.\n    \"\"\"\n    with self.drawing_context() as ctxt:\n        ctxt.add_item(path, copy)",
      "language": "python"
    },
    {
      "code": "def draw_vector_glyph(\n    self, path: Union[PaintedPath, GraphicsContext], font: \"Type3Font\"\n) -> str:\n    \"\"\"\n    Add a pre-constructed path to the document.\n    \"\"\"\n    output_stream: str = \"\"\n    with self.glyph_drawing_context() as ctxt:\n        ctxt.add_item(path)\n\n        starting_style = GraphicsStyle()\n        render_args = (\n            self._resource_catalog,\n            Point(0, 0),\n            1,\n            0,\n            starting_style,\n        )\n\n        output_stream = ctxt.render(*render_args)\n        # Registering raster images embedded in the vector graphics:\n        for resource_type, resource_id in self._resource_catalog.scan_stream(\n            output_stream\n        ):\n            if resource_type == PDFResourceType.X_OBJECT:\n                font.images_used.add(int(resource_id))\n            if resource_type == PDFResourceType.EXT_G_STATE:\n                font.graphics_style_used.add(resource_id)\n            if resource_type == PDFResourceType.PATTERN:\n                font.patterns_used.add(resource_id)\n\n    return output_stream",
      "language": "python"
    },
    {
      "code": "@contextmanager\n@check_page\ndef drawing_context(\n    self, debug_stream: Optional[bool] = None  # pylint: disable=unused-argument\n) -> Iterator[DrawingContext]:\n    \"\"\"\n    Create a context for drawing paths on the current page.\n\n    If this context manager is called again inside of an active context, it will\n    raise an exception, as base drawing contexts cannot be nested.\n    \"\"\"\n\n    if self._current_draw_context is not None:\n        raise FPDFException(\n            \"cannot create a drawing context while one is already open\"\n        )\n\n    context = DrawingContext()\n    self._current_draw_context = context\n    try:\n        yield context\n    finally:\n        self._current_draw_context = None\n\n    starting_style = self._current_graphic_style()\n    render_args = (\n        self._resource_catalog,\n        Point(self.x, self.y),\n        self.k,\n        self.h,\n        starting_style,\n    )\n\n    rendered = context.render(*render_args)\n\n    # Let the catalog scan & register resources used by this drawing:\n    self._resource_catalog.index_stream_resources(rendered, self.page)\n    # Once we handle text-rendering SVG tags (cf. PR #1029),\n    # we should also detect fonts used and add them to the resource catalog\n\n    self._out(rendered)\n    # The drawing API makes use of features (notably transparency and blending modes) that were introduced in PDF 1.4:\n    self._set_min_pdf_version(\"1.4\")",
      "language": "python"
    },
    {
      "code": "@check_page\ndef ellipse(\n    self,\n    x: float,\n    y: float,\n    w: float,\n    h: float,\n    style: Optional[RenderStyle | str] = None,\n) -> None:\n    \"\"\"\n    Outputs an ellipse.\n    It can be drawn (border only), filled (with no border) or both.\n\n    Args:\n        x (float): Abscissa of upper-left bounding box.\n        y (float): Ordinate of upper-left bounding box.\n        w (float): Width\n        h (float): Height\n        style (fpdf.enums.RenderStyle, str): Optional style of rendering. Possible values are:\n\n        * `D` or empty string: draw border. This is the default value.\n        * `F`: fill\n        * `DF` or `FD`: draw and fill\n    \"\"\"\n    style = RenderStyle.coerce(style) if style is not None else RenderStyle.D\n    self._draw_ellipse(x, y, w, h, style.operator)",
      "language": "python"
    },
    {
      "code": "@check_page\n@contextmanager\ndef elliptic_clip(self, x: float, y: float, w: float, h: float) -> Iterator[None]:\n    \"\"\"\n    Context manager that defines an elliptic crop zone,\n    useful to render only part of an image.\n\n    Args:\n        x (float): abscissa of the clipping region top left corner\n        y (float): ordinate of the clipping region top left corner\n        w (float): ellipse width\n        h (float): ellipse height\n    \"\"\"\n    self._out(\"q\")\n    self._draw_ellipse(x, y, w, h, \"W n\")\n    yield\n    self._out(\"Q\")",
      "language": "python"
    },
    {
      "code": "def embed_file(\n    self,\n    file_path: Optional[Union[str, Path]] = None,\n    bytes: Optional[bytes] = None,\n    basename: Optional[str] = None,\n    modification_date: Optional[datetime] = None,\n    mime_type: Optional[str] = None,\n    associated_file_relationship: Optional[str] = None,\n    **kwargs: Any,\n) -> PDFEmbeddedFile:\n    \"\"\"\n    Embed a file into the PDF as an attachment (and, for PDF/A-3 or PDF/A-4f, as an\n    Associated File).\n\n    Args:\n        file_path (str or Path): filesystem path to the existing file to embed\n        bytes (bytes): optional, as an alternative to file_path, bytes content of the file to embed\n        basename (str): optional, required if bytes is provided, file base name\n        creation_date (datetime): date and time when the file was created\n        modification_date (datetime): date and time when the file was last modified\n        desc (str): optional description of the file\n        mime_type: MIME type of the embedded content (e.g., \"application/pdf\", \"text/csv\", \"image/png\")\n        associated_file_relationship: For PDF/A-3/A-4f, the AF relationship to declare in the FileSpec\n            (e.g., \"Data\", \"Source\", \"Alternative\", \"Supplement\", or \"Unspecified\").\n\n        **kwargs:\n        desc (str): Optional human-readable description for the FileSpec.\n        creation_date (datetime): Original creation time of the file.\n        compress (bool): enabled zlib compression of the file - False by default\n        checksum (bool): insert a MD5 checksum of the file content - False by default\n\n    Returns: a PDFEmbeddedFile instance, with a .basename string attribute representing the internal file name\n    \"\"\"\n    if file_path:\n        if bytes:\n            raise ValueError(\"'bytes' cannot be provided with 'file_path'\")\n        if basename:\n            raise ValueError(\"'basename' cannot be provided with 'file_path'\")\n        file_path = Path(file_path)\n        with file_path.open(\"rb\") as input_file:\n            bytes = input_file.read()\n        basename = file_path.name\n        stats = file_path.stat()\n        if modification_date is None:\n            modification_date = datetime.fromtimestamp(stats.st_mtime).astimezone()\n    else:\n        if not bytes:\n            raise ValueError(\"'bytes' is required if 'file_path' is not provided\")\n        if not basename:\n            raise ValueError(\n                \"'basename' is required if 'file_path' is not provided\"\n            )\n    if mime_type is None:\n        mime_type = mimetypes.guess_type(basename)[0] or \"application/octet-stream\"\n    mime_type = mime_type.lower()\n    af_relationship = (\n        AssociatedFileRelationship.coerce(associated_file_relationship)\n        if associated_file_relationship is not None\n        else None\n    )\n    already_embedded_basenames = set(\n        file.basename() for file in self.embedded_files\n    )\n    if basename in already_embedded_basenames:\n        raise ValueError(f\"{basename} has already been embedded in this file\")\n\n    if self._compliance and self._compliance.profile == \"PDFA\":\n        if self._compliance.part == 1:\n            raise PDFAComplianceError(\n                f\"Embedding files is not allowed for documents compliant with {self._compliance.label}\"\n            )\n        if self._compliance.part == 2 or (\n            self._compliance.part == 4 and self._compliance.conformance is None\n        ):\n            if (mime_type == \"application/pdf\") or basename.lower().endswith(\n                \".pdf\"\n            ):\n                LOGGER.warning(\n                    \"%s: ensure the embedded PDF '%s' is itself PDF/A to remain compliant.\",\n                    self._compliance.label,\n                    basename,\n                )\n            else:\n                raise PDFAComplianceError(\n                    f\"{self._compliance.label} permits embedding only PDF files, which must themselves be PDF/A.\"\n                )\n        if self._compliance.part in (3, 4):\n            if af_relationship is None:\n                af_relationship = AssociatedFileRelationship.UNSPECIFIED\n\n    embedded_file = PDFEmbeddedFile(\n        basename=basename,\n        contents=bytes,\n        modification_date=modification_date,\n        mime_type=mime_type,\n        af_relationship=af_relationship,\n        **kwargs,\n    )\n    self.embedded_files.append(embedded_file)\n    self._set_min_pdf_version(\"1.4\")\n    return embedded_file",
      "language": "python"
    },
    {
      "code": "@check_page\ndef file_attachment_annotation(\n    self,\n    file_path: str | Path,\n    x: float,\n    y: float,\n    w: float = 1,\n    h: float = 1,\n    name: Optional[FileAttachmentAnnotationName | str] = None,\n    flags: tuple[AnnotationFlag | str, ...] = DEFAULT_ANNOT_FLAGS,\n    **kwargs: Any,\n) -> AnnotationDict:\n    \"\"\"\n    Puts a file attachment annotation on a rectangular area of the page.\n\n    Args:\n        file_path (str or Path): filesystem path to the existing file to embed\n        x (float): horizontal position (from the left) to the left side of the link rectangle\n        y (float): vertical position (from the top) to the bottom side of the link rectangle\n        w (float): optional width of the link rectangle\n        h (float): optional height of the link rectangle\n        name (fpdf.enums.FileAttachmentAnnotationName, str): optional icon that shall be used in displaying the annotation\n        flags (Tuple[fpdf.enums.AnnotationFlag], Tuple[str]): optional list of flags defining annotation properties\n        bytes (bytes): optional, as an alternative to file_path, bytes content of the file to embed\n        basename (str): optional, required if bytes is provided, file base name\n        creation_date (datetime): date and time when the file was created\n        modification_date (datetime): date and time when the file was last modified\n        desc (str): optional description of the file\n        compress (bool): enabled zlib compression of the file - False by default\n        checksum (bool): insert a MD5 checksum of the file content - False by default\n    \"\"\"\n    embedded_file = self.embed_file(file_path, **kwargs)\n    # Attachment annotations should not be listed in the document-level AF entry\n    # (they are reachable through the annotation itself), so keep them out of AF:\n    embedded_file.set_globally_enclosed(False)\n    annotation = AnnotationDict(\n        \"FileAttachment\",\n        x * self.k,\n        self.h_pt - y * self.k,\n        w * self.k,\n        h * self.k,\n        file_spec=embedded_file.file_spec(),\n        name=FileAttachmentAnnotationName.coerce(name) if name else None,\n        flags=flags,\n    )\n    self.pages[self.page].add_annotation(annotation)\n    return annotation",
      "language": "python"
    },
    {
      "code": "def file_id(self) -> Optional[str | Literal[-1]]:  # pylint: disable=no-self-use\n    \"\"\"\n    This method can be overridden in inherited classes\n    in order to define a custom file identifier.\n    Its output must have the format \"<hex_string1><hex_string2>\".\n    If this method returns a falsy value (None, empty string),\n    no /ID will be inserted in the generated PDF document.\n    \"\"\"\n    return -1",
      "language": "python"
    },
    {
      "code": "def footer(self) -> None:\n    \"\"\"\n    Footer to be implemented in your own inherited class.\n\n    This is automatically called by `FPDF.add_page()` and `FPDF.output()`\n    and should not be called directly by the user application.\n    The default implementation performs nothing: you have to override this method\n    in a subclass to implement your own rendering logic.\n    \"\"\"",
      "language": "python"
    },
    {
      "code": "@check_page\ndef free_text_annotation(\n    self,\n    text: str,\n    x: Optional[float] = None,\n    y: Optional[float] = None,\n    w: Optional[float] = None,\n    h: Optional[float] = None,\n    **kwargs: Any,\n) -> AnnotationDict:\n    \"\"\"\n    Puts a free text annotation on a rectangular area of the page.\n\n    Args:\n        text (str): text to display\n        x (float): optional horizontal position (from the left) to the left side of the link rectangle.\n            Default value: None, meaning the current abscissa is used\n        y (float): vertical position (from the top) to the bottom side of the link rectangle.\n            Default value: None, meaning the current ordinate is used\n        w (float): optional width of the link rectangle. Default value: None, meaning the length of text in user unit\n        h (float): optional height of the link rectangle. Default value: None, meaning an height equal\n            to the current font size\n        flags (Tuple[fpdf.enums.AnnotationFlag], Tuple[str]): optional list of flags defining annotation properties\n        color (tuple): a tuple of numbers in the range 0.0 to 1.0, representing a colour used for the annotation background\n        border_width (float): width of the annotation border\n    \"\"\"\n    if not self.font_family:\n        raise FPDFException(\"No font set, you need to call set_font() beforehand\")\n    if not self.current_font_is_set_on_page:\n        assert self.current_font is not None\n        self._out(self._set_font_for_page(self.current_font, self.font_size_pt))\n    if x is None:\n        x = self.x\n    if y is None:\n        y = self.y\n    if h is None:\n        h = self.font_size\n    if w is None:\n        w = self.get_string_width(text, normalized=True, markdown=False)\n\n    assert self.draw_color is not None and self.current_font is not None\n    annotation = AnnotationDict(\n        \"FreeText\",\n        x * self.k,\n        self.h_pt - y * self.k,\n        w * self.k,\n        h * self.k,\n        contents=text,\n        default_appearance=f\"({self.draw_color.serialize()} /F{self.current_font.i} {self.font_size_pt:.2f} Tf)\",\n        **kwargs,\n    )\n    self.pages[self.page].add_annotation(annotation)\n    return annotation",
      "language": "python"
    },
    {
      "code": "def get_fallback_font(self, char: str, style: str = \"\") -> Optional[str]:\n    \"\"\"\n    Returns which fallback font has the requested glyph.\n    This method can be overridden to provide more control than the `select_mode` parameter\n    of `FPDF.set_fallback_fonts()` provides.\n    \"\"\"\n    emphasis = TextEmphasis.coerce(style)\n    fonts_with_char = [\n        font_id\n        for font_id in self._fallback_font_ids\n        if ord(char) in self.fonts[font_id].cmap  # type: ignore[union-attr]\n    ]\n    if not fonts_with_char:\n        return None\n    font_with_matching_emphasis = next(\n        (font for font in fonts_with_char if self.fonts[font].emphasis == emphasis),\n        None,\n    )\n    if font_with_matching_emphasis:\n        return font_with_matching_emphasis\n    if self._fallback_font_exact_match:\n        return None\n    return fonts_with_char[0]",
      "language": "python"
    },
    {
      "code": "def get_named_destination(self, name: str) -> str:\n    \"\"\"\n    Retrieves a named destination by its name and creates a link to it.\n\n    Args:\n        name (str): The name of the destination to retrieve.\n\n    Returns:\n        str: A string with format \"#name\" that can be used with cell(), write(), image(), or link()\n\n    Raises:\n        KeyError: If no destination exists with the given name\n    \"\"\"\n    if name not in self.named_destinations:\n        # Create a placeholder named destination pointing to page 0\n        # This will be caught during output if never set properly\n        self.named_destinations[name] = DestinationXYZ(0, top=self.h_pt * self.k)\n\n    # Return the name prefixed with # to indicate it's a named destination\n    # This way, the link() method will use the named destination string\n    return f\"#{name}\"",
      "language": "python"
    },
    {
      "code": "def get_page_label(self) -> str:\n    \"\"\"\n    Return the current page `fpdf.output.PDFPageLabel`.\n    This will be displayed by some PDF readers to identify pages.\n    `FPDF.set_page_label()` needs to be called first for those to be inserted.\n    \"\"\"\n    return self.pages[self.page].get_label()",
      "language": "python"
    },
    {
      "code": "def get_string_width(\n    self, s: str, normalized: bool = False, markdown: bool = False\n) -> float:\n    \"\"\"\n    Returns the length of a string in user unit. A font must be selected.\n    The value is calculated with stretching and spacing.\n\n    Note that the width of a cell has some extra padding added to this width,\n    on the left & right sides, equal to the .c_margin property.\n\n    Args:\n        s (str): the string whose length is to be computed.\n        normalized (bool): whether normalization needs to be performed on the input string.\n        markdown (bool): indicates if basic markdown support is enabled\n    \"\"\"\n    if not self.font_family:\n        raise FPDFException(\"No font set, you need to call set_font() beforehand\")\n    # normalized is parameter for internal use\n    s = s if normalized else self.normalize_text(s)\n    return sum(\n        frag.get_width() for frag in self._preload_bidirectional_text(s, markdown)\n    )",
      "language": "python"
    },
    {
      "code": "def get_x(self) -> float:\n    \"\"\"Returns the abscissa of the current position.\"\"\"\n    return self.x",
      "language": "python"
    },
    {
      "code": "def get_y(self) -> float:\n    \"\"\"Returns the ordinate of the current position.\"\"\"\n    if self._in_unbreakable:\n        raise FPDFException(\n            \"Using get_y() inside an unbreakable() code block is error-prone\"\n        )\n    return self.y",
      "language": "python"
    },
    {
      "code": "@contextmanager\ndef glyph_drawing_context(self) -> Iterator[DrawingContext]:\n    \"\"\"\n    Create a context for drawing paths for type 3 font glyphs, without writing on the current page.\n    \"\"\"\n\n    if self._current_draw_context is not None:\n        raise FPDFException(\n            \"cannot create a drawing context while one is already open\"\n        )\n\n    context = DrawingContext()\n    self._current_draw_context = context\n    try:\n        yield context\n    finally:\n        self._current_draw_context = None\n\n    self._set_min_pdf_version(\"1.4\")",
      "language": "python"
    },
    {
      "code": "def header(self) -> None:\n    \"\"\"\n    Header to be implemented in your own inherited class\n\n    This is automatically called by `FPDF.add_page()`\n    and should not be called directly by the user application.\n    The default implementation performs nothing: you have to override this method\n    in a subclass to implement your own rendering logic.\n\n    Note that header rendering can have an impact on the initial\n    (x,y) position when starting to render the page content.\n    \"\"\"",
      "language": "python"
    },
    {
      "code": "@contextmanager\ndef highlight(\n    self,\n    text: str,\n    type: TextMarkupType | str = \"Highlight\",\n    color: tuple[float, float, float] = (1, 1, 0),\n    modification_time: Optional[datetime] = None,\n    **kwargs: Any,\n) -> Iterator[None]:\n    \"\"\"\n    Context manager that adds a single highlight annotation based on the text lines inserted\n    inside its indented block.\n\n    Args:\n        text (str): text of the annotation\n        title (str): the text label that shall be displayed in the title bar of the annotation’s\n            pop-up window when open and active. This entry shall identify the user who added the annotation.\n        type (fpdf.enums.TextMarkupType, str): \"Highlight\", \"Underline\", \"Squiggly\" or \"StrikeOut\".\n        color (tuple): a tuple of numbers in the range 0.0 to 1.0, representing a colour used for\n            the title bar of the annotation’s pop-up window. Defaults to yellow.\n        modification_time (datetime): date and time when the annotation was most recently modified\n    \"\"\"\n    if self._record_text_quad_points:\n        raise FPDFException(\"highlight() cannot be nested\")\n    self._record_text_quad_points = True\n    yield\n    for page, quad_points in self._text_quad_points.items():\n        self.add_text_markup_annotation(\n            type,\n            text,\n            quad_points=quad_points,\n            modification_time=modification_time,\n            page=page,\n            color=color,\n            **kwargs,\n        )\n    self._text_quad_points = defaultdict(list)\n    self._record_text_quad_points = False",
      "language": "python"
    },
    {
      "code": "def image(\n    self,\n    name: ImageType,\n    x: Optional[float | Align] = None,\n    y: Optional[float] = None,\n    w: float = 0,\n    h: float = 0,\n    type: str | Literal[\"DEPRECATED\"] | None = \"\",\n    link: Optional[str | int] = \"\",\n    title: Optional[str] = None,\n    alt_text: Optional[str] = None,\n    dims: Optional[tuple[float, float]] = None,\n    keep_aspect_ratio: bool = False,\n) -> RasterImageInfo | VectorImageInfo:\n    \"\"\"\n    Put an image on the page.\n\n    The size of the image on the page can be specified in different ways:\n    * explicit width and height (expressed in user units)\n    * one explicit dimension, the other being calculated automatically\n      in order to keep the original proportions\n    * no explicit dimension, in which case the image is put at 72 dpi.\n    * explicit width and height (expressed in user units) and `keep_aspect_ratio=True`\n\n    **Remarks**:\n    * if an image is used several times, only one copy is embedded in the file.\n    * when using an animated GIF, only the first frame is used.\n\n    Args:\n        name: either a string representing a file path to an image, an URL to an image,\n            bytes, an io.BytesIO, or a instance of `PIL.Image.Image`\n        x (float, fpdf.enums.Align): optional horizontal position where to put the image on the page.\n            If not specified or equal to None, the current abscissa is used.\n            `fpdf.enums.Align.C` can also be passed to center the image horizontally;\n            and `fpdf.enums.Align.R` to place it along the right page margin\n        y (float): optional vertical position where to put the image on the page.\n            If not specified or equal to None, the current ordinate is used.\n            After the call, the current ordinate is moved to the bottom of the image\n        w (float): optional width of the image. If not specified or equal to zero,\n            it is automatically calculated from the image size.\n            Pass `pdf.epw` to scale horizontally to the full page width.\n        h (float): optional height of the image. If not specified or equal to zero,\n            it is automatically calculated from the image size.\n            Pass `pdf.eph` to scale horizontally to the full page height.\n        type (str): [**DEPRECATED since 2.2.0**] unused, will be removed in a later version.\n        link (str): optional link to add on the image, internal\n            (identifier returned by `FPDF.add_link`) or external URL.\n        title (str): optional. Currently, never seem rendered by PDF readers.\n        alt_text (str): optional alternative text describing the image,\n            for accessibility purposes. Displayed by some PDF readers on hover.\n        dims (Tuple[float]): optional dimensions as a tuple (width, height) to resize the image\n            before storing it in the PDF. Note that those are the **intrinsic** image dimensions,\n            but the image will still be rendered on the page with the width (`w`) and height (`h`)\n            provided as parameters. Note also that the `.oversized_images` attribute of FPDF\n            provides an automated way to auto-adjust those intrinsic image dimensions.\n        keep_aspect_ratio (bool): ensure the image fits in the rectangle defined by `x`, `y`, `w` & `h`\n            while preserving its original aspect ratio. Defaults to False.\n            Only meaningful if both `w` & `h` are provided.\n\n    If `y` is provided, this method will not trigger any page break;\n    otherwise, auto page break detection will be performed.\n\n    Returns: an instance of a subclass of `ImageInfo`.\n    \"\"\"\n    if not self.page:\n        raise FPDFException(\"No page open, you need to call add_page() first\")\n    if type:\n        warnings.warn(\n            (\n                '\"type\" parameter is deprecated since v2.2.0, '\n                \"unused and will soon be removed\"\n            ),\n            DeprecationWarning,\n            stacklevel=get_stack_level(),\n        )\n\n    name, img, info = preload_image(self.image_cache, name, dims)\n    if isinstance(info, VectorImageInfo):\n        return self._vector_image(\n            name,\n            cast(SVGObject, img),\n            info,\n            x,\n            y,\n            w,\n            h,\n            link,\n            title,\n            alt_text,\n            keep_aspect_ratio,\n        )\n    if TYPE_CHECKING:\n        assert not isinstance(img, SVGObject)\n    return self._raster_image(\n        name,\n        img,\n        info,\n        x,\n        y,\n        w,\n        h,\n        link,\n        title,\n        alt_text,\n        dims,\n        keep_aspect_ratio,\n    )",
      "language": "python"
    },
    {
      "code": "@check_page\ndef ink_annotation(\n    self,\n    coords: Sequence[tuple[float, float]],\n    text: str = \"\",\n    color: tuple[float, float, float] = (1, 1, 0),\n    border_width: float = 1,\n    **kwargs: Any,\n) -> AnnotationDict:\n    \"\"\"\n    Adds add an ink annotation on the page.\n\n    Args:\n        coords (tuple): an iterable of coordinates (pairs of numbers) defining a path\n        text (str): textual description\n        title (str): the text label that shall be displayed in the title bar of the annotation’s\n            pop-up window when open and active. This entry shall identify the user who added the annotation.\n        color (tuple): a tuple of numbers in the range 0.0 to 1.0, representing a colour used for\n            the title bar of the annotation’s pop-up window. Defaults to yellow.\n        border_width (float): thickness of the path stroke.\n    \"\"\"\n    ink_list = sum(((x * self.k, (self.h - y) * self.k) for (x, y) in coords), ())\n    x_min = min(ink_list[0::2])\n    y_min = min(ink_list[1::2])\n    x_max = max(ink_list[0::2])\n    y_max = max(ink_list[1::2])\n    annotation = AnnotationDict(\n        \"Ink\",\n        x=y_min,\n        y=y_max,\n        width=x_max - x_min,\n        height=y_max - y_min,\n        ink_list=ink_list,\n        contents=text,\n        border_width=border_width,\n        color=color,\n        **kwargs,\n    )\n    self.pages[self.page].add_annotation(annotation)\n    return annotation",
      "language": "python"
    },
    {
      "code": "@check_page\ndef insert_toc_placeholder(\n    self,\n    render_toc_function: Callable[[\"FPDF\", list[OutlineSection]], None],\n    pages: int = 1,\n    allow_extra_pages: bool = False,\n    reset_page_indices: bool = True,\n) -> None:\n    \"\"\"\n    Configure Table Of Contents rendering at the end of the document generation,\n    and reserve some vertical space right now in order to insert it.\n    At least one page break is triggered by this method.\n\n    Args:\n        render_toc_function (function): a function that will be invoked to render the ToC.\n            This function will receive 2 parameters: `pdf`, an instance of FPDF, and `outline`,\n            a list of `fpdf.outline.OutlineSection`.\n        pages (int): the number of pages that the Table of Contents will span,\n            including the current one that will. As many page breaks as the value of this argument\n            will occur immediately after calling this method.\n        allow_extra_pages (bool): If set to `True`, allows for an unlimited number of\n            extra pages in the ToC, which may cause discrepancies with pre-rendered\n            page numbers. For consistent numbering, using page labels to create a\n            separate numbering style for the ToC is recommended.\n        reset_page_indices (bool): Whether to reset the pages indices after the ToC. Default to True.\n    \"\"\"\n    if pages < 1:\n        raise ValueError(\n            f\"'pages' parameter must be equal or greater than 1: {pages}\"\n        )\n    if not callable(render_toc_function):\n        raise TypeError(\n            f\"The first argument must be a callable, got: {type(render_toc_function)}\"\n        )\n    if self.toc_placeholder:\n        raise FPDFException(\n            \"A placeholder for the table of contents has already been defined\"\n            f\" on page {self.toc_placeholder.start_page}\"\n        )\n    self.toc_placeholder = ToCPlaceholder(\n        render_toc_function,\n        self.page,\n        self.y,\n        self.cur_orientation,\n        pages,\n        reset_page_indices,\n    )\n    self._toc_allow_page_insertion = allow_extra_pages\n    for _ in range(pages):\n        self._perform_page_break()",
      "language": "python"
    },
    {
      "code": "@check_page\n@support_deprecated_txt_arg\ndef interleaved2of5(\n    self, text: str, x: float, y: float, w: float = 1, h: float = 10\n) -> None:\n    \"\"\"Barcode I2of5 (numeric), adds a 0 if odd length\"\"\"\n    narrow = w / 3\n    wide = w\n\n    # wide/narrow codes for the digits\n    bar_char = {\n        \"0\": \"nnwwn\",\n        \"1\": \"wnnnw\",\n        \"2\": \"nwnnw\",\n        \"3\": \"wwnnn\",\n        \"4\": \"nnwnw\",\n        \"5\": \"wnwnn\",\n        \"6\": \"nwwnn\",\n        \"7\": \"nnnww\",\n        \"8\": \"wnnwn\",\n        \"9\": \"nwnwn\",\n        \"A\": \"nn\",\n        \"Z\": \"wn\",\n    }\n    # The caller should do this, or we can't rotate the thing.\n    # self.set_fill_color(0)\n    code = text\n    # add leading zero if code-length is odd\n    if len(code) % 2 != 0:\n        code = f\"0{code}\"\n\n    # add start and stop codes\n    code = f\"AA{code.lower()}ZA\"\n\n    for i in range(0, len(code), 2):\n        # choose next pair of digits\n        char_bar = code[i]\n        char_space = code[i + 1]\n        # check whether it is a valid digit\n        if char_bar not in bar_char:\n            raise RuntimeError(f'Char \"{char_bar}\" invalid for I25:')\n        if char_space not in bar_char:\n            raise RuntimeError(f'Char \"{char_space}\" invalid for I25: ')\n\n        # create a wide/narrow-seq (first digit=bars, second digit=spaces)\n        seq = \"\".join(\n            f\"{cb}{cs}\" for cb, cs in zip(bar_char[char_bar], bar_char[char_space])\n        )\n\n        for bar_index, char in enumerate(seq):\n            # set line_width depending on value\n            line_width = narrow if char == \"n\" else wide\n\n            # draw every second value, the other is represented by space\n            if bar_index % 2 == 0:\n                self.rect(x, y, line_width, h, \"F\")\n\n            x += line_width",
      "language": "python"
    },
    {
      "code": "@check_page\ndef line(self, x1: float, y1: float, x2: float, y2: float) -> None:\n    \"\"\"\n    Draw a line between two points.\n\n    Args:\n        x1 (float): Abscissa of first point\n        y1 (float): Ordinate of first point\n        x2 (float): Abscissa of second point\n        y2 (float): Ordinate of second point\n    \"\"\"\n    self._out(\n        f\"{x1 * self.k:.2f} {(self.h - y1) * self.k:.2f} m {x2 * self.k:.2f} \"\n        f\"{(self.h - y2) * self.k:.2f} l S\"\n    )",
      "language": "python"
    },
    {
      "code": "def link(\n    self,\n    x: float,\n    y: float,\n    w: float,\n    h: float,\n    link: str | int,\n    alt_text: Optional[str] = None,\n    **kwargs: Any,\n) -> AnnotationDict:\n    \"\"\"\n    Puts a link annotation on a rectangular area of the page.\n    Text or image links are generally put via `FPDF.cell`,\n    `FPDF.write` or `FPDF.image`,\n    but this method can be useful for instance to define a clickable area inside an image.\n\n    Args:\n        x (float): horizontal position (from the left) to the left side of the link rectangle\n        y (float): vertical position (from the top) to the bottom side of the link rectangle\n        w (float): width of the link rectangle\n        h (float): height of the link rectangle\n        link: can be one of the following:\n            - a URL string to create an external link\n            - an integer returned by `FPDF.add_link`, defining an internal link to a page\n            - a named destination string prefixed with '#' (e.g., '#chapter1')\n        alt_text (str): optional textual description of the link, for accessibility purposes\n        border_width (int): thickness of an optional black border surrounding the link.\n            Not all PDF readers honor this: Acrobat renders it but not Sumatra.\n    \"\"\"\n    action: Optional[URIAction] = None\n    dest: Optional[PDFString | DestinationXYZ] = None\n    if link:\n        if isinstance(link, str):\n            # Check if this is a named destination (prefixed with '#')\n            if link.startswith(\"#\"):\n                dest_name = link[1:]  # Remove the '#' prefix\n                # If the named destination doesn't exist yet, create a placeholder\n                # destination pointing to page 0 (which doesn't exist)\n                # This will be caught during output if never set properly\n                if dest_name not in self.named_destinations:\n                    self.named_destinations[dest_name] = DestinationXYZ(\n                        0, top=self.h_pt * self.k\n                    )\n                # Use destination name instead of destination object for named destinations\n                dest = PDFString(dest_name, encrypt=True)\n            else:\n                # Regular URL\n                action = URIAction(link)\n        else:  # Dest type ending of annotation entry\n            assert (\n                link in self.links\n            ), f\"Link with an invalid index: {link} (doc #links={len(self.links)})\"\n            dest = self.links[link]\n            if not dest.page_number:\n                raise ValueError(\n                    f\"Cannot insert link {link} with no page number assigned\"\n                )\n    link_annot = AnnotationDict(\n        \"Link\",\n        x=x * self.k,\n        y=self.h_pt - y * self.k,\n        width=w * self.k,\n        height=h * self.k,\n        action=action,\n        dest=dest,\n        **kwargs,\n    )\n    self.pages[self.page].add_annotation(link_annot)\n    if alt_text is not None:\n        # Note: the spec indicates that a /StructParent could be added **inside* this /Annot,\n        # but tests with Adobe Acrobat Reader reveal that the page /StructParents inserted below\n        # is enough to link the marked content in the hierarchy tree with this annotation link.\n        self._add_marked_content(struct_type=\"/Link\", alt_text=alt_text)\n    return link_annot",
      "language": "python"
    },
    {
      "code": "@check_page\ndef ln(self, h: Optional[float] = None) -> None:\n    \"\"\"\n    Line Feed.\n    The current abscissa goes back to the left margin and the ordinate increases by\n    the amount passed as parameter.\n\n    Args:\n        h (float): The height of the break.\n            By default, the value equals the height of the last printed text line\n            (except when written by `.text()`). If no text has been written yet to\n            the document, then the current font height is used.\n    \"\"\"\n    self.x = self.l_margin\n    if h is not None:\n        self.y += h\n    elif self._lasth:\n        self.y += self._lasth\n    else:\n        self.y += self.font_size",
      "language": "python"
    },
    {
      "code": "@check_page\n@contextmanager\ndef local_context(self, **kwargs: Any) -> Iterator[None]:\n    \"\"\"\n    Creates a local graphics state, which won't affect the surrounding code.\n    This method must be used as a context manager using `with`:\n\n        with pdf.local_context():\n            set_some_state()\n            draw_some_stuff()\n\n    The affected settings are those controlled by GraphicsStateMixin and drawing.GraphicsStyle:\n\n    * allow_transparency\n    * auto_close\n    * blend_mode\n    * char_vpos\n    * char_spacing\n    * dash_pattern\n    * denom_lift\n    * denom_scale\n    * draw_color\n    * fill_color\n    * fill_opacity\n    * font_family\n    * font_size\n    * font_size_pt\n    * font_style\n    * font_stretching\n    * intersection_rule\n    * line_width\n    * nom_lift\n    * nom_scale\n    * paint_rule\n    * strikethrough\n    * stroke_cap_style\n    * stroke_join_style\n    * stroke_miter_limit\n    * stroke_opacity\n    * sub_lift\n    * sub_scale\n    * sup_lift\n    * sup_scale\n    * text_color\n    * text_mode\n    * text_shaping\n    * underline\n\n    Font size can be specified in document units with `font_size` or in points with `font_size_pt`.\n\n    Args:\n        **kwargs: key-values settings to set at the beginning of this context.\n    \"\"\"\n    if self._in_unbreakable:\n        raise FPDFException(\n            \"cannot create a local context inside an unbreakable() code block\"\n        )\n    self._push_local_stack()\n    self._start_local_context(**kwargs)\n    yield\n    self._end_local_context()\n    self._pop_local_stack()",
      "language": "python"
    },
    {
      "code": "with pdf.local_context():\n    set_some_state()\n    draw_some_stuff()",
      "language": "unknown"
    },
    {
      "code": "@check_page\n@contextmanager\ndef mirror(\n    self, origin: tuple[float, float], angle: Angle | str | float\n) -> Iterator[None]:\n    \"\"\"\n    Method to perform a reflection transformation over a given mirror line.\n    It must be used as a context-manager using `with`:\n\n        with mirror(origin=(15,15), angle=\"SOUTH\"):\n            pdf.something()\n\n    The mirror transformation affects all elements which are rendered inside the indented\n    context (with the exception of clickable areas).\n\n    Args:\n        origin (float, Sequence(float, float)): a point on the mirror line\n        angle: (fpdf.enums.Angle): the direction of the mirror line\n    \"\"\"\n    x, y = origin\n\n    try:\n        if isinstance(angle, (str, Angle)):\n            theta = float(Angle.coerce(angle).value)\n        else:\n            theta = float(angle)\n    except ValueError:\n        theta = float(angle)\n\n    a = math.cos(math.radians(theta * 2))\n    b = math.sin(math.radians(theta * 2))\n    cx, cy = x * self.k, (self.h - y) * self.k\n\n    with self.local_context():\n        self._out(\n            f\"{a:.5f} {b:.5f} {b:.5f} {a*-1:.5f} {cx:.2f} {cy:.2f} cm \"\n            f\"1 0 0 1 -{cx:.2f} -{cy:.2f} cm\"\n        )\n        yield",
      "language": "python"
    },
    {
      "code": "with mirror(origin=(15,15), angle=\"SOUTH\"):\n    pdf.something()",
      "language": "unknown"
    },
    {
      "code": "@check_page\n@support_deprecated_txt_arg\ndef multi_cell(\n    self,\n    w: float,\n    h: Optional[float] = None,\n    text: str = \"\",\n    border: Literal[0, 1] | str = 0,\n    align: str | Align = Align.J,\n    fill: bool = False,\n    split_only: bool = False,  # DEPRECATED\n    link: Optional[int | str] = None,\n    ln: Literal[\"DEPRECATED\"] = \"DEPRECATED\",\n    max_line_height: Optional[float] = None,\n    markdown: bool = False,\n    print_sh: bool = False,\n    new_x: str | XPos = XPos.RIGHT,\n    new_y: str | YPos = YPos.NEXT,\n    wrapmode: WrapMode = WrapMode.WORD,\n    dry_run: bool = False,\n    output: str | MethodReturnValue = MethodReturnValue.PAGE_BREAK,\n    center: bool = False,\n    padding: int | Sequence[int] | Padding = 0,\n) -> MultiCellResult:\n    \"\"\"\n    This method allows printing text with line breaks. They can be automatic\n    (breaking at the most recent space or soft-hyphen character) as soon as the text\n    reaches the right border of the cell, or explicit (via the `\\\\n` character).\n    As many cells as necessary are stacked, one below the other.\n    Text can be aligned, centered or justified. The cell block can be framed and\n    the background painted. A cell has an horizontal padding, on the left & right sides,\n    defined by the.c_margin property.\n\n    Args:\n        w (float): cell width. If 0, they extend up to the right margin of the page.\n        h (float): height of a single line of text.  Default value: None, meaning to use the current font size.\n        text (str): string to print.\n        border: Indicates if borders must be drawn around the cell.\n            The value can be either a number (`0`: no border ; `1`: frame)\n            or a string containing some or all of the following characters\n            (in any order):\n            `L`: left ; `T`: top ; `R`: right ; `B`: bottom. Default value: 0.\n        align (fpdf.enums.Align, str): Set text alignment inside the cell.\n            Possible values are:\n            `J`: justify (default value); `L` or empty string: left align;\n            `C`: center; `X`: center around current x position; `R`: right align\n        fill (bool): Indicates if the cell background must be painted (`True`)\n            or transparent (`False`). Default value: False.\n        split_only (bool): **DEPRECATED since 2.7.4**:\n            Use `dry_run=True` and `output=(\"LINES\",)` instead.\n        link (str): optional link to add on the cell, internal\n            (identifier returned by `add_link`) or external URL.\n        new_x (fpdf.enums.XPos, str): New current position in x after the call. Default: RIGHT\n        new_y (fpdf.enums.YPos, str): New current position in y after the call. Default: NEXT\n        ln (int): **DEPRECATED since 2.5.1**: Use `new_x` and `new_y` instead.\n        max_line_height (float): optional maximum height of each sub-cell generated\n        markdown (bool): enable minimal markdown-like markup to render part\n            of text as bold / italics / strikethrough / underlined.\n            Supports `\\\\` as escape character. Default to False.\n        print_sh (bool): Treat a soft-hyphen (\\\\u00ad) as a normal printable\n            character, instead of a line breaking opportunity. Default value: False\n        wrapmode (fpdf.enums.WrapMode): \"WORD\" for word based line wrapping (default),\n            \"CHAR\" for character based line wrapping.\n        dry_run (bool): if `True`, does not output anything in the document.\n            Can be useful when combined with `output`.\n        output (fpdf.enums.MethodReturnValue): defines what this method returns.\n            If several enum values are joined, the result will be a tuple.\n        txt (str): [**DEPRECATED since v2.7.6**] string to print.\n        center (bool): center the cell horizontally on the page.\n        padding (float or Sequence): padding to apply around the text. Default value: 0.\n            When one value is specified, it applies the same padding to all four sides.\n            When two values are specified, the first padding applies to the top and bottom, the second to\n            the left and right. When three values are specified, the first padding applies to the top,\n            the second to the right and left, the third to the bottom. When four values are specified,\n            the paddings apply to the top, right, bottom, and left in that order (clockwise)\n            If padding for left or right ends up being non-zero then respective c_margin is ignored.\n\n    Center overrides values for horizontal padding\n\n    Using `new_x=XPos.RIGHT, new_y=XPos.TOP, maximum height=pdf.font_size` is\n    useful to build tables with multiline text in cells.\n\n    Returns: a single value or a tuple, depending on the `output` parameter value\n    \"\"\"\n\n    padding = Padding.new(padding)\n    wrapmode = WrapMode.coerce(wrapmode)\n\n    if split_only:\n        warnings.warn(\n            (\n                'The parameter \"split_only\" is deprecated since v2.7.4.'\n                ' Use instead dry_run=True and output=\"LINES\".'\n            ),\n            DeprecationWarning,\n            stacklevel=get_stack_level(),\n        )\n    if dry_run or split_only:\n        with self._disable_writing():\n            return self.multi_cell(\n                w=w,\n                h=h,\n                text=text,\n                border=border,\n                align=align,\n                fill=fill,\n                link=link,\n                ln=ln,\n                max_line_height=max_line_height,\n                markdown=markdown,\n                print_sh=print_sh,\n                new_x=new_x,\n                new_y=new_y,\n                wrapmode=wrapmode,\n                dry_run=False,\n                split_only=False,\n                output=MethodReturnValue.LINES if split_only else output,\n                center=center,\n                padding=padding,\n            )\n    if not self.font_family:\n        raise FPDFException(\"No font set, you need to call set_font() beforehand\")\n    if isinstance(w, str) or isinstance(h, str):\n        raise ValueError(\n            \"Parameter 'w' and 'h' must be numbers, not strings.\"\n            \" You can omit them by passing string content with text=\"\n        )\n    new_x = XPos.coerce(new_x)\n    new_y = YPos.coerce(new_y)\n    if ln != \"DEPRECATED\":\n        # For backwards compatibility, if \"ln\" is used we overwrite \"new_[xy]\".\n        if ln == 0:\n            new_x = XPos.RIGHT\n            new_y = YPos.NEXT\n        elif ln == 1:\n            new_x = XPos.LMARGIN\n            new_y = YPos.NEXT\n        elif ln == 2:\n            new_x = XPos.LEFT\n            new_y = YPos.NEXT\n        elif ln == 3:\n            new_x = XPos.RIGHT\n            new_y = YPos.TOP\n        else:\n            raise ValueError(\n                f'Invalid value for parameter \"ln\" ({ln}),'\n                \" must be an int between 0 and 3.\"\n            )\n        warnings.warn(\n            (\n                'The parameter \"ln\" is deprecated since v2.5.2.'\n                f\" Instead of ln={ln} use new_x=XPos.{new_x.name}, new_y=YPos.{new_y.name}.\"\n            ),\n            DeprecationWarning,\n            stacklevel=get_stack_level(),\n        )\n    align = Align.coerce(align)\n\n    page_break_triggered = False\n\n    if h is None:\n        h = self.font_size\n\n    # If width is 0, set width to available width between margins\n    if w == 0:\n        w = self.w - self.r_margin - self.x\n\n    # Store the starting position before applying padding\n    prev_x, prev_y = self.x, self.y\n\n    # Apply padding to contents\n    # decrease maximum allowed width by padding\n    # shift the starting point by padding\n    maximum_allowed_width = w = w - padding.right - padding.left\n    clearance_margins: list[float] = []\n    # If we don't have padding on either side, we need a clearance margin.\n    if not padding.left:\n        clearance_margins.append(self.c_margin)\n    if not padding.right:\n        clearance_margins.append(self.c_margin)\n    if align != Align.X:\n        self.x += padding.left\n    self.y += padding.top\n\n    # Center overrides padding\n    if center:\n        self.x = (\n            self.w / 2 if align == Align.X else self.l_margin + (self.epw - w) / 2\n        )\n        prev_x = self.x\n\n    # Calculate text length\n    text = self.normalize_text(text)\n    normalized_string = text.replace(\"\\r\", \"\")\n    styled_text_fragments = (\n        self._preload_bidirectional_text(normalized_string, markdown)\n        if self.text_shaping\n        else self._preload_font_styles(normalized_string, markdown)\n    )\n\n    prev_current_font = self.current_font\n    prev_font_style = self.font_style\n    prev_underline = self.underline\n    total_height: float = 0\n\n    text_lines: list[TextLine] = []\n    multi_line_break = MultiLineBreak(\n        styled_text_fragments,\n        maximum_allowed_width,\n        clearance_margins,\n        align=align,\n        print_sh=print_sh,\n        wrapmode=wrapmode,\n    )\n    text_line = multi_line_break.get_line()\n    while (text_line) is not None:\n        text_lines.append(text_line)\n        text_line = multi_line_break.get_line()\n\n    if not text_lines:  # ensure we display at least one cell - cf. issue #349\n        text_lines = [\n            TextLine(\n                [],\n                text_width=0,\n                number_of_spaces=0,\n                align=align,\n                height=h,\n                max_width=w,\n                trailing_nl=False,\n            )\n        ]\n\n    if max_line_height is None or len(text_lines) == 1:\n        line_height = h\n    else:\n        line_height = min(h, max_line_height)\n\n    box_required = fill or border\n    page_break_triggered = False\n\n    for text_line_index, text_line in enumerate(text_lines):\n        start_of_new_page = self._perform_page_break_if_need_be(h + padding.bottom)\n        if start_of_new_page:\n            page_break_triggered = True\n            self.y += padding.top\n\n        if box_required and (text_line_index == 0 or start_of_new_page):\n            # estimate how many cells can fit on this page\n            top_gap = self.y  # Top padding has already been added\n            bottom_gap = padding.bottom + self.b_margin\n            lines_before_break = int((self.h - top_gap - bottom_gap) // line_height)\n            # check how many cells should be rendered\n            num_lines = min(lines_before_break, len(text_lines) - text_line_index)\n            box_height = max(\n                h - text_line_index * line_height, num_lines * line_height\n            )\n            # render the box\n            x = self.x - (w / 2 if align == Align.X else 0)\n            draw_box_borders(\n                self,\n                x - padding.left,\n                self.y - padding.top,\n                x + w + padding.right,\n                self.y + box_height + padding.bottom,\n                border,\n                self.fill_color if fill else None,\n            )\n        is_last_line = text_line_index == len(text_lines) - 1\n        self._render_styled_text_line(\n            text_line,\n            h=line_height,\n            new_x=new_x if is_last_line else XPos.LEFT,\n            new_y=new_y if is_last_line else YPos.NEXT,\n            border=0,  # already rendered\n            fill=False,  # already rendered\n            link=link,\n            padding=Padding(0, padding.right, 0, padding.left),\n            prevent_font_change=markdown,\n        )\n        total_height += line_height\n        if not is_last_line and align == Align.X:\n            # prevent cumulative shift to the left\n            self.x = prev_x\n\n    if total_height < h:\n        # Move to the bottom of the multi_cell\n        if new_y == YPos.NEXT:\n            self.y += h - total_height\n        total_height = h\n\n    if page_break_triggered and new_y == YPos.TOP:\n        # When a page jump is performed and the requested y is TOP,\n        # pretend we started at the top of the text block on the new page.\n        # cf. test_multi_cell_table_with_automatic_page_break\n        prev_y = self.y\n\n    last_line = text_lines[-1]\n    if last_line and last_line.trailing_nl and new_y in (YPos.LAST, YPos.NEXT):\n        # The line renderer can't handle trailing newlines in the text.\n        self.ln()\n\n    if new_y == YPos.TOP:  # We may have jumped a few lines -> reset\n        self.y = prev_y\n    elif new_y == YPos.NEXT:  # move down by bottom padding\n        self.y += padding.bottom\n\n    if markdown:\n        self.font_style = prev_font_style\n        self.current_font = prev_current_font\n        self.underline = prev_underline\n\n    if new_x == XPos.RIGHT:  # move right by right padding to align outer RHS edge\n        self.x += padding.right\n    elif new_x == XPos.LEFT:  # move left by left padding to align outer LHS edge\n        self.x -= padding.left\n\n    output = MethodReturnValue.coerce(output)\n    return_value = ()\n    if output & MethodReturnValue.PAGE_BREAK:\n        return_value += (page_break_triggered,)  # type: ignore[assignment]\n    if output & MethodReturnValue.LINES:\n        output_lines: list[str] = []\n        for text_line in text_lines:\n            characters: list[str] = []\n            for frag in text_line.fragments:\n                characters.extend(frag.characters)\n            output_lines.append(\"\".join(characters))\n        return_value += (output_lines,)  # type: ignore[assignment]\n    if output & MethodReturnValue.HEIGHT:\n        return_value += (total_height + padding.top + padding.bottom,)  # type: ignore[assignment]\n    if len(return_value) == 1:\n        return return_value[0]\n    return return_value  # type: ignore[return-value]",
      "language": "python"
    },
    {
      "code": "@contextmanager\ndef new_path(\n    self,\n    x: float = 0,\n    y: float = 0,\n    paint_rule: PathPaintRule = PathPaintRule.AUTO,\n    debug_stream: Optional[bool] = None,  # pylint: disable=unused-argument\n) -> Iterator[PaintedPath]:\n    \"\"\"\n    Create a path for appending lines and curves to.\n\n    Args:\n        x (float): Abscissa of the path starting point\n        y (float): Ordinate of the path starting point\n        paint_rule (PathPaintRule): Optional choice of how the path should\n            be painted. The default (AUTO) automatically selects stroke/fill based\n            on the path style settings.\n    \"\"\"\n    with self.drawing_context() as ctxt:\n        path = PaintedPath(x=x, y=y)\n        path.style.paint_rule = paint_rule\n        yield path\n        ctxt.add_item(path)",
      "language": "python"
    },
    {
      "code": "def normalize_text(self, text: str) -> str:\n    \"\"\"Check that text input is in the correct format/encoding\"\"\"\n    # - for TTF unicode fonts: unicode object (utf8 encoding)\n    # - for built-in fonts: string instances (encoding: latin-1, cp1252)\n    if not self.is_ttf_font and self.core_fonts_encoding:\n        try:\n            return text.encode(self.core_fonts_encoding).decode(\"latin-1\")\n        except UnicodeEncodeError as error:\n            raise FPDFUnicodeEncodingException(\n                text_index=error.start,\n                character=text[error.start],\n                font_name=self.font_family + self.font_style,\n            ) from error\n    return text",
      "language": "python"
    },
    {
      "code": "@contextmanager\ndef offset_rendering(self) -> Iterator[FPDFRecorder]:\n    \"\"\"\n    All rendering performed in this context is made on a dummy FPDF object.\n    This allows to test the results of some operations on the global layout\n    before performing them \"for real\".\n    \"\"\"\n    prev_page, prev_y = self.page, self.y\n    recorder = FPDFRecorder(self, accept_page_break=False)\n    recorder.page_break_triggered = False\n    yield recorder\n    y_scroll = recorder.y - prev_y + (recorder.page - prev_page) * self.eph\n    if prev_y + y_scroll > self.page_break_trigger or recorder.page > prev_page:\n        recorder.page_break_triggered = True\n    recorder.rewind()",
      "language": "python"
    },
    {
      "code": "@deprecated_parameter([(\"dest\", \"2.2.0\")])\ndef output(\n    self,\n    name: str | os.PathLike[str] | BinaryIO = \"\",\n    *,\n    linearize: bool = False,\n    output_producer_class: Type[OutputProducer] = OutputProducer,\n) -> Optional[bytearray]:\n    \"\"\"\n    Output PDF to some destination.\n    The method first calls [close](close.md) if necessary to terminate the document.\n    After calling this method, content cannot be added to the document anymore.\n\n    By default the bytearray buffer is returned.\n    If a `name` is given, the PDF is written to a new file.\n\n    Args:\n        name (str): optional File object or file path where to save the PDF under\n        output_producer_class (class): use a custom class for PDF file generation\n    \"\"\"\n    # Clear cache of cached functions to free up memory after output\n    get_unicode_script.cache_clear()\n    # Finish document if necessary:\n    if not self.buffer:\n        if self.page == 0:\n            self.add_page()\n        # Generating final page footer:\n        self._render_footer()\n        # Generating .buffer based on .pages:\n        if self.toc_placeholder:\n            self._insert_table_of_contents()\n        if self.str_alias_nb_pages:\n            for page in self.pages.values():\n                for substitution_item in page.get_text_substitutions():\n                    page.contents = page.contents.replace(  # type: ignore[union-attr]\n                        substitution_item.get_placeholder_string().encode(\n                            \"latin-1\"\n                        ),\n                        substitution_item.render_text_substitution(\n                            str(self.pages_count)\n                        ).encode(\"latin-1\"),\n                    )\n        for _, font in self.fonts.items():\n            if isinstance(font, TTFFont) and font.color_font:\n                font.color_font.load_glyphs()\n        if self._compliance and self._compliance.profile == \"PDFA\":\n            if len(self._output_intents) == 0:\n                self.add_output_intent(\n                    OutputIntentSubType.PDFA,\n                    output_condition_identifier=\"sRGB\",\n                    output_condition=\"IEC 61966-2-1:1999\",\n                    registry_name=\"http://www.color.org\",\n                    dest_output_profile=PDFICCProfile(\n                        contents=builtin_srgb2014_bytes(),\n                        n=3,\n                        alternate=\"DeviceRGB\",\n                    ),\n                    info=\"sRGB2014 (v2)\",\n                )\n            if (\n                self._compliance.part == 4\n                and self._compliance.conformance == \"F\"\n                and len(self.embedded_files) == 0\n            ):\n                raise PDFAComplianceError(\n                    f\"{self._compliance.label} requires at least one embedded file\"\n                )\n        if linearize:\n            output_producer_class = LinearizedOutputProducer\n        output_producer = output_producer_class(self)\n        self.buffer = output_producer.bufferize()\n    if name:\n        if isinstance(name, (str, os.PathLike)):\n            Path(name).write_bytes(self.buffer)\n        else:\n            name.write(self.buffer)\n        return None\n    return self.buffer",
      "language": "python"
    },
    {
      "code": "def page_no(self) -> int:\n    \"\"\"Get the current page number\"\"\"\n    return self.page",
      "language": "python"
    },
    {
      "code": "@check_page\ndef polygon(\n    self,\n    point_list: Sequence[tuple[float, float]],\n    fill: bool = False,\n    style: Optional[RenderStyle | str] = None,\n) -> None:\n    \"\"\"\n    Outputs a polygon defined by three or more points.\n\n    Args:\n        point_list (list of tuples): List of coordinates defining the polygon to draw\n        fill (bool): [**DEPRECATED since v2.5.4**] Use `style=\"F\"` or `style=\"DF\"` instead\n        style (fpdf.enums.RenderStyle, str): Optional style of rendering. Possible values are:\n\n        * `D` or None: draw border. This is the default value.\n        * `F`: fill\n        * `DF` or `FD`: draw and fill\n    \"\"\"\n    self.polyline(point_list, fill=fill, polygon=True, style=style)",
      "language": "python"
    },
    {
      "code": "@check_page\ndef polyline(\n    self,\n    point_list: Sequence[tuple[float, float]],\n    fill: bool = False,\n    polygon: bool = False,\n    style: Optional[RenderStyle | str] = None,\n) -> None:\n    \"\"\"\n    Draws lines between two or more points.\n\n    Args:\n        point_list (list of tuples): List of Abscissa and Ordinate of\n                                    segments that should be drawn\n        fill (bool): [**DEPRECATED since v2.5.4**] Use `style=\"F\"` or `style=\"DF\"` instead\n        polygon (bool): If true, close path before stroking, to fill the inside of the polyline\n        style (fpdf.enums.RenderStyle, str): Optional style of rendering. Possible values are:\n\n        * `D` or None: draw border. This is the default value.\n        * `F`: fill\n        * `DF` or `FD`: draw and fill\n    \"\"\"\n    if fill:\n        warnings.warn(\n            (\n                '\"fill\" parameter is deprecated since v2.5.4, '\n                'use style=\"F\" or style=\"DF\" instead'\n            ),\n            DeprecationWarning,\n            stacklevel=get_stack_level(),\n        )\n    if fill and style is None:\n        style = RenderStyle.DF\n    else:\n        style = RenderStyle.coerce(style) if style is not None else RenderStyle.D\n        if fill and style == RenderStyle.D:\n            raise ValueError(\n                f\"Conflicting values provided: fill={fill} & style={style}\"\n            )\n    operator = \"m\"\n    for point in point_list:\n        self._out(\n            f\"{point[0] * self.k:.2f} {(self.h - point[1]) * self.k:.2f} {operator}\"\n        )\n        operator = \"l\"\n    if polygon:\n        self._out(\" h\")\n    self._out(f\" {style.operator}\")",
      "language": "python"
    },
    {
      "code": "def preload_glyph_image(self, glyph_image_bytes: bytes | BinaryIO) -> tuple[\n    str,\n    SVGObject | Image | bytes | BinaryIO | Path | None,\n    RasterImageInfo | VectorImageInfo,\n]:\n    return preload_image(\n        image_cache=self.image_cache,\n        name=glyph_image_bytes,\n        dims=None,  # pyright: ignore[reportArgumentType, reportReturnType]\n    )",
      "language": "python"
    },
    {
      "code": "def preload_image(\n    self,\n    name: str | bytes | BinaryIO | Image | Path,\n    dims: tuple[float, float] | None = None,\n) -> tuple[\n    str,\n    SVGObject | Image | bytes | BinaryIO | Path | None,\n    RasterImageInfo | VectorImageInfo,\n]:\n    \"\"\"\n    Read an image and load it into memory.\n\n    .. deprecated:: 2.7.7\n        Use `fpdf.image_parsing.preload_image` instead.\n    \"\"\"\n    warnings.warn(\n        (\n            \"FPDF.preload_image() is deprecated since v2.7.7 \"\n            \"and will be removed in a future release. \"\n            \"Use `fpdf.image_parsing.preload_image` instead.\"\n        ),\n        DeprecationWarning,\n        stacklevel=get_stack_level(),\n    )\n    return preload_image(\n        self.image_cache,\n        name,  # pyright: ignore[reportArgumentType, reportReturnType]\n        dims,\n    )",
      "language": "python"
    },
    {
      "code": "@check_page\ndef rect(\n    self,\n    x: float,\n    y: float,\n    w: float,\n    h: float,\n    style: Optional[RenderStyle | str] = None,\n    round_corners: bool = False,\n    corner_radius: float = 0,\n) -> None:\n    \"\"\"\n    Outputs a rectangle.\n    It can be drawn (border only), filled (with no border) or both.\n\n    Args:\n        x (float): Abscissa of upper-left bounding box.\n        y (float): Ordinate of upper-left bounding box.\n        w (float): Width.\n        h (float): Height.\n        style (fpdf.enums.RenderStyle, str): Optional style of rendering. Possible values are:\n\n        * `D` or empty string: draw border. This is the default value.\n        * `F`: fill\n        * `DF` or `FD`: draw and fill\n\n        round_corners (tuple of str, tuple of fpdf.enums.Corner, bool): Optional draw a rectangle with round corners.\n        Possible values are:\n\n        *`TOP_LEFT`: a rectangle with round top left corner\n        *`TOP_RIGHT`: a rectangle with round top right corner\n        *`BOTTOM_LEFT`: a rectangle with round bottom left corner\n        *`BOTTOM_RIGHT`: a rectangle with round bottom right corner\n        *`True`: a rectangle with all round corners\n        *`False`: a rectangle with no round corners\n\n        corner_radius: Optional radius of the corners\n    \"\"\"\n\n    style = RenderStyle.coerce(style) if style is not None else RenderStyle.D\n    if round_corners is not False:\n        self._draw_rounded_rect(x, y, w, h, style, round_corners, corner_radius)\n    else:\n        self._out(\n            f\"{x * self.k:.2f} {(self.h - y) * self.k:.2f} {w * self.k:.2f} \"\n            f\"{-h * self.k:.2f} re {style.operator}\"\n        )",
      "language": "python"
    },
    {
      "code": "@check_page\n@contextmanager\ndef rect_clip(self, x: float, y: float, w: float, h: float) -> Iterator[None]:\n    \"\"\"\n    Context manager that defines a rectangular crop zone,\n    useful to render only part of an image.\n\n    Args:\n        x (float): abscissa of the clipping region top left corner\n        y (float): ordinate of the clipping region top left corner\n        w (float): width of the clipping region\n        h (float): height of the clipping region\n    \"\"\"\n    self._out(\n        (\n            f\"q {x * self.k:.2f} {(self.h - y - h) * self.k:.2f} {w * self.k:.2f} \"\n            f\"{h * self.k:.2f} re W n\"\n        )\n    )\n    yield\n    self._out(\"Q\")",
      "language": "python"
    },
    {
      "code": "@check_page\ndef regular_polygon(\n    self,\n    x: float,\n    y: float,\n    numSides: int,\n    polyWidth: float,\n    rotateDegrees: float = 0,\n    style: Optional[RenderStyle | str] = None,\n) -> None:\n    \"\"\"\n    Outputs a regular polygon with n sides\n    It can be rotated\n    Style can also be applied (fill, border...)\n\n    Args:\n        x (float): Abscissa of upper-left bounding box.\n        y (float): Ordinate of upper-left bounding box.\n        numSides (int): Number of sides for polygon.\n        polyWidth (float): Width of the polygon.\n        rotateDegrees (float): Optional degree amount to rotate polygon.\n        style (fpdf.enums.RenderStyle, str): Optional style of rendering. Possible values are:\n\n        * `D` or None: draw border. This is the default value.\n        * `F`: fill\n        * `DF` or `FD`: draw and fill\n    \"\"\"\n    radius = polyWidth / 2\n    centerX = x + radius\n    centerY = y - radius\n    # center point is (centerX, centerY)\n    points: list[tuple[float, float]] = []\n    for i in range(1, numSides + 1):\n        point = centerX + radius * math.cos(\n            math.radians((360 / numSides) * i) + math.radians(rotateDegrees)\n        ), centerY + radius * math.sin(\n            math.radians((360 / numSides) * i) + math.radians(rotateDegrees)\n        )\n        points.append(point)\n    # creates list of tuples containing coordinate points of vertices\n\n    self.polygon(points, style=style)\n    # passes points through polygon function",
      "language": "python"
    },
    {
      "code": "@check_page\ndef rotate(\n    self, angle: float, x: Optional[float] = None, y: Optional[float] = None\n) -> None:\n    \"\"\"\n    .. deprecated:: 2.1.0\n        Use `FPDF.rotation()` instead.\n    \"\"\"\n    warnings.warn(\n        (\n            \"rotate() can produces malformed PDFs and is deprecated since v2.1.0. \"\n            \"It will be removed in a future release. \"\n            \"Use the rotation() context manager instead.\"\n        ),\n        DeprecationWarning,\n        stacklevel=get_stack_level(),\n    )\n    if x is None:\n        x = self.x\n    if y is None:\n        y = self.y\n\n    if self._angle != 0:\n        self._out(\"Q\")\n    self._angle = angle\n    if angle != 0:\n        angle *= math.pi / 180\n        c = math.cos(angle)\n        s = math.sin(angle)\n        cx = x * self.k\n        cy = (self.h - y) * self.k\n        output = (\n            f\"q {c:.5F} {s:.5F} {-s:.5F} {c:.5F} {cx:.2F} {cy:.2F} cm \"\n            f\"1 0 0 1 {-cx:.2F} {-cy:.2F} cm\"\n        )\n        self._out(output)",
      "language": "python"
    },
    {
      "code": "@check_page\n@contextmanager\ndef rotation(\n    self, angle: float, x: Optional[float] = None, y: Optional[float] = None\n) -> Iterator[None]:\n    \"\"\"\n    Method to perform a rotation around a given center.\n    It must be used as a context-manager using `with`:\n\n        with rotation(angle=90, x=x, y=y):\n            pdf.something()\n\n    The rotation affects all elements which are printed inside the indented\n    context (with the exception of clickable areas).\n\n    Args:\n        angle (float): angle in degrees\n        x (float): abscissa of the center of the rotation\n        y (float): ordinate of the center of the rotation\n\n    Notes\n    -----\n\n    Only the rendering is altered. The `FPDF.get_x()` and `FPDF.get_y()` methods are\n    not affected, nor the automatic page break mechanism.\n    The rotation also establishes a local graphics state, so that any\n    graphics state settings changed within will not affect the operations\n    invoked after it has finished.\n    \"\"\"\n    if x is None:\n        x = self.x\n    if y is None:\n        y = self.y\n    angle *= math.pi / 180\n    c, s = math.cos(angle), math.sin(angle)\n    cx, cy = x * self.k, (self.h - y) * self.k\n    with self.local_context():\n        self._out(\n            f\"{c:.5F} {s:.5F} {-s:.5F} {c:.5F} {cx:.2F} {cy:.2F} cm \"\n            f\"1 0 0 1 {-cx:.2F} {-cy:.2F} cm\"\n        )\n        yield",
      "language": "python"
    },
    {
      "code": "with rotation(angle=90, x=x, y=y):\n    pdf.something()",
      "language": "unknown"
    },
    {
      "code": "@check_page\n@contextmanager\ndef round_clip(self, x: float, y: float, r: float) -> Iterator[None]:\n    \"\"\"\n    Context manager that defines a circular crop zone,\n    useful to render only part of an image.\n\n    Args:\n        x (float): abscissa of the clipping region top left corner\n        y (float): ordinate of the clipping region top left corner\n        r (float): radius of the clipping region\n    \"\"\"\n    with self.elliptic_clip(x, y, r, r):\n        yield",
      "language": "python"
    },
    {
      "code": "def set_author(self, author: str | Sequence[str]) -> None:\n    \"\"\"\n    Defines the author of the document.\n\n    Args:\n        author(str): the name of the author\n    \"\"\"\n    self.author = author",
      "language": "python"
    },
    {
      "code": "def set_auto_page_break(self, auto: bool, margin: float = 0) -> None:\n    \"\"\"\n    Set auto page break mode, and optionally the bottom margin that triggers it.\n    By default, the mode is on and the bottom margin is 2 cm.\n\n    Detailed documentation on page breaks: https://py-pdf.github.io/fpdf2/PageBreaks.html\n\n    Args:\n        auto (bool): enable or disable this mode\n        margin (float): optional bottom margin (distance from the bottom of the page)\n            in the unit specified to FPDF constructor\n    \"\"\"\n    self.auto_page_break: bool = auto\n    self.b_margin: float = margin\n    self.page_break_trigger: float = self.h - self.b_margin",
      "language": "python"
    },
    {
      "code": "def set_char_spacing(self, spacing: float) -> None:\n    \"\"\"\n    Sets horizontal character spacing.\n    A positive value increases the space between characters, a negative value\n    reduces it (which may result in glyph overlap).\n    By default, no spacing is set (which is equivalent to a value of 0).\n\n    Args:\n        spacing (float): horizontal spacing in document units\n    \"\"\"\n    if self.char_spacing == spacing:\n        return\n    self.char_spacing = spacing\n    if self.page > 0:\n        self._out(f\"BT {spacing:.2f} Tc ET\")",
      "language": "python"
    },
    {
      "code": "def set_compression(self, compress: bool) -> None:\n    \"\"\"\n    Activates or deactivates page compression.\n\n    When activated, the internal representation of each page is compressed\n    using the zlib/deflate method (FlateDecode), which leads to a compression ratio\n    of about 2 for the resulting document.\n\n    Page compression is enabled by default.\n\n    Args:\n        compress (bool): indicates if compression should be enabled\n    \"\"\"\n    self.compress = compress",
      "language": "python"
    },
    {
      "code": "def set_creation_date(self, date: Optional[datetime] = None) -> None:\n    \"\"\"Sets Creation of Date time, or current time if None given.\"\"\"\n    if self._sign_key:\n        raise FPDFException(\n            \".set_creation_date() must always be called before .sign*() methods\"\n        )\n    if not isinstance(date, datetime):\n        raise TypeError(f\"date should be a datetime but is a {type(date)}\")\n    if not date.tzinfo:\n        date = date.astimezone()\n    self.creation_date = date",
      "language": "python"
    },
    {
      "code": "def set_creator(self, creator: str) -> None:\n    \"\"\"\n    Defines the creator of the document.\n    This is typically the name of the application that generates the PDF.\n\n    Args:\n        creator (str): name of the PDF creator\n    \"\"\"\n    self.creator = creator",
      "language": "python"
    },
    {
      "code": "def set_dash_pattern(\n    self, dash: float = 0, gap: float = 0, phase: float = 0\n) -> None:\n    \"\"\"\n    Set the current dash pattern for lines and curves.\n\n    Args:\n        dash (float): The length of the dashes in current units.\n\n        gap (float): The length of the gaps between dashes in current units.\n            If omitted, the dash length will be used.\n\n        phase (float): Where in the sequence to start drawing.\n\n    Omitting 'dash' (= 0) resets the pattern to a solid line.\n    \"\"\"\n    if not (isinstance(dash, (int, float)) and dash >= 0):\n        raise ValueError(\"Dash length must be zero or a positive number.\")\n    if not (isinstance(gap, (int, float)) and gap >= 0):\n        raise ValueError(\"gap length must be zero or a positive number.\")\n    if not (isinstance(phase, (int, float)) and phase >= 0):\n        raise ValueError(\"Phase must be zero or a positive number.\")\n\n    pattern: dict[str, float] = dict(\n        dash=float(dash), gap=float(gap), phase=float(phase)\n    )\n\n    if pattern != self.dash_pattern:\n        self.dash_pattern = pattern\n        self._write_dash_pattern(dash, gap, phase)",
      "language": "python"
    },
    {
      "code": "def set_display_mode(\n    self,\n    zoom: str | float,\n    layout: str = \"continuous\",\n) -> None:\n    \"\"\"\n    Defines the way the document is to be displayed by the viewer.\n\n    It allows to set the zoom level: pages can be displayed entirely on screen,\n    occupy the full width of the window, use the real size,\n    be scaled by a specific zooming factor or use the viewer default (configured in its Preferences menu).\n\n    The page layout can also be specified: single page at a time, continuous display, two columns or viewer default.\n\n    Args:\n        zoom: either \"fullpage\", \"fullwidth\", \"real\", \"default\",\n            or a number indicating the zooming factor to use, interpreted as a percentage.\n            The zoom level set by default is \"default\".\n        layout (fpdf.enums.PageLayout, str): allowed layout aliases are \"single\", \"continuous\", \"two\" or \"default\",\n            meaning to use the viewer default mode.\n            The layout set by default is \"continuous\".\n    \"\"\"\n    if zoom in ZOOM_CONFIGS or not isinstance(zoom, str):\n        self.zoom_mode = zoom\n    elif zoom != \"default\":\n        raise FPDFException(f\"Incorrect zoom display mode: {zoom}\")\n    if isinstance(layout, PageLayout):\n        self.page_layout = layout\n    else:\n        # First support legacy aliases like \"continuous\"/\"single\"/\"default\"\n        alias_layout = LAYOUT_ALIASES.get(str(layout))\n        if alias_layout is not None or str(layout) in LAYOUT_ALIASES:\n            self.page_layout = alias_layout\n        else:\n            try:\n                self.page_layout = PageLayout.coerce(str(layout))\n            except (ValueError, TypeError) as exc:\n                raise FPDFException(\n                    f\"Incorrect layout display mode: {layout}\"\n                ) from exc",
      "language": "python"
    },
    {
      "code": "def set_doc_option(self, opt: Literal[\"core_fonts_encoding\"], value: str) -> None:\n    \"\"\"\n    Defines a document option.\n\n    Args:\n        opt (str): name of the option to set\n        value (str) option value\n\n    .. deprecated:: 2.4.0\n        Simply set the `FPDF.core_fonts_encoding` property as a replacement.\n    \"\"\"\n    warnings.warn(\n        (\n            \"set_doc_option() is deprecated since v2.4.0 \"\n            \"and will be removed in a future release. \"\n            \"Simply set the `.core_fonts_encoding` property as a replacement.\"\n        ),\n        DeprecationWarning,\n        stacklevel=get_stack_level(),\n    )\n    if opt != \"core_fonts_encoding\":\n        raise FPDFException(f'Unknown document option \"{opt}\"')\n    self.core_fonts_encoding = value",
      "language": "python"
    },
    {
      "code": "def set_draw_color(\n    self, r: Number | Color | str | Sequence[Number], g: Number = -1, b: Number = -1\n) -> None:\n    \"\"\"\n    Defines the color used for all stroking operations (lines, rectangles and cell borders).\n    Accepts either a single greyscale value, 3 values as RGB components, a single `#abc` or `#abcdef` hexadecimal color string,\n    or an instance of `fpdf.drawing.DeviceCMYK`, `fpdf.drawing.DeviceRGB` or `fpdf.drawing.DeviceGray`.\n    The method can be called before the first page is created and the value is retained from page to page.\n\n    Args:\n        r (int, tuple, fpdf.drawing.DeviceGray, fpdf.drawing.DeviceRGB): if `g` and `b` are given, this indicates the red component.\n            Else, this indicates the grey level. The value must be between 0 and 255.\n        g (int): green component (between 0 and 255)\n        b (int): blue component (between 0 and 255)\n    \"\"\"\n    draw_color = convert_to_device_color(r, g, b)\n    if draw_color != self.draw_color:\n        self.draw_color = draw_color\n        if self.page > 0:\n            self._out(\n                self.draw_color.serialize().upper()  # pyright: ignore[reportOptionalMemberAccess]\n            )",
      "language": "python"
    },
    {
      "code": "def set_encryption(\n    self,\n    owner_password: str,\n    user_password: Optional[str] = None,\n    encryption_method: EncryptionMethod = EncryptionMethod.RC4,\n    permissions: int = AccessPermission.all(),\n    encrypt_metadata: bool = False,\n) -> None:\n    \"\"\"\n    Activate encryption of the document content.\n\n    Args:\n        owner_password (str): mandatory. The owner password allows to perform any change on the document,\n            including removing all encryption and access permissions.\n        user_password (str): optional. If a user password is set, the content of the document will be encrypted\n            and a password prompt displayed when a user opens the document.\n            The document will only be displayed after either the user or owner password is entered.\n        encryption_method (fpdf.enums.EncryptionMethod, str): algorithm to be used to encrypt the document.\n            Defaults to RC4.\n        permissions (fpdf.enums.AccessPermission): specify access permissions granted\n            when the document is opened with user access. Defaults to ALL.\n        encrypt_metadata (bool): whether to also encrypt document metadata (author, creation date, etc.).\n            Defaults to False.\n    \"\"\"\n    if self._compliance and self._compliance.profile == \"PDFA\":\n        raise PDFAComplianceError(\n            f\"Encryption is now allowed for documents compliant with {self._compliance.label}\"\n        )\n\n    self._security_handler = StandardSecurityHandler(\n        self,\n        owner_password=owner_password,\n        user_password=user_password,\n        permission=permissions,\n        encryption_method=encryption_method,\n        encrypt_metadata=encrypt_metadata,\n    )",
      "language": "python"
    },
    {
      "code": "def set_fallback_fonts(\n    self, fallback_fonts: Sequence[str], exact_match: bool = True\n) -> None:\n    \"\"\"\n    Allows you to specify a list of fonts to be used if any character is not available on the font currently set.\n    Detailed documentation: https://py-pdf.github.io/fpdf2/Unicode.html#fallback-fonts\n\n    Args:\n        fallback_fonts: sequence of fallback font IDs\n        exact_match (bool): when a glyph cannot be rendered uing the current font,\n            fpdf2 will look for a fallback font matching the current character emphasis (bold/italics).\n            If it does not find such matching font, and `exact_match` is True, no fallback font will be used.\n            If it does not find such matching font, and `exact_match` is False, a fallback font will still be used.\n            To get even more control over this logic, you can also override `FPDF.get_fallback_font()`\n    \"\"\"\n    fallback_font_ids: list[str] = []\n    for fallback_font in fallback_fonts:\n        found = False\n        for fontkey in self.fonts:\n            # will add all font styles on the same family\n            if fontkey.replace(\"B\", \"\").replace(\"I\", \"\") == fallback_font.lower():\n                if fontkey not in fallback_font_ids:\n                    fallback_font_ids.append(fontkey)\n                found = True\n        if not found:\n            raise FPDFException(\n                f\"Undefined fallback font: {fallback_font} - Use FPDF.add_font() beforehand\"\n            )\n    self._fallback_font_ids = fallback_font_ids\n    self._fallback_font_exact_match = exact_match",
      "language": "python"
    },
    {
      "code": "def set_fill_color(\n    self, r: Number | Color | str | Sequence[Number], g: Number = -1, b: Number = -1\n) -> None:\n    \"\"\"\n    Defines the color used for all filling operations (filled rectangles and cell backgrounds).\n    Accepts either a single greyscale value, 3 values as RGB components, a single `#abc` or `#abcdef` hexadecimal color string,\n    or an instance of `fpdf.drawing.DeviceCMYK`, `fpdf.drawing.DeviceRGB` or `fpdf.drawing.DeviceGray`.\n    The method can be called before the first page is created and the value is retained from page to page.\n\n    Args:\n        r (int, tuple, fpdf.drawing.DeviceGray, fpdf.drawing.DeviceRGB): if `g` and `b` are given, this indicates the red component.\n            Else, this indicates the grey level. The value must be between 0 and 255.\n        g (int): green component (between 0 and 255)\n        b (int): blue component (between 0 and 255)\n    \"\"\"\n    fill_color = convert_to_device_color(r, g, b)\n    if fill_color != self.fill_color:\n        self.fill_color = fill_color\n        if self.page > 0:\n            self._out(\n                self.fill_color.serialize().lower()  # pyright: ignore[reportOptionalMemberAccess]\n            )",
      "language": "python"
    },
    {
      "code": "def set_font(\n    self,\n    family: Optional[str] = None,\n    style: Union[str, TextEmphasis] = \"\",\n    size: float = 0,\n) -> None:\n    \"\"\"\n    Sets the font used to print character strings.\n    It is mandatory to call this method at least once before printing text.\n\n    Default encoding is not specified, but all text writing methods accept only\n    unicode for external fonts and one byte encoding for standard.\n\n    Standard fonts use `Latin-1` encoding by default, but Windows\n    encoding `cp1252` (Western Europe) can be used with\n    `self.core_fonts_encoding = encoding`.\n\n    The font specified is retained from page to page.\n    The method can be called before the first page is created.\n\n    Args:\n        family (str): name of a font added with `FPDF.add_font`,\n            or name of one of the 14 standard \"PostScript\" fonts:\n            Courier (fixed-width), Helvetica (sans serif), Times (serif),\n            Symbol (symbolic) or ZapfDingbats (symbolic)\n            If an empty string is provided, the current family is retained.\n        style (str, fpdf.enums.TextEmphasis): empty string (by default) or a combination\n            of one or several letters among B (bold), I (italic), S (strikethrough) and U (underline).\n            Bold and italic styles do not apply to Symbol and ZapfDingbats fonts.\n        size (float): in points. The default value is the current size.\n    \"\"\"\n    if not family:\n        family = self.font_family\n\n    family = family.lower()\n    if isinstance(style, TextEmphasis):\n        style = style.style\n    style = \"\".join(sorted(style.upper()))\n    if any(letter not in \"BISU\" for letter in style):\n        raise ValueError(\n            f\"Unknown style provided (only B/I/S/U letters are allowed): {style}\"\n        )\n    if \"U\" in style:\n        self.underline = True\n        style = style.replace(\"U\", \"\")\n    else:\n        self.underline = False\n    if \"S\" in style:\n        self.strikethrough = True\n        style = style.replace(\"S\", \"\")\n    else:\n        self.strikethrough = False\n\n    if family in self.font_aliases and family + style not in self.fonts:\n        warnings.warn(\n            f\"Substituting font {family} by core font {self.font_aliases[family]}\"\n            \" - This is deprecated since v2.7.8, and will soon be removed\",\n            DeprecationWarning,\n            stacklevel=get_stack_level(),\n        )\n        family = self.font_aliases[family]\n    elif family in (\"symbol\", \"zapfdingbats\") and style:\n        warnings.warn(\n            f\"Built-in font {family} only has a single 'style' \"\n            \"and can't be bold or italic\",\n            stacklevel=get_stack_level(),\n        )\n        style = \"\"\n\n    if not size:\n        size = self.font_size_pt\n\n    # Test if font is already selected\n    if (\n        self.font_family == family\n        and self.font_style == style\n        and isclose(self.font_size_pt, size)\n    ):\n        return\n\n    # Test if used for the first time\n    fontkey = family + style\n    if fontkey not in self.fonts:\n        if fontkey not in CORE_FONTS:\n            raise FPDFException(\n                f\"Undefined font: {fontkey} - \"\n                f\"Use built-in fonts or FPDF.add_font() beforehand\"\n            )\n        # If it's one of the core fonts, add it to self.fonts\n        if self._compliance and self._compliance.profile == \"PDFA\":\n            raise PDFAComplianceError(\n                f\"Usage of base fonts is now allowed for documents compliant with {self._compliance.label}. Use add_font() to embed a font file\"\n            )\n\n        self.fonts[fontkey] = CoreFont(len(self.fonts) + 1, fontkey, style)\n\n    # Select it\n    self.font_family = family\n    self.font_style = style\n    self.font_size_pt = size\n    self.current_font = self.fonts[fontkey]\n    self.current_font_is_set_on_page = False",
      "language": "python"
    },
    {
      "code": "def set_font_size(self, size: float) -> None:\n    \"\"\"\n    Configure the font size in points\n\n    Args:\n        size (float): font size in points\n    \"\"\"\n    if isclose(self.font_size_pt, size):\n        return\n    self.font_size_pt = size\n    self.current_font_is_set_on_page = False",
      "language": "python"
    },
    {
      "code": "def set_image_filter(self, image_filter: str) -> None:\n    \"\"\"\n    Args:\n        image_filter (str): name of a the image filter to use\n            when embedding images in the document, or \"AUTO\",\n            meaning to use the best image filter given the images provided.\n            Allowed values: `FlateDecode` (lossless zlib/deflate compression),\n            `DCTDecode` (lossy compression with JPEG)\n            `LZWDecode` (Lempel-Ziv-Welch aka LZW compression)\n            and `JPXDecode` (lossy compression with JPEG2000).\n\n    [**NEW in 2.8.4**] Note that, when using `LZWDecode`, having NumPy installed\n    will improve performances, reducing execution time.\n    \"\"\"\n    if image_filter not in SUPPORTED_IMAGE_FILTERS:\n        raise ValueError(\n            f\"'{image_filter}' is not a supported image filter\"\n            f\" - Allowed values: {''.join(SUPPORTED_IMAGE_FILTERS)}\"\n        )\n    self.image_cache.image_filter = cast(ImageFilter, image_filter)\n    if image_filter == \"JPXDecode\":\n        self._set_min_pdf_version(\"1.5\")",
      "language": "python"
    },
    {
      "code": "def set_keywords(self, keywords: str | Sequence[str]) -> None:\n    \"\"\"\n    Associate keywords with the document\n\n    Args:\n        keywords (str): a space-separated list of words\n    \"\"\"\n    self.keywords = keywords",
      "language": "python"
    },
    {
      "code": "def set_lang(self, lang: str) -> None:\n    \"\"\"\n    A language identifier specifying the natural language for all text in the document\n    except where overridden by language specifications for structure elements or marked content.\n    A language identifier can either be the empty text string, to indicate that the language is unknown,\n    or a Language-Tag as defined in RFC 3066, \"Tags for the Identification of Languages\".\n\n    Args:\n        lang (str): the document main language\n    \"\"\"\n    self.lang = lang\n    if lang:\n        self._set_min_pdf_version(\"1.4\")",
      "language": "python"
    },
    {
      "code": "def set_left_margin(self, margin: float) -> None:\n    \"\"\"\n    Sets the document left margin.\n    Also sets the current FPDF.x on the page to this minimum horizontal position.\n\n    Args:\n        margin (float): margin in the unit specified to FPDF constructor\n    \"\"\"\n    if self.x < margin or self.x == self.l_margin:\n        self.x = margin\n    self.l_margin = margin",
      "language": "python"
    },
    {
      "code": "def set_line_width(self, width: float) -> None:\n    \"\"\"\n    Defines the line width of all stroking operations (lines, rectangles and cell borders).\n    By default, the value equals 0.2 mm.\n    The method can be called before the first page is created and the value is retained from page to page.\n\n    Args:\n        width (float): the width in user unit\n    \"\"\"\n    if width != self.line_width:\n        self.line_width = width\n        if self.page > 0:\n            self._out(f\"{width * self.k:.2f} w\")",
      "language": "python"
    },
    {
      "code": "def set_link(\n    self,\n    link: Optional[int] = None,\n    y: float = 0,\n    x: float = 0,\n    page: int = -1,\n    zoom: float | str = \"null\",\n    name: Optional[str] = None,\n) -> DestinationXYZ | str:\n    \"\"\"\n    Defines the page and position a link points to.\n\n    Args:\n        link (int, optional): a link identifier returned by `FPDF.add_link()`.\n            If None and name is provided, will create or update a named destination.\n        y (float): optional ordinate of target position.\n            The default value is 0 (top of page).\n        x (float): optional abscissa of target position.\n            The default value is 0 (top of page).\n        page (int): optional number of target page.\n            -1 indicates the current page, which is the default value.\n        zoom (float): optional new zoom level after following the link.\n            Currently ignored by Sumatra PDF Reader, but observed by Adobe Acrobat reader.\n        name (str, optional): Name for the destination. If provided, creates or updates a named\n            destination in the PDF that can be referenced from other parts of the document\n            or from external documents.\n    \"\"\"\n    # Handle named destination case\n    if name and link is None:\n        # Create the destination\n        dest = DestinationXYZ(\n            self.page if page == -1 else page,\n            top=self.h_pt - y * self.k,\n            left=x * self.k,\n            zoom=zoom,\n        )\n        # Store it in the named destinations dictionary\n        self.named_destinations[name] = dest\n        # Return the name for reference\n        return name\n\n    # Regular link handling (backward compatibility)\n    # We must take care to update the existing DestinationXYZ,\n    # and NOT re-assign self.links[link] to a new instance,\n    # as a reference to self.links[link] is kept in self.pages[].annots:\n    assert link is not None\n    destination = self.links[link]\n    destination.page_number = self.page if page == -1 else page\n    destination.top = self.h_pt - y * self.k\n    destination.left = x * self.k\n    destination.zoom = zoom\n\n    # If a name is provided with an existing link, associate the name with this link\n    if name:\n        self.named_destinations[name] = destination\n        return name\n\n    # Return link index for backward compatibility\n    return destination",
      "language": "python"
    },
    {
      "code": "def set_margin(self, margin: float) -> None:\n    \"\"\"\n    Sets the document right, left, top & bottom margins to the same value.\n\n    Args:\n        margin (float): margin in the unit specified to FPDF constructor\n    \"\"\"\n    self.set_margins(margin, margin)\n    self.set_auto_page_break(self.auto_page_break, margin)",
      "language": "python"
    },
    {
      "code": "def set_margins(self, left: float, top: float, right: float = -1) -> None:\n    \"\"\"\n    Sets the document left, top & optionally right margins to the same value.\n    By default, they equal 1 cm.\n    Also sets the current FPDF.y on the page to this minimum vertical position.\n\n    Args:\n        left (float): left margin in the unit specified to FPDF constructor\n        top (float): top margin in the unit specified to FPDF constructor\n        right (float): optional right margin in the unit specified to FPDF constructor\n    \"\"\"\n    self.set_left_margin(left)\n    if self.y < top or self.y == self.t_margin:\n        self.y = top\n    self.t_margin = top\n    if right == -1:\n        right = left\n    self.r_margin = right",
      "language": "python"
    },
    {
      "code": "def set_page_background(\n    self, background: Optional[str | BinaryIO | Image | DeviceRGB | tuple[float]]\n) -> None:\n    \"\"\"\n    Sets a background color or image to be drawn every time `FPDF.add_page()` is called, or removes a previously set background.\n    The method can be called before the first page is created and the value is retained from page to page.\n\n    Args:\n        background: either a string representing a file path or URL to an image,\n            an io.BytesIO containing an image as bytes, an instance of `PIL.Image.Image`, drawing.DeviceRGB\n            or a RGB tuple representing a color to fill the background with or `None` to remove the background\n    \"\"\"\n\n    if isinstance(\n        background, (str, io.BytesIO, Image, DeviceRGB, tuple, type(None))\n    ):\n        if isinstance(background, DeviceRGB):\n            self.page_background = background.colors255\n        else:\n            self.page_background = background\n    else:\n        raise TypeError(\n            f\"\"\"background must be of type str, io.BytesIO, PIL.Image.Image, drawing.DeviceRGB, tuple or None\n    got: {type(background)}\"\"\"\n        )",
      "language": "python"
    },
    {
      "code": "@check_page\ndef set_page_label(\n    self,\n    label_style: Optional[str | PageLabelStyle] = None,\n    label_prefix: Optional[str] = None,\n    label_start: Optional[int] = None,\n) -> None:\n    \"\"\"\n    Enable `fpdf.output.PDFPageLabel` to be inserted on every page.\n    This will be displayed by some PDF readers to identify pages.\n    \"\"\"\n    current_page_label = None\n    if self.page in self.pages:\n        current_page_label = self.pages[self.page].get_page_label()\n    elif self.page > 1:\n        current_page_label = self.pages[self.page - 1].get_page_label()\n    new_page_label = None\n    if label_style or label_prefix or label_start:\n        if current_page_label:\n            if label_style is None:\n                label_style = current_page_label.get_style()\n            if label_prefix is None:\n                label_prefix = current_page_label.get_prefix()\n            if label_start is None and not (\n                self.toc_placeholder and self.toc_placeholder.reset_page_indices\n            ):\n                label_start = current_page_label.get_start()\n        label_style = (\n            PageLabelStyle.coerce(label_style, case_sensitive=True)\n            if label_style\n            else None\n        )\n        new_page_label = PDFPageLabel(label_style, label_prefix, label_start)\n    self.pages[self.page].set_page_label(current_page_label, new_page_label)",
      "language": "python"
    },
    {
      "code": "def set_producer(self, producer: str) -> None:\n    \"\"\"Producer of document\"\"\"\n    self.producer = producer",
      "language": "python"
    },
    {
      "code": "def set_right_margin(self, margin: float) -> None:\n    \"\"\"\n    Sets the document right margin.\n\n    Args:\n        margin (float): margin in the unit specified to FPDF constructor\n    \"\"\"\n    self.r_margin = margin",
      "language": "python"
    },
    {
      "code": "def set_section_title_styles(\n    self,\n    level0: TextStyle,\n    level1: Optional[TextStyle] = None,\n    level2: Optional[TextStyle] = None,\n    level3: Optional[TextStyle] = None,\n    level4: Optional[TextStyle] = None,\n    level5: Optional[TextStyle] = None,\n    level6: Optional[TextStyle] = None,\n) -> None:\n    \"\"\"\n    Defines a style for section titles.\n    After calling this method, calls to `FPDF.start_section` will render section names visually.\n\n    Args:\n        level0 (TextStyle): style for the top level section titles\n        level1 (TextStyle): optional style for the level 1 section titles\n        level2 (TextStyle): optional style for the level 2 section titles\n        level3 (TextStyle): optional style for the level 3 section titles\n        level4 (TextStyle): optional style for the level 4 section titles\n        level5 (TextStyle): optional style for the level 5 section titles\n        level6 (TextStyle): optional style for the level 6 section titles\n    \"\"\"\n    index: int\n    level: Optional[TextStyle]\n    for index, level in enumerate(\n        [level0, level1, level2, level3, level4, level5, level6]\n    ):\n        if level is not None:\n            if not isinstance(level, TextStyle):\n                raise TypeError(\n                    f\"Arguments must all be TextStyle instances, got: {type(level)}\"\n                )\n            self.section_title_styles[index] = level",
      "language": "python"
    },
    {
      "code": "def set_stretching(self, stretching: float) -> None:\n    \"\"\"\n    Sets horizontal font stretching.\n    By default, no stretching is set (which is equivalent to a value of 100).\n\n    Args:\n        stretching (float): horizontal stretching (scaling) in percents.\n    \"\"\"\n    if self.font_stretching == stretching:\n        return\n    self.font_stretching = stretching\n    if self.page > 0:\n        self._out(f\"BT {stretching:.2f} Tz ET\")",
      "language": "python"
    },
    {
      "code": "def set_subject(self, subject: str) -> None:\n    \"\"\"\n    Defines the subject of the document.\n\n    Args:\n        subject (str): the document main subject\n    \"\"\"\n    self.subject = subject",
      "language": "python"
    },
    {
      "code": "def set_text_color(\n    self,\n    r: (\n        Number\n        | Color\n        | str\n        | Sequence[Number]\n        | DeviceCMYK\n        | DeviceGray\n        | DeviceRGB\n    ),\n    g: Number = -1,\n    b: Number = -1,\n) -> None:\n    \"\"\"\n    Defines the color used for text.\n    Accepts either a single greyscale value, 3 values as RGB components, a single `#abc` or `#abcdef` hexadecimal color string,\n    or an instance of `fpdf.drawing.DeviceCMYK`, `fpdf.drawing.DeviceRGB` or `fpdf.drawing.DeviceGray`.\n    The method can be called before the first page is created and the value is retained from page to page.\n\n    Args:\n        r (int, tuple, fpdf.drawing.DeviceGray, fpdf.drawing.DeviceRGB): if `g` and `b` are given, this indicates the red component.\n            Else, this indicates the grey level. The value must be between 0 and 255.\n        g (int): green component (between 0 and 255)\n        b (int): blue component (between 0 and 255)\n    \"\"\"\n    self.text_color = convert_to_device_color(r, g, b)",
      "language": "python"
    },
    {
      "code": "def set_text_shaping(\n    self,\n    use_shaping_engine: bool = True,\n    features: Optional[dict[str, Any]] = None,\n    direction: Optional[str | TextDirection] = None,\n    script: Optional[str] = None,\n    language: Optional[str] = None,\n) -> None:\n    \"\"\"\n    Enable or disable text shaping engine when rendering text.\n    If features, direction, script or language are not specified the shaping engine will try\n    to guess the values based on the input text.\n\n    Args:\n        use_shaping_engine: enable or disable the use of the shaping engine to process the text\n        features: a dictionary containing 4 digit OpenType features and whether each feature\n            should be enabled or disabled\n            example: features={\"kern\": False, \"liga\": False}\n        direction: the direction the text should be rendered, either \"ltr\" (left to right)\n            or \"rtl\" (right to left).\n        script: a valid OpenType script tag like \"arab\" or \"latn\"\n        language: a valid OpenType language tag like \"eng\" or \"fra\"\n    \"\"\"\n    if not use_shaping_engine:\n        self.text_shaping = None\n        return\n\n    try:\n        # pylint: disable=import-outside-toplevel, unused-import\n        import uharfbuzz  # pyright: ignore[reportUnusedImport]\n    except ImportError as exc:\n        raise FPDFException(\n            \"The uharfbuzz package could not be imported, but is required for text shaping. Try: pip install uharfbuzz\"\n        ) from exc\n\n    #\n    # Features must be a dictionary containing opentype features and a boolean flag\n    # stating whether the feature should be enabled or disabled.\n    #\n    # e.g. features={\"liga\": True, \"kern\": False}\n    #\n    # https://harfbuzz.github.io/shaping-opentype-features.html\n    #\n\n    if features and not isinstance(features, dict):\n        raise FPDFException(\n            \"Features must be a dictionary. See text shaping documentation\"\n        )\n    if not features:\n        features = {}\n\n    # Buffer properties (direction, script and language)\n    # if the properties are not provided, Harfbuzz \"guessing\" logic is used.\n    # https://harfbuzz.github.io/setting-buffer-properties.html\n    # Valid harfbuzz directions are ltr (left to right), rtl (right to left),\n    # ttb (top to bottom) or btt (bottom to top)\n\n    text_direction = None\n    if direction:\n        text_direction = (\n            direction\n            if isinstance(direction, TextDirection)\n            else TextDirection.coerce(direction)\n        )\n        if text_direction not in [TextDirection.LTR, TextDirection.RTL]:\n            raise FPDFException(\n                \"FPDF2 only accept ltr (left to right) or rtl (right to left) directions for now.\"\n            )\n\n    self.text_shaping = {\n        \"use_shaping_engine\": True,\n        \"features\": features,\n        \"direction\": text_direction,\n        \"script\": script,\n        \"language\": language,\n        \"fragment_direction\": None,\n        \"paragraph_direction\": None,\n    }",
      "language": "python"
    },
    {
      "code": "def set_title(self, title: str) -> None:\n    \"\"\"\n    Defines the title of the document.\n\n    Most PDF readers will display it when viewing the document.\n    There is also a related `fpdf.prefs.ViewerPreferences` entry:\n\n        pdf.viewer_preferences = ViewerPreferences(display_doc_title=True)\n\n    Args:\n        title (str): the title\n    \"\"\"\n    self.title = title",
      "language": "python"
    },
    {
      "code": "pdf.viewer_preferences = ViewerPreferences(display_doc_title=True)",
      "language": "unknown"
    },
    {
      "code": "def set_top_margin(self, margin: float) -> None:\n    \"\"\"\n    Sets the document top margin.\n\n    Args:\n        margin (float): margin in the unit specified to FPDF constructor\n    \"\"\"\n    self.t_margin = margin",
      "language": "python"
    },
    {
      "code": "def set_x(self, x: float) -> None:\n    \"\"\"\n    Defines the abscissa of the current position.\n    If the value provided is negative, it is relative to the right of the page.\n\n    Args:\n        x (float): the new current abscissa\n    \"\"\"\n    self.x = x if x >= 0 else self.w + x",
      "language": "python"
    },
    {
      "code": "def set_xmp_metadata(self, xmp_metadata: str) -> None:\n    if \"<?xpacket\" in xmp_metadata[:50]:\n        raise ValueError(\n            \"fpdf2 already performs XMP metadata wrapping in a <?xpacket> tag\"\n        )\n    self.xmp_metadata = xmp_metadata\n    if xmp_metadata:\n        self._set_min_pdf_version(\"1.4\")",
      "language": "python"
    },
    {
      "code": "def set_xy(self, x: float, y: float) -> None:\n    \"\"\"\n    Defines the abscissa and ordinate of the current position.\n    If the values provided are negative, they are relative respectively to the right and bottom of the page.\n\n    Args:\n        x (float): the new current abscissa\n        y (float): the new current ordinate\n    \"\"\"\n    self.set_y(y)\n    self.set_x(x)",
      "language": "python"
    },
    {
      "code": "def set_y(self, y: float) -> None:\n    \"\"\"\n    Moves the current abscissa back to the left margin and sets the ordinate.\n    If the value provided is negative, it is relative to the bottom of the page.\n\n    Args:\n        y (float): the new current ordinate\n    \"\"\"\n    self.x = self.l_margin\n    self.y = y if y >= 0 else self.h + y",
      "language": "python"
    },
    {
      "code": "@check_page\ndef sign(\n    self,\n    key: Optional[\"PrivateKeyTypes\"],\n    cert: \"Certificate\",\n    extra_certs: Optional[list[\"Certificate\"]] = None,\n    hashalgo: str = \"sha256\",\n    contact_info: Optional[str] = None,\n    location: Optional[str] = None,\n    signing_time: Optional[datetime] = None,\n    reason: Optional[str] = None,\n    flags: tuple[AnnotationFlag | str, ...] = (\n        AnnotationFlag.PRINT,\n        AnnotationFlag.LOCKED,\n    ),\n) -> None:\n    \"\"\"\n    Args:\n        key: certificate private key\n        cert (cryptography.x509.Certificate): certificate\n        extra_certs (list[cryptography.x509.Certificate]): list of additional PKCS12 certificates\n        hashalgo (str): hashing algorithm used, passed to `hashlib.new`\n        contact_info (str): optional information provided by the signer to enable\n            a recipient to contact the signer to verify the signature\n        location (str): optional CPU host name or physical location of the signing\n        signing_time (datetime): optional time of signing\n        reason (str): optional signing reason\n        flags (Tuple[fpdf.enums.AnnotationFlag], Tuple[str]): optional list of flags defining annotation properties\n    \"\"\"\n    if not signer:\n        raise EnvironmentError(\n            \"endesive.signer not available - PDF cannot be signed - Try: pip install endesive\"\n        )\n    if self._sign_key:\n        raise FPDFException(\".sign* methods should be called only once\")\n\n    self._sign_key = key\n    self._sign_cert = cert\n    self._sign_extra_certs = extra_certs if extra_certs is not None else []\n    self._sign_hashalgo = hashalgo\n    self._sign_time: datetime = signing_time or self.creation_date\n\n    annotation = PDFAnnotation(\n        \"Widget\",\n        field_type=\"Sig\",\n        x=0,\n        y=0,\n        width=0,\n        height=0,\n        flags=flags,\n        title=\"signature\",\n        value=Signature(\n            contact_info=contact_info,\n            location=location,\n            m=PDFDate(self._sign_time),\n            reason=reason,\n        ),\n    )\n    self.pages[self.page].add_annotation(annotation)",
      "language": "python"
    },
    {
      "code": "def sign_pkcs12(\n    self,\n    pkcs_filepath: str | Path,\n    password: Optional[bytes] = None,\n    hashalgo: str = \"sha256\",\n    contact_info: Optional[str] = None,\n    location: Optional[str] = None,\n    signing_time: Optional[datetime] = None,\n    reason: Optional[str] = None,\n    flags: tuple[AnnotationFlag | str, ...] = (\n        AnnotationFlag.PRINT,\n        AnnotationFlag.LOCKED,\n    ),\n) -> None:\n    \"\"\"\n    Args:\n        pkcs_filepath (str): file path to a .pfx or .p12 PKCS12,\n            in the binary format described by RFC 7292\n        password (bytes-like): the password to use to decrypt the data.\n            `None` if the PKCS12 is not encrypted.\n        hashalgo (str): hashing algorithm used, passed to `hashlib.new`\n        contact_info (str): optional information provided by the signer to enable\n            a recipient to contact the signer to verify the signature\n        location (str): optional CPU host name or physical location of the signing\n        signing_time (datetime): optional time of signing\n        reason (str): optional signing reason\n        flags (Tuple[fpdf.enums.AnnotationFlag], Tuple[str]): optional list of flags defining annotation properties\n    \"\"\"\n    if not signer:\n        raise EnvironmentError(\n            \"endesive.signer not available - PDF cannot be signed - Try: pip install endesive\"\n        )\n    with open(pkcs_filepath, \"rb\") as pkcs_file:\n        key, cert, extra_certs = (\n            pkcs12.load_key_and_certificates(  # pyright: ignore[reportOptionalMemberAccess]\n                pkcs_file.read(), password\n            )\n        )\n    assert cert is not None\n    self.sign(\n        key=key,\n        cert=cert,\n        extra_certs=extra_certs,\n        hashalgo=hashalgo,\n        contact_info=contact_info,\n        location=location,\n        signing_time=signing_time,\n        reason=reason,\n        flags=flags,\n    )",
      "language": "python"
    },
    {
      "code": "@check_page\n@contextmanager\ndef skew(\n    self,\n    ax: float = 0,\n    ay: float = 0,\n    x: Optional[float] = None,\n    y: Optional[float] = None,\n) -> Iterator[None]:\n    \"\"\"\n    Method to perform a skew transformation originating from a given center.\n    It must be used as a context-manager using `with`:\n\n        with skew(ax=15, ay=15, x=x, y=y):\n            pdf.something()\n\n    The skew transformation affects all elements which are printed inside the indented\n    context (with the exception of clickable areas).\n\n    Args:\n        ax (float): angle of skew in the horizontal direction in degrees\n        ay (float): angle of skew in the vertical direction in degrees\n        x (float): abscissa of the center of the skew transformation\n        y (float): ordinate of the center of the skew transformation\n    \"\"\"\n    lim_val = 2**32\n    if x is None:\n        x = self.x\n    if y is None:\n        y = self.y\n    ax = max(min(math.tan(ax * (math.pi / 180)), lim_val), -lim_val)\n    ay = max(min(math.tan(ay * (math.pi / 180)), lim_val), -lim_val)\n    cx, cy = x * self.k, (self.h - y) * self.k\n    with self.local_context():\n        self._out(\n            f\"1 {ay:.5f} {ax:.5f} 1 {cx:.2f} {cy:.2f} cm \"\n            f\"1 0 0 1 -{cx:.2f} -{cy:.2f} cm\"\n        )\n        yield",
      "language": "python"
    },
    {
      "code": "with skew(ax=15, ay=15, x=x, y=y):\n    pdf.something()",
      "language": "unknown"
    },
    {
      "code": "def solid_arc(\n    self,\n    x: float,\n    y: float,\n    a: float,\n    start_angle: float,\n    end_angle: float,\n    b: Optional[float] = None,\n    inclination: float = 0,\n    clockwise: bool = False,\n    style: Optional[RenderStyle | str] = None,\n) -> None:\n    \"\"\"\n    Outputs a solid arc. A solid arc combines an arc and a triangle to form a pie slice\n    It can be drawn (border only), filled (with no border) or both.\n\n    Args:\n        x (float): Abscissa of upper-left bounding box.\n        y (float): Ordinate of upper-left bounding box.\n        a (float): Semi-major axis.\n        b (float): Semi-minor axis, if None, equals to a (default: None).\n        start_angle (float): Start angle of the arc (in degrees).\n        end_angle (float): End angle of the arc (in degrees).\n        inclination (float): Inclination of the arc in respect of the x-axis (default: 0).\n        clockwise (bool): Way of drawing the arc (True: clockwise, False: counterclockwise) (default: False).\n        style (str): Style of rendering. Possible values are:\n\n        * `D` or None: draw border. This is the default value.\n        * `F`: fill\n        * `DF` or `FD`: draw and fill\n    \"\"\"\n    self.arc(\n        x,\n        y,\n        a,\n        start_angle,\n        end_angle,\n        b,\n        inclination,\n        clockwise,\n        True,\n        True,\n        style,\n    )",
      "language": "python"
    },
    {
      "code": "@check_page\ndef star(\n    self,\n    x: float,\n    y: float,\n    r_in: float,\n    r_out: float,\n    corners: int,\n    rotate_degrees: float = 0,\n    style: Optional[RenderStyle | str] = None,\n) -> None:\n    \"\"\"\n    Outputs a regular star with n corners.\n    It can be rotated.\n    It can be drawn (border only), filled (with no border) or both.\n\n    Args:\n        x (float): Abscissa of star's centre.\n        y (float): Ordinate of star's centre.\n        r_in (float): radius of internal circle.\n        r_out (float): radius of external circle.\n        corners (int): number of star's corners.\n        rotate_degrees (float): Optional degree amount to rotate star clockwise.\n\n        style (fpdf.enums.RenderStyle, str): Optional style of rendering. Possible values are:\n        * `D`: draw border. This is the default value.\n        * `F`: fill.\n        * `DF` or `FD`: draw and fill.\n    \"\"\"\n    th = math.radians(rotate_degrees)\n    point_list: list[tuple[float, float]] = []\n    for i in range(0, (corners * 2) + 1):\n        corner_x = x + (r_out if i % 2 == 0 else r_in) * math.sin(th)\n        corner_y = y + (r_out if i % 2 == 0 else r_in) * math.cos(th)\n        point_list.append((corner_x, corner_y))\n\n        th += math.radians(180 / corners)\n\n    self.polyline(point_list, polygon=True, style=style)",
      "language": "python"
    },
    {
      "code": "@check_page\ndef start_section(self, name: str, level: int = 0, strict: bool = True) -> None:\n    \"\"\"\n    Start a section in the document outline.\n    If section_title_styles have been configured,\n    render the section name visually as a title.\n\n    Args:\n        name (str): section name\n        level (int): section level in the document outline. 0 means top-level.\n        strict (bool): whether to raise an exception if levels increase incorrectly,\n            for example with a level-3 section following a level-1 section.\n    \"\"\"\n    if level < 0:\n        raise ValueError('\"level\" mut be equal or greater than zero')\n    if strict and self._outline and level > self._outline[-1].level + 1:\n        raise ValueError(\n            f\"Incoherent hierarchy: cannot start a level {level} section after a level {self._outline[-1].level} one\"\n        )\n    dest = DestinationXYZ(self.page, top=self.h_pt - self.y * self.k)\n    outline_struct_elem = None\n    if self.section_title_styles:\n        text_style = self.section_title_styles[level]\n        # We first check if adding this multi-cell will trigger a page break:\n        if text_style.size_pt is not None:\n            prev_font_size_pt = self.font_size_pt\n            self.font_size_pt = text_style.size_pt\n        # check if l_margin value is of type Align or string\n        align = Align.L\n        if isinstance(text_style.l_margin, (Align, str)):\n            align = Align.coerce(text_style.l_margin)\n        page_break_triggered = self.multi_cell(\n            w=self.epw,\n            h=self.font_size,\n            text=name,\n            new_x=XPos.LMARGIN,\n            new_y=YPos.NEXT,\n            dry_run=True,  # => does not produce any output\n            output=MethodReturnValue.PAGE_BREAK,\n            align=align,\n            padding=Padding(\n                top=text_style.t_margin or 0,\n                left=(\n                    text_style.l_margin\n                    if isinstance(text_style.l_margin, (int, float))\n                    else 0\n                ),\n                bottom=text_style.b_margin or 0,\n            ),\n        )\n        if text_style.size_pt is not None:\n            self.font_size_pt = (\n                prev_font_size_pt  # pyright: ignore[reportPossiblyUnboundVariable]\n            )\n        if page_break_triggered:\n            # If so, we trigger a page break manually beforehand:\n            self.add_page()\n        with self._marked_sequence(title=name) as struct_elem:\n            outline_struct_elem = struct_elem\n            with self.use_text_style(text_style):\n                self.multi_cell(\n                    w=self.epw,\n                    h=self.font_size,\n                    text=name,\n                    align=align,\n                    new_x=XPos.LMARGIN,\n                    new_y=YPos.NEXT,\n                    center=text_style.l_margin == Align.C,\n                )\n    self._outline.append(\n        OutlineSection(name, level, self.page, dest, outline_struct_elem)\n    )",
      "language": "python"
    },
    {
      "code": "@check_page\n@contextmanager\ndef table(self, *args: Any, **kwargs: Any) -> Iterator[Table]:\n    \"\"\"\n    Inserts a table, that can be built using the `fpdf.table.Table` object yield.\n    Detailed usage documentation: https://py-pdf.github.io/fpdf2/Tables.html\n\n    Args:\n        rows: optional. Sequence of rows (iterable) of str to initiate the table cells with text content.\n        align (str, fpdf.enums.Align): optional, default to CENTER. Sets the table horizontal position\n            relative to the page, when it's not using the full page width.\n        borders_layout (str, fpdf.enums.TableBordersLayout): optional, default to ALL. Control what cell\n            borders are drawn.\n        cell_fill_color (int, tuple, fpdf.drawing.DeviceCMYK, fpdf.drawing.DeviceGray, fpdf.drawing.DeviceRGB): optional.\n            Defines the cells background color.\n        cell_fill_mode (str, fpdf.enums.TableCellFillMode): optional. Defines which cells are filled\n            with color in the background.\n        col_widths (int, tuple): optional. Sets column width. Can be a single number or a sequence of numbers.\n        first_row_as_headings (bool): optional, default to True. If False, the first row of the table\n            is not styled differently from the others.\n        gutter_height (float): optional vertical space between rows.\n        gutter_width (float): optional horizontal space between columns.\n        headings_style (fpdf.fonts.FontFace): optional, default to bold.\n            Defines the visual style of the top headings row: size, color, emphasis...\n        line_height (number): optional. Defines how much vertical space a line of text will occupy.\n        markdown (bool): optional, default to False. Enable markdown interpretation of cells textual content.\n        text_align (str, fpdf.enums.Align): optional, default to JUSTIFY. Control text alignment inside cells.\n        v_align (str, fpdf.enums.VAlign): optional, default to CENTER. Control vertical alignment of cells content.\n        width (number): optional. Sets the table width.\n        wrapmode (fpdf.enums.WrapMode): \"WORD\" for word based line wrapping (default),\n            \"CHAR\" for character based line wrapping.\n        padding (number, tuple, Padding): optional. Sets the cell padding. Can be a single number or a sequence\n            of numbers, default:0\n            If padding for left or right ends up being non-zero then the respective c_margin is ignored.\n        outer_border_width (number): optional. The outer_border_width will trigger rendering of the outer\n            border of the table with the given width regardless of any other defined border styles.\n        num_heading_rows (number): optional. Sets the number of heading rows, default value is 1. If this value is not 1,\n            first_row_as_headings needs to be True if num_heading_rows>1 and False if num_heading_rows=0. For backwards compatibility,\n            first_row_as_headings is used in case num_heading_rows is 1.\n        repeat_headings (fpdf.enums.TableHeadingsDisplay): optional, indicates whether to print table headings on every page, default to 1.\n    \"\"\"\n    table = Table(self, *args, **kwargs)\n    yield table\n    table.render()",
      "language": "python"
    },
    {
      "code": "@check_page\n@support_deprecated_txt_arg\ndef text(self, x: float, y: float, text: str = \"\") -> None:\n    \"\"\"\n    Prints a character string. The origin is on the left of the first character,\n    on the baseline. This method allows placing a string precisely on the page,\n    but it is usually easier to use the `FPDF.cell()`, `FPDF.multi_cell() or `FPDF.write()` methods.\n\n    Args:\n        x (float): abscissa of the origin\n        y (float): ordinate of the origin\n        text (str): string to print\n        txt (str): [**DEPRECATED since v2.7.6**] string to print\n\n    Notes\n    -----\n\n    `text()` lacks many of the features available in `FPDF.write()`,\n    `FPDF.cell()` and `FPDF.multi_cell()` like markdown and text shaping.\n    \"\"\"\n    if not self.font_family:\n        raise FPDFException(\"No font set, you need to call set_font() beforehand\")\n    text = self.normalize_text(text)\n    assert self.current_font is not None\n    if not self.current_font_is_set_on_page:\n        self._out(self._set_font_for_page(self.current_font, self.font_size_pt))\n    sl = [f\"BT {x * self.k:.2f} {(self.h - y) * self.k:.2f} Td\"]\n    if self.text_mode != TextMode.FILL:\n        sl.append(f\" {self.text_mode} Tr {self.line_width:.2f} w\")\n    sl.append(f\"{self.current_font.encode_text(text)} ET\")\n    if (\n        text != \"\" and (self.underline or self.strikethrough)\n    ) or self._record_text_quad_points:\n        w = self.get_string_width(text, normalized=True, markdown=False)\n        if text != \"\":\n            if self.underline:\n                sl.append(self._do_underline(x, y, w))\n            if self.strikethrough:\n                sl.append(self._do_strikethrough(x, y, w))\n        if self._record_text_quad_points:\n            h = self.font_size\n            y -= 0.8 * h  # same coefficient as in _render_styled_text_line()\n            self._add_quad_points(x, y, w, h)\n    attr_l: list[str] = []\n    if self.fill_color != self.text_color:\n        assert self.text_color is not None\n        attr_l.append(f\"{self.text_color.serialize().lower()}\")\n    if attr_l:\n        sl = [\"q\"] + attr_l + sl + [\"Q\"]\n    self._out(\" \".join(sl))",
      "language": "python"
    },
    {
      "code": "@check_page\ndef text_annotation(\n    self,\n    x: float,\n    y: float,\n    text: str,\n    w: float = 1,\n    h: float = 1,\n    name: Optional[AnnotationName | str] = None,\n    **kwargs: Any,\n) -> AnnotationDict:\n    \"\"\"\n    Puts a text annotation on a rectangular area of the page.\n\n    Args:\n        x (float): horizontal position (from the left) to the left side of the link rectangle\n        y (float): vertical position (from the top) to the bottom side of the link rectangle\n        text (str): text to display\n        w (float): optional width of the link rectangle\n        h (float): optional height of the link rectangle\n        name (fpdf.enums.AnnotationName, str): optional icon that shall be used in displaying the annotation\n        flags (Tuple[fpdf.enums.AnnotationFlag], Tuple[str]): optional list of flags defining annotation properties\n        title (str): the text label that shall be displayed in the title bar of the annotation’s\n            pop-up window when open and active. This entry shall identify the user who added the annotation.\n    \"\"\"\n    annotation = AnnotationDict(\n        \"Text\",\n        x * self.k,\n        self.h_pt - y * self.k,\n        w * self.k,\n        h * self.k,\n        contents=text,\n        name=AnnotationName.coerce(name) if name else None,\n        **kwargs,\n    )\n    self.pages[self.page].add_annotation(annotation)\n    return annotation",
      "language": "python"
    },
    {
      "code": "@check_page\ndef text_columns(\n    self,\n    text: Optional[str] = None,\n    img: Optional[str] = None,\n    img_fill_width: bool = False,\n    ncols: int = 1,\n    gutter: Optional[float] = 10,\n    balance: bool = False,\n    text_align: Optional[Align | str] = \"LEFT\",\n    line_height: Optional[float] = 1,\n    l_margin: Optional[float] = None,\n    r_margin: Optional[float] = None,\n    print_sh: Optional[bool] = False,\n    wrapmode: Optional[WrapMode] = WrapMode.WORD,\n    skip_leading_spaces: Optional[bool] = False,\n) -> TextColumns:\n    \"\"\"Establish a layout with multiple columns to fill with text.\n    Args:\n        text (str, optional): A first piece of text to insert.\n        ncols (int, optional): the number of columns to create. (Default: 1).\n        gutter (float, optional): The distance between the columns. (Default: 10).\n        balance: (bool, optional): Specify whether multiple columns should end at approximately\n            the same height, if they don't fill the page. (Default: False)\n        text_align (Align or str, optional): The alignment of the text within the region.\n            (Default: \"LEFT\")\n        line_height (float, optional): A multiplier relative to the font size changing the\n            vertical space occupied by a line of text. (Default: 1.0).\n        l_margin (float, optional): Override the current left page margin.\n        r_margin (float, optional): Override the current right page margin.\n        print_sh (bool, optional): Treat a soft-hyphen (\\\\u00ad) as a printable character,\n            instead of a line breaking opportunity. (Default: False)\n        wrapmode (fpdf.enums.WrapMode, optional): \"WORD\" for word based line wrapping,\n            \"CHAR\" for character based line wrapping. (Default: \"WORD\")\n        skip_leading_spaces (bool, optional): On each line, any space characters at the\n            beginning will be skipped if True. (Default: False)\n    \"\"\"\n    return TextColumns(\n        self,\n        text=text,\n        img=img,\n        img_fill_width=img_fill_width,\n        ncols=ncols,\n        gutter=gutter or 10,\n        balance=balance,\n        text_align=text_align,\n        line_height=line_height,\n        l_margin=l_margin,\n        r_margin=r_margin,\n        print_sh=print_sh,\n        wrapmode=wrapmode,\n        skip_leading_spaces=skip_leading_spaces,\n    )",
      "language": "python"
    },
    {
      "code": "@contextmanager\ndef unbreakable(self) -> Iterator[FPDFRecorder]:\n    \"\"\"\n    Ensures that all rendering performed in this context appear on a single page\n    by performing page break beforehand if need be.\n\n    Detailed documentation on page breaks: https://py-pdf.github.io/fpdf2/PageBreaks.html\n\n    Notes\n    -----\n\n    Using this method means to duplicate the FPDF `bytearray` buffer:\n    when generating large PDFs, doubling memory usage may be troublesome.\n    \"\"\"\n    prev_page, prev_y = self.page, self.y\n    recorder = FPDFRecorder(self, accept_page_break=False)\n    recorder.page_break_triggered = False\n    self._in_unbreakable = True\n    LOGGER.debug(\"Starting unbreakable block\")\n    yield recorder\n    y_scroll = recorder.y - prev_y + (recorder.page - prev_page) * self.eph\n    if prev_y + y_scroll > self.page_break_trigger or recorder.page > prev_page:\n        LOGGER.debug(\"Performing page jump due to unbreakable height\")\n        recorder.rewind()\n        # pylint: disable=protected-access\n        # Performing this call through .pdf so that it does not get recorded & replayed:\n        recorder.pdf._perform_page_break()\n        recorder.replay()\n        recorder.page_break_triggered = True\n    self._in_unbreakable = False\n    LOGGER.debug(\"Ending unbreakable block\")",
      "language": "python"
    },
    {
      "code": "@contextmanager\ndef use_font_face(self, font_face: FontFace) -> Iterator[None]:\n    \"\"\"\n    Sets the provided `fpdf.fonts.FontFace` in a local context,\n    then restore font settings back to they were initially.\n    This method must be used as a context manager using `with`:\n\n        with pdf.use_font_face(FontFace(emphasis=\"BOLD\", color=255, size_pt=42)):\n            put_some_text()\n\n    Known limitation: in case of a page jump in this local context,\n    the temporary style may \"leak\" in the header() & footer().\n    \"\"\"\n    if not font_face:\n        yield\n        return\n    prev_font = (self.font_family, self.font_style, self.font_size_pt)\n    self.set_font(\n        font_face.family or self.font_family,\n        (\n            font_face.emphasis.style\n            if font_face.emphasis is not None\n            else self.font_style\n        ),\n        font_face.size_pt or self.font_size_pt,\n    )\n    self.current_font_is_set_on_page = False\n    prev_text_color = self.text_color\n    if font_face.color is not None and font_face.color != self.text_color:\n        self.set_text_color(font_face.color)\n    prev_fill_color = self.fill_color\n    if font_face.fill_color is not None:\n        self.set_fill_color(font_face.fill_color)\n    yield\n    if font_face.fill_color is not None:\n        assert prev_fill_color is not None\n        self.set_fill_color(prev_fill_color)\n    self.text_color = prev_text_color\n    self.set_font(*prev_font)",
      "language": "python"
    },
    {
      "code": "with pdf.use_font_face(FontFace(emphasis=\"BOLD\", color=255, size_pt=42)):\n    put_some_text()",
      "language": "unknown"
    },
    {
      "code": "@contextmanager\n@check_page\ndef use_pattern(self, shading: Gradient) -> Iterator[None]:\n    \"\"\"\n    Create a context for using a shading pattern on the current page.\n    \"\"\"\n    self._resource_catalog.add(PDFResourceType.SHADING, shading, self.page)\n    pattern = shading.get_pattern()\n    pattern_name = self._resource_catalog.add(\n        PDFResourceType.PATTERN, pattern, self.page\n    )\n    self._out(f\"/Pattern cs /{pattern_name} scn\")\n    try:\n        yield\n    finally:\n        assert self.draw_color is not None\n        self._out(self.draw_color.serialize().lower())",
      "language": "python"
    },
    {
      "code": "@contextmanager\ndef use_text_style(self, text_style: TextStyle) -> Iterator[None]:\n    prev_l_margin = None\n    if text_style:\n        if text_style.t_margin:\n            self.ln(text_style.t_margin)\n        if text_style.l_margin:\n            if isinstance(text_style.l_margin, (float, int)):\n                prev_l_margin = self.l_margin\n                self.l_margin = text_style.l_margin\n                self.x = self.l_margin\n            else:\n                LOGGER.debug(\n                    \"Unsupported '%s' value provided as l_margin to .use_text_style()\",\n                    text_style.l_margin,\n                )\n    with self.use_font_face(text_style):\n        yield\n    if text_style and text_style.b_margin:\n        self.ln(text_style.b_margin)\n    if prev_l_margin is not None:\n        self.l_margin = prev_l_margin\n        self.x = self.l_margin",
      "language": "python"
    },
    {
      "code": "def will_page_break(self, height: float) -> bool:\n    \"\"\"\n    Let you know if adding an element will trigger a page break,\n    based on its height and the current ordinate (`y` position).\n\n    Detailed documentation on page breaks: https://py-pdf.github.io/fpdf2/PageBreaks.html\n\n    Args:\n        height (float): height of the section that would be added, e.g. a cell\n\n    Returns: a boolean indicating if a page break would occur\n    \"\"\"\n    return (\n        self.y + height > self.page_break_trigger\n        and not self.in_footer\n        and self.accept_page_break\n    )",
      "language": "python"
    },
    {
      "code": "@check_page\n@support_deprecated_txt_arg\ndef write(\n    self,\n    h: Optional[float] = None,\n    text: str = \"\",\n    link: Optional[str | int] = \"\",\n    print_sh: bool = False,\n    wrapmode: WrapMode = WrapMode.WORD,\n) -> bool:\n    \"\"\"\n    Prints text from the current position.\n    When the right margin is reached, a line break occurs at the most recent\n    space or soft-hyphen character, and text continues from the left margin.\n    A manual break happens any time the \\\\n character is met,\n    Upon method exit, the current position is left just at the end of the text.\n\n    Args:\n        h (float): line height. Default value: None, meaning to use the current font size.\n        text (str): text content\n        link (str): optional link to add on the text, internal\n            (identifier returned by `FPDF.add_link`) or external URL.\n        print_sh (bool): Treat a soft-hyphen (\\\\u00ad) as a normal printable\n            character, instead of a line breaking opportunity. Default value: False\n        wrapmode (fpdf.enums.WrapMode): \"WORD\" for word based line wrapping (default),\n            \"CHAR\" for character based line wrapping.\n        txt (str): [**DEPRECATED since v2.7.6**] text content\n    \"\"\"\n    wrapmode = WrapMode.coerce(wrapmode)\n    if not self.font_family:\n        raise FPDFException(\"No font set, you need to call set_font() beforehand\")\n    if isinstance(h, str):\n        raise ValueError(\n            \"Parameter 'h' must be a number, not a string.\"\n            \" You can omit it by passing string content with text=\"\n        )\n    if h is None:\n        h = self.font_size\n\n    page_break_triggered = False\n    normalized_string = self.normalize_text(text).replace(\"\\r\", \"\")\n    styled_text_fragments = (\n        self._preload_bidirectional_text(normalized_string, False)\n        if self.text_shaping\n        else self._preload_font_styles(normalized_string, False)\n    )\n\n    text_lines: list[TextLine] = []\n    multi_line_break = MultiLineBreak(\n        styled_text_fragments,\n        lambda _height: max_width,  # pyright: ignore[reportUnknownLambdaType]\n        (self.c_margin, self.c_margin),\n        print_sh=print_sh,\n        wrapmode=wrapmode,\n    )\n    # first line from current x position to right margin\n    first_width = self.w - self.x - self.r_margin\n    max_width = first_width\n    text_line = multi_line_break.get_line()\n    # remaining lines fill between margins\n    full_width = self.w - self.l_margin - self.r_margin\n    max_width = full_width\n    while (text_line) is not None:\n        text_lines.append(text_line)\n        text_line = multi_line_break.get_line()\n    if not text_lines:\n        return False\n\n    for text_line_index, text_line in enumerate(text_lines):\n        if text_line_index > 0:\n            self.ln()\n        new_page = self._render_styled_text_line(\n            text_line,\n            h=h,\n            border=0,\n            new_x=XPos.WCONT,\n            new_y=YPos.TOP,\n            fill=False,\n            link=link,\n        )\n        page_break_triggered = page_break_triggered or new_page\n    if text_line is not None and text_line.trailing_nl:\n        # The line renderer can't handle trailing newlines in the text.\n        self.ln()\n    return page_break_triggered",
      "language": "python"
    },
    {
      "code": "def write_html(self, text: str, *args: Any, **kwargs: Any) -> None:\n    \"\"\"\n    Parse HTML and convert it to PDF.\n    cf. https://py-pdf.github.io/fpdf2/HTML.html\n\n    Args:\n        text (str): HTML content to render\n        image_map (function): an optional one-argument function that map `<img>` \"src\" to new image URLs\n        li_tag_indent (int): [**DEPRECATED since v2.7.9**]\n            numeric indentation of `<li>` elements - Set `tag_styles` instead\n        dd_tag_indent (int): [**DEPRECATED since v2.7.9**]\n            numeric indentation of `<dd>` elements - Set `tag_styles` instead\n        table_line_separators (bool): enable horizontal line separators in `<table>`. Defaults to `False`.\n        ul_bullet_char (str): bullet character preceding `<li>` items in `<ul>` lists.\n            Can also be configured using the HTML `type` attribute of `<ul>` tags.\n        li_prefix_color (tuple, str, fpdf.drawing.DeviceCMYK, fpdf.drawing.DeviceGray, fpdf.drawing.DeviceRGB): color for bullets\n            or numbers preceding `<li>` tags. This applies to both `<ul>` & `<ol>` lists.\n        heading_sizes (dict): [**DEPRECATED since v2.7.9**]\n            font size per heading level names (\"h1\", \"h2\"...) - Set `tag_styles` instead\n        pre_code_font (str): [**DEPRECATED since v2.7.9**]\n            font to use for `<pre>` & `<code>` blocks - Set `tag_styles` instead\n        warn_on_tags_not_matching (bool): control warnings production for unmatched HTML tags. Defaults to `True`.\n        tag_indents (dict): [**DEPRECATED since v2.8.0**]\n            mapping of HTML tag names to numeric values representing their horizontal left indentation. - Set `tag_styles` instead\n        tag_styles (dict[str, fpdf.fonts.TextStyle]): mapping of HTML tag names to `fpdf.fonts.TextStyle` or `fpdf.fonts.FontFace` instances\n    \"\"\"\n    html2pdf = self.HTML2FPDF_CLASS(self, *args, **kwargs)\n    with self.local_context():\n        html2pdf.feed(text)",
      "language": "python"
    },
    {
      "code": "def x_by_align(\n    self,\n    x: Align | str,\n    w: float,\n    h: float,\n    img_info: RasterImageInfo | VectorImageInfo,\n    keep_aspect_ratio: bool,\n) -> float:\n    if keep_aspect_ratio:\n        _, _, w, h = img_info.scale_inside_box(0, 0, w, h)\n    x = Align.coerce(x)\n    if x == Align.C:\n        return (self.w - w) / 2\n    if x == Align.R:\n        return self.w - w - self.r_margin\n    if x == Align.L:\n        return self.l_margin\n    raise ValueError(f\"Unsupported 'x' value passed to .image(): {x}\")",
      "language": "python"
    },
    {
      "code": "class ImageInfo(dict[str, object]):\n    \"\"\"Information about an image used in the PDF document (base class).\n    We subclass this to distinguish between raster and vector images.\"\"\"\n\n    @property\n    def width(self) -> float:\n        \"Intrinsic image width\"\n        return cast(float, self[\"w\"])\n\n    @property\n    def height(self) -> float:\n        \"Intrinsic image height\"\n        return cast(float, self[\"h\"])\n\n    @property\n    def rendered_width(self) -> float:\n        \"Only available if the image has been placed on the document\"\n        return cast(float, self[\"rendered_width\"])\n\n    @property\n    def rendered_height(self) -> float:\n        \"Only available if the image has been placed on the document\"\n        return cast(float, self[\"rendered_height\"])\n\n    def __str__(self) -> str:\n        d = {\n            k: (\"...\" if k in (\"data\", \"iccp\", \"smask\") else v) for k, v in self.items()\n        }\n        return f\"self.__class__.__name__({d})\"\n\n    def scale_inside_box(\n        self, x: float, y: float, w: float, h: float\n    ) -> tuple[float, float, float, float]:\n        \"\"\"\n        Make an image fit within a bounding box, maintaining its proportions.\n        In the reduced dimension it will be centered within the available space.\n        \"\"\"\n        img_w: float = self[\"w\"]  # type: ignore\n        img_h: float = self[\"h\"]  # type: ignore\n        ratio = img_w / img_h\n        if h * ratio < w:\n            new_w = h * ratio\n            new_h = h\n            x += (w - new_w) / 2\n        else:  # => too wide, limiting width:\n            new_h = w / ratio\n            new_w = w\n            y += (h - new_h) / 2\n        return x, y, new_w, new_h",
      "language": "python"
    },
    {
      "code": "@property\ndef height(self) -> float:\n    \"Intrinsic image height\"\n    return cast(float, self[\"h\"])",
      "language": "python"
    },
    {
      "code": "@property\ndef rendered_height(self) -> float:\n    \"Only available if the image has been placed on the document\"\n    return cast(float, self[\"rendered_height\"])",
      "language": "python"
    },
    {
      "code": "@property\ndef rendered_width(self) -> float:\n    \"Only available if the image has been placed on the document\"\n    return cast(float, self[\"rendered_width\"])",
      "language": "python"
    },
    {
      "code": "@property\ndef width(self) -> float:\n    \"Intrinsic image width\"\n    return cast(float, self[\"w\"])",
      "language": "python"
    },
    {
      "code": "def scale_inside_box(\n    self, x: float, y: float, w: float, h: float\n) -> tuple[float, float, float, float]:\n    \"\"\"\n    Make an image fit within a bounding box, maintaining its proportions.\n    In the reduced dimension it will be centered within the available space.\n    \"\"\"\n    img_w: float = self[\"w\"]  # type: ignore\n    img_h: float = self[\"h\"]  # type: ignore\n    ratio = img_w / img_h\n    if h * ratio < w:\n        new_w = h * ratio\n        new_h = h\n        x += (w - new_w) / 2\n    else:  # => too wide, limiting width:\n        new_h = w / ratio\n        new_w = w\n        y += (h - new_h) / 2\n    return x, y, new_w, new_h",
      "language": "python"
    },
    {
      "code": "class RasterImageInfo(ImageInfo):\n    \"Information about a raster image used in the PDF document\"\n\n    def size_in_document_units(\n        self, w: float, h: float, scale: float = 1\n    ) -> tuple[float, float]:\n        img_w: float = self[\"w\"]  # type: ignore\n        img_h: float = self[\"h\"]  # type: ignore\n        if w == 0 and h == 0:  # Put image at 72 dpi\n            w = img_w / scale\n            h = img_h / scale\n        elif w == 0:\n            w = h * img_w / img_h\n        elif h == 0:\n            h = w * img_h / img_w\n        return w, h",
      "language": "python"
    },
    {
      "code": "def size_in_document_units(\n    self, w: float, h: float, scale: float = 1\n) -> tuple[float, float]:\n    img_w: float = self[\"w\"]  # type: ignore\n    img_h: float = self[\"h\"]  # type: ignore\n    if w == 0 and h == 0:  # Put image at 72 dpi\n        w = img_w / scale\n        h = img_h / scale\n    elif w == 0:\n        w = h * img_w / img_h\n    elif h == 0:\n        h = w * img_h / img_w\n    return w, h",
      "language": "python"
    },
    {
      "code": "class TextMode(CoerciveIntEnum):\n    \"Values described in PDF spec section 'Text Rendering Mode'\"\n\n    FILL = 0\n    STROKE = 1\n    FILL_STROKE = 2\n    INVISIBLE = 3\n    FILL_CLIP = 4\n    STROKE_CLIP = 5\n    FILL_STROKE_CLIP = 6\n    CLIP = 7",
      "language": "python"
    },
    {
      "code": "class TitleStyle(TextStyle):\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        warnings.warn(\n            (\n                \"fpdf.TitleStyle is deprecated since 2.8.0.\"\n                \" It has been replaced by fpdf.TextStyle.\"\n            ),\n            DeprecationWarning,\n            stacklevel=get_stack_level(),\n        )\n        super().__init__(*args, **kwargs)",
      "language": "python"
    },
    {
      "code": "class VectorImageInfo(ImageInfo):\n    \"Information about a vector image used in the PDF document\"\n\n    # pass",
      "language": "python"
    },
    {
      "code": "class XPos(CoerciveEnum):\n    \"Positional values in horizontal direction for use after printing text.\"\n\n    LEFT = intern(\"LEFT\")  # self.x\n    \"left end of the cell\"\n\n    RIGHT = intern(\"RIGHT\")  # self.x + w\n    \"right end of the cell (default)\"\n\n    START = intern(\"START\")\n    \"left start of actual text\"\n\n    END = intern(\"END\")\n    \"right end of actual text\"\n\n    WCONT = intern(\"WCONT\")\n    \"for write() to continue next (slightly left of END)\"\n\n    CENTER = intern(\"CENTER\")\n    \"center of actual text\"\n\n    LMARGIN = intern(\"LMARGIN\")  # self.l_margin\n    \"left page margin (start of printable area)\"\n\n    RMARGIN = intern(\"RMARGIN\")  # self.w - self.r_margin\n    \"right page margin (end of printable area)\"",
      "language": "python"
    },
    {
      "code": "class YPos(CoerciveEnum):\n    \"Positional values in vertical direction for use after printing text\"\n\n    TOP = intern(\"TOP\")  # self.y\n    \"top of the first line (default)\"\n\n    LAST = intern(\"LAST\")\n    \"top of the last line (same as TOP for single-line text)\"\n\n    NEXT = intern(\"NEXT\")  # LAST + h\n    \"top of next line (bottom of current text)\"\n\n    TMARGIN = intern(\"TMARGIN\")  # self.t_margin\n    \"top page margin (start of printable area)\"\n\n    BMARGIN = intern(\"BMARGIN\")  # self.h - self.b_margin\n    \"bottom page margin (end of printable area)\"",
      "language": "python"
    }
  ],
  "patterns": [
    {
      "description": "Enable or disable text shaping engine when rendering text. If features, direction, script or language are not specified the shaping engine will try to guess the values based on the input text. Args use_shaping_engine enable or disable the use of the shaping engine to process the text features a dictionary containing 4 digit OpenType features and whether each feature should be enabled or disabled example: features={\"kern\": False, \"liga\": False} direction the direction the text should be rendered, either \"ltr\" (left to right) or \"rtl\" (right to left). script a valid OpenType script tag like \"arab\" or \"latn\" language a valid OpenType language tag like \"eng\" or \"fra\"",
      "code": "use_shaping_engine"
    }
  ],
  "links": [
    "https://py-pdf.github.io/fpdf2/fpdf/fpdf.html",
    "https://py-pdf.github.io/fpdf2/fpdf/enums.html",
    "https://py-pdf.github.io/fpdf2/fpdf/graphics_state.html",
    "https://py-pdf.github.io/fpdf2/fpdf/text_region.html",
    "https://py-pdf.github.io/fpdf2/PageBreaks.html",
    "https://py-pdf.github.io/fpdf2/TextStyling.html",
    "https://py-pdf.github.io/fpdf2/fpdf/fonts.html",
    "https://py-pdf.github.io/fpdf2/fpdf/output.html",
    "https://py-pdf.github.io/fpdf2/fpdf/actions.html",
    "https://py-pdf.github.io/fpdf2/fpdf/annotations.html",
    "https://py-pdf.github.io/fpdf2/fpdf/transitions.html",
    "https://py-pdf.github.io/fpdf2/fpdf/drawing.html",
    "https://py-pdf.github.io/fpdf2/fpdf/image_datastructures.html",
    "https://py-pdf.github.io/fpdf2/fpdf/outline.html",
    "https://py-pdf.github.io/fpdf2/fpdf/util.html",
    "https://py-pdf.github.io/fpdf2/fpdf/recorder.html",
    "https://py-pdf.github.io/fpdf2/fpdf/close.md",
    "https://py-pdf.github.io/fpdf2/fpdf/svg.html",
    "https://py-pdf.github.io/fpdf2/fpdf/image_parsing.html",
    "https://py-pdf.github.io/fpdf2/Unicode.html",
    "https://py-pdf.github.io/fpdf2/fpdf/syntax.html",
    "https://py-pdf.github.io/fpdf2/fpdf/drawing_primitives.html",
    "https://py-pdf.github.io/fpdf2/fpdf/prefs.html",
    "https://py-pdf.github.io/fpdf2/fpdf/table.html",
    "https://py-pdf.github.io/fpdf2/Tables.html",
    "https://py-pdf.github.io/fpdf2/fpdf/pattern.html",
    "https://py-pdf.github.io/fpdf2/HTML.html",
    "https://py-pdf.github.io/fpdf2/fpdf/index.html"
  ]
}