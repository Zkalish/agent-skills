{
  "url": "https://py-pdf.github.io/fpdf2/fpdf/bidi.html",
  "title": "Module fpdf.bidi",
  "content": "This function applies rules P2 and P3 to detect the direction of a paragraph, retuning the first strong direction and skipping over isolate sequences. P1 must be applied before calling this function (breaking into paragraphs) stop_at_pdi can be set to True to get the direction of a single isolate sequence\n\nUsed for conformance validation\n\nDirectionalStatus(embedding_level: int, directional_override_status: str, directional_isolate_status: bool)\n\nCalculate all the bracket pairs on an isolate run, to be used on rule N0 How to calculate bracket pairs: - Basic definitions 14, 15 and 16: http://www.unicode.org/reports/tr9/#BD14 - BIDI brackets for dummies: https://www.unicode.org/notes/tn39/",
  "headings": [
    {
      "level": "h1",
      "text": "Module fpdf.bidi",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Functions",
      "id": "header-functions"
    },
    {
      "level": "h2",
      "text": "Classes",
      "id": "header-classes"
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Instance variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    }
  ],
  "code_samples": [
    {
      "code": "def auto_detect_base_direction(\n    string: str, stop_at_pdi: bool = False, debug: bool = False\n) -> TextDirection:\n    \"\"\"\n    This function applies rules P2 and P3 to detect the direction of a paragraph, retuning\n    the first strong direction and skipping over isolate sequences.\n    P1 must be applied before calling this function (breaking into paragraphs)\n    stop_at_pdi can be set to True to get the direction of a single isolate sequence\n    \"\"\"\n    # Auto-LTR (standard BIDI) uses the first L/R/AL character, and is LTR if none is found.\n    isolate = 0\n    for char in string:\n        bidi_class = unicodedata.bidirectional(char)\n        if debug and bidi_class.isupper():\n            bidi_class = \"R\"\n        if bidi_class == \"PDI\" and isolate == 0 and stop_at_pdi:\n            return TextDirection.LTR\n        if bidi_class in (\"LRI\", \"RLI\", \"FSI\"):\n            isolate += 1\n        if bidi_class == \"PDI\" and isolate > 0:\n            isolate -= 1\n        if bidi_class in (\"R\", \"AL\") and isolate == 0:\n            return TextDirection.RTL\n        if bidi_class == \"L\" and isolate == 0:\n            return TextDirection.LTR\n    return TextDirection.LTR",
      "language": "python"
    },
    {
      "code": "def calculate_isolate_runs(paragraph: list[BidiCharacter]) -> list[IsolatingRun]:\n    # BD13 and X10\n    class LevelRun(TypedDict):\n        level: int\n        text: list[BidiCharacter]\n        complete: bool\n        sos: str\n        eos: str\n\n    level_run: list[LevelRun] = []\n    lr: list[BidiCharacter] = []\n    lr_embedding_level: int = paragraph[0].embedding_level\n\n    for bidi_char in paragraph:\n        if bidi_char.embedding_level != lr_embedding_level:\n            level_run.append(\n                {\n                    \"level\": lr_embedding_level,\n                    \"text\": lr,\n                    \"complete\": False,\n                    \"sos\": \"\",\n                    \"eos\": \"\",\n                }\n            )\n            lr = []\n            lr_embedding_level = bidi_char.embedding_level\n        lr.append(bidi_char)\n    level_run.append(\n        {\n            \"level\": lr_embedding_level,\n            \"text\": lr,\n            \"complete\": False,\n            \"sos\": \"\",\n            \"eos\": \"\",\n        }\n    )\n\n    def level_to_direction(level: int) -> str:\n        if level % 2 == 0:\n            return \"L\"\n        return \"R\"\n\n    # compute sos, eos for each level run\n    for index, lr1 in enumerate(level_run):\n        if lr1[\"complete\"]:\n            continue\n        if index == 0:\n            sos = level_to_direction(lr1[\"level\"])\n        else:\n            sos = level_to_direction(max(lr1[\"level\"], level_run[index - 1][\"level\"]))\n        if index == len(level_run) - 1:\n            eos = level_to_direction(lr1[\"level\"])\n        else:\n            if lr1[\"text\"][-1].original_bidi_class in (\"LRI\", \"RLI\", \"FSI\"):\n                # X10 - last char is an isolator without matching PDI - set EOS to embedding level\n                eos = level_to_direction(lr1[\"level\"])\n            else:\n                eos = level_to_direction(\n                    max(lr1[\"level\"], level_run[index + 1][\"level\"])\n                )\n        lr1[\"sos\"] = sos\n        lr1[\"eos\"] = eos\n\n    # combine levels runs to create isolate runs\n    isolate_runs: list[IsolatingRun] = []\n    for index, lr2 in enumerate(level_run):\n        if lr2[\"complete\"]:\n            continue\n        sos = lr2[\"sos\"]\n        eos = lr2[\"eos\"]\n        ir_chars = lr2[\"text\"]\n        lr2[\"complete\"] = True\n        if lr2[\"text\"][-1].original_bidi_class in (\"LRI\", \"RLI\", \"FSI\"):\n            for nlr in level_run[index + 1 :]:\n                if (\n                    nlr[\"level\"] == lr2[\"level\"]\n                    and nlr[\"text\"][0].original_bidi_class == \"PDI\"\n                ):\n                    lr2[\"text\"] += nlr[\"text\"]\n                    nlr[\"complete\"] = True\n                    eos = nlr[\"eos\"]\n                    if nlr[\"text\"][-1].original_bidi_class not in (\"LRI\", \"RLI\", \"FSI\"):\n                        break\n        isolate_runs.append(IsolatingRun(characters=ir_chars, sos=sos, eos=eos))\n\n    return isolate_runs",
      "language": "python"
    },
    {
      "code": "class BidiCharacter:\n    __slots__ = [\n        \"character_index\",\n        \"character\",\n        \"bidi_class\",\n        \"original_bidi_class\",\n        \"embedding_level\",\n        \"direction\",\n    ]\n\n    def __init__(\n        self, character_index: int, character: str, embedding_level: int, debug: bool\n    ) -> None:\n        self.character_index = character_index\n        self.character = character\n        if debug and character.isupper():\n            self.bidi_class = \"R\"\n        else:\n            self.bidi_class = unicodedata.bidirectional(character)\n        self.original_bidi_class = self.bidi_class\n        self.embedding_level = embedding_level\n        self.direction = None\n\n    def get_direction_from_level(self) -> str:\n        return \"R\" if self.embedding_level % 2 else \"L\"\n\n    def set_class(self, cls: str) -> None:\n        self.bidi_class = cls\n\n    def __repr__(self) -> str:\n        return (\n            f\"character_index: {self.character_index} character: {self.character}\"\n            + f\" bidi_class: {self.bidi_class} original_bidi_class: {self.original_bidi_class}\"\n            + f\" embedding_level: {self.embedding_level} direction: {self.direction}\"\n        )",
      "language": "python"
    },
    {
      "code": "class BidiCharacter:\n    __slots__ = [\n        \"character_index\",\n        \"character\",\n        \"bidi_class\",\n        \"original_bidi_class\",\n        \"embedding_level\",\n        \"direction\",\n    ]\n\n    def __init__(\n        self, character_index: int, character: str, embedding_level: int, debug: bool\n    ) -> None:\n        self.character_index = character_index\n        self.character = character\n        if debug and character.isupper():\n            self.bidi_class = \"R\"\n        else:\n            self.bidi_class = unicodedata.bidirectional(character)\n        self.original_bidi_class = self.bidi_class\n        self.embedding_level = embedding_level\n        self.direction = None\n\n    def get_direction_from_level(self) -> str:\n        return \"R\" if self.embedding_level % 2 else \"L\"\n\n    def set_class(self, cls: str) -> None:\n        self.bidi_class = cls\n\n    def __repr__(self) -> str:\n        return (\n            f\"character_index: {self.character_index} character: {self.character}\"\n            + f\" bidi_class: {self.bidi_class} original_bidi_class: {self.original_bidi_class}\"\n            + f\" embedding_level: {self.embedding_level} direction: {self.direction}\"\n        )",
      "language": "python"
    },
    {
      "code": "class BidiCharacter:\n    __slots__ = [\n        \"character_index\",\n        \"character\",\n        \"bidi_class\",\n        \"original_bidi_class\",\n        \"embedding_level\",\n        \"direction\",\n    ]\n\n    def __init__(\n        self, character_index: int, character: str, embedding_level: int, debug: bool\n    ) -> None:\n        self.character_index = character_index\n        self.character = character\n        if debug and character.isupper():\n            self.bidi_class = \"R\"\n        else:\n            self.bidi_class = unicodedata.bidirectional(character)\n        self.original_bidi_class = self.bidi_class\n        self.embedding_level = embedding_level\n        self.direction = None\n\n    def get_direction_from_level(self) -> str:\n        return \"R\" if self.embedding_level % 2 else \"L\"\n\n    def set_class(self, cls: str) -> None:\n        self.bidi_class = cls\n\n    def __repr__(self) -> str:\n        return (\n            f\"character_index: {self.character_index} character: {self.character}\"\n            + f\" bidi_class: {self.bidi_class} original_bidi_class: {self.original_bidi_class}\"\n            + f\" embedding_level: {self.embedding_level} direction: {self.direction}\"\n        )",
      "language": "python"
    },
    {
      "code": "class BidiCharacter:\n    __slots__ = [\n        \"character_index\",\n        \"character\",\n        \"bidi_class\",\n        \"original_bidi_class\",\n        \"embedding_level\",\n        \"direction\",\n    ]\n\n    def __init__(\n        self, character_index: int, character: str, embedding_level: int, debug: bool\n    ) -> None:\n        self.character_index = character_index\n        self.character = character\n        if debug and character.isupper():\n            self.bidi_class = \"R\"\n        else:\n            self.bidi_class = unicodedata.bidirectional(character)\n        self.original_bidi_class = self.bidi_class\n        self.embedding_level = embedding_level\n        self.direction = None\n\n    def get_direction_from_level(self) -> str:\n        return \"R\" if self.embedding_level % 2 else \"L\"\n\n    def set_class(self, cls: str) -> None:\n        self.bidi_class = cls\n\n    def __repr__(self) -> str:\n        return (\n            f\"character_index: {self.character_index} character: {self.character}\"\n            + f\" bidi_class: {self.bidi_class} original_bidi_class: {self.original_bidi_class}\"\n            + f\" embedding_level: {self.embedding_level} direction: {self.direction}\"\n        )",
      "language": "python"
    },
    {
      "code": "class BidiCharacter:\n    __slots__ = [\n        \"character_index\",\n        \"character\",\n        \"bidi_class\",\n        \"original_bidi_class\",\n        \"embedding_level\",\n        \"direction\",\n    ]\n\n    def __init__(\n        self, character_index: int, character: str, embedding_level: int, debug: bool\n    ) -> None:\n        self.character_index = character_index\n        self.character = character\n        if debug and character.isupper():\n            self.bidi_class = \"R\"\n        else:\n            self.bidi_class = unicodedata.bidirectional(character)\n        self.original_bidi_class = self.bidi_class\n        self.embedding_level = embedding_level\n        self.direction = None\n\n    def get_direction_from_level(self) -> str:\n        return \"R\" if self.embedding_level % 2 else \"L\"\n\n    def set_class(self, cls: str) -> None:\n        self.bidi_class = cls\n\n    def __repr__(self) -> str:\n        return (\n            f\"character_index: {self.character_index} character: {self.character}\"\n            + f\" bidi_class: {self.bidi_class} original_bidi_class: {self.original_bidi_class}\"\n            + f\" embedding_level: {self.embedding_level} direction: {self.direction}\"\n        )",
      "language": "python"
    },
    {
      "code": "class BidiCharacter:\n    __slots__ = [\n        \"character_index\",\n        \"character\",\n        \"bidi_class\",\n        \"original_bidi_class\",\n        \"embedding_level\",\n        \"direction\",\n    ]\n\n    def __init__(\n        self, character_index: int, character: str, embedding_level: int, debug: bool\n    ) -> None:\n        self.character_index = character_index\n        self.character = character\n        if debug and character.isupper():\n            self.bidi_class = \"R\"\n        else:\n            self.bidi_class = unicodedata.bidirectional(character)\n        self.original_bidi_class = self.bidi_class\n        self.embedding_level = embedding_level\n        self.direction = None\n\n    def get_direction_from_level(self) -> str:\n        return \"R\" if self.embedding_level % 2 else \"L\"\n\n    def set_class(self, cls: str) -> None:\n        self.bidi_class = cls\n\n    def __repr__(self) -> str:\n        return (\n            f\"character_index: {self.character_index} character: {self.character}\"\n            + f\" bidi_class: {self.bidi_class} original_bidi_class: {self.original_bidi_class}\"\n            + f\" embedding_level: {self.embedding_level} direction: {self.direction}\"\n        )",
      "language": "python"
    },
    {
      "code": "class BidiCharacter:\n    __slots__ = [\n        \"character_index\",\n        \"character\",\n        \"bidi_class\",\n        \"original_bidi_class\",\n        \"embedding_level\",\n        \"direction\",\n    ]\n\n    def __init__(\n        self, character_index: int, character: str, embedding_level: int, debug: bool\n    ) -> None:\n        self.character_index = character_index\n        self.character = character\n        if debug and character.isupper():\n            self.bidi_class = \"R\"\n        else:\n            self.bidi_class = unicodedata.bidirectional(character)\n        self.original_bidi_class = self.bidi_class\n        self.embedding_level = embedding_level\n        self.direction = None\n\n    def get_direction_from_level(self) -> str:\n        return \"R\" if self.embedding_level % 2 else \"L\"\n\n    def set_class(self, cls: str) -> None:\n        self.bidi_class = cls\n\n    def __repr__(self) -> str:\n        return (\n            f\"character_index: {self.character_index} character: {self.character}\"\n            + f\" bidi_class: {self.bidi_class} original_bidi_class: {self.original_bidi_class}\"\n            + f\" embedding_level: {self.embedding_level} direction: {self.direction}\"\n        )",
      "language": "python"
    },
    {
      "code": "def get_direction_from_level(self) -> str:\n    return \"R\" if self.embedding_level % 2 else \"L\"",
      "language": "python"
    },
    {
      "code": "def set_class(self, cls: str) -> None:\n    self.bidi_class = cls",
      "language": "python"
    },
    {
      "code": "class BidiParagraph:\n    __slots__ = (\n        \"text\",\n        \"base_direction\",\n        \"debug\",\n        \"base_embedding_level\",\n        \"characters\",\n    )\n\n    def __init__(\n        self,\n        text: str,\n        base_direction: Optional[TextDirection] = None,\n        debug: bool = False,\n    ) -> None:\n        self.text = text\n        self.base_direction = (\n            auto_detect_base_direction(self.text, debug)\n            if not base_direction\n            else base_direction\n        )\n        self.debug = debug\n        self.base_embedding_level = (\n            0 if self.base_direction == TextDirection.LTR else 1\n        )  # base level\n        self.characters: list[BidiCharacter] = []\n        self.get_bidi_characters()\n\n    def get_characters(self) -> list[BidiCharacter]:\n        return self.characters\n\n    def get_characters_with_embedding_level(self) -> list[BidiCharacter]:\n        # Calculate embedding level for each character after breaking isolating runs.\n        # Only used on conformance testing\n        self.reorder_resolved_levels()\n        return self.characters\n\n    def get_reordered_characters(self) -> tuple[BidiCharacter, ...]:\n        return self.reorder_resolved_levels()\n\n    def get_all(self) -> tuple[list[BidiCharacter], tuple[BidiCharacter, ...]]:\n        return self.characters, self.reorder_resolved_levels()\n\n    def get_reordered_string(self) -> str:\n        \"Used for conformance validation\"\n        return \"\".join(c.character for c in self.reorder_resolved_levels())\n\n    def get_bidi_fragments(self) -> tuple[tuple[str, TextDirection], ...]:\n        return self.split_bidi_fragments()\n\n    def get_bidi_characters(self) -> None:\n        # Explicit levels and directions. Rule X1\n\n        stack: deque[DirectionalStatus] = deque()\n        current_status = DirectionalStatus(\n            embedding_level=self.base_embedding_level,\n            directional_override_status=\"N\",\n            directional_isolate_status=False,\n        )\n        stack.append(replace(current_status))\n        overflow_isolate_count = 0\n        overflow_embedding_count = 0\n        valid_isolate_count = 0\n        results: list[BidiCharacter] = []\n\n        # Explicit embeddings. Process each character individually applying rules X2 through X8\n        for index, char in enumerate(self.text):\n            bidi_char = BidiCharacter(\n                index, char, current_status.embedding_level, self.debug\n            )\n            new_bidi_class = None\n\n            if bidi_char.bidi_class == \"FSI\":\n                bidi_char.bidi_class = (\n                    \"LRI\"\n                    if auto_detect_base_direction(\n                        self.text[index + 1 :], stop_at_pdi=True, debug=self.debug\n                    )\n                    == TextDirection.LTR\n                    else \"RLI\"\n                )\n\n            if bidi_char.bidi_class in (\"RLE\", \"LRE\", \"RLO\", \"LRO\", \"RLI\", \"LRI\"):\n                # X2 - X5: calculate explicit embeddings and explicit overrides\n                if bidi_char.bidi_class[0] == \"R\":\n                    new_embedding_level = (\n                        current_status.embedding_level + 1\n                    ) | 1  # least greater odd\n                else:\n                    new_embedding_level = (\n                        current_status.embedding_level + 2\n                    ) & ~1  # least greater even\n                if (\n                    bidi_char.bidi_class[2] == \"I\"\n                    and current_status.directional_override_status != \"N\"\n                ):\n                    new_bidi_class = current_status.directional_override_status\n                if (\n                    new_embedding_level <= MAX_DEPTH\n                    and overflow_isolate_count == 0\n                    and overflow_embedding_count == 0\n                ):\n                    current_status.embedding_level = new_embedding_level\n                    current_status.directional_override_status = (\n                        bidi_char.bidi_class[0]\n                        if bidi_char.bidi_class[2] == \"O\"\n                        else \"N\"\n                    )\n                    if bidi_char.bidi_class[2] == \"I\":\n                        valid_isolate_count += 1\n                        current_status.directional_isolate_status = True\n                    else:\n                        current_status.directional_isolate_status = False\n                    stack.append(replace(current_status))\n                else:\n                    if bidi_char.bidi_class[2] == \"I\":\n                        overflow_isolate_count += 1\n                    else:\n                        if overflow_isolate_count == 0:\n                            overflow_embedding_count += 1\n\n            if bidi_char.bidi_class not in (\n                \"B\",\n                \"BN\",\n                \"RLE\",\n                \"LRE\",\n                \"RLO\",\n                \"LRO\",\n                \"PDF\",\n                \"FSI\",\n                \"PDI\",\n            ):  # X6\n                if current_status.directional_override_status != \"N\":\n                    new_bidi_class = current_status.directional_override_status\n\n            if bidi_char.bidi_class == \"PDI\":  # X6a\n                if overflow_isolate_count > 0:\n                    overflow_isolate_count -= 1\n                elif valid_isolate_count > 0:\n                    overflow_embedding_count = 0\n                    while True:\n                        if not stack[-1].directional_isolate_status:\n                            stack.pop()\n                            continue\n                        break\n                    stack.pop()\n                    current_status = replace(stack[-1])\n                    valid_isolate_count -= 1\n                assert isinstance(current_status, DirectionalStatus)\n                bidi_char.embedding_level = current_status.embedding_level\n                if current_status.directional_override_status != \"N\":\n                    new_bidi_class = current_status.directional_override_status\n\n            if bidi_char.bidi_class == \"PDF\":  # X7\n                if overflow_isolate_count == 0:\n                    if overflow_embedding_count > 0:\n                        overflow_embedding_count -= 1\n                    else:\n                        if (\n                            not current_status.directional_isolate_status\n                            and len(stack) > 1\n                        ):\n                            stack.pop()\n                            current_status = replace(stack[-1])\n\n            if new_bidi_class:\n                bidi_char.bidi_class = new_bidi_class\n            if bidi_char.bidi_class not in (\n                \"RLE\",\n                \"LRE\",\n                \"RLO\",\n                \"LRO\",\n                \"PDF\",\n                \"BN\",\n            ):  # X9\n                if bidi_char.bidi_class == \"B\":\n                    bidi_char.embedding_level = self.base_embedding_level\n                elif bidi_char.original_bidi_class not in (\"LRI\", \"RLI\", \"FSI\"):\n                    bidi_char.embedding_level = current_status.embedding_level\n                results.append(bidi_char)\n\n        if not results:\n            self.characters = []\n            return\n        self.characters = results\n        calculate_isolate_runs(results)\n\n    def split_bidi_fragments(self) -> tuple[tuple[str, TextDirection], ...]:\n        bidi_fragments: list[tuple[str, TextDirection]] = []\n        if len(self.characters) == 0:\n            return ()\n        current_fragment = \"\"\n        current_direction = \"\"\n        for c in self.characters:\n            if c.get_direction_from_level() != current_direction:\n                if current_fragment:\n                    bidi_fragments.append(\n                        (\n                            current_fragment,\n                            (\n                                TextDirection.RTL\n                                if current_direction == \"R\"\n                                else TextDirection.LTR\n                            ),\n                        )\n                    )\n                current_fragment = \"\"\n                current_direction = c.get_direction_from_level()\n            current_fragment += c.character\n        if current_fragment:\n            bidi_fragments.append(\n                (\n                    current_fragment,\n                    (\n                        TextDirection.RTL\n                        if current_direction == \"R\"\n                        else TextDirection.LTR\n                    ),\n                )\n            )\n        return tuple(bidi_fragments)\n\n    def reorder_resolved_levels(self) -> tuple[BidiCharacter, ...]:\n        before_separator = True\n        end_of_line = True\n        max_level = 0\n        min_odd_level = 999\n        for bidi_char in reversed(self.characters):\n            # Rule L1. Reset the embedding level of segment separators, paragraph separators,\n            # and any adjacent whitespace.\n            if bidi_char.original_bidi_class in (\"S\", \"B\"):\n                bidi_char.embedding_level = self.base_embedding_level\n                before_separator = True\n            elif bidi_char.original_bidi_class in (\n                \"BN\",\n                \"WS\",\n                \"FSI\",\n                \"LRI\",\n                \"RLI\",\n                \"PDI\",\n            ):\n                if before_separator or end_of_line:\n                    bidi_char.embedding_level = self.base_embedding_level\n            else:\n                before_separator = False\n                end_of_line = False\n\n            if bidi_char.embedding_level > max_level:\n                max_level = bidi_char.embedding_level\n            if (\n                bidi_char.embedding_level % 2 != 0\n                and bidi_char.embedding_level < min_odd_level\n            ):\n                min_odd_level = bidi_char.embedding_level\n\n        # Rule L2. From the highest level found in the text to the lowest odd level on each line,\n        # reverse any contiguous sequence of characters that are at that level or higher.\n        reordered_paragraph = self.characters.copy()\n        for level in range(max_level, min_odd_level - 1, -1):\n            temp_results: list[BidiCharacter] = []\n            rev: list[BidiCharacter] = []\n            for bidi_char in reordered_paragraph:\n                if bidi_char.embedding_level >= level:\n                    rev.append(bidi_char)\n                else:\n                    if rev:\n                        rev.reverse()\n                        temp_results += rev\n                        rev = []\n                    temp_results.append(bidi_char)\n            if rev:\n                rev.reverse()\n                temp_results += rev\n            reordered_paragraph = temp_results\n        return tuple(reordered_paragraph)",
      "language": "python"
    },
    {
      "code": "class BidiParagraph:\n    __slots__ = (\n        \"text\",\n        \"base_direction\",\n        \"debug\",\n        \"base_embedding_level\",\n        \"characters\",\n    )\n\n    def __init__(\n        self,\n        text: str,\n        base_direction: Optional[TextDirection] = None,\n        debug: bool = False,\n    ) -> None:\n        self.text = text\n        self.base_direction = (\n            auto_detect_base_direction(self.text, debug)\n            if not base_direction\n            else base_direction\n        )\n        self.debug = debug\n        self.base_embedding_level = (\n            0 if self.base_direction == TextDirection.LTR else 1\n        )  # base level\n        self.characters: list[BidiCharacter] = []\n        self.get_bidi_characters()\n\n    def get_characters(self) -> list[BidiCharacter]:\n        return self.characters\n\n    def get_characters_with_embedding_level(self) -> list[BidiCharacter]:\n        # Calculate embedding level for each character after breaking isolating runs.\n        # Only used on conformance testing\n        self.reorder_resolved_levels()\n        return self.characters\n\n    def get_reordered_characters(self) -> tuple[BidiCharacter, ...]:\n        return self.reorder_resolved_levels()\n\n    def get_all(self) -> tuple[list[BidiCharacter], tuple[BidiCharacter, ...]]:\n        return self.characters, self.reorder_resolved_levels()\n\n    def get_reordered_string(self) -> str:\n        \"Used for conformance validation\"\n        return \"\".join(c.character for c in self.reorder_resolved_levels())\n\n    def get_bidi_fragments(self) -> tuple[tuple[str, TextDirection], ...]:\n        return self.split_bidi_fragments()\n\n    def get_bidi_characters(self) -> None:\n        # Explicit levels and directions. Rule X1\n\n        stack: deque[DirectionalStatus] = deque()\n        current_status = DirectionalStatus(\n            embedding_level=self.base_embedding_level,\n            directional_override_status=\"N\",\n            directional_isolate_status=False,\n        )\n        stack.append(replace(current_status))\n        overflow_isolate_count = 0\n        overflow_embedding_count = 0\n        valid_isolate_count = 0\n        results: list[BidiCharacter] = []\n\n        # Explicit embeddings. Process each character individually applying rules X2 through X8\n        for index, char in enumerate(self.text):\n            bidi_char = BidiCharacter(\n                index, char, current_status.embedding_level, self.debug\n            )\n            new_bidi_class = None\n\n            if bidi_char.bidi_class == \"FSI\":\n                bidi_char.bidi_class = (\n                    \"LRI\"\n                    if auto_detect_base_direction(\n                        self.text[index + 1 :], stop_at_pdi=True, debug=self.debug\n                    )\n                    == TextDirection.LTR\n                    else \"RLI\"\n                )\n\n            if bidi_char.bidi_class in (\"RLE\", \"LRE\", \"RLO\", \"LRO\", \"RLI\", \"LRI\"):\n                # X2 - X5: calculate explicit embeddings and explicit overrides\n                if bidi_char.bidi_class[0] == \"R\":\n                    new_embedding_level = (\n                        current_status.embedding_level + 1\n                    ) | 1  # least greater odd\n                else:\n                    new_embedding_level = (\n                        current_status.embedding_level + 2\n                    ) & ~1  # least greater even\n                if (\n                    bidi_char.bidi_class[2] == \"I\"\n                    and current_status.directional_override_status != \"N\"\n                ):\n                    new_bidi_class = current_status.directional_override_status\n                if (\n                    new_embedding_level <= MAX_DEPTH\n                    and overflow_isolate_count == 0\n                    and overflow_embedding_count == 0\n                ):\n                    current_status.embedding_level = new_embedding_level\n                    current_status.directional_override_status = (\n                        bidi_char.bidi_class[0]\n                        if bidi_char.bidi_class[2] == \"O\"\n                        else \"N\"\n                    )\n                    if bidi_char.bidi_class[2] == \"I\":\n                        valid_isolate_count += 1\n                        current_status.directional_isolate_status = True\n                    else:\n                        current_status.directional_isolate_status = False\n                    stack.append(replace(current_status))\n                else:\n                    if bidi_char.bidi_class[2] == \"I\":\n                        overflow_isolate_count += 1\n                    else:\n                        if overflow_isolate_count == 0:\n                            overflow_embedding_count += 1\n\n            if bidi_char.bidi_class not in (\n                \"B\",\n                \"BN\",\n                \"RLE\",\n                \"LRE\",\n                \"RLO\",\n                \"LRO\",\n                \"PDF\",\n                \"FSI\",\n                \"PDI\",\n            ):  # X6\n                if current_status.directional_override_status != \"N\":\n                    new_bidi_class = current_status.directional_override_status\n\n            if bidi_char.bidi_class == \"PDI\":  # X6a\n                if overflow_isolate_count > 0:\n                    overflow_isolate_count -= 1\n                elif valid_isolate_count > 0:\n                    overflow_embedding_count = 0\n                    while True:\n                        if not stack[-1].directional_isolate_status:\n                            stack.pop()\n                            continue\n                        break\n                    stack.pop()\n                    current_status = replace(stack[-1])\n                    valid_isolate_count -= 1\n                assert isinstance(current_status, DirectionalStatus)\n                bidi_char.embedding_level = current_status.embedding_level\n                if current_status.directional_override_status != \"N\":\n                    new_bidi_class = current_status.directional_override_status\n\n            if bidi_char.bidi_class == \"PDF\":  # X7\n                if overflow_isolate_count == 0:\n                    if overflow_embedding_count > 0:\n                        overflow_embedding_count -= 1\n                    else:\n                        if (\n                            not current_status.directional_isolate_status\n                            and len(stack) > 1\n                        ):\n                            stack.pop()\n                            current_status = replace(stack[-1])\n\n            if new_bidi_class:\n                bidi_char.bidi_class = new_bidi_class\n            if bidi_char.bidi_class not in (\n                \"RLE\",\n                \"LRE\",\n                \"RLO\",\n                \"LRO\",\n                \"PDF\",\n                \"BN\",\n            ):  # X9\n                if bidi_char.bidi_class == \"B\":\n                    bidi_char.embedding_level = self.base_embedding_level\n                elif bidi_char.original_bidi_class not in (\"LRI\", \"RLI\", \"FSI\"):\n                    bidi_char.embedding_level = current_status.embedding_level\n                results.append(bidi_char)\n\n        if not results:\n            self.characters = []\n            return\n        self.characters = results\n        calculate_isolate_runs(results)\n\n    def split_bidi_fragments(self) -> tuple[tuple[str, TextDirection], ...]:\n        bidi_fragments: list[tuple[str, TextDirection]] = []\n        if len(self.characters) == 0:\n            return ()\n        current_fragment = \"\"\n        current_direction = \"\"\n        for c in self.characters:\n            if c.get_direction_from_level() != current_direction:\n                if current_fragment:\n                    bidi_fragments.append(\n                        (\n                            current_fragment,\n                            (\n                                TextDirection.RTL\n                                if current_direction == \"R\"\n                                else TextDirection.LTR\n                            ),\n                        )\n                    )\n                current_fragment = \"\"\n                current_direction = c.get_direction_from_level()\n            current_fragment += c.character\n        if current_fragment:\n            bidi_fragments.append(\n                (\n                    current_fragment,\n                    (\n                        TextDirection.RTL\n                        if current_direction == \"R\"\n                        else TextDirection.LTR\n                    ),\n                )\n            )\n        return tuple(bidi_fragments)\n\n    def reorder_resolved_levels(self) -> tuple[BidiCharacter, ...]:\n        before_separator = True\n        end_of_line = True\n        max_level = 0\n        min_odd_level = 999\n        for bidi_char in reversed(self.characters):\n            # Rule L1. Reset the embedding level of segment separators, paragraph separators,\n            # and any adjacent whitespace.\n            if bidi_char.original_bidi_class in (\"S\", \"B\"):\n                bidi_char.embedding_level = self.base_embedding_level\n                before_separator = True\n            elif bidi_char.original_bidi_class in (\n                \"BN\",\n                \"WS\",\n                \"FSI\",\n                \"LRI\",\n                \"RLI\",\n                \"PDI\",\n            ):\n                if before_separator or end_of_line:\n                    bidi_char.embedding_level = self.base_embedding_level\n            else:\n                before_separator = False\n                end_of_line = False\n\n            if bidi_char.embedding_level > max_level:\n                max_level = bidi_char.embedding_level\n            if (\n                bidi_char.embedding_level % 2 != 0\n                and bidi_char.embedding_level < min_odd_level\n            ):\n                min_odd_level = bidi_char.embedding_level\n\n        # Rule L2. From the highest level found in the text to the lowest odd level on each line,\n        # reverse any contiguous sequence of characters that are at that level or higher.\n        reordered_paragraph = self.characters.copy()\n        for level in range(max_level, min_odd_level - 1, -1):\n            temp_results: list[BidiCharacter] = []\n            rev: list[BidiCharacter] = []\n            for bidi_char in reordered_paragraph:\n                if bidi_char.embedding_level >= level:\n                    rev.append(bidi_char)\n                else:\n                    if rev:\n                        rev.reverse()\n                        temp_results += rev\n                        rev = []\n                    temp_results.append(bidi_char)\n            if rev:\n                rev.reverse()\n                temp_results += rev\n            reordered_paragraph = temp_results\n        return tuple(reordered_paragraph)",
      "language": "python"
    },
    {
      "code": "class BidiParagraph:\n    __slots__ = (\n        \"text\",\n        \"base_direction\",\n        \"debug\",\n        \"base_embedding_level\",\n        \"characters\",\n    )\n\n    def __init__(\n        self,\n        text: str,\n        base_direction: Optional[TextDirection] = None,\n        debug: bool = False,\n    ) -> None:\n        self.text = text\n        self.base_direction = (\n            auto_detect_base_direction(self.text, debug)\n            if not base_direction\n            else base_direction\n        )\n        self.debug = debug\n        self.base_embedding_level = (\n            0 if self.base_direction == TextDirection.LTR else 1\n        )  # base level\n        self.characters: list[BidiCharacter] = []\n        self.get_bidi_characters()\n\n    def get_characters(self) -> list[BidiCharacter]:\n        return self.characters\n\n    def get_characters_with_embedding_level(self) -> list[BidiCharacter]:\n        # Calculate embedding level for each character after breaking isolating runs.\n        # Only used on conformance testing\n        self.reorder_resolved_levels()\n        return self.characters\n\n    def get_reordered_characters(self) -> tuple[BidiCharacter, ...]:\n        return self.reorder_resolved_levels()\n\n    def get_all(self) -> tuple[list[BidiCharacter], tuple[BidiCharacter, ...]]:\n        return self.characters, self.reorder_resolved_levels()\n\n    def get_reordered_string(self) -> str:\n        \"Used for conformance validation\"\n        return \"\".join(c.character for c in self.reorder_resolved_levels())\n\n    def get_bidi_fragments(self) -> tuple[tuple[str, TextDirection], ...]:\n        return self.split_bidi_fragments()\n\n    def get_bidi_characters(self) -> None:\n        # Explicit levels and directions. Rule X1\n\n        stack: deque[DirectionalStatus] = deque()\n        current_status = DirectionalStatus(\n            embedding_level=self.base_embedding_level,\n            directional_override_status=\"N\",\n            directional_isolate_status=False,\n        )\n        stack.append(replace(current_status))\n        overflow_isolate_count = 0\n        overflow_embedding_count = 0\n        valid_isolate_count = 0\n        results: list[BidiCharacter] = []\n\n        # Explicit embeddings. Process each character individually applying rules X2 through X8\n        for index, char in enumerate(self.text):\n            bidi_char = BidiCharacter(\n                index, char, current_status.embedding_level, self.debug\n            )\n            new_bidi_class = None\n\n            if bidi_char.bidi_class == \"FSI\":\n                bidi_char.bidi_class = (\n                    \"LRI\"\n                    if auto_detect_base_direction(\n                        self.text[index + 1 :], stop_at_pdi=True, debug=self.debug\n                    )\n                    == TextDirection.LTR\n                    else \"RLI\"\n                )\n\n            if bidi_char.bidi_class in (\"RLE\", \"LRE\", \"RLO\", \"LRO\", \"RLI\", \"LRI\"):\n                # X2 - X5: calculate explicit embeddings and explicit overrides\n                if bidi_char.bidi_class[0] == \"R\":\n                    new_embedding_level = (\n                        current_status.embedding_level + 1\n                    ) | 1  # least greater odd\n                else:\n                    new_embedding_level = (\n                        current_status.embedding_level + 2\n                    ) & ~1  # least greater even\n                if (\n                    bidi_char.bidi_class[2] == \"I\"\n                    and current_status.directional_override_status != \"N\"\n                ):\n                    new_bidi_class = current_status.directional_override_status\n                if (\n                    new_embedding_level <= MAX_DEPTH\n                    and overflow_isolate_count == 0\n                    and overflow_embedding_count == 0\n                ):\n                    current_status.embedding_level = new_embedding_level\n                    current_status.directional_override_status = (\n                        bidi_char.bidi_class[0]\n                        if bidi_char.bidi_class[2] == \"O\"\n                        else \"N\"\n                    )\n                    if bidi_char.bidi_class[2] == \"I\":\n                        valid_isolate_count += 1\n                        current_status.directional_isolate_status = True\n                    else:\n                        current_status.directional_isolate_status = False\n                    stack.append(replace(current_status))\n                else:\n                    if bidi_char.bidi_class[2] == \"I\":\n                        overflow_isolate_count += 1\n                    else:\n                        if overflow_isolate_count == 0:\n                            overflow_embedding_count += 1\n\n            if bidi_char.bidi_class not in (\n                \"B\",\n                \"BN\",\n                \"RLE\",\n                \"LRE\",\n                \"RLO\",\n                \"LRO\",\n                \"PDF\",\n                \"FSI\",\n                \"PDI\",\n            ):  # X6\n                if current_status.directional_override_status != \"N\":\n                    new_bidi_class = current_status.directional_override_status\n\n            if bidi_char.bidi_class == \"PDI\":  # X6a\n                if overflow_isolate_count > 0:\n                    overflow_isolate_count -= 1\n                elif valid_isolate_count > 0:\n                    overflow_embedding_count = 0\n                    while True:\n                        if not stack[-1].directional_isolate_status:\n                            stack.pop()\n                            continue\n                        break\n                    stack.pop()\n                    current_status = replace(stack[-1])\n                    valid_isolate_count -= 1\n                assert isinstance(current_status, DirectionalStatus)\n                bidi_char.embedding_level = current_status.embedding_level\n                if current_status.directional_override_status != \"N\":\n                    new_bidi_class = current_status.directional_override_status\n\n            if bidi_char.bidi_class == \"PDF\":  # X7\n                if overflow_isolate_count == 0:\n                    if overflow_embedding_count > 0:\n                        overflow_embedding_count -= 1\n                    else:\n                        if (\n                            not current_status.directional_isolate_status\n                            and len(stack) > 1\n                        ):\n                            stack.pop()\n                            current_status = replace(stack[-1])\n\n            if new_bidi_class:\n                bidi_char.bidi_class = new_bidi_class\n            if bidi_char.bidi_class not in (\n                \"RLE\",\n                \"LRE\",\n                \"RLO\",\n                \"LRO\",\n                \"PDF\",\n                \"BN\",\n            ):  # X9\n                if bidi_char.bidi_class == \"B\":\n                    bidi_char.embedding_level = self.base_embedding_level\n                elif bidi_char.original_bidi_class not in (\"LRI\", \"RLI\", \"FSI\"):\n                    bidi_char.embedding_level = current_status.embedding_level\n                results.append(bidi_char)\n\n        if not results:\n            self.characters = []\n            return\n        self.characters = results\n        calculate_isolate_runs(results)\n\n    def split_bidi_fragments(self) -> tuple[tuple[str, TextDirection], ...]:\n        bidi_fragments: list[tuple[str, TextDirection]] = []\n        if len(self.characters) == 0:\n            return ()\n        current_fragment = \"\"\n        current_direction = \"\"\n        for c in self.characters:\n            if c.get_direction_from_level() != current_direction:\n                if current_fragment:\n                    bidi_fragments.append(\n                        (\n                            current_fragment,\n                            (\n                                TextDirection.RTL\n                                if current_direction == \"R\"\n                                else TextDirection.LTR\n                            ),\n                        )\n                    )\n                current_fragment = \"\"\n                current_direction = c.get_direction_from_level()\n            current_fragment += c.character\n        if current_fragment:\n            bidi_fragments.append(\n                (\n                    current_fragment,\n                    (\n                        TextDirection.RTL\n                        if current_direction == \"R\"\n                        else TextDirection.LTR\n                    ),\n                )\n            )\n        return tuple(bidi_fragments)\n\n    def reorder_resolved_levels(self) -> tuple[BidiCharacter, ...]:\n        before_separator = True\n        end_of_line = True\n        max_level = 0\n        min_odd_level = 999\n        for bidi_char in reversed(self.characters):\n            # Rule L1. Reset the embedding level of segment separators, paragraph separators,\n            # and any adjacent whitespace.\n            if bidi_char.original_bidi_class in (\"S\", \"B\"):\n                bidi_char.embedding_level = self.base_embedding_level\n                before_separator = True\n            elif bidi_char.original_bidi_class in (\n                \"BN\",\n                \"WS\",\n                \"FSI\",\n                \"LRI\",\n                \"RLI\",\n                \"PDI\",\n            ):\n                if before_separator or end_of_line:\n                    bidi_char.embedding_level = self.base_embedding_level\n            else:\n                before_separator = False\n                end_of_line = False\n\n            if bidi_char.embedding_level > max_level:\n                max_level = bidi_char.embedding_level\n            if (\n                bidi_char.embedding_level % 2 != 0\n                and bidi_char.embedding_level < min_odd_level\n            ):\n                min_odd_level = bidi_char.embedding_level\n\n        # Rule L2. From the highest level found in the text to the lowest odd level on each line,\n        # reverse any contiguous sequence of characters that are at that level or higher.\n        reordered_paragraph = self.characters.copy()\n        for level in range(max_level, min_odd_level - 1, -1):\n            temp_results: list[BidiCharacter] = []\n            rev: list[BidiCharacter] = []\n            for bidi_char in reordered_paragraph:\n                if bidi_char.embedding_level >= level:\n                    rev.append(bidi_char)\n                else:\n                    if rev:\n                        rev.reverse()\n                        temp_results += rev\n                        rev = []\n                    temp_results.append(bidi_char)\n            if rev:\n                rev.reverse()\n                temp_results += rev\n            reordered_paragraph = temp_results\n        return tuple(reordered_paragraph)",
      "language": "python"
    },
    {
      "code": "class BidiParagraph:\n    __slots__ = (\n        \"text\",\n        \"base_direction\",\n        \"debug\",\n        \"base_embedding_level\",\n        \"characters\",\n    )\n\n    def __init__(\n        self,\n        text: str,\n        base_direction: Optional[TextDirection] = None,\n        debug: bool = False,\n    ) -> None:\n        self.text = text\n        self.base_direction = (\n            auto_detect_base_direction(self.text, debug)\n            if not base_direction\n            else base_direction\n        )\n        self.debug = debug\n        self.base_embedding_level = (\n            0 if self.base_direction == TextDirection.LTR else 1\n        )  # base level\n        self.characters: list[BidiCharacter] = []\n        self.get_bidi_characters()\n\n    def get_characters(self) -> list[BidiCharacter]:\n        return self.characters\n\n    def get_characters_with_embedding_level(self) -> list[BidiCharacter]:\n        # Calculate embedding level for each character after breaking isolating runs.\n        # Only used on conformance testing\n        self.reorder_resolved_levels()\n        return self.characters\n\n    def get_reordered_characters(self) -> tuple[BidiCharacter, ...]:\n        return self.reorder_resolved_levels()\n\n    def get_all(self) -> tuple[list[BidiCharacter], tuple[BidiCharacter, ...]]:\n        return self.characters, self.reorder_resolved_levels()\n\n    def get_reordered_string(self) -> str:\n        \"Used for conformance validation\"\n        return \"\".join(c.character for c in self.reorder_resolved_levels())\n\n    def get_bidi_fragments(self) -> tuple[tuple[str, TextDirection], ...]:\n        return self.split_bidi_fragments()\n\n    def get_bidi_characters(self) -> None:\n        # Explicit levels and directions. Rule X1\n\n        stack: deque[DirectionalStatus] = deque()\n        current_status = DirectionalStatus(\n            embedding_level=self.base_embedding_level,\n            directional_override_status=\"N\",\n            directional_isolate_status=False,\n        )\n        stack.append(replace(current_status))\n        overflow_isolate_count = 0\n        overflow_embedding_count = 0\n        valid_isolate_count = 0\n        results: list[BidiCharacter] = []\n\n        # Explicit embeddings. Process each character individually applying rules X2 through X8\n        for index, char in enumerate(self.text):\n            bidi_char = BidiCharacter(\n                index, char, current_status.embedding_level, self.debug\n            )\n            new_bidi_class = None\n\n            if bidi_char.bidi_class == \"FSI\":\n                bidi_char.bidi_class = (\n                    \"LRI\"\n                    if auto_detect_base_direction(\n                        self.text[index + 1 :], stop_at_pdi=True, debug=self.debug\n                    )\n                    == TextDirection.LTR\n                    else \"RLI\"\n                )\n\n            if bidi_char.bidi_class in (\"RLE\", \"LRE\", \"RLO\", \"LRO\", \"RLI\", \"LRI\"):\n                # X2 - X5: calculate explicit embeddings and explicit overrides\n                if bidi_char.bidi_class[0] == \"R\":\n                    new_embedding_level = (\n                        current_status.embedding_level + 1\n                    ) | 1  # least greater odd\n                else:\n                    new_embedding_level = (\n                        current_status.embedding_level + 2\n                    ) & ~1  # least greater even\n                if (\n                    bidi_char.bidi_class[2] == \"I\"\n                    and current_status.directional_override_status != \"N\"\n                ):\n                    new_bidi_class = current_status.directional_override_status\n                if (\n                    new_embedding_level <= MAX_DEPTH\n                    and overflow_isolate_count == 0\n                    and overflow_embedding_count == 0\n                ):\n                    current_status.embedding_level = new_embedding_level\n                    current_status.directional_override_status = (\n                        bidi_char.bidi_class[0]\n                        if bidi_char.bidi_class[2] == \"O\"\n                        else \"N\"\n                    )\n                    if bidi_char.bidi_class[2] == \"I\":\n                        valid_isolate_count += 1\n                        current_status.directional_isolate_status = True\n                    else:\n                        current_status.directional_isolate_status = False\n                    stack.append(replace(current_status))\n                else:\n                    if bidi_char.bidi_class[2] == \"I\":\n                        overflow_isolate_count += 1\n                    else:\n                        if overflow_isolate_count == 0:\n                            overflow_embedding_count += 1\n\n            if bidi_char.bidi_class not in (\n                \"B\",\n                \"BN\",\n                \"RLE\",\n                \"LRE\",\n                \"RLO\",\n                \"LRO\",\n                \"PDF\",\n                \"FSI\",\n                \"PDI\",\n            ):  # X6\n                if current_status.directional_override_status != \"N\":\n                    new_bidi_class = current_status.directional_override_status\n\n            if bidi_char.bidi_class == \"PDI\":  # X6a\n                if overflow_isolate_count > 0:\n                    overflow_isolate_count -= 1\n                elif valid_isolate_count > 0:\n                    overflow_embedding_count = 0\n                    while True:\n                        if not stack[-1].directional_isolate_status:\n                            stack.pop()\n                            continue\n                        break\n                    stack.pop()\n                    current_status = replace(stack[-1])\n                    valid_isolate_count -= 1\n                assert isinstance(current_status, DirectionalStatus)\n                bidi_char.embedding_level = current_status.embedding_level\n                if current_status.directional_override_status != \"N\":\n                    new_bidi_class = current_status.directional_override_status\n\n            if bidi_char.bidi_class == \"PDF\":  # X7\n                if overflow_isolate_count == 0:\n                    if overflow_embedding_count > 0:\n                        overflow_embedding_count -= 1\n                    else:\n                        if (\n                            not current_status.directional_isolate_status\n                            and len(stack) > 1\n                        ):\n                            stack.pop()\n                            current_status = replace(stack[-1])\n\n            if new_bidi_class:\n                bidi_char.bidi_class = new_bidi_class\n            if bidi_char.bidi_class not in (\n                \"RLE\",\n                \"LRE\",\n                \"RLO\",\n                \"LRO\",\n                \"PDF\",\n                \"BN\",\n            ):  # X9\n                if bidi_char.bidi_class == \"B\":\n                    bidi_char.embedding_level = self.base_embedding_level\n                elif bidi_char.original_bidi_class not in (\"LRI\", \"RLI\", \"FSI\"):\n                    bidi_char.embedding_level = current_status.embedding_level\n                results.append(bidi_char)\n\n        if not results:\n            self.characters = []\n            return\n        self.characters = results\n        calculate_isolate_runs(results)\n\n    def split_bidi_fragments(self) -> tuple[tuple[str, TextDirection], ...]:\n        bidi_fragments: list[tuple[str, TextDirection]] = []\n        if len(self.characters) == 0:\n            return ()\n        current_fragment = \"\"\n        current_direction = \"\"\n        for c in self.characters:\n            if c.get_direction_from_level() != current_direction:\n                if current_fragment:\n                    bidi_fragments.append(\n                        (\n                            current_fragment,\n                            (\n                                TextDirection.RTL\n                                if current_direction == \"R\"\n                                else TextDirection.LTR\n                            ),\n                        )\n                    )\n                current_fragment = \"\"\n                current_direction = c.get_direction_from_level()\n            current_fragment += c.character\n        if current_fragment:\n            bidi_fragments.append(\n                (\n                    current_fragment,\n                    (\n                        TextDirection.RTL\n                        if current_direction == \"R\"\n                        else TextDirection.LTR\n                    ),\n                )\n            )\n        return tuple(bidi_fragments)\n\n    def reorder_resolved_levels(self) -> tuple[BidiCharacter, ...]:\n        before_separator = True\n        end_of_line = True\n        max_level = 0\n        min_odd_level = 999\n        for bidi_char in reversed(self.characters):\n            # Rule L1. Reset the embedding level of segment separators, paragraph separators,\n            # and any adjacent whitespace.\n            if bidi_char.original_bidi_class in (\"S\", \"B\"):\n                bidi_char.embedding_level = self.base_embedding_level\n                before_separator = True\n            elif bidi_char.original_bidi_class in (\n                \"BN\",\n                \"WS\",\n                \"FSI\",\n                \"LRI\",\n                \"RLI\",\n                \"PDI\",\n            ):\n                if before_separator or end_of_line:\n                    bidi_char.embedding_level = self.base_embedding_level\n            else:\n                before_separator = False\n                end_of_line = False\n\n            if bidi_char.embedding_level > max_level:\n                max_level = bidi_char.embedding_level\n            if (\n                bidi_char.embedding_level % 2 != 0\n                and bidi_char.embedding_level < min_odd_level\n            ):\n                min_odd_level = bidi_char.embedding_level\n\n        # Rule L2. From the highest level found in the text to the lowest odd level on each line,\n        # reverse any contiguous sequence of characters that are at that level or higher.\n        reordered_paragraph = self.characters.copy()\n        for level in range(max_level, min_odd_level - 1, -1):\n            temp_results: list[BidiCharacter] = []\n            rev: list[BidiCharacter] = []\n            for bidi_char in reordered_paragraph:\n                if bidi_char.embedding_level >= level:\n                    rev.append(bidi_char)\n                else:\n                    if rev:\n                        rev.reverse()\n                        temp_results += rev\n                        rev = []\n                    temp_results.append(bidi_char)\n            if rev:\n                rev.reverse()\n                temp_results += rev\n            reordered_paragraph = temp_results\n        return tuple(reordered_paragraph)",
      "language": "python"
    },
    {
      "code": "class BidiParagraph:\n    __slots__ = (\n        \"text\",\n        \"base_direction\",\n        \"debug\",\n        \"base_embedding_level\",\n        \"characters\",\n    )\n\n    def __init__(\n        self,\n        text: str,\n        base_direction: Optional[TextDirection] = None,\n        debug: bool = False,\n    ) -> None:\n        self.text = text\n        self.base_direction = (\n            auto_detect_base_direction(self.text, debug)\n            if not base_direction\n            else base_direction\n        )\n        self.debug = debug\n        self.base_embedding_level = (\n            0 if self.base_direction == TextDirection.LTR else 1\n        )  # base level\n        self.characters: list[BidiCharacter] = []\n        self.get_bidi_characters()\n\n    def get_characters(self) -> list[BidiCharacter]:\n        return self.characters\n\n    def get_characters_with_embedding_level(self) -> list[BidiCharacter]:\n        # Calculate embedding level for each character after breaking isolating runs.\n        # Only used on conformance testing\n        self.reorder_resolved_levels()\n        return self.characters\n\n    def get_reordered_characters(self) -> tuple[BidiCharacter, ...]:\n        return self.reorder_resolved_levels()\n\n    def get_all(self) -> tuple[list[BidiCharacter], tuple[BidiCharacter, ...]]:\n        return self.characters, self.reorder_resolved_levels()\n\n    def get_reordered_string(self) -> str:\n        \"Used for conformance validation\"\n        return \"\".join(c.character for c in self.reorder_resolved_levels())\n\n    def get_bidi_fragments(self) -> tuple[tuple[str, TextDirection], ...]:\n        return self.split_bidi_fragments()\n\n    def get_bidi_characters(self) -> None:\n        # Explicit levels and directions. Rule X1\n\n        stack: deque[DirectionalStatus] = deque()\n        current_status = DirectionalStatus(\n            embedding_level=self.base_embedding_level,\n            directional_override_status=\"N\",\n            directional_isolate_status=False,\n        )\n        stack.append(replace(current_status))\n        overflow_isolate_count = 0\n        overflow_embedding_count = 0\n        valid_isolate_count = 0\n        results: list[BidiCharacter] = []\n\n        # Explicit embeddings. Process each character individually applying rules X2 through X8\n        for index, char in enumerate(self.text):\n            bidi_char = BidiCharacter(\n                index, char, current_status.embedding_level, self.debug\n            )\n            new_bidi_class = None\n\n            if bidi_char.bidi_class == \"FSI\":\n                bidi_char.bidi_class = (\n                    \"LRI\"\n                    if auto_detect_base_direction(\n                        self.text[index + 1 :], stop_at_pdi=True, debug=self.debug\n                    )\n                    == TextDirection.LTR\n                    else \"RLI\"\n                )\n\n            if bidi_char.bidi_class in (\"RLE\", \"LRE\", \"RLO\", \"LRO\", \"RLI\", \"LRI\"):\n                # X2 - X5: calculate explicit embeddings and explicit overrides\n                if bidi_char.bidi_class[0] == \"R\":\n                    new_embedding_level = (\n                        current_status.embedding_level + 1\n                    ) | 1  # least greater odd\n                else:\n                    new_embedding_level = (\n                        current_status.embedding_level + 2\n                    ) & ~1  # least greater even\n                if (\n                    bidi_char.bidi_class[2] == \"I\"\n                    and current_status.directional_override_status != \"N\"\n                ):\n                    new_bidi_class = current_status.directional_override_status\n                if (\n                    new_embedding_level <= MAX_DEPTH\n                    and overflow_isolate_count == 0\n                    and overflow_embedding_count == 0\n                ):\n                    current_status.embedding_level = new_embedding_level\n                    current_status.directional_override_status = (\n                        bidi_char.bidi_class[0]\n                        if bidi_char.bidi_class[2] == \"O\"\n                        else \"N\"\n                    )\n                    if bidi_char.bidi_class[2] == \"I\":\n                        valid_isolate_count += 1\n                        current_status.directional_isolate_status = True\n                    else:\n                        current_status.directional_isolate_status = False\n                    stack.append(replace(current_status))\n                else:\n                    if bidi_char.bidi_class[2] == \"I\":\n                        overflow_isolate_count += 1\n                    else:\n                        if overflow_isolate_count == 0:\n                            overflow_embedding_count += 1\n\n            if bidi_char.bidi_class not in (\n                \"B\",\n                \"BN\",\n                \"RLE\",\n                \"LRE\",\n                \"RLO\",\n                \"LRO\",\n                \"PDF\",\n                \"FSI\",\n                \"PDI\",\n            ):  # X6\n                if current_status.directional_override_status != \"N\":\n                    new_bidi_class = current_status.directional_override_status\n\n            if bidi_char.bidi_class == \"PDI\":  # X6a\n                if overflow_isolate_count > 0:\n                    overflow_isolate_count -= 1\n                elif valid_isolate_count > 0:\n                    overflow_embedding_count = 0\n                    while True:\n                        if not stack[-1].directional_isolate_status:\n                            stack.pop()\n                            continue\n                        break\n                    stack.pop()\n                    current_status = replace(stack[-1])\n                    valid_isolate_count -= 1\n                assert isinstance(current_status, DirectionalStatus)\n                bidi_char.embedding_level = current_status.embedding_level\n                if current_status.directional_override_status != \"N\":\n                    new_bidi_class = current_status.directional_override_status\n\n            if bidi_char.bidi_class == \"PDF\":  # X7\n                if overflow_isolate_count == 0:\n                    if overflow_embedding_count > 0:\n                        overflow_embedding_count -= 1\n                    else:\n                        if (\n                            not current_status.directional_isolate_status\n                            and len(stack) > 1\n                        ):\n                            stack.pop()\n                            current_status = replace(stack[-1])\n\n            if new_bidi_class:\n                bidi_char.bidi_class = new_bidi_class\n            if bidi_char.bidi_class not in (\n                \"RLE\",\n                \"LRE\",\n                \"RLO\",\n                \"LRO\",\n                \"PDF\",\n                \"BN\",\n            ):  # X9\n                if bidi_char.bidi_class == \"B\":\n                    bidi_char.embedding_level = self.base_embedding_level\n                elif bidi_char.original_bidi_class not in (\"LRI\", \"RLI\", \"FSI\"):\n                    bidi_char.embedding_level = current_status.embedding_level\n                results.append(bidi_char)\n\n        if not results:\n            self.characters = []\n            return\n        self.characters = results\n        calculate_isolate_runs(results)\n\n    def split_bidi_fragments(self) -> tuple[tuple[str, TextDirection], ...]:\n        bidi_fragments: list[tuple[str, TextDirection]] = []\n        if len(self.characters) == 0:\n            return ()\n        current_fragment = \"\"\n        current_direction = \"\"\n        for c in self.characters:\n            if c.get_direction_from_level() != current_direction:\n                if current_fragment:\n                    bidi_fragments.append(\n                        (\n                            current_fragment,\n                            (\n                                TextDirection.RTL\n                                if current_direction == \"R\"\n                                else TextDirection.LTR\n                            ),\n                        )\n                    )\n                current_fragment = \"\"\n                current_direction = c.get_direction_from_level()\n            current_fragment += c.character\n        if current_fragment:\n            bidi_fragments.append(\n                (\n                    current_fragment,\n                    (\n                        TextDirection.RTL\n                        if current_direction == \"R\"\n                        else TextDirection.LTR\n                    ),\n                )\n            )\n        return tuple(bidi_fragments)\n\n    def reorder_resolved_levels(self) -> tuple[BidiCharacter, ...]:\n        before_separator = True\n        end_of_line = True\n        max_level = 0\n        min_odd_level = 999\n        for bidi_char in reversed(self.characters):\n            # Rule L1. Reset the embedding level of segment separators, paragraph separators,\n            # and any adjacent whitespace.\n            if bidi_char.original_bidi_class in (\"S\", \"B\"):\n                bidi_char.embedding_level = self.base_embedding_level\n                before_separator = True\n            elif bidi_char.original_bidi_class in (\n                \"BN\",\n                \"WS\",\n                \"FSI\",\n                \"LRI\",\n                \"RLI\",\n                \"PDI\",\n            ):\n                if before_separator or end_of_line:\n                    bidi_char.embedding_level = self.base_embedding_level\n            else:\n                before_separator = False\n                end_of_line = False\n\n            if bidi_char.embedding_level > max_level:\n                max_level = bidi_char.embedding_level\n            if (\n                bidi_char.embedding_level % 2 != 0\n                and bidi_char.embedding_level < min_odd_level\n            ):\n                min_odd_level = bidi_char.embedding_level\n\n        # Rule L2. From the highest level found in the text to the lowest odd level on each line,\n        # reverse any contiguous sequence of characters that are at that level or higher.\n        reordered_paragraph = self.characters.copy()\n        for level in range(max_level, min_odd_level - 1, -1):\n            temp_results: list[BidiCharacter] = []\n            rev: list[BidiCharacter] = []\n            for bidi_char in reordered_paragraph:\n                if bidi_char.embedding_level >= level:\n                    rev.append(bidi_char)\n                else:\n                    if rev:\n                        rev.reverse()\n                        temp_results += rev\n                        rev = []\n                    temp_results.append(bidi_char)\n            if rev:\n                rev.reverse()\n                temp_results += rev\n            reordered_paragraph = temp_results\n        return tuple(reordered_paragraph)",
      "language": "python"
    },
    {
      "code": "class BidiParagraph:\n    __slots__ = (\n        \"text\",\n        \"base_direction\",\n        \"debug\",\n        \"base_embedding_level\",\n        \"characters\",\n    )\n\n    def __init__(\n        self,\n        text: str,\n        base_direction: Optional[TextDirection] = None,\n        debug: bool = False,\n    ) -> None:\n        self.text = text\n        self.base_direction = (\n            auto_detect_base_direction(self.text, debug)\n            if not base_direction\n            else base_direction\n        )\n        self.debug = debug\n        self.base_embedding_level = (\n            0 if self.base_direction == TextDirection.LTR else 1\n        )  # base level\n        self.characters: list[BidiCharacter] = []\n        self.get_bidi_characters()\n\n    def get_characters(self) -> list[BidiCharacter]:\n        return self.characters\n\n    def get_characters_with_embedding_level(self) -> list[BidiCharacter]:\n        # Calculate embedding level for each character after breaking isolating runs.\n        # Only used on conformance testing\n        self.reorder_resolved_levels()\n        return self.characters\n\n    def get_reordered_characters(self) -> tuple[BidiCharacter, ...]:\n        return self.reorder_resolved_levels()\n\n    def get_all(self) -> tuple[list[BidiCharacter], tuple[BidiCharacter, ...]]:\n        return self.characters, self.reorder_resolved_levels()\n\n    def get_reordered_string(self) -> str:\n        \"Used for conformance validation\"\n        return \"\".join(c.character for c in self.reorder_resolved_levels())\n\n    def get_bidi_fragments(self) -> tuple[tuple[str, TextDirection], ...]:\n        return self.split_bidi_fragments()\n\n    def get_bidi_characters(self) -> None:\n        # Explicit levels and directions. Rule X1\n\n        stack: deque[DirectionalStatus] = deque()\n        current_status = DirectionalStatus(\n            embedding_level=self.base_embedding_level,\n            directional_override_status=\"N\",\n            directional_isolate_status=False,\n        )\n        stack.append(replace(current_status))\n        overflow_isolate_count = 0\n        overflow_embedding_count = 0\n        valid_isolate_count = 0\n        results: list[BidiCharacter] = []\n\n        # Explicit embeddings. Process each character individually applying rules X2 through X8\n        for index, char in enumerate(self.text):\n            bidi_char = BidiCharacter(\n                index, char, current_status.embedding_level, self.debug\n            )\n            new_bidi_class = None\n\n            if bidi_char.bidi_class == \"FSI\":\n                bidi_char.bidi_class = (\n                    \"LRI\"\n                    if auto_detect_base_direction(\n                        self.text[index + 1 :], stop_at_pdi=True, debug=self.debug\n                    )\n                    == TextDirection.LTR\n                    else \"RLI\"\n                )\n\n            if bidi_char.bidi_class in (\"RLE\", \"LRE\", \"RLO\", \"LRO\", \"RLI\", \"LRI\"):\n                # X2 - X5: calculate explicit embeddings and explicit overrides\n                if bidi_char.bidi_class[0] == \"R\":\n                    new_embedding_level = (\n                        current_status.embedding_level + 1\n                    ) | 1  # least greater odd\n                else:\n                    new_embedding_level = (\n                        current_status.embedding_level + 2\n                    ) & ~1  # least greater even\n                if (\n                    bidi_char.bidi_class[2] == \"I\"\n                    and current_status.directional_override_status != \"N\"\n                ):\n                    new_bidi_class = current_status.directional_override_status\n                if (\n                    new_embedding_level <= MAX_DEPTH\n                    and overflow_isolate_count == 0\n                    and overflow_embedding_count == 0\n                ):\n                    current_status.embedding_level = new_embedding_level\n                    current_status.directional_override_status = (\n                        bidi_char.bidi_class[0]\n                        if bidi_char.bidi_class[2] == \"O\"\n                        else \"N\"\n                    )\n                    if bidi_char.bidi_class[2] == \"I\":\n                        valid_isolate_count += 1\n                        current_status.directional_isolate_status = True\n                    else:\n                        current_status.directional_isolate_status = False\n                    stack.append(replace(current_status))\n                else:\n                    if bidi_char.bidi_class[2] == \"I\":\n                        overflow_isolate_count += 1\n                    else:\n                        if overflow_isolate_count == 0:\n                            overflow_embedding_count += 1\n\n            if bidi_char.bidi_class not in (\n                \"B\",\n                \"BN\",\n                \"RLE\",\n                \"LRE\",\n                \"RLO\",\n                \"LRO\",\n                \"PDF\",\n                \"FSI\",\n                \"PDI\",\n            ):  # X6\n                if current_status.directional_override_status != \"N\":\n                    new_bidi_class = current_status.directional_override_status\n\n            if bidi_char.bidi_class == \"PDI\":  # X6a\n                if overflow_isolate_count > 0:\n                    overflow_isolate_count -= 1\n                elif valid_isolate_count > 0:\n                    overflow_embedding_count = 0\n                    while True:\n                        if not stack[-1].directional_isolate_status:\n                            stack.pop()\n                            continue\n                        break\n                    stack.pop()\n                    current_status = replace(stack[-1])\n                    valid_isolate_count -= 1\n                assert isinstance(current_status, DirectionalStatus)\n                bidi_char.embedding_level = current_status.embedding_level\n                if current_status.directional_override_status != \"N\":\n                    new_bidi_class = current_status.directional_override_status\n\n            if bidi_char.bidi_class == \"PDF\":  # X7\n                if overflow_isolate_count == 0:\n                    if overflow_embedding_count > 0:\n                        overflow_embedding_count -= 1\n                    else:\n                        if (\n                            not current_status.directional_isolate_status\n                            and len(stack) > 1\n                        ):\n                            stack.pop()\n                            current_status = replace(stack[-1])\n\n            if new_bidi_class:\n                bidi_char.bidi_class = new_bidi_class\n            if bidi_char.bidi_class not in (\n                \"RLE\",\n                \"LRE\",\n                \"RLO\",\n                \"LRO\",\n                \"PDF\",\n                \"BN\",\n            ):  # X9\n                if bidi_char.bidi_class == \"B\":\n                    bidi_char.embedding_level = self.base_embedding_level\n                elif bidi_char.original_bidi_class not in (\"LRI\", \"RLI\", \"FSI\"):\n                    bidi_char.embedding_level = current_status.embedding_level\n                results.append(bidi_char)\n\n        if not results:\n            self.characters = []\n            return\n        self.characters = results\n        calculate_isolate_runs(results)\n\n    def split_bidi_fragments(self) -> tuple[tuple[str, TextDirection], ...]:\n        bidi_fragments: list[tuple[str, TextDirection]] = []\n        if len(self.characters) == 0:\n            return ()\n        current_fragment = \"\"\n        current_direction = \"\"\n        for c in self.characters:\n            if c.get_direction_from_level() != current_direction:\n                if current_fragment:\n                    bidi_fragments.append(\n                        (\n                            current_fragment,\n                            (\n                                TextDirection.RTL\n                                if current_direction == \"R\"\n                                else TextDirection.LTR\n                            ),\n                        )\n                    )\n                current_fragment = \"\"\n                current_direction = c.get_direction_from_level()\n            current_fragment += c.character\n        if current_fragment:\n            bidi_fragments.append(\n                (\n                    current_fragment,\n                    (\n                        TextDirection.RTL\n                        if current_direction == \"R\"\n                        else TextDirection.LTR\n                    ),\n                )\n            )\n        return tuple(bidi_fragments)\n\n    def reorder_resolved_levels(self) -> tuple[BidiCharacter, ...]:\n        before_separator = True\n        end_of_line = True\n        max_level = 0\n        min_odd_level = 999\n        for bidi_char in reversed(self.characters):\n            # Rule L1. Reset the embedding level of segment separators, paragraph separators,\n            # and any adjacent whitespace.\n            if bidi_char.original_bidi_class in (\"S\", \"B\"):\n                bidi_char.embedding_level = self.base_embedding_level\n                before_separator = True\n            elif bidi_char.original_bidi_class in (\n                \"BN\",\n                \"WS\",\n                \"FSI\",\n                \"LRI\",\n                \"RLI\",\n                \"PDI\",\n            ):\n                if before_separator or end_of_line:\n                    bidi_char.embedding_level = self.base_embedding_level\n            else:\n                before_separator = False\n                end_of_line = False\n\n            if bidi_char.embedding_level > max_level:\n                max_level = bidi_char.embedding_level\n            if (\n                bidi_char.embedding_level % 2 != 0\n                and bidi_char.embedding_level < min_odd_level\n            ):\n                min_odd_level = bidi_char.embedding_level\n\n        # Rule L2. From the highest level found in the text to the lowest odd level on each line,\n        # reverse any contiguous sequence of characters that are at that level or higher.\n        reordered_paragraph = self.characters.copy()\n        for level in range(max_level, min_odd_level - 1, -1):\n            temp_results: list[BidiCharacter] = []\n            rev: list[BidiCharacter] = []\n            for bidi_char in reordered_paragraph:\n                if bidi_char.embedding_level >= level:\n                    rev.append(bidi_char)\n                else:\n                    if rev:\n                        rev.reverse()\n                        temp_results += rev\n                        rev = []\n                    temp_results.append(bidi_char)\n            if rev:\n                rev.reverse()\n                temp_results += rev\n            reordered_paragraph = temp_results\n        return tuple(reordered_paragraph)",
      "language": "python"
    },
    {
      "code": "def get_all(self) -> tuple[list[BidiCharacter], tuple[BidiCharacter, ...]]:\n    return self.characters, self.reorder_resolved_levels()",
      "language": "python"
    },
    {
      "code": "def get_bidi_characters(self) -> None:\n    # Explicit levels and directions. Rule X1\n\n    stack: deque[DirectionalStatus] = deque()\n    current_status = DirectionalStatus(\n        embedding_level=self.base_embedding_level,\n        directional_override_status=\"N\",\n        directional_isolate_status=False,\n    )\n    stack.append(replace(current_status))\n    overflow_isolate_count = 0\n    overflow_embedding_count = 0\n    valid_isolate_count = 0\n    results: list[BidiCharacter] = []\n\n    # Explicit embeddings. Process each character individually applying rules X2 through X8\n    for index, char in enumerate(self.text):\n        bidi_char = BidiCharacter(\n            index, char, current_status.embedding_level, self.debug\n        )\n        new_bidi_class = None\n\n        if bidi_char.bidi_class == \"FSI\":\n            bidi_char.bidi_class = (\n                \"LRI\"\n                if auto_detect_base_direction(\n                    self.text[index + 1 :], stop_at_pdi=True, debug=self.debug\n                )\n                == TextDirection.LTR\n                else \"RLI\"\n            )\n\n        if bidi_char.bidi_class in (\"RLE\", \"LRE\", \"RLO\", \"LRO\", \"RLI\", \"LRI\"):\n            # X2 - X5: calculate explicit embeddings and explicit overrides\n            if bidi_char.bidi_class[0] == \"R\":\n                new_embedding_level = (\n                    current_status.embedding_level + 1\n                ) | 1  # least greater odd\n            else:\n                new_embedding_level = (\n                    current_status.embedding_level + 2\n                ) & ~1  # least greater even\n            if (\n                bidi_char.bidi_class[2] == \"I\"\n                and current_status.directional_override_status != \"N\"\n            ):\n                new_bidi_class = current_status.directional_override_status\n            if (\n                new_embedding_level <= MAX_DEPTH\n                and overflow_isolate_count == 0\n                and overflow_embedding_count == 0\n            ):\n                current_status.embedding_level = new_embedding_level\n                current_status.directional_override_status = (\n                    bidi_char.bidi_class[0]\n                    if bidi_char.bidi_class[2] == \"O\"\n                    else \"N\"\n                )\n                if bidi_char.bidi_class[2] == \"I\":\n                    valid_isolate_count += 1\n                    current_status.directional_isolate_status = True\n                else:\n                    current_status.directional_isolate_status = False\n                stack.append(replace(current_status))\n            else:\n                if bidi_char.bidi_class[2] == \"I\":\n                    overflow_isolate_count += 1\n                else:\n                    if overflow_isolate_count == 0:\n                        overflow_embedding_count += 1\n\n        if bidi_char.bidi_class not in (\n            \"B\",\n            \"BN\",\n            \"RLE\",\n            \"LRE\",\n            \"RLO\",\n            \"LRO\",\n            \"PDF\",\n            \"FSI\",\n            \"PDI\",\n        ):  # X6\n            if current_status.directional_override_status != \"N\":\n                new_bidi_class = current_status.directional_override_status\n\n        if bidi_char.bidi_class == \"PDI\":  # X6a\n            if overflow_isolate_count > 0:\n                overflow_isolate_count -= 1\n            elif valid_isolate_count > 0:\n                overflow_embedding_count = 0\n                while True:\n                    if not stack[-1].directional_isolate_status:\n                        stack.pop()\n                        continue\n                    break\n                stack.pop()\n                current_status = replace(stack[-1])\n                valid_isolate_count -= 1\n            assert isinstance(current_status, DirectionalStatus)\n            bidi_char.embedding_level = current_status.embedding_level\n            if current_status.directional_override_status != \"N\":\n                new_bidi_class = current_status.directional_override_status\n\n        if bidi_char.bidi_class == \"PDF\":  # X7\n            if overflow_isolate_count == 0:\n                if overflow_embedding_count > 0:\n                    overflow_embedding_count -= 1\n                else:\n                    if (\n                        not current_status.directional_isolate_status\n                        and len(stack) > 1\n                    ):\n                        stack.pop()\n                        current_status = replace(stack[-1])\n\n        if new_bidi_class:\n            bidi_char.bidi_class = new_bidi_class\n        if bidi_char.bidi_class not in (\n            \"RLE\",\n            \"LRE\",\n            \"RLO\",\n            \"LRO\",\n            \"PDF\",\n            \"BN\",\n        ):  # X9\n            if bidi_char.bidi_class == \"B\":\n                bidi_char.embedding_level = self.base_embedding_level\n            elif bidi_char.original_bidi_class not in (\"LRI\", \"RLI\", \"FSI\"):\n                bidi_char.embedding_level = current_status.embedding_level\n            results.append(bidi_char)\n\n    if not results:\n        self.characters = []\n        return\n    self.characters = results\n    calculate_isolate_runs(results)",
      "language": "python"
    },
    {
      "code": "def get_bidi_fragments(self) -> tuple[tuple[str, TextDirection], ...]:\n    return self.split_bidi_fragments()",
      "language": "python"
    },
    {
      "code": "def get_characters(self) -> list[BidiCharacter]:\n    return self.characters",
      "language": "python"
    },
    {
      "code": "def get_characters_with_embedding_level(self) -> list[BidiCharacter]:\n    # Calculate embedding level for each character after breaking isolating runs.\n    # Only used on conformance testing\n    self.reorder_resolved_levels()\n    return self.characters",
      "language": "python"
    },
    {
      "code": "def get_reordered_characters(self) -> tuple[BidiCharacter, ...]:\n    return self.reorder_resolved_levels()",
      "language": "python"
    },
    {
      "code": "def get_reordered_string(self) -> str:\n    \"Used for conformance validation\"\n    return \"\".join(c.character for c in self.reorder_resolved_levels())",
      "language": "python"
    },
    {
      "code": "def reorder_resolved_levels(self) -> tuple[BidiCharacter, ...]:\n    before_separator = True\n    end_of_line = True\n    max_level = 0\n    min_odd_level = 999\n    for bidi_char in reversed(self.characters):\n        # Rule L1. Reset the embedding level of segment separators, paragraph separators,\n        # and any adjacent whitespace.\n        if bidi_char.original_bidi_class in (\"S\", \"B\"):\n            bidi_char.embedding_level = self.base_embedding_level\n            before_separator = True\n        elif bidi_char.original_bidi_class in (\n            \"BN\",\n            \"WS\",\n            \"FSI\",\n            \"LRI\",\n            \"RLI\",\n            \"PDI\",\n        ):\n            if before_separator or end_of_line:\n                bidi_char.embedding_level = self.base_embedding_level\n        else:\n            before_separator = False\n            end_of_line = False\n\n        if bidi_char.embedding_level > max_level:\n            max_level = bidi_char.embedding_level\n        if (\n            bidi_char.embedding_level % 2 != 0\n            and bidi_char.embedding_level < min_odd_level\n        ):\n            min_odd_level = bidi_char.embedding_level\n\n    # Rule L2. From the highest level found in the text to the lowest odd level on each line,\n    # reverse any contiguous sequence of characters that are at that level or higher.\n    reordered_paragraph = self.characters.copy()\n    for level in range(max_level, min_odd_level - 1, -1):\n        temp_results: list[BidiCharacter] = []\n        rev: list[BidiCharacter] = []\n        for bidi_char in reordered_paragraph:\n            if bidi_char.embedding_level >= level:\n                rev.append(bidi_char)\n            else:\n                if rev:\n                    rev.reverse()\n                    temp_results += rev\n                    rev = []\n                temp_results.append(bidi_char)\n        if rev:\n            rev.reverse()\n            temp_results += rev\n        reordered_paragraph = temp_results\n    return tuple(reordered_paragraph)",
      "language": "python"
    },
    {
      "code": "def split_bidi_fragments(self) -> tuple[tuple[str, TextDirection], ...]:\n    bidi_fragments: list[tuple[str, TextDirection]] = []\n    if len(self.characters) == 0:\n        return ()\n    current_fragment = \"\"\n    current_direction = \"\"\n    for c in self.characters:\n        if c.get_direction_from_level() != current_direction:\n            if current_fragment:\n                bidi_fragments.append(\n                    (\n                        current_fragment,\n                        (\n                            TextDirection.RTL\n                            if current_direction == \"R\"\n                            else TextDirection.LTR\n                        ),\n                    )\n                )\n            current_fragment = \"\"\n            current_direction = c.get_direction_from_level()\n        current_fragment += c.character\n    if current_fragment:\n        bidi_fragments.append(\n            (\n                current_fragment,\n                (\n                    TextDirection.RTL\n                    if current_direction == \"R\"\n                    else TextDirection.LTR\n                ),\n            )\n        )\n    return tuple(bidi_fragments)",
      "language": "python"
    },
    {
      "code": "@dataclass\nclass DirectionalStatus:\n    __slots__ = [\n        \"embedding_level\",\n        \"directional_override_status\",\n        \"directional_isolate_status\",\n    ]\n    embedding_level: int  # between 0 and MAX_DEPTH\n    directional_override_status: str  # \"N\" (Neutral), \"L\" (Left) or \"R\" (Right)\n    directional_isolate_status: bool",
      "language": "python"
    },
    {
      "code": "@dataclass\nclass DirectionalStatus:\n    __slots__ = [\n        \"embedding_level\",\n        \"directional_override_status\",\n        \"directional_isolate_status\",\n    ]\n    embedding_level: int  # between 0 and MAX_DEPTH\n    directional_override_status: str  # \"N\" (Neutral), \"L\" (Left) or \"R\" (Right)\n    directional_isolate_status: bool",
      "language": "python"
    },
    {
      "code": "@dataclass\nclass DirectionalStatus:\n    __slots__ = [\n        \"embedding_level\",\n        \"directional_override_status\",\n        \"directional_isolate_status\",\n    ]\n    embedding_level: int  # between 0 and MAX_DEPTH\n    directional_override_status: str  # \"N\" (Neutral), \"L\" (Left) or \"R\" (Right)\n    directional_isolate_status: bool",
      "language": "python"
    },
    {
      "code": "@dataclass\nclass DirectionalStatus:\n    __slots__ = [\n        \"embedding_level\",\n        \"directional_override_status\",\n        \"directional_isolate_status\",\n    ]\n    embedding_level: int  # between 0 and MAX_DEPTH\n    directional_override_status: str  # \"N\" (Neutral), \"L\" (Left) or \"R\" (Right)\n    directional_isolate_status: bool",
      "language": "python"
    },
    {
      "code": "class IsolatingRun:\n    __slots__ = [\"characters\", \"previous_direction\", \"next_direction\"]\n\n    def __init__(self, characters: list[BidiCharacter], sos: str, eos: str) -> None:\n        self.characters = characters\n        self.previous_direction = sos\n        self.next_direction = eos\n        self.resolve_weak_types()\n        self.resolve_neutral_types()\n        self.resolve_implicit_levels()\n\n    def resolve_weak_types(self) -> None:\n        # W1. Examine each nonspacing mark (NSM) in the isolating run sequence, and change the type of the NSM to Other Neutral\n        #     if the previous character is an isolate initiator or PDI, and to the type of the previous character otherwise.\n        #     If the NSM is at the start of the isolating run sequence, it will get the type of sos.\n        for i, bidi_char in enumerate(self.characters):\n            if bidi_char.bidi_class == \"NSM\":\n                if i == 0:\n                    bidi_char.set_class(self.previous_direction)\n                else:\n                    bidi_char.set_class(\n                        \"ON\"\n                        if self.characters[i - 1].bidi_class\n                        in (\"LRI\", \"RLI\", \"FSI\", \"PDI\")\n                        else self.characters[i - 1].bidi_class\n                    )\n\n        # W2. Search backward from each instance of a European number until the first strong type (R, L, AL, or sos) is found.\n        #     If an AL is found, change the type of the European number to Arabic number.\n        # W3. Change all ALs to R.\n\n        last_strong_type = self.previous_direction\n        for bidi_char in self.characters:\n            if bidi_char.bidi_class in (\"R\", \"L\", \"AL\"):\n                last_strong_type = bidi_char.bidi_class\n            if bidi_char.bidi_class == \"AL\":\n                bidi_char.set_class(\"R\")\n            if bidi_char.bidi_class == \"EN\" and last_strong_type == \"AL\":\n                bidi_char.set_class(\"AN\")\n\n        # W4. A single European separator between two European numbers changes to a European number.\n        #     A single common separator between two numbers of the same type changes to that type.\n        for i, bidi_char in enumerate(self.characters):\n            if i in (0, len(self.characters) - 1):\n                continue\n            if (\n                bidi_char.bidi_class == \"ES\"\n                and self.characters[i - 1].bidi_class == \"EN\"\n                and self.characters[i + 1].bidi_class == \"EN\"\n            ):\n                bidi_char.set_class(\"EN\")\n\n            if (\n                bidi_char.bidi_class == \"CS\"\n                and self.characters[i - 1].bidi_class in (\"AN\", \"EN\")\n                and self.characters[i + 1].bidi_class\n                == self.characters[i - 1].bidi_class\n            ):\n                bidi_char.set_class(self.characters[i - 1].bidi_class)\n\n        # W5. A sequence of European terminators adjacent to European numbers changes to all European numbers.\n        # W6. All remaining separators and terminators (after the application of W4 and W5) change to Other Neutral.\n        def prev_is_en(i: int) -> bool:\n            if i == 0:\n                return False\n            if self.characters[i - 1].bidi_class == \"ET\":\n                return prev_is_en(i - 1)\n            return self.characters[i - 1].bidi_class == \"EN\"\n\n        def next_is_en(i: int) -> bool:\n            if i == len(self.characters) - 1:\n                return False\n            if self.characters[i + 1].bidi_class == \"ET\":\n                return next_is_en(i + 1)\n            return self.characters[i + 1].bidi_class == \"EN\"\n\n        for i, bidi_char in enumerate(self.characters):\n            if bidi_char.bidi_class == \"ET\":\n                if prev_is_en(i) or next_is_en(i):\n                    bidi_char.set_class(\"EN\")\n\n            if bidi_char.bidi_class in (\"ET\", \"ES\", \"CS\"):\n                bidi_char.set_class(\"ON\")\n        # W7. Search backward from each instance of a European number until the first strong type (R, L, or sos) is found.\n        #     If an L is found, then change the type of the European number to L.\n        last_strong_type = self.previous_direction\n        for bidi_char in self.characters:\n            if bidi_char.bidi_class in (\"R\", \"L\", \"AL\"):\n                last_strong_type = bidi_char.bidi_class\n            if bidi_char.bidi_class == \"EN\" and last_strong_type == \"L\":\n                bidi_char.set_class(\"L\")\n\n    def pair_brackets(self) -> list[tuple[int, int]]:\n        \"\"\"\n        Calculate all the bracket pairs on an isolate run, to be used on rule N0\n        How to calculate bracket pairs:\n        - Basic definitions 14, 15 and 16: http://www.unicode.org/reports/tr9/#BD14\n        - BIDI brackets for dummies: https://www.unicode.org/notes/tn39/\n        \"\"\"\n        open_brackets: list[tuple[str, int]] = []\n        open_bracket_count = 0\n        bracket_pairs: list[tuple[int, int]] = []\n        for index, char in enumerate(self.characters):\n            if char.character in BIDI_BRACKETS and char.bidi_class == \"ON\":\n                if BIDI_BRACKETS[char.character][\"type\"] == \"o\":\n                    if open_bracket_count >= 63:\n                        return []\n                    open_brackets.append((char.character, index))\n                    open_bracket_count += 1\n                if BIDI_BRACKETS[char.character][\"type\"] == \"c\":\n                    if open_bracket_count == 0:\n                        continue\n                    for current_open_bracket in range(open_bracket_count, 0, -1):\n                        open_char, open_index = open_brackets[current_open_bracket - 1]\n                        if (BIDI_BRACKETS[open_char][\"pair\"] == char.character) or (\n                            BIDI_BRACKETS[open_char][\"pair\"] in (\"\", \"\")\n                            and char.character in (\"\", \"\")\n                        ):\n                            bracket_pairs.append((open_index, index))\n                            open_brackets = open_brackets[: current_open_bracket - 1]\n                            open_bracket_count = current_open_bracket - 1\n                            break\n        return sorted(bracket_pairs, key=itemgetter(0))\n\n    def resolve_neutral_types(self) -> None:\n        def previous_strong(index: int) -> str:\n            if index == 0:\n                return self.previous_direction\n            if self.characters[index - 1].bidi_class == \"L\":\n                return \"L\"\n            if self.characters[index - 1].bidi_class in (\"R\", \"AN\", \"EN\"):\n                return \"R\"\n            return previous_strong(index - 1)\n\n        def next_strong(index: int) -> str:\n            if index >= len(self.characters) - 1:\n                return self.next_direction\n            if self.characters[index + 1].bidi_class == \"L\":\n                return \"L\"\n            if self.characters[index + 1].bidi_class in (\"R\", \"AN\", \"EN\"):\n                return \"R\"\n            return next_strong(index + 1)\n\n        # N0-N2: Resolving neutral types\n        # N0\n        brackets = self.pair_brackets()\n        if brackets:\n            embedding_direction = self.characters[0].get_direction_from_level()\n            for b in brackets:\n                strong_same_direction = False\n                strong_opposite_direction = False\n                resulting_direction = None\n                for index in range(b[0], b[1]):\n                    if (\n                        self.characters[index].bidi_class == \"L\"\n                        and embedding_direction == \"L\"\n                    ) or (\n                        self.characters[index].bidi_class in (\"R\", \"AN\", \"EN\")\n                        and embedding_direction == \"R\"\n                    ):\n                        strong_same_direction = True\n                        break\n                    if (\n                        self.characters[index].bidi_class == \"L\"\n                        and embedding_direction == \"R\"\n                    ) or (\n                        self.characters[index].bidi_class in (\"R\", \"AN\", \"EN\")\n                        and embedding_direction == \"L\"\n                    ):\n                        strong_opposite_direction = True\n                if strong_same_direction:\n                    resulting_direction = embedding_direction\n                elif strong_opposite_direction:\n                    opposite_direction = \"L\" if embedding_direction == \"R\" else \"R\"\n                    if previous_strong(b[0]) == opposite_direction:\n                        resulting_direction = opposite_direction\n                    else:\n                        resulting_direction = embedding_direction\n                if resulting_direction:\n                    self.characters[b[0]].bidi_class = resulting_direction\n                    self.characters[b[1]].bidi_class = resulting_direction\n                    if len(self.characters) > b[1] + 1:\n                        next_char = self.characters[b[1] + 1]\n                        if (\n                            next_char.original_bidi_class == \"NSM\"\n                            and next_char.bidi_class == \"ON\"\n                        ):\n                            next_char.bidi_class = resulting_direction\n\n        for i, bidi_char in enumerate(self.characters):\n            # N1-N2\n            if bidi_char.bidi_class in (\n                \"B\",\n                \"S\",\n                \"WS\",\n                \"ON\",\n                \"FSI\",\n                \"LRI\",\n                \"RLI\",\n                \"PDI\",\n            ):\n                if previous_strong(i) == next_strong(i):\n                    bidi_char.bidi_class = previous_strong(i)\n                else:\n                    bidi_char.bidi_class = bidi_char.get_direction_from_level()\n\n    def resolve_implicit_levels(self) -> None:\n        for bidi_char in self.characters:\n            # I1. For all characters with an even (left-to-right) embedding level,\n            #     those of type R go up one level and those of type AN or EN go up two levels.\n            if bidi_char.embedding_level % 2 == 0:\n                if bidi_char.bidi_class == \"R\":\n                    bidi_char.embedding_level += 1\n                if bidi_char.bidi_class in (\"AN\", \"EN\"):\n                    bidi_char.embedding_level += 2\n\n            # I2. For all characters with an odd (right-to-left) embedding level, those of type L, EN or AN go up one level.\n            else:\n                if bidi_char.bidi_class in (\"L\", \"EN\", \"AN\"):\n                    bidi_char.embedding_level += 1",
      "language": "python"
    },
    {
      "code": "class IsolatingRun:\n    __slots__ = [\"characters\", \"previous_direction\", \"next_direction\"]\n\n    def __init__(self, characters: list[BidiCharacter], sos: str, eos: str) -> None:\n        self.characters = characters\n        self.previous_direction = sos\n        self.next_direction = eos\n        self.resolve_weak_types()\n        self.resolve_neutral_types()\n        self.resolve_implicit_levels()\n\n    def resolve_weak_types(self) -> None:\n        # W1. Examine each nonspacing mark (NSM) in the isolating run sequence, and change the type of the NSM to Other Neutral\n        #     if the previous character is an isolate initiator or PDI, and to the type of the previous character otherwise.\n        #     If the NSM is at the start of the isolating run sequence, it will get the type of sos.\n        for i, bidi_char in enumerate(self.characters):\n            if bidi_char.bidi_class == \"NSM\":\n                if i == 0:\n                    bidi_char.set_class(self.previous_direction)\n                else:\n                    bidi_char.set_class(\n                        \"ON\"\n                        if self.characters[i - 1].bidi_class\n                        in (\"LRI\", \"RLI\", \"FSI\", \"PDI\")\n                        else self.characters[i - 1].bidi_class\n                    )\n\n        # W2. Search backward from each instance of a European number until the first strong type (R, L, AL, or sos) is found.\n        #     If an AL is found, change the type of the European number to Arabic number.\n        # W3. Change all ALs to R.\n\n        last_strong_type = self.previous_direction\n        for bidi_char in self.characters:\n            if bidi_char.bidi_class in (\"R\", \"L\", \"AL\"):\n                last_strong_type = bidi_char.bidi_class\n            if bidi_char.bidi_class == \"AL\":\n                bidi_char.set_class(\"R\")\n            if bidi_char.bidi_class == \"EN\" and last_strong_type == \"AL\":\n                bidi_char.set_class(\"AN\")\n\n        # W4. A single European separator between two European numbers changes to a European number.\n        #     A single common separator between two numbers of the same type changes to that type.\n        for i, bidi_char in enumerate(self.characters):\n            if i in (0, len(self.characters) - 1):\n                continue\n            if (\n                bidi_char.bidi_class == \"ES\"\n                and self.characters[i - 1].bidi_class == \"EN\"\n                and self.characters[i + 1].bidi_class == \"EN\"\n            ):\n                bidi_char.set_class(\"EN\")\n\n            if (\n                bidi_char.bidi_class == \"CS\"\n                and self.characters[i - 1].bidi_class in (\"AN\", \"EN\")\n                and self.characters[i + 1].bidi_class\n                == self.characters[i - 1].bidi_class\n            ):\n                bidi_char.set_class(self.characters[i - 1].bidi_class)\n\n        # W5. A sequence of European terminators adjacent to European numbers changes to all European numbers.\n        # W6. All remaining separators and terminators (after the application of W4 and W5) change to Other Neutral.\n        def prev_is_en(i: int) -> bool:\n            if i == 0:\n                return False\n            if self.characters[i - 1].bidi_class == \"ET\":\n                return prev_is_en(i - 1)\n            return self.characters[i - 1].bidi_class == \"EN\"\n\n        def next_is_en(i: int) -> bool:\n            if i == len(self.characters) - 1:\n                return False\n            if self.characters[i + 1].bidi_class == \"ET\":\n                return next_is_en(i + 1)\n            return self.characters[i + 1].bidi_class == \"EN\"\n\n        for i, bidi_char in enumerate(self.characters):\n            if bidi_char.bidi_class == \"ET\":\n                if prev_is_en(i) or next_is_en(i):\n                    bidi_char.set_class(\"EN\")\n\n            if bidi_char.bidi_class in (\"ET\", \"ES\", \"CS\"):\n                bidi_char.set_class(\"ON\")\n        # W7. Search backward from each instance of a European number until the first strong type (R, L, or sos) is found.\n        #     If an L is found, then change the type of the European number to L.\n        last_strong_type = self.previous_direction\n        for bidi_char in self.characters:\n            if bidi_char.bidi_class in (\"R\", \"L\", \"AL\"):\n                last_strong_type = bidi_char.bidi_class\n            if bidi_char.bidi_class == \"EN\" and last_strong_type == \"L\":\n                bidi_char.set_class(\"L\")\n\n    def pair_brackets(self) -> list[tuple[int, int]]:\n        \"\"\"\n        Calculate all the bracket pairs on an isolate run, to be used on rule N0\n        How to calculate bracket pairs:\n        - Basic definitions 14, 15 and 16: http://www.unicode.org/reports/tr9/#BD14\n        - BIDI brackets for dummies: https://www.unicode.org/notes/tn39/\n        \"\"\"\n        open_brackets: list[tuple[str, int]] = []\n        open_bracket_count = 0\n        bracket_pairs: list[tuple[int, int]] = []\n        for index, char in enumerate(self.characters):\n            if char.character in BIDI_BRACKETS and char.bidi_class == \"ON\":\n                if BIDI_BRACKETS[char.character][\"type\"] == \"o\":\n                    if open_bracket_count >= 63:\n                        return []\n                    open_brackets.append((char.character, index))\n                    open_bracket_count += 1\n                if BIDI_BRACKETS[char.character][\"type\"] == \"c\":\n                    if open_bracket_count == 0:\n                        continue\n                    for current_open_bracket in range(open_bracket_count, 0, -1):\n                        open_char, open_index = open_brackets[current_open_bracket - 1]\n                        if (BIDI_BRACKETS[open_char][\"pair\"] == char.character) or (\n                            BIDI_BRACKETS[open_char][\"pair\"] in (\"\", \"\")\n                            and char.character in (\"\", \"\")\n                        ):\n                            bracket_pairs.append((open_index, index))\n                            open_brackets = open_brackets[: current_open_bracket - 1]\n                            open_bracket_count = current_open_bracket - 1\n                            break\n        return sorted(bracket_pairs, key=itemgetter(0))\n\n    def resolve_neutral_types(self) -> None:\n        def previous_strong(index: int) -> str:\n            if index == 0:\n                return self.previous_direction\n            if self.characters[index - 1].bidi_class == \"L\":\n                return \"L\"\n            if self.characters[index - 1].bidi_class in (\"R\", \"AN\", \"EN\"):\n                return \"R\"\n            return previous_strong(index - 1)\n\n        def next_strong(index: int) -> str:\n            if index >= len(self.characters) - 1:\n                return self.next_direction\n            if self.characters[index + 1].bidi_class == \"L\":\n                return \"L\"\n            if self.characters[index + 1].bidi_class in (\"R\", \"AN\", \"EN\"):\n                return \"R\"\n            return next_strong(index + 1)\n\n        # N0-N2: Resolving neutral types\n        # N0\n        brackets = self.pair_brackets()\n        if brackets:\n            embedding_direction = self.characters[0].get_direction_from_level()\n            for b in brackets:\n                strong_same_direction = False\n                strong_opposite_direction = False\n                resulting_direction = None\n                for index in range(b[0], b[1]):\n                    if (\n                        self.characters[index].bidi_class == \"L\"\n                        and embedding_direction == \"L\"\n                    ) or (\n                        self.characters[index].bidi_class in (\"R\", \"AN\", \"EN\")\n                        and embedding_direction == \"R\"\n                    ):\n                        strong_same_direction = True\n                        break\n                    if (\n                        self.characters[index].bidi_class == \"L\"\n                        and embedding_direction == \"R\"\n                    ) or (\n                        self.characters[index].bidi_class in (\"R\", \"AN\", \"EN\")\n                        and embedding_direction == \"L\"\n                    ):\n                        strong_opposite_direction = True\n                if strong_same_direction:\n                    resulting_direction = embedding_direction\n                elif strong_opposite_direction:\n                    opposite_direction = \"L\" if embedding_direction == \"R\" else \"R\"\n                    if previous_strong(b[0]) == opposite_direction:\n                        resulting_direction = opposite_direction\n                    else:\n                        resulting_direction = embedding_direction\n                if resulting_direction:\n                    self.characters[b[0]].bidi_class = resulting_direction\n                    self.characters[b[1]].bidi_class = resulting_direction\n                    if len(self.characters) > b[1] + 1:\n                        next_char = self.characters[b[1] + 1]\n                        if (\n                            next_char.original_bidi_class == \"NSM\"\n                            and next_char.bidi_class == \"ON\"\n                        ):\n                            next_char.bidi_class = resulting_direction\n\n        for i, bidi_char in enumerate(self.characters):\n            # N1-N2\n            if bidi_char.bidi_class in (\n                \"B\",\n                \"S\",\n                \"WS\",\n                \"ON\",\n                \"FSI\",\n                \"LRI\",\n                \"RLI\",\n                \"PDI\",\n            ):\n                if previous_strong(i) == next_strong(i):\n                    bidi_char.bidi_class = previous_strong(i)\n                else:\n                    bidi_char.bidi_class = bidi_char.get_direction_from_level()\n\n    def resolve_implicit_levels(self) -> None:\n        for bidi_char in self.characters:\n            # I1. For all characters with an even (left-to-right) embedding level,\n            #     those of type R go up one level and those of type AN or EN go up two levels.\n            if bidi_char.embedding_level % 2 == 0:\n                if bidi_char.bidi_class == \"R\":\n                    bidi_char.embedding_level += 1\n                if bidi_char.bidi_class in (\"AN\", \"EN\"):\n                    bidi_char.embedding_level += 2\n\n            # I2. For all characters with an odd (right-to-left) embedding level, those of type L, EN or AN go up one level.\n            else:\n                if bidi_char.bidi_class in (\"L\", \"EN\", \"AN\"):\n                    bidi_char.embedding_level += 1",
      "language": "python"
    },
    {
      "code": "class IsolatingRun:\n    __slots__ = [\"characters\", \"previous_direction\", \"next_direction\"]\n\n    def __init__(self, characters: list[BidiCharacter], sos: str, eos: str) -> None:\n        self.characters = characters\n        self.previous_direction = sos\n        self.next_direction = eos\n        self.resolve_weak_types()\n        self.resolve_neutral_types()\n        self.resolve_implicit_levels()\n\n    def resolve_weak_types(self) -> None:\n        # W1. Examine each nonspacing mark (NSM) in the isolating run sequence, and change the type of the NSM to Other Neutral\n        #     if the previous character is an isolate initiator or PDI, and to the type of the previous character otherwise.\n        #     If the NSM is at the start of the isolating run sequence, it will get the type of sos.\n        for i, bidi_char in enumerate(self.characters):\n            if bidi_char.bidi_class == \"NSM\":\n                if i == 0:\n                    bidi_char.set_class(self.previous_direction)\n                else:\n                    bidi_char.set_class(\n                        \"ON\"\n                        if self.characters[i - 1].bidi_class\n                        in (\"LRI\", \"RLI\", \"FSI\", \"PDI\")\n                        else self.characters[i - 1].bidi_class\n                    )\n\n        # W2. Search backward from each instance of a European number until the first strong type (R, L, AL, or sos) is found.\n        #     If an AL is found, change the type of the European number to Arabic number.\n        # W3. Change all ALs to R.\n\n        last_strong_type = self.previous_direction\n        for bidi_char in self.characters:\n            if bidi_char.bidi_class in (\"R\", \"L\", \"AL\"):\n                last_strong_type = bidi_char.bidi_class\n            if bidi_char.bidi_class == \"AL\":\n                bidi_char.set_class(\"R\")\n            if bidi_char.bidi_class == \"EN\" and last_strong_type == \"AL\":\n                bidi_char.set_class(\"AN\")\n\n        # W4. A single European separator between two European numbers changes to a European number.\n        #     A single common separator between two numbers of the same type changes to that type.\n        for i, bidi_char in enumerate(self.characters):\n            if i in (0, len(self.characters) - 1):\n                continue\n            if (\n                bidi_char.bidi_class == \"ES\"\n                and self.characters[i - 1].bidi_class == \"EN\"\n                and self.characters[i + 1].bidi_class == \"EN\"\n            ):\n                bidi_char.set_class(\"EN\")\n\n            if (\n                bidi_char.bidi_class == \"CS\"\n                and self.characters[i - 1].bidi_class in (\"AN\", \"EN\")\n                and self.characters[i + 1].bidi_class\n                == self.characters[i - 1].bidi_class\n            ):\n                bidi_char.set_class(self.characters[i - 1].bidi_class)\n\n        # W5. A sequence of European terminators adjacent to European numbers changes to all European numbers.\n        # W6. All remaining separators and terminators (after the application of W4 and W5) change to Other Neutral.\n        def prev_is_en(i: int) -> bool:\n            if i == 0:\n                return False\n            if self.characters[i - 1].bidi_class == \"ET\":\n                return prev_is_en(i - 1)\n            return self.characters[i - 1].bidi_class == \"EN\"\n\n        def next_is_en(i: int) -> bool:\n            if i == len(self.characters) - 1:\n                return False\n            if self.characters[i + 1].bidi_class == \"ET\":\n                return next_is_en(i + 1)\n            return self.characters[i + 1].bidi_class == \"EN\"\n\n        for i, bidi_char in enumerate(self.characters):\n            if bidi_char.bidi_class == \"ET\":\n                if prev_is_en(i) or next_is_en(i):\n                    bidi_char.set_class(\"EN\")\n\n            if bidi_char.bidi_class in (\"ET\", \"ES\", \"CS\"):\n                bidi_char.set_class(\"ON\")\n        # W7. Search backward from each instance of a European number until the first strong type (R, L, or sos) is found.\n        #     If an L is found, then change the type of the European number to L.\n        last_strong_type = self.previous_direction\n        for bidi_char in self.characters:\n            if bidi_char.bidi_class in (\"R\", \"L\", \"AL\"):\n                last_strong_type = bidi_char.bidi_class\n            if bidi_char.bidi_class == \"EN\" and last_strong_type == \"L\":\n                bidi_char.set_class(\"L\")\n\n    def pair_brackets(self) -> list[tuple[int, int]]:\n        \"\"\"\n        Calculate all the bracket pairs on an isolate run, to be used on rule N0\n        How to calculate bracket pairs:\n        - Basic definitions 14, 15 and 16: http://www.unicode.org/reports/tr9/#BD14\n        - BIDI brackets for dummies: https://www.unicode.org/notes/tn39/\n        \"\"\"\n        open_brackets: list[tuple[str, int]] = []\n        open_bracket_count = 0\n        bracket_pairs: list[tuple[int, int]] = []\n        for index, char in enumerate(self.characters):\n            if char.character in BIDI_BRACKETS and char.bidi_class == \"ON\":\n                if BIDI_BRACKETS[char.character][\"type\"] == \"o\":\n                    if open_bracket_count >= 63:\n                        return []\n                    open_brackets.append((char.character, index))\n                    open_bracket_count += 1\n                if BIDI_BRACKETS[char.character][\"type\"] == \"c\":\n                    if open_bracket_count == 0:\n                        continue\n                    for current_open_bracket in range(open_bracket_count, 0, -1):\n                        open_char, open_index = open_brackets[current_open_bracket - 1]\n                        if (BIDI_BRACKETS[open_char][\"pair\"] == char.character) or (\n                            BIDI_BRACKETS[open_char][\"pair\"] in (\"\", \"\")\n                            and char.character in (\"\", \"\")\n                        ):\n                            bracket_pairs.append((open_index, index))\n                            open_brackets = open_brackets[: current_open_bracket - 1]\n                            open_bracket_count = current_open_bracket - 1\n                            break\n        return sorted(bracket_pairs, key=itemgetter(0))\n\n    def resolve_neutral_types(self) -> None:\n        def previous_strong(index: int) -> str:\n            if index == 0:\n                return self.previous_direction\n            if self.characters[index - 1].bidi_class == \"L\":\n                return \"L\"\n            if self.characters[index - 1].bidi_class in (\"R\", \"AN\", \"EN\"):\n                return \"R\"\n            return previous_strong(index - 1)\n\n        def next_strong(index: int) -> str:\n            if index >= len(self.characters) - 1:\n                return self.next_direction\n            if self.characters[index + 1].bidi_class == \"L\":\n                return \"L\"\n            if self.characters[index + 1].bidi_class in (\"R\", \"AN\", \"EN\"):\n                return \"R\"\n            return next_strong(index + 1)\n\n        # N0-N2: Resolving neutral types\n        # N0\n        brackets = self.pair_brackets()\n        if brackets:\n            embedding_direction = self.characters[0].get_direction_from_level()\n            for b in brackets:\n                strong_same_direction = False\n                strong_opposite_direction = False\n                resulting_direction = None\n                for index in range(b[0], b[1]):\n                    if (\n                        self.characters[index].bidi_class == \"L\"\n                        and embedding_direction == \"L\"\n                    ) or (\n                        self.characters[index].bidi_class in (\"R\", \"AN\", \"EN\")\n                        and embedding_direction == \"R\"\n                    ):\n                        strong_same_direction = True\n                        break\n                    if (\n                        self.characters[index].bidi_class == \"L\"\n                        and embedding_direction == \"R\"\n                    ) or (\n                        self.characters[index].bidi_class in (\"R\", \"AN\", \"EN\")\n                        and embedding_direction == \"L\"\n                    ):\n                        strong_opposite_direction = True\n                if strong_same_direction:\n                    resulting_direction = embedding_direction\n                elif strong_opposite_direction:\n                    opposite_direction = \"L\" if embedding_direction == \"R\" else \"R\"\n                    if previous_strong(b[0]) == opposite_direction:\n                        resulting_direction = opposite_direction\n                    else:\n                        resulting_direction = embedding_direction\n                if resulting_direction:\n                    self.characters[b[0]].bidi_class = resulting_direction\n                    self.characters[b[1]].bidi_class = resulting_direction\n                    if len(self.characters) > b[1] + 1:\n                        next_char = self.characters[b[1] + 1]\n                        if (\n                            next_char.original_bidi_class == \"NSM\"\n                            and next_char.bidi_class == \"ON\"\n                        ):\n                            next_char.bidi_class = resulting_direction\n\n        for i, bidi_char in enumerate(self.characters):\n            # N1-N2\n            if bidi_char.bidi_class in (\n                \"B\",\n                \"S\",\n                \"WS\",\n                \"ON\",\n                \"FSI\",\n                \"LRI\",\n                \"RLI\",\n                \"PDI\",\n            ):\n                if previous_strong(i) == next_strong(i):\n                    bidi_char.bidi_class = previous_strong(i)\n                else:\n                    bidi_char.bidi_class = bidi_char.get_direction_from_level()\n\n    def resolve_implicit_levels(self) -> None:\n        for bidi_char in self.characters:\n            # I1. For all characters with an even (left-to-right) embedding level,\n            #     those of type R go up one level and those of type AN or EN go up two levels.\n            if bidi_char.embedding_level % 2 == 0:\n                if bidi_char.bidi_class == \"R\":\n                    bidi_char.embedding_level += 1\n                if bidi_char.bidi_class in (\"AN\", \"EN\"):\n                    bidi_char.embedding_level += 2\n\n            # I2. For all characters with an odd (right-to-left) embedding level, those of type L, EN or AN go up one level.\n            else:\n                if bidi_char.bidi_class in (\"L\", \"EN\", \"AN\"):\n                    bidi_char.embedding_level += 1",
      "language": "python"
    },
    {
      "code": "class IsolatingRun:\n    __slots__ = [\"characters\", \"previous_direction\", \"next_direction\"]\n\n    def __init__(self, characters: list[BidiCharacter], sos: str, eos: str) -> None:\n        self.characters = characters\n        self.previous_direction = sos\n        self.next_direction = eos\n        self.resolve_weak_types()\n        self.resolve_neutral_types()\n        self.resolve_implicit_levels()\n\n    def resolve_weak_types(self) -> None:\n        # W1. Examine each nonspacing mark (NSM) in the isolating run sequence, and change the type of the NSM to Other Neutral\n        #     if the previous character is an isolate initiator or PDI, and to the type of the previous character otherwise.\n        #     If the NSM is at the start of the isolating run sequence, it will get the type of sos.\n        for i, bidi_char in enumerate(self.characters):\n            if bidi_char.bidi_class == \"NSM\":\n                if i == 0:\n                    bidi_char.set_class(self.previous_direction)\n                else:\n                    bidi_char.set_class(\n                        \"ON\"\n                        if self.characters[i - 1].bidi_class\n                        in (\"LRI\", \"RLI\", \"FSI\", \"PDI\")\n                        else self.characters[i - 1].bidi_class\n                    )\n\n        # W2. Search backward from each instance of a European number until the first strong type (R, L, AL, or sos) is found.\n        #     If an AL is found, change the type of the European number to Arabic number.\n        # W3. Change all ALs to R.\n\n        last_strong_type = self.previous_direction\n        for bidi_char in self.characters:\n            if bidi_char.bidi_class in (\"R\", \"L\", \"AL\"):\n                last_strong_type = bidi_char.bidi_class\n            if bidi_char.bidi_class == \"AL\":\n                bidi_char.set_class(\"R\")\n            if bidi_char.bidi_class == \"EN\" and last_strong_type == \"AL\":\n                bidi_char.set_class(\"AN\")\n\n        # W4. A single European separator between two European numbers changes to a European number.\n        #     A single common separator between two numbers of the same type changes to that type.\n        for i, bidi_char in enumerate(self.characters):\n            if i in (0, len(self.characters) - 1):\n                continue\n            if (\n                bidi_char.bidi_class == \"ES\"\n                and self.characters[i - 1].bidi_class == \"EN\"\n                and self.characters[i + 1].bidi_class == \"EN\"\n            ):\n                bidi_char.set_class(\"EN\")\n\n            if (\n                bidi_char.bidi_class == \"CS\"\n                and self.characters[i - 1].bidi_class in (\"AN\", \"EN\")\n                and self.characters[i + 1].bidi_class\n                == self.characters[i - 1].bidi_class\n            ):\n                bidi_char.set_class(self.characters[i - 1].bidi_class)\n\n        # W5. A sequence of European terminators adjacent to European numbers changes to all European numbers.\n        # W6. All remaining separators and terminators (after the application of W4 and W5) change to Other Neutral.\n        def prev_is_en(i: int) -> bool:\n            if i == 0:\n                return False\n            if self.characters[i - 1].bidi_class == \"ET\":\n                return prev_is_en(i - 1)\n            return self.characters[i - 1].bidi_class == \"EN\"\n\n        def next_is_en(i: int) -> bool:\n            if i == len(self.characters) - 1:\n                return False\n            if self.characters[i + 1].bidi_class == \"ET\":\n                return next_is_en(i + 1)\n            return self.characters[i + 1].bidi_class == \"EN\"\n\n        for i, bidi_char in enumerate(self.characters):\n            if bidi_char.bidi_class == \"ET\":\n                if prev_is_en(i) or next_is_en(i):\n                    bidi_char.set_class(\"EN\")\n\n            if bidi_char.bidi_class in (\"ET\", \"ES\", \"CS\"):\n                bidi_char.set_class(\"ON\")\n        # W7. Search backward from each instance of a European number until the first strong type (R, L, or sos) is found.\n        #     If an L is found, then change the type of the European number to L.\n        last_strong_type = self.previous_direction\n        for bidi_char in self.characters:\n            if bidi_char.bidi_class in (\"R\", \"L\", \"AL\"):\n                last_strong_type = bidi_char.bidi_class\n            if bidi_char.bidi_class == \"EN\" and last_strong_type == \"L\":\n                bidi_char.set_class(\"L\")\n\n    def pair_brackets(self) -> list[tuple[int, int]]:\n        \"\"\"\n        Calculate all the bracket pairs on an isolate run, to be used on rule N0\n        How to calculate bracket pairs:\n        - Basic definitions 14, 15 and 16: http://www.unicode.org/reports/tr9/#BD14\n        - BIDI brackets for dummies: https://www.unicode.org/notes/tn39/\n        \"\"\"\n        open_brackets: list[tuple[str, int]] = []\n        open_bracket_count = 0\n        bracket_pairs: list[tuple[int, int]] = []\n        for index, char in enumerate(self.characters):\n            if char.character in BIDI_BRACKETS and char.bidi_class == \"ON\":\n                if BIDI_BRACKETS[char.character][\"type\"] == \"o\":\n                    if open_bracket_count >= 63:\n                        return []\n                    open_brackets.append((char.character, index))\n                    open_bracket_count += 1\n                if BIDI_BRACKETS[char.character][\"type\"] == \"c\":\n                    if open_bracket_count == 0:\n                        continue\n                    for current_open_bracket in range(open_bracket_count, 0, -1):\n                        open_char, open_index = open_brackets[current_open_bracket - 1]\n                        if (BIDI_BRACKETS[open_char][\"pair\"] == char.character) or (\n                            BIDI_BRACKETS[open_char][\"pair\"] in (\"\", \"\")\n                            and char.character in (\"\", \"\")\n                        ):\n                            bracket_pairs.append((open_index, index))\n                            open_brackets = open_brackets[: current_open_bracket - 1]\n                            open_bracket_count = current_open_bracket - 1\n                            break\n        return sorted(bracket_pairs, key=itemgetter(0))\n\n    def resolve_neutral_types(self) -> None:\n        def previous_strong(index: int) -> str:\n            if index == 0:\n                return self.previous_direction\n            if self.characters[index - 1].bidi_class == \"L\":\n                return \"L\"\n            if self.characters[index - 1].bidi_class in (\"R\", \"AN\", \"EN\"):\n                return \"R\"\n            return previous_strong(index - 1)\n\n        def next_strong(index: int) -> str:\n            if index >= len(self.characters) - 1:\n                return self.next_direction\n            if self.characters[index + 1].bidi_class == \"L\":\n                return \"L\"\n            if self.characters[index + 1].bidi_class in (\"R\", \"AN\", \"EN\"):\n                return \"R\"\n            return next_strong(index + 1)\n\n        # N0-N2: Resolving neutral types\n        # N0\n        brackets = self.pair_brackets()\n        if brackets:\n            embedding_direction = self.characters[0].get_direction_from_level()\n            for b in brackets:\n                strong_same_direction = False\n                strong_opposite_direction = False\n                resulting_direction = None\n                for index in range(b[0], b[1]):\n                    if (\n                        self.characters[index].bidi_class == \"L\"\n                        and embedding_direction == \"L\"\n                    ) or (\n                        self.characters[index].bidi_class in (\"R\", \"AN\", \"EN\")\n                        and embedding_direction == \"R\"\n                    ):\n                        strong_same_direction = True\n                        break\n                    if (\n                        self.characters[index].bidi_class == \"L\"\n                        and embedding_direction == \"R\"\n                    ) or (\n                        self.characters[index].bidi_class in (\"R\", \"AN\", \"EN\")\n                        and embedding_direction == \"L\"\n                    ):\n                        strong_opposite_direction = True\n                if strong_same_direction:\n                    resulting_direction = embedding_direction\n                elif strong_opposite_direction:\n                    opposite_direction = \"L\" if embedding_direction == \"R\" else \"R\"\n                    if previous_strong(b[0]) == opposite_direction:\n                        resulting_direction = opposite_direction\n                    else:\n                        resulting_direction = embedding_direction\n                if resulting_direction:\n                    self.characters[b[0]].bidi_class = resulting_direction\n                    self.characters[b[1]].bidi_class = resulting_direction\n                    if len(self.characters) > b[1] + 1:\n                        next_char = self.characters[b[1] + 1]\n                        if (\n                            next_char.original_bidi_class == \"NSM\"\n                            and next_char.bidi_class == \"ON\"\n                        ):\n                            next_char.bidi_class = resulting_direction\n\n        for i, bidi_char in enumerate(self.characters):\n            # N1-N2\n            if bidi_char.bidi_class in (\n                \"B\",\n                \"S\",\n                \"WS\",\n                \"ON\",\n                \"FSI\",\n                \"LRI\",\n                \"RLI\",\n                \"PDI\",\n            ):\n                if previous_strong(i) == next_strong(i):\n                    bidi_char.bidi_class = previous_strong(i)\n                else:\n                    bidi_char.bidi_class = bidi_char.get_direction_from_level()\n\n    def resolve_implicit_levels(self) -> None:\n        for bidi_char in self.characters:\n            # I1. For all characters with an even (left-to-right) embedding level,\n            #     those of type R go up one level and those of type AN or EN go up two levels.\n            if bidi_char.embedding_level % 2 == 0:\n                if bidi_char.bidi_class == \"R\":\n                    bidi_char.embedding_level += 1\n                if bidi_char.bidi_class in (\"AN\", \"EN\"):\n                    bidi_char.embedding_level += 2\n\n            # I2. For all characters with an odd (right-to-left) embedding level, those of type L, EN or AN go up one level.\n            else:\n                if bidi_char.bidi_class in (\"L\", \"EN\", \"AN\"):\n                    bidi_char.embedding_level += 1",
      "language": "python"
    },
    {
      "code": "def pair_brackets(self) -> list[tuple[int, int]]:\n    \"\"\"\n    Calculate all the bracket pairs on an isolate run, to be used on rule N0\n    How to calculate bracket pairs:\n    - Basic definitions 14, 15 and 16: http://www.unicode.org/reports/tr9/#BD14\n    - BIDI brackets for dummies: https://www.unicode.org/notes/tn39/\n    \"\"\"\n    open_brackets: list[tuple[str, int]] = []\n    open_bracket_count = 0\n    bracket_pairs: list[tuple[int, int]] = []\n    for index, char in enumerate(self.characters):\n        if char.character in BIDI_BRACKETS and char.bidi_class == \"ON\":\n            if BIDI_BRACKETS[char.character][\"type\"] == \"o\":\n                if open_bracket_count >= 63:\n                    return []\n                open_brackets.append((char.character, index))\n                open_bracket_count += 1\n            if BIDI_BRACKETS[char.character][\"type\"] == \"c\":\n                if open_bracket_count == 0:\n                    continue\n                for current_open_bracket in range(open_bracket_count, 0, -1):\n                    open_char, open_index = open_brackets[current_open_bracket - 1]\n                    if (BIDI_BRACKETS[open_char][\"pair\"] == char.character) or (\n                        BIDI_BRACKETS[open_char][\"pair\"] in (\"\", \"\")\n                        and char.character in (\"\", \"\")\n                    ):\n                        bracket_pairs.append((open_index, index))\n                        open_brackets = open_brackets[: current_open_bracket - 1]\n                        open_bracket_count = current_open_bracket - 1\n                        break\n    return sorted(bracket_pairs, key=itemgetter(0))",
      "language": "python"
    },
    {
      "code": "def resolve_implicit_levels(self) -> None:\n    for bidi_char in self.characters:\n        # I1. For all characters with an even (left-to-right) embedding level,\n        #     those of type R go up one level and those of type AN or EN go up two levels.\n        if bidi_char.embedding_level % 2 == 0:\n            if bidi_char.bidi_class == \"R\":\n                bidi_char.embedding_level += 1\n            if bidi_char.bidi_class in (\"AN\", \"EN\"):\n                bidi_char.embedding_level += 2\n\n        # I2. For all characters with an odd (right-to-left) embedding level, those of type L, EN or AN go up one level.\n        else:\n            if bidi_char.bidi_class in (\"L\", \"EN\", \"AN\"):\n                bidi_char.embedding_level += 1",
      "language": "python"
    },
    {
      "code": "def resolve_neutral_types(self) -> None:\n    def previous_strong(index: int) -> str:\n        if index == 0:\n            return self.previous_direction\n        if self.characters[index - 1].bidi_class == \"L\":\n            return \"L\"\n        if self.characters[index - 1].bidi_class in (\"R\", \"AN\", \"EN\"):\n            return \"R\"\n        return previous_strong(index - 1)\n\n    def next_strong(index: int) -> str:\n        if index >= len(self.characters) - 1:\n            return self.next_direction\n        if self.characters[index + 1].bidi_class == \"L\":\n            return \"L\"\n        if self.characters[index + 1].bidi_class in (\"R\", \"AN\", \"EN\"):\n            return \"R\"\n        return next_strong(index + 1)\n\n    # N0-N2: Resolving neutral types\n    # N0\n    brackets = self.pair_brackets()\n    if brackets:\n        embedding_direction = self.characters[0].get_direction_from_level()\n        for b in brackets:\n            strong_same_direction = False\n            strong_opposite_direction = False\n            resulting_direction = None\n            for index in range(b[0], b[1]):\n                if (\n                    self.characters[index].bidi_class == \"L\"\n                    and embedding_direction == \"L\"\n                ) or (\n                    self.characters[index].bidi_class in (\"R\", \"AN\", \"EN\")\n                    and embedding_direction == \"R\"\n                ):\n                    strong_same_direction = True\n                    break\n                if (\n                    self.characters[index].bidi_class == \"L\"\n                    and embedding_direction == \"R\"\n                ) or (\n                    self.characters[index].bidi_class in (\"R\", \"AN\", \"EN\")\n                    and embedding_direction == \"L\"\n                ):\n                    strong_opposite_direction = True\n            if strong_same_direction:\n                resulting_direction = embedding_direction\n            elif strong_opposite_direction:\n                opposite_direction = \"L\" if embedding_direction == \"R\" else \"R\"\n                if previous_strong(b[0]) == opposite_direction:\n                    resulting_direction = opposite_direction\n                else:\n                    resulting_direction = embedding_direction\n            if resulting_direction:\n                self.characters[b[0]].bidi_class = resulting_direction\n                self.characters[b[1]].bidi_class = resulting_direction\n                if len(self.characters) > b[1] + 1:\n                    next_char = self.characters[b[1] + 1]\n                    if (\n                        next_char.original_bidi_class == \"NSM\"\n                        and next_char.bidi_class == \"ON\"\n                    ):\n                        next_char.bidi_class = resulting_direction\n\n    for i, bidi_char in enumerate(self.characters):\n        # N1-N2\n        if bidi_char.bidi_class in (\n            \"B\",\n            \"S\",\n            \"WS\",\n            \"ON\",\n            \"FSI\",\n            \"LRI\",\n            \"RLI\",\n            \"PDI\",\n        ):\n            if previous_strong(i) == next_strong(i):\n                bidi_char.bidi_class = previous_strong(i)\n            else:\n                bidi_char.bidi_class = bidi_char.get_direction_from_level()",
      "language": "python"
    },
    {
      "code": "def resolve_weak_types(self) -> None:\n    # W1. Examine each nonspacing mark (NSM) in the isolating run sequence, and change the type of the NSM to Other Neutral\n    #     if the previous character is an isolate initiator or PDI, and to the type of the previous character otherwise.\n    #     If the NSM is at the start of the isolating run sequence, it will get the type of sos.\n    for i, bidi_char in enumerate(self.characters):\n        if bidi_char.bidi_class == \"NSM\":\n            if i == 0:\n                bidi_char.set_class(self.previous_direction)\n            else:\n                bidi_char.set_class(\n                    \"ON\"\n                    if self.characters[i - 1].bidi_class\n                    in (\"LRI\", \"RLI\", \"FSI\", \"PDI\")\n                    else self.characters[i - 1].bidi_class\n                )\n\n    # W2. Search backward from each instance of a European number until the first strong type (R, L, AL, or sos) is found.\n    #     If an AL is found, change the type of the European number to Arabic number.\n    # W3. Change all ALs to R.\n\n    last_strong_type = self.previous_direction\n    for bidi_char in self.characters:\n        if bidi_char.bidi_class in (\"R\", \"L\", \"AL\"):\n            last_strong_type = bidi_char.bidi_class\n        if bidi_char.bidi_class == \"AL\":\n            bidi_char.set_class(\"R\")\n        if bidi_char.bidi_class == \"EN\" and last_strong_type == \"AL\":\n            bidi_char.set_class(\"AN\")\n\n    # W4. A single European separator between two European numbers changes to a European number.\n    #     A single common separator between two numbers of the same type changes to that type.\n    for i, bidi_char in enumerate(self.characters):\n        if i in (0, len(self.characters) - 1):\n            continue\n        if (\n            bidi_char.bidi_class == \"ES\"\n            and self.characters[i - 1].bidi_class == \"EN\"\n            and self.characters[i + 1].bidi_class == \"EN\"\n        ):\n            bidi_char.set_class(\"EN\")\n\n        if (\n            bidi_char.bidi_class == \"CS\"\n            and self.characters[i - 1].bidi_class in (\"AN\", \"EN\")\n            and self.characters[i + 1].bidi_class\n            == self.characters[i - 1].bidi_class\n        ):\n            bidi_char.set_class(self.characters[i - 1].bidi_class)\n\n    # W5. A sequence of European terminators adjacent to European numbers changes to all European numbers.\n    # W6. All remaining separators and terminators (after the application of W4 and W5) change to Other Neutral.\n    def prev_is_en(i: int) -> bool:\n        if i == 0:\n            return False\n        if self.characters[i - 1].bidi_class == \"ET\":\n            return prev_is_en(i - 1)\n        return self.characters[i - 1].bidi_class == \"EN\"\n\n    def next_is_en(i: int) -> bool:\n        if i == len(self.characters) - 1:\n            return False\n        if self.characters[i + 1].bidi_class == \"ET\":\n            return next_is_en(i + 1)\n        return self.characters[i + 1].bidi_class == \"EN\"\n\n    for i, bidi_char in enumerate(self.characters):\n        if bidi_char.bidi_class == \"ET\":\n            if prev_is_en(i) or next_is_en(i):\n                bidi_char.set_class(\"EN\")\n\n        if bidi_char.bidi_class in (\"ET\", \"ES\", \"CS\"):\n            bidi_char.set_class(\"ON\")\n    # W7. Search backward from each instance of a European number until the first strong type (R, L, or sos) is found.\n    #     If an L is found, then change the type of the European number to L.\n    last_strong_type = self.previous_direction\n    for bidi_char in self.characters:\n        if bidi_char.bidi_class in (\"R\", \"L\", \"AL\"):\n            last_strong_type = bidi_char.bidi_class\n        if bidi_char.bidi_class == \"EN\" and last_strong_type == \"L\":\n            bidi_char.set_class(\"L\")",
      "language": "python"
    }
  ],
  "patterns": [],
  "links": [
    "https://py-pdf.github.io/fpdf2/fpdf/enums.html",
    "https://py-pdf.github.io/fpdf2/fpdf/bidi.html",
    "https://py-pdf.github.io/fpdf2/fpdf/index.html"
  ]
}