{
  "url": "https://py-pdf.github.io/fpdf2/fpdf/html.html",
  "title": "Module fpdf.html",
  "content": "The contents of this module are internal to fpdf2, and not part of the public API. They may change at any time without prior warning or any deprecation period, in non-backward-compatible ways.\n\nUsage documentation at: https://py-pdf.github.io/fpdf2/HTML.html\n\nConvert a web color name to a (R, G, B) color tuple. cf. https://en.wikipedia.org/wiki/Web_colors#HTML_color_names\n\nParse style=\"...\" HTML attributes, and return a dict of key-value\n\nRender basic HTML to FPDF\n\nThe type of the None singleton.\n\nThe type of the None singleton.\n\nFeed data to the parser.\n\nCall this as often as you want, with as little or as much text as you want (may include '\\n').\n\nThis method can be overridden by subclasses to customize the Table of Contents style.\n\n[DEPRECATED since v2.6.0] You can now directly use the FPDF.write_html() method",
  "headings": [
    {
      "level": "h1",
      "text": "Module fpdf.html",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Functions",
      "id": "header-functions"
    },
    {
      "level": "h2",
      "text": "Classes",
      "id": "header-classes"
    },
    {
      "level": "h2",
      "text": "Args",
      "id": "args"
    },
    {
      "level": "h3",
      "text": "Ancestors",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Class variables",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": ""
    }
  ],
  "code_samples": [
    {
      "code": "def color_as_decimal(\n    color: Optional[str] = \"#000000\",\n) -> Optional[DeviceRGB | DeviceGray]:\n    \"\"\"\n    Convert a web color name to a (R, G, B) color tuple.\n    cf. https://en.wikipedia.org/wiki/Web_colors#HTML_color_names\n    \"\"\"\n    if not color:\n        return None\n    # Checks if color is a name and gets the hex value\n    hexcolor = COLOR_DICT.get(color.lower(), color)\n    return color_from_hex_string(hexcolor)",
      "language": "python"
    },
    {
      "code": "def ol_prefix(ol_type: str, index: int) -> int | str:\n    if ol_type == \"1\":\n        return index\n    if ol_type == \"a\":\n        return ascii_lowercase[index - 1]\n    if ol_type == \"A\":\n        return ascii_uppercase[index - 1]\n    if ol_type == \"I\":\n        return int2roman(index)\n    if ol_type == \"i\":\n        return int2roman(index).lower()\n    raise NotImplementedError(f\"Unsupported type: {ol_type}\")",
      "language": "python"
    },
    {
      "code": "def parse_css_style(style_attr: str) -> dict[str, str]:\n    \"\"\"Parse `style=\"...\"` HTML attributes, and return a dict of key-value\"\"\"\n    style: dict[str, str] = {}\n    for element in style_attr.split(\";\"):\n        if not element:\n            continue\n        pair = element.split(\":\")\n        if len(pair) == 2 and pair[0] and pair[1]:\n            attr, value = pair\n            style[attr.strip()] = value.strip()\n    return style",
      "language": "python"
    },
    {
      "code": "def ul_prefix(ul_type: str, is_ttf_font: bool) -> str:\n    if ul_type == \"disc\":\n        return BULLET_UNICODE if is_ttf_font else MESSAGE_WAITING_WIN1252\n    if ul_type == \"circle\":\n        return RING_OPERATOR_UNICODE if is_ttf_font else DEGREE_SIGN_WIN1252\n    if len(ul_type) == 1:\n        return ul_type\n    raise NotImplementedError(f\"Unsupported type: {ul_type}\")",
      "language": "python"
    },
    {
      "code": "class HTML2FPDF(HTMLParser):\n    \"Render basic HTML to FPDF\"\n\n    HTML_UNCLOSED_TAGS = (\"br\", \"dd\", \"dt\", \"hr\", \"img\", \"li\", \"td\", \"tr\")\n    TABLE_LINE_HEIGHT = 1.3\n\n    def __init__(\n        self,\n        pdf: \"FPDF\",\n        image_map: Callable[[str], str] = lambda src: src,\n        li_tag_indent: Optional[float] = None,\n        dd_tag_indent: Optional[float] = None,\n        table_line_separators: bool = False,\n        ul_bullet_char: str = \"disc\",\n        li_prefix_color: ColorInput = (190, 0, 0),\n        heading_sizes: Optional[dict[str, float]] = None,\n        pre_code_font: Optional[str] = None,\n        warn_on_tags_not_matching: bool = True,\n        tag_indents: Optional[dict[str, float]] = None,\n        tag_styles: Optional[dict[str, TextStyle]] = None,\n        font_family: str = \"times\",\n        render_title_tag: bool = False,\n    ) -> None:\n        \"\"\"\n        Args:\n            pdf (fpdf.fpdf.FPDF): an instance of `FPDF`\n            image_map (function): an optional one-argument function that map `<img>` \"src\" to new image URLs\n            li_tag_indent (int): [**DEPRECATED since v2.7.9**]\n                numeric indentation of `<li>` elements - Set `tag_styles` instead\n            dd_tag_indent (int): [**DEPRECATED since v2.7.9**]\n                numeric indentation of `<dd>` elements - Set `tag_styles` instead\n            table_line_separators (bool): enable horizontal line separators in `<table>`. Defaults to `False`.\n            ul_bullet_char (str): bullet character preceding `<li>` items in `<ul>` lists.\n                You can also specify special bullet names like `\"circle\"` or `\"disc\"` (the default).\n                Can also be configured using the HTML `type` attribute of `<ul>` tags.\n            li_prefix_color (tuple, str, fpdf.drawing.DeviceCMYK, fpdf.drawing.DeviceGray, fpdf.drawing.DeviceRGB): color for bullets\n                or numbers preceding `<li>` tags. This applies to both `<ul>` & `<ol>` lists.\n            heading_sizes (dict): [**DEPRECATED since v2.7.9**]\n                font size per heading level names (\"h1\", \"h2\"...) - Set `tag_styles` instead\n            pre_code_font (str): [**DEPRECATED since v2.7.9**]\n                font to use for `<pre>` & `<code>` blocks - Set `tag_styles` instead\n            warn_on_tags_not_matching (bool): control warnings production for unmatched HTML tags. Defaults to `True`.\n            tag_indents (dict): [**DEPRECATED since v2.8.0**]\n                mapping of HTML tag names to numeric values representing their horizontal left indentation. - Set `tag_styles` instead\n            tag_styles (dict[str, fpdf.fonts.TextStyle]): mapping of HTML tag names to `fpdf.TextStyle` or `fpdf.FontFace` instances\n            font_family (str): optional font family. Default to Times.\n            render_title_tag (bool): Render the document <title> at the beginning of the PDF. Default to False.\n        \"\"\"\n        super().__init__()\n        self.pdf = pdf\n        self.ul_bullet_char = ul_bullet_char\n        self.image_map = image_map\n        self.li_prefix_color = (\n            color_as_decimal(li_prefix_color)\n            if isinstance(li_prefix_color, str)\n            else convert_to_device_color(li_prefix_color)\n        )\n        self.warn_on_tags_not_matching = warn_on_tags_not_matching\n        # The following 4 attributes are there to serve as \"temporary state\",\n        # so that changes to those settings are saved,\n        # but not reflected onto self.pdf yet,\n        # and only \"effectively\" applied when self._write_paragraph() is called.\n        # This way, we often avoid useless operators in the PDF content stream.\n        self.font_family: str = pdf.font_family or font_family\n        self.font_size_pt: float = pdf.font_size_pt\n        self.font_emphasis = TextEmphasis.NONE\n        self.font_color = pdf.text_color\n        # For historical / backward-compatibility reasons,\n        # write_html() sets an active font (Times by default):\n        self.pdf.set_font(\n            family=self.font_family,\n            size=self.font_size_pt,\n            style=self.font_emphasis.style,\n        )\n        self.style_stack: list[FontFace] = []  # list of FontFace\n        self._page_break_after_paragraph = False\n        self.follows_trailing_space = False  # The last write has ended with a space.\n        self.follows_heading = False  # We don't want extra space below a heading.\n        self.align: Optional[Union[float, Align]] = None\n        self.heading_level: Optional[int] = None\n        self._tags_stack: list[str] = []\n        self._column = self.pdf.text_columns(skip_leading_spaces=True)\n        self._paragraph: Optional[\"Paragraph\"] = self._column.paragraph()\n        # <pre>-related properties:\n        self._pre_formatted = False  # preserve whitespace while True.\n        # nothing written yet to <pre>, remove one initial nl:\n        self._pre_started = False\n        # <a>-related properties:\n        self.href: int | str = \"\"\n        # <ul>/<ol>-related properties:\n        self.indent = 0\n        self.line_height_stack: list[float | None] = []\n        self.ol_type: dict[int, str] = (\n            {}\n        )  # when inside a <ol> tag, can be \"a\", \"A\", \"i\", \"I\" or \"1\"\n        self.bullet: list[int | str] = []\n        # <title>-related properties:\n        self.render_title_tag = render_title_tag\n        self._in_title = False\n        # <table>-related properties:\n        self.table_line_separators = table_line_separators\n        self.table: Optional[Table] = (\n            None  # becomes a Table instance when processing <table> tags\n        )\n        self.table_row: Optional[Row] = (\n            None  # becomes a Row instance when processing <tr> tags\n        )\n        self.tr: Optional[dict[str, Optional[str]]] = (\n            None  # becomes a dict of attributes when processing <tr> tags\n        )\n        self.td_th: Optional[dict[str, Any]] = (\n            None  # becomes a dict of attributes when processing <td>/<th> tags\n        )\n        #                    \"inserted\" is a special attribute indicating that a cell has be inserted in self.table_row\n\n        self.tag_styles = _scale_units(pdf, DEFAULT_TAG_STYLES)\n        for tag, tag_style in (tag_styles or {}).items():\n            if tag not in DEFAULT_TAG_STYLES:\n                raise NotImplementedError(\n                    f\"Cannot set style for HTML tag <{tag}> (contributions are welcome to add support for this)\"\n                )\n            if not isinstance(tag_style, FontFace):\n                raise ValueError(\n                    f\"tag_styles values must be instances of FontFace or TextStyle - received: {tag_style}\"\n                )\n            # We convert FontFace values provided for block tags into TextStyle values:\n            if tag in BLOCK_TAGS and not isinstance(tag_style, TextStyle):\n                # pylint: disable=redefined-loop-name\n                tag_style = TextStyle(\n                    font_family=tag_style.family,\n                    font_style=(\n                        \"\" if not tag_style.emphasis else tag_style.emphasis.style\n                    ),\n                    font_size_pt=tag_style.size_pt,\n                    color=tag_style.color,\n                    fill_color=tag_style.fill_color,\n                    # Using default tag margins:\n                    t_margin=self.tag_styles[\n                        tag\n                    ].t_margin,  # pyright: ignore[reportAttributeAccessIssue, reportUnknownMemberType, reportUnknownArgumentType]\n                    l_margin=self.tag_styles[\n                        tag\n                    ].l_margin,  # pyright: ignore[reportAttributeAccessIssue, reportUnknownMemberType, reportUnknownArgumentType]\n                    b_margin=self.tag_styles[\n                        tag\n                    ].b_margin,  # pyright: ignore[reportAttributeAccessIssue, reportUnknownMemberType, reportUnknownArgumentType]\n                )\n            self.tag_styles[tag] = tag_style\n        if heading_sizes is not None:\n            warnings.warn(\n                (\n                    \"The heading_sizes parameter is deprecated since v2.7.9 \"\n                    \"and will be removed in a future release. \"\n                    \"Set the `tag_styles` parameter instead.\"\n                ),\n                DeprecationWarning,\n                stacklevel=get_stack_level(),\n            )\n            for tag, size in heading_sizes.items():\n                self.tag_styles[tag] = self.tag_styles[tag].replace(font_size_pt=size)\n        if pre_code_font is not None:\n            warnings.warn(\n                (\n                    \"The pre_code_font parameter is deprecated since v2.7.9 \"\n                    \"and will be removed in a future release. \"\n                    \"Set the `tag_styles` parameter instead.\"\n                ),\n                DeprecationWarning,\n                stacklevel=get_stack_level(),\n            )\n            code_style = self.tag_styles[\"code\"]\n            pre_style = self.tag_styles[\"pre\"]\n            if isinstance(code_style, TextStyle):\n                code_style = code_style.replace(font_family=pre_code_font)\n            else:\n                code_style = code_style.replace(family=pre_code_font)\n            if isinstance(pre_style, TextStyle):\n                pre_style = pre_style.replace(font_family=pre_code_font)\n            else:\n                pre_style = pre_style.replace(family=pre_code_font)\n            self.tag_styles[\"code\"] = code_style\n            self.tag_styles[\"pre\"] = pre_style\n        if dd_tag_indent is not None:\n            warnings.warn(\n                (\n                    \"The dd_tag_indent parameter is deprecated since v2.7.9 \"\n                    \"and will be removed in a future release. \"\n                    \"Set the `tag_styles` parameter instead.\"\n                ),\n                DeprecationWarning,\n                stacklevel=get_stack_level(),\n            )\n            self.tag_styles[\"dd\"] = self.tag_styles[\"dd\"].replace(\n                l_margin=dd_tag_indent\n            )\n        if li_tag_indent is not None:\n            warnings.warn(\n                (\n                    \"The li_tag_indent parameter is deprecated since v2.7.9 \"\n                    \"and will be removed in a future release. \"\n                    \"Set the `tag_styles` parameter instead.\"\n                ),\n                DeprecationWarning,\n                stacklevel=get_stack_level(),\n            )\n            self.tag_styles[\"li\"] = self.tag_styles[\"li\"].replace(\n                l_margin=li_tag_indent\n            )\n        if tag_indents:\n            warnings.warn(\n                (\n                    \"The tag_indents parameter is deprecated since v2.8.0 \"\n                    \"and will be removed in a future release. \"\n                    \"Set the `tag_styles` parameter instead.\"\n                ),\n                DeprecationWarning,\n                stacklevel=get_stack_level(),\n            )\n            for tag, indent in tag_indents.items():\n                if tag not in self.tag_styles:\n                    raise NotImplementedError(\n                        f\"Cannot set style for HTML tag <{tag}> (contributions are welcome to add support for this)\"\n                    )\n                self.tag_styles[tag] = self.tag_styles[tag].replace(l_margin=indent)\n\n    @staticmethod\n    def _normalize_l_margin(l_margin: Any) -> Union[float, Align]:\n        if isinstance(l_margin, Align):\n            return l_margin\n        if isinstance(l_margin, (int, float)):\n            return float(l_margin)\n        return 0.0\n\n    def _new_paragraph(\n        self,\n        align: Optional[Union[float, Align]] = None,\n        line_height: Optional[float] = 1.0,\n        top_margin: float = 0,\n        bottom_margin: float = 0,\n        indent: Union[float, Align] = 0,\n        bullet: str = \"\",\n    ) -> None:\n        # Note that currently top_margin is ignored if bullet is also provided,\n        # due to the behaviour of TextRegion._render_column_lines()\n        self._end_paragraph()\n        self.align = align\n        if isinstance(indent, Align):\n            # Explicit alignment takes priority over alignment provided as TextStyle.l_margin:\n            if not self.align:\n                self.align = indent\n            indent = 0\n        if not top_margin and not self.follows_heading:\n            top_margin = self.font_size_pt / self.pdf.k\n        self._paragraph = self._column.paragraph(\n            text_align=self.align if isinstance(self.align, Align) else None,\n            line_height=line_height,\n            skip_leading_spaces=True,\n            top_margin=top_margin,\n            bottom_margin=bottom_margin,\n            indent=indent,\n            bullet_string=bullet,\n        )\n        self.follows_trailing_space = True\n        self.follows_heading = False\n\n    def _end_paragraph(self) -> None:\n        self.align = None\n        if not self._paragraph:\n            return\n        self._column.end_paragraph()\n        self._column.render()\n        self._paragraph = None\n        self.follows_trailing_space = True\n        if self._page_break_after_paragraph:\n            # pylint: disable=protected-access\n            self.pdf._perform_page_break()  # pyright: ignore[reportPrivateUsage]\n            self._page_break_after_paragraph = False\n\n    def _write_paragraph(self, text: str, link: Optional[int | str] = None) -> None:\n        if not text:\n            return\n        if not self._paragraph:\n            self._new_paragraph()\n        # The following local stack is required\n        # in order for FPDF._get_current_graphics_state()\n        # to properly capture the current graphics state,\n        # and then to be able to drop those temporary changes,\n        # because they will only be \"effectively\" applied in .end_paragraph().\n        # pylint: disable=protected-access\n        self.pdf._push_local_stack()  # pyright: ignore[reportPrivateUsage]\n        prev_page = self.pdf.page\n        self.pdf.page = 0\n        self.pdf.set_font(\n            family=self.font_family,\n            size=self.font_size_pt,\n            style=self.font_emphasis.style,\n        )\n        if self.font_color != self.pdf.text_color and self.font_color is not None:\n            self.pdf.set_text_color(self.font_color)\n        assert self._paragraph is not None\n        self._paragraph.write(text, link=link)\n        self.pdf.page = prev_page\n        self.pdf._pop_local_stack()  # pyright: ignore[reportPrivateUsage]\n\n    def _ln(self, h: Optional[float] = None) -> None:\n        if self._paragraph:\n            self._paragraph.ln(h=h)\n        else:\n            self._column.ln(h=h)\n        self.follows_trailing_space = True\n\n    def handle_data(self, data: str) -> None:\n        if self._in_title:\n            if self.pdf.title:\n                LOGGER.warning('Ignoring repeated <title> \"%s\"', data)\n            else:\n                self.pdf.set_title(data)\n            if not self.render_title_tag:\n                return\n        if self.td_th is not None:\n            data = data.strip()\n            if not data:\n                return\n            if \"inserted\" in self.td_th:\n                td_th_tag = self.td_th[\"tag\"]\n                raise NotImplementedError(\n                    f\"Unsupported nested HTML tags inside <{td_th_tag}> element: <{self._tags_stack[-1]}>\"\n                )\n                # We could potentially support nested <b> / <em> / <font> tags\n                # by building a list of Fragment instances from the HTML cell content\n                # and then passing those fragments to Row.cell().\n                # However there should be an incoming refactoring of this code\n                # dedicated to text layout, and we should probably wait for that\n                # before supporting this feature.\n            align = self.td_th.get(\"align\")\n            if align is None and self.tr is not None:\n                align = self.tr.get(\"align\")\n            if align:\n                align = align.upper()\n            bgcolor_str = self.td_th.get(\"bgcolor\")\n            if bgcolor_str is None and self.tr is not None:\n                bgcolor_str = self.tr.get(\"bgcolor\")\n            bgcolor = color_as_decimal(bgcolor_str)\n            colspan = int(self.td_th.get(\"colspan\") or \"1\")\n            rowspan = int(self.td_th.get(\"rowspan\") or \"1\")\n            emphasis = 0\n            if self.td_th.get(\"b\"):\n                emphasis |= TextEmphasis.B\n            if self.td_th.get(\"i\"):\n                emphasis |= TextEmphasis.I\n            if self.td_th.get(\"U\"):\n                emphasis |= TextEmphasis.U\n            font_family = (\n                self.font_family if self.font_family != self.pdf.font_family else None\n            )\n            font_size_pt = (\n                self.font_size_pt\n                if self.font_size_pt != self.pdf.font_size_pt\n                else None\n            )\n            font_style = None\n            if font_family or emphasis or font_size_pt or bgcolor:\n                font_style = FontFace(\n                    family=font_family,\n                    emphasis=emphasis,\n                    size_pt=font_size_pt,\n                    color=self.pdf.text_color,\n                    fill_color=bgcolor,\n                )\n            assert self.table_row is not None\n            self.table_row.cell(\n                text=data,\n                align=align,\n                style=font_style,\n                colspan=colspan,\n                rowspan=rowspan,\n            )\n            self.td_th[\"inserted\"] = True\n        elif self.table is not None:\n            # ignore anything else than td inside a table\n            pass\n        elif self._pre_formatted:  # pre blocks\n            # If we want to mimic the exact HTML semantics about newlines at the\n            # beginning and end of the block, then this needs some more thought.\n            if data.startswith(\"\\n\") and self._pre_started:\n                if data.endswith(\"\\n\"):\n                    data = data[1:-1]\n                else:\n                    data = data[1:]\n            self._pre_started = False\n            self._write_data(data)\n        else:\n            data = _WS_SUB_PAT.sub(\" \", data)\n            if self.follows_trailing_space and data[0] == \" \":\n                self._write_data(data[1:])\n            else:\n                self._write_data(data)\n            self.follows_trailing_space = data[-1] == \" \"\n        if self._page_break_after_paragraph:\n            self._end_paragraph()\n\n    def _write_data(self, data: str) -> None:\n        if self.href:\n            self.put_link(data)\n        else:\n            if self.heading_level:\n                if self.pdf.section_title_styles:\n                    raise NotImplementedError(\n                        \"Combining write_html() & section styles is currently not supported.\"\n                        \" You can open up an issue on github.com/py-pdf/fpdf2 if this is something you would like to see implemented.\"\n                    )\n                self.pdf.start_section(data, self.heading_level - 1, strict=False)\n            self._write_paragraph(data)\n\n    def handle_starttag(self, tag: str, attrs: list[tuple[str, str | None]]) -> None:\n        self._pre_started = False\n        attrs_dict: dict[str, str | None] = dict(attrs)\n        del attrs\n        css_style = parse_css_style(attrs_dict.get(\"style\") or \"\")\n        self._tags_stack.append(tag)\n        if css_style.get(\"break-before\") == \"page\":\n            self._end_paragraph()\n            # pylint: disable=protected-access\n            self.pdf._perform_page_break()  # pyright: ignore[reportPrivateUsage]\n        if tag in (\"b\", \"i\", \"u\") and self.td_th is not None:\n            self.td_th[tag] = True\n        if tag == \"a\":\n            self.href = attrs_dict[\"href\"] or \"\"\n            try:\n                page = int(self.href)\n                self.href = self.pdf.add_link(page=page)\n            except ValueError:\n                pass\n        if tag == \"br\":\n            self._write_paragraph(\"\\n\")\n        if tag == \"hr\":\n            self._end_paragraph()\n            width_str = css_style.get(\"width\", attrs_dict.get(\"width\"))\n            if width_str:\n                if width_str[-1] == \"%\":\n                    hr_width = self.pdf.epw * float(width_str[:-1]) / 100\n                else:\n                    hr_width = float(width_str) / self.pdf.k\n            else:\n                hr_width = self.pdf.epw\n            # Centering:\n            x_start = self.pdf.l_margin + (self.pdf.epw - hr_width) / 2\n            self.pdf.line(\n                x1=x_start,\n                y1=self.pdf.y,\n                x2=x_start + hr_width,\n                y2=self.pdf.y,\n            )\n            self._write_paragraph(\"\\n\")\n        if tag == \"p\":\n            self.style_stack.append(\n                FontFace(\n                    family=self.font_family,\n                    emphasis=self.font_emphasis,\n                    size_pt=self.font_size_pt,\n                    color=self.font_color,\n                )\n            )\n            align: Optional[Align] = None\n            if \"align\" in attrs_dict:\n                try:\n                    align_str = attrs_dict.get(\"align\")\n                    align = Align.coerce(align_str) if align_str is not None else None\n                except ValueError:\n                    align = None\n            line_height_str = css_style.get(\n                \"line-height\", attrs_dict.get(\"line-height\")\n            )\n            # \"line-height\" attributes are not valid in HTML,\n            # but we support it for backward compatibility,\n            # because fpdf2 honors it since 2.6.1 and PR #629\n            line_height: Optional[float] = None\n            if line_height_str:\n                try:\n                    # YYY parse and convert non-float line_height values\n                    line_height = float(line_height_str)\n                except ValueError:\n                    line_height = None\n            tag_style = self.tag_styles[tag]\n            if tag_style.color is not None and tag_style.color != self.font_color:\n                self.font_color = tag_style.color\n            if tag_style.family is not None and tag_style.family != self.font_family:\n                self.font_family = tag_style.family\n            if tag_style.size_pt is not None and tag_style.size_pt != self.font_size_pt:\n                self.font_size_pt = tag_style.size_pt\n            if tag_style.emphasis:\n                self.font_emphasis |= tag_style.emphasis\n            if isinstance(tag_style, TextStyle):\n                t_margin = tag_style.t_margin\n                b_margin = tag_style.b_margin\n                l_margin = tag_style.l_margin\n            else:\n                t_margin = b_margin = l_margin = 0.0\n            l_margin = self._normalize_l_margin(l_margin)\n            self._new_paragraph(\n                align=align,\n                line_height=line_height or 1.0,\n                top_margin=t_margin,\n                bottom_margin=b_margin,\n                indent=l_margin,\n            )\n        if tag in HEADING_TAGS:\n            self.style_stack.append(\n                FontFace(\n                    family=self.font_family,\n                    emphasis=self.font_emphasis,\n                    size_pt=self.font_size_pt,\n                    color=self.font_color,\n                )\n            )\n            self.heading_level = 0 if tag == \"title\" else int(tag[1:])\n            tag_style = self.tag_styles[tag]\n            hsize = (tag_style.size_pt or self.font_size_pt) / self.pdf.k\n            align = None\n            if \"align\" in attrs_dict:\n                try:\n                    align_str = attrs_dict.get(\"align\")\n                    align = Align.coerce(align_str) if align_str is not None else None\n                except ValueError:\n                    align = None\n            if isinstance(tag_style, TextStyle):\n                t_margin = tag_style.t_margin\n                b_margin = tag_style.b_margin\n                l_margin = tag_style.l_margin\n            else:\n                t_margin = b_margin = l_margin = 0.0\n            l_margin = self._normalize_l_margin(l_margin)\n            self._new_paragraph(\n                align=align,\n                top_margin=t_margin,\n                bottom_margin=b_margin * hsize,\n                indent=l_margin,\n            )\n            if \"color\" in css_style:\n                self.font_color = color_as_decimal(css_style[\"color\"])\n            elif \"color\" in attrs_dict:\n                # \"color\" attributes are not valid in HTML,\n                # but we support it for backward compatibility:\n                self.font_color = color_as_decimal(attrs_dict[\"color\"])\n            elif tag_style.color is not None and tag_style.color != self.font_color:\n                self.font_color = tag_style.color\n            if tag_style.family is not None and tag_style.family != self.font_family:\n                self.font_family = tag_style.family\n            if tag_style.size_pt is not None and tag_style.size_pt != self.font_size_pt:\n                self.font_size_pt = tag_style.size_pt\n            if tag_style.emphasis:\n                self.font_emphasis |= tag_style.emphasis\n        if tag in (\n            \"b\",\n            \"blockquote\",\n            \"center\",\n            \"code\",\n            \"del\",\n            \"em\",\n            \"i\",\n            \"dd\",\n            \"dt\",\n            \"pre\",\n            \"s\",\n            \"strong\",\n            \"u\",\n        ):\n            if tag in BLOCK_TAGS:\n                self._end_paragraph()\n            self.style_stack.append(\n                FontFace(\n                    family=self.font_family,\n                    emphasis=self.font_emphasis,\n                    size_pt=self.font_size_pt,\n                    color=self.font_color,\n                )\n            )\n            tag_style = self.tag_styles[tag]\n            if tag_style.color:\n                self.font_color = tag_style.color\n            self.font_family = tag_style.family or self.font_family\n            self.font_size_pt = tag_style.size_pt or self.font_size_pt\n            if tag_style.emphasis:\n                self.font_emphasis |= tag_style.emphasis\n            if tag == \"pre\":\n                self._pre_formatted = True\n                self._pre_started = True\n            if tag in BLOCK_TAGS:\n                if tag == \"dd\":\n                    # Not compliant with the HTML spec, but backward-compatible\n                    # cf. https://github.com/py-pdf/fpdf2/pull/1217#discussion_r1666643777\n                    self.follows_heading = True\n                if isinstance(tag_style, TextStyle):\n                    t_margin = tag_style.t_margin\n                    b_margin = tag_style.b_margin\n                    l_margin = tag_style.l_margin\n                else:\n                    t_margin = b_margin = l_margin = 0.0\n                l_margin = self._normalize_l_margin(l_margin)\n                self._new_paragraph(\n                    line_height=(\n                        self.line_height_stack[-1] if self.line_height_stack else None\n                    ),\n                    top_margin=t_margin,\n                    bottom_margin=b_margin,\n                    indent=l_margin,\n                )\n        if tag == \"ul\":\n            self.indent += 1\n            bullet_char = attrs_dict.get(\"type\", self.ul_bullet_char)\n            assert bullet_char is not None\n            self.bullet.append(bullet_char)\n            line_height_str = css_style.get(\n                \"line-height\", attrs_dict.get(\"line-height\")\n            )\n            # \"line-height\" attributes are not valid in HTML,\n            # but we support it for backward compatibility,\n            # because fpdf2 honors it since 2.6.1 and PR #629\n            if line_height_str:\n                try:\n                    # YYY parse and convert non-float line_height values\n                    self.line_height_stack.append(float(line_height_str))\n                except ValueError:\n                    pass\n            else:\n                self.line_height_stack.append(None)\n            if self.indent == 1:\n                tag_style = self.tag_styles[tag]\n                if isinstance(tag_style, TextStyle):\n                    t_margin = tag_style.t_margin\n                    b_margin = tag_style.b_margin\n                    l_margin = tag_style.l_margin\n                else:\n                    t_margin = b_margin = l_margin = 0.0\n                l_margin = self._normalize_l_margin(l_margin)\n                self._new_paragraph(\n                    line_height=0,\n                    top_margin=t_margin,\n                    bottom_margin=b_margin,\n                    indent=l_margin,\n                )\n                self._write_paragraph(\"\\u00a0\")\n            self._end_paragraph()\n        if tag == \"ol\":\n            self.indent += 1\n            start = 1\n            if \"start\" in attrs_dict:\n                start_str = attrs_dict[\"start\"] or \"1\"\n                try:\n                    start = int(start_str)\n                except ValueError:\n                    start = 1\n            self.bullet.append(start - 1)\n            self.ol_type[self.indent] = attrs_dict.get(\"type\") or \"1\"\n            line_height_str = css_style.get(\"line-height\") or attrs_dict.get(\n                \"line-height\"\n            )\n            # \"line-height\" attributes are not valid in HTML,\n            # but we support it for backward compatibility,\n            # because fpdf2 honors it since 2.6.1 and PR #629\n            if line_height_str:\n                try:\n                    # YYY parse and convert non-float line_height values\n                    self.line_height_stack.append(float(line_height_str))\n                except ValueError:\n                    pass\n            else:\n                self.line_height_stack.append(None)\n            if self.indent == 1:\n                tag_style = self.tag_styles[tag]\n                if isinstance(tag_style, TextStyle):\n                    t_margin = tag_style.t_margin\n                    b_margin = tag_style.b_margin\n                    l_margin = tag_style.l_margin\n                else:\n                    t_margin = b_margin = l_margin = 0.0\n                l_margin = self._normalize_l_margin(l_margin)\n                self._new_paragraph(\n                    line_height=0,\n                    top_margin=t_margin,\n                    bottom_margin=b_margin,\n                    indent=l_margin,\n                )\n                self._write_paragraph(\"\\u00a0\")\n            self._end_paragraph()\n        if tag == \"li\":\n            prev_text_color = self.pdf.text_color\n            self.pdf.text_color = self.li_prefix_color\n            if self.bullet:\n                bullet = self.bullet[self.indent - 1]\n            else:\n                # Allow <li> to be used outside of <ul> or <ol>.\n                bullet = self.ul_bullet_char\n            if not isinstance(bullet, int):\n                bullet = ul_prefix(bullet, self.pdf.is_ttf_font)\n            if not isinstance(bullet, str):\n                bullet += 1\n                self.bullet[self.indent - 1] = bullet\n                ol_type = self.ol_type[self.indent]\n                bullet = f\"{ol_prefix(ol_type, bullet)}.\"\n            tag_style = self.tag_styles[tag]\n            if isinstance(tag_style, TextStyle):\n                b_margin = tag_style.b_margin\n                l_margin = tag_style.l_margin\n                t_margin = tag_style.t_margin\n            else:\n                b_margin = l_margin = t_margin = 0.0\n            l_margin = self._normalize_l_margin(l_margin)\n            self._ln(t_margin)\n            numeric_indent = 0.0 if isinstance(l_margin, Align) else l_margin\n            self._new_paragraph(\n                line_height=(\n                    self.line_height_stack[-1] if self.line_height_stack else None\n                ),\n                indent=numeric_indent * self.indent,\n                bottom_margin=b_margin,\n                bullet=bullet,\n            )\n            self.pdf.text_color = prev_text_color\n        if tag == \"font\":\n            self.style_stack.append(\n                FontFace(\n                    family=self.font_family,\n                    emphasis=self.font_emphasis,\n                    size_pt=self.font_size_pt,\n                    color=self.font_color,\n                )\n            )\n            if \"color\" in attrs_dict:\n                self.font_color = color_as_decimal(attrs_dict[\"color\"])\n            if \"font-size\" in css_style:\n                font_size_str = css_style.get(\"font-size\") or \"\"\n                try:\n                    self.font_size_pt = float(font_size_str)\n                except ValueError:\n                    pass\n            elif \"size\" in attrs_dict:\n                font_size_str = attrs_dict.get(\"size\") or \"\"\n                try:\n                    self.font_size_pt = float(font_size_str)\n                except ValueError:\n                    pass\n            if \"face\" in attrs_dict:\n                font_family = attrs_dict.get(\"face\") or \"\"\n                self.font_family = font_family.lower()\n        if tag == \"table\":\n            self._end_paragraph()\n            width: Optional[float] = None\n            width_str = css_style.get(\"width\") or attrs_dict.get(\"width\")\n            if width_str:\n                if width_str[-1] == \"%\":\n                    width = self.pdf.epw * float(width_str[:-1]) / 100\n                else:\n                    width = float(width_str) / self.pdf.k\n            if \"border\" not in attrs_dict:  # default borders\n                borders_layout = (\n                    \"HORIZONTAL_LINES\"\n                    if self.table_line_separators\n                    else \"SINGLE_TOP_LINE\"\n                )\n            else:\n                borders_str = attrs_dict[\"border\"] or \"\"\n                try:\n                    if int(borders_str) > 0:  # explicitly enabled borders\n                        borders_layout = (\n                            \"ALL\"\n                            if self.table_line_separators\n                            else \"NO_HORIZONTAL_LINES\"\n                        )\n                    else:  # explicitly disabled borders\n                        borders_layout = \"NONE\"\n                except ValueError:\n                    borders_layout = \"NONE\"\n            align = Align.coerce(attrs_dict.get(\"align\") or \"CENTER\")\n            padding = (\n                float(attrs_dict[\"cellpadding\"] or 0)\n                if \"cellpadding\" in attrs_dict\n                else None\n            )\n            spacing = float(attrs_dict.get(\"cellspacing\") or 0)\n            self.table = Table(\n                self.pdf,\n                align=align,\n                borders_layout=borders_layout,\n                line_height=self.font_size_pt / self.pdf.k * self.TABLE_LINE_HEIGHT,\n                width=width,\n                padding=padding,\n                gutter_width=spacing,\n                gutter_height=spacing,\n            )\n            self._ln()\n        if tag == \"tr\":\n            if not self.table:\n                raise FPDFException(\"Invalid HTML: <tr> used outside any <table>\")\n            self.tr = {k.lower(): v for k, v in attrs_dict.items()}\n            self.table_row = self.table.row()\n        if tag in (\"td\", \"th\"):\n            if not self.table or not self.table_row:\n                raise FPDFException(f\"Invalid HTML: <{tag}> used outside any <tr>\")\n            self.td_th = {k.lower(): v for k, v in attrs_dict.items()}\n            self.td_th[\"tag\"] = tag\n            if tag == \"th\":\n                if \"align\" not in self.td_th:\n                    self.td_th[\"align\"] = \"CENTER\"\n                self.td_th[\"b\"] = True\n            elif len(self.table.rows) == 1 and not self.table_row.cells:\n                # => we are in the 1st <tr>, and the 1st cell is a <td>\n                # => we do not treat the first row as a header\n                # pylint: disable=protected-access\n                self.table._first_row_as_headings = (\n                    False  # pyright: ignore[reportPrivateUsage]\n                )\n                self.table._num_heading_rows = 0  # pyright: ignore[reportPrivateUsage]\n            if \"height\" in attrs_dict:\n                LOGGER.warning(\n                    'Ignoring unsupported height=\"%s\" specified on a <%s>',\n                    attrs_dict[\"height\"],\n                    tag,\n                )\n            if \"width\" in attrs_dict:\n                width_str = attrs_dict[\"width\"] or \"0\"\n                # pylint: disable=protected-access\n                if len(self.table.rows) == 1:  # => first table row\n                    if width_str[-1] == \"%\":\n                        width = float(width_str[:-1])\n                    else:\n                        width = float(width_str)\n                    if not self.table._col_widths:\n                        self.table._col_widths = []\n                    assert isinstance(self.table._col_widths, list)\n                    self.table._col_widths.append(width)\n                else:\n                    LOGGER.warning(\n                        'Ignoring width=\"%s\" specified on a <%s> that is not in the first <tr>',\n                        width_str,\n                        tag,\n                    )\n        if tag == \"img\" and \"src\" in attrs_dict:\n            width = float(attrs_dict.get(\"width\") or 0) / self.pdf.k\n            height = float(attrs_dict.get(\"height\") or 0) / self.pdf.k\n            if self.table_row:  # => <img> in a <table>\n                if width or height:\n                    LOGGER.warning(\n                        'Ignoring unsupported \"width\" / \"height\" set on <img> element'\n                    )\n                if self.align:\n                    LOGGER.warning(\"Ignoring unsupported <img> alignment\")\n                self.table_row.cell(img=attrs_dict[\"src\"], img_fill_width=True)\n                assert self.td_th is not None\n                self.td_th[\"inserted\"] = True\n                return\n            x: float | Align = self.pdf.get_x()\n            if self.align:\n                x = self.align\n            self.pdf.image(\n                self.image_map(attrs_dict[\"src\"] or \"\"),\n                x=x,\n                w=width,\n                h=height,\n                link=self.href,\n            )\n        if tag == \"toc\":\n            self._end_paragraph()\n            self.pdf.insert_toc_placeholder(\n                self.render_toc, pages=int(attrs_dict.get(\"pages\") or \"1\")\n            )\n        if tag == \"sup\":\n            self.pdf.char_vpos = CharVPos.SUP\n        if tag == \"sub\":\n            self.pdf.char_vpos = CharVPos.SUB\n        if tag == \"title\":\n            self._in_title = True\n        if css_style.get(\"break-after\") == \"page\":\n            if tag in (\"br\", \"hr\", \"img\"):\n                self._end_paragraph()\n                # pylint: disable=protected-access\n                self.pdf._perform_page_break()  # pyright: ignore[reportPrivateUsage]\n            else:\n                self._page_break_after_paragraph = True\n\n    def handle_endtag(self, tag: str) -> None:\n        while (\n            self._tags_stack\n            and tag != self._tags_stack[-1]\n            and self._tags_stack[-1] in self.HTML_UNCLOSED_TAGS\n        ):\n            self._tags_stack.pop()\n        if not self._tags_stack:\n            if self.warn_on_tags_not_matching:\n                LOGGER.warning(\n                    \"Unexpected HTML end tag </%s>, start tag may be missing?\", tag\n                )\n        elif tag == self._tags_stack[-1]:\n            self._tags_stack.pop()\n        elif self.warn_on_tags_not_matching:\n            LOGGER.warning(\n                \"Unexpected HTML end tag </%s>, start tag was <%s>\",\n                tag,\n                self._tags_stack[-1],\n            )\n        if tag == \"a\":\n            self.href = \"\"\n        if tag == \"p\":\n            if self.style_stack:\n                font_face = self.style_stack.pop()\n                self.font_family = font_face.family or self.font_family\n                self.font_size_pt = font_face.size_pt or self.font_size_pt\n                self.font_emphasis = font_face.emphasis or TextEmphasis.NONE\n                self.font_color = font_face.color\n            self._end_paragraph()\n            self.align = None\n        if tag in HEADING_TAGS:\n            self.heading_level = None\n            if self.style_stack:\n                font_face = self.style_stack.pop()\n                self.font_family = font_face.family or self.font_family\n                self.font_size_pt = font_face.size_pt or self.font_size_pt\n                self.font_emphasis = font_face.emphasis or TextEmphasis.NONE\n                self.font_color = font_face.color\n            self._end_paragraph()\n            self.follows_heading = True  # We don't want extra space below a heading.\n        if tag in (\n            \"b\",\n            \"blockquote\",\n            \"center\",\n            \"code\",\n            \"em\",\n            \"i\",\n            \"dd\",\n            \"dt\",\n            \"pre\",\n            \"s\",\n            \"strong\",\n            \"u\",\n        ):\n            if self.style_stack:\n                font_face = self.style_stack.pop()\n                self.font_family = font_face.family or self.font_family\n                self.font_size_pt = font_face.size_pt or self.font_size_pt\n                self.font_emphasis = font_face.emphasis or TextEmphasis.NONE\n                self.font_color = font_face.color\n            if tag == \"pre\":\n                self._pre_formatted = False\n                self._pre_started = False\n            if tag in BLOCK_TAGS:\n                self._end_paragraph()\n        if tag in (\"ul\", \"ol\"):\n            self._end_paragraph()\n            if tag == \"ol\":\n                self.ol_type.pop(self.indent)\n            self.indent -= 1\n            self.line_height_stack.pop()\n            self.bullet.pop()\n        if tag == \"table\":\n            assert self.table is not None\n            self.table.render()\n            self.table = None\n            self._ln()\n        if tag == \"tr\":\n            self.tr = None\n            self.table_row = None\n        if tag in (\"td\", \"th\"):\n            assert (\n                self.td_th is not None\n                and self.tr is not None\n                and self.table_row is not None\n            )\n            if \"inserted\" not in self.td_th:\n                # handle_data() was not called => we call it to produce an empty cell:\n                bgcolor = color_as_decimal(\n                    self.td_th.get(\"bgcolor\") or self.tr.get(\"bgcolor\", None)\n                )\n                style = FontFace(fill_color=bgcolor) if bgcolor else None\n                colspan = int(self.td_th.get(\"colspan\", \"1\"))\n                rowspan = int(self.td_th.get(\"rowspan\", \"1\"))\n                self.table_row.cell(\n                    text=\"\", style=style, colspan=colspan, rowspan=rowspan\n                )\n            self.td_th = None\n        if tag == \"font\":\n            if self.style_stack:\n                font_face = self.style_stack.pop()\n                self.font_family = font_face.family or self.font_family\n                self.font_size_pt = font_face.size_pt or self.font_size_pt\n                self.font_emphasis = font_face.emphasis or TextEmphasis.NONE\n                self.font_color = font_face.color\n        if tag == \"sup\":\n            self.pdf.char_vpos = CharVPos.LINE\n        if tag == \"sub\":\n            self.pdf.char_vpos = CharVPos.LINE\n        if tag == \"title\":\n            self._in_title = False\n\n    def feed(self, data: str) -> None:\n        super().feed(data)\n        while self._tags_stack and self._tags_stack[-1] in self.HTML_UNCLOSED_TAGS:\n            self._tags_stack.pop()\n        self._end_paragraph()  # render the final chunk of text and clean up our local context.\n        if self._tags_stack and self.warn_on_tags_not_matching:\n            LOGGER.warning(\"Missing HTML end tag for <%s>\", self._tags_stack[-1])\n\n    def put_link(self, text: str) -> None:\n        \"Insert a hyperlink\"\n        prev_style = FontFace(\n            family=self.font_family,\n            emphasis=self.font_emphasis,\n            size_pt=self.font_size_pt,\n            color=self.font_color,\n        )\n        tag_style = self.tag_styles[\"a\"]\n        if tag_style.color:\n            self.font_color = tag_style.color\n        self.font_family = tag_style.family or self.font_family\n        self.font_size_pt = tag_style.size_pt or self.font_size_pt\n        if tag_style.emphasis:\n            self.font_emphasis |= tag_style.emphasis\n        self._write_paragraph(text, link=self.href)\n        # Restore previous style:\n        self.font_family = prev_style.family or self.font_family\n        self.font_size_pt = prev_style.size_pt or self.font_size_pt\n        self.font_emphasis = prev_style.emphasis or TextEmphasis.NONE\n        self.font_color = prev_style.color\n\n    # pylint: disable=no-self-use\n    def render_toc(self, pdf: \"FPDF\", outline: list[OutlineSection]) -> None:\n        \"This method can be overridden by subclasses to customize the Table of Contents style.\"\n        pdf.ln()\n        for section in outline:\n            link = pdf.add_link(page=section.page_number)\n            text = f'{\" \" * section.level * 2} {section.name}'\n            text += f' {\".\" * (60 - section.level*2 - len(section.name))} {section.page_number}'\n            pdf.multi_cell(\n                w=pdf.epw,\n                h=pdf.font_size,\n                text=text,\n                new_x=XPos.LMARGIN,\n                new_y=YPos.NEXT,\n                link=link,\n            )\n\n    # Subclasses of _markupbase.ParserBase must implement this:\n    def error(self, message: str) -> None:\n        raise RuntimeError(message)",
      "language": "python"
    },
    {
      "code": "def error(self, message: str) -> None:\n    raise RuntimeError(message)",
      "language": "python"
    },
    {
      "code": "def feed(self, data: str) -> None:\n    super().feed(data)\n    while self._tags_stack and self._tags_stack[-1] in self.HTML_UNCLOSED_TAGS:\n        self._tags_stack.pop()\n    self._end_paragraph()  # render the final chunk of text and clean up our local context.\n    if self._tags_stack and self.warn_on_tags_not_matching:\n        LOGGER.warning(\"Missing HTML end tag for <%s>\", self._tags_stack[-1])",
      "language": "python"
    },
    {
      "code": "def handle_data(self, data: str) -> None:\n    if self._in_title:\n        if self.pdf.title:\n            LOGGER.warning('Ignoring repeated <title> \"%s\"', data)\n        else:\n            self.pdf.set_title(data)\n        if not self.render_title_tag:\n            return\n    if self.td_th is not None:\n        data = data.strip()\n        if not data:\n            return\n        if \"inserted\" in self.td_th:\n            td_th_tag = self.td_th[\"tag\"]\n            raise NotImplementedError(\n                f\"Unsupported nested HTML tags inside <{td_th_tag}> element: <{self._tags_stack[-1]}>\"\n            )\n            # We could potentially support nested <b> / <em> / <font> tags\n            # by building a list of Fragment instances from the HTML cell content\n            # and then passing those fragments to Row.cell().\n            # However there should be an incoming refactoring of this code\n            # dedicated to text layout, and we should probably wait for that\n            # before supporting this feature.\n        align = self.td_th.get(\"align\")\n        if align is None and self.tr is not None:\n            align = self.tr.get(\"align\")\n        if align:\n            align = align.upper()\n        bgcolor_str = self.td_th.get(\"bgcolor\")\n        if bgcolor_str is None and self.tr is not None:\n            bgcolor_str = self.tr.get(\"bgcolor\")\n        bgcolor = color_as_decimal(bgcolor_str)\n        colspan = int(self.td_th.get(\"colspan\") or \"1\")\n        rowspan = int(self.td_th.get(\"rowspan\") or \"1\")\n        emphasis = 0\n        if self.td_th.get(\"b\"):\n            emphasis |= TextEmphasis.B\n        if self.td_th.get(\"i\"):\n            emphasis |= TextEmphasis.I\n        if self.td_th.get(\"U\"):\n            emphasis |= TextEmphasis.U\n        font_family = (\n            self.font_family if self.font_family != self.pdf.font_family else None\n        )\n        font_size_pt = (\n            self.font_size_pt\n            if self.font_size_pt != self.pdf.font_size_pt\n            else None\n        )\n        font_style = None\n        if font_family or emphasis or font_size_pt or bgcolor:\n            font_style = FontFace(\n                family=font_family,\n                emphasis=emphasis,\n                size_pt=font_size_pt,\n                color=self.pdf.text_color,\n                fill_color=bgcolor,\n            )\n        assert self.table_row is not None\n        self.table_row.cell(\n            text=data,\n            align=align,\n            style=font_style,\n            colspan=colspan,\n            rowspan=rowspan,\n        )\n        self.td_th[\"inserted\"] = True\n    elif self.table is not None:\n        # ignore anything else than td inside a table\n        pass\n    elif self._pre_formatted:  # pre blocks\n        # If we want to mimic the exact HTML semantics about newlines at the\n        # beginning and end of the block, then this needs some more thought.\n        if data.startswith(\"\\n\") and self._pre_started:\n            if data.endswith(\"\\n\"):\n                data = data[1:-1]\n            else:\n                data = data[1:]\n        self._pre_started = False\n        self._write_data(data)\n    else:\n        data = _WS_SUB_PAT.sub(\" \", data)\n        if self.follows_trailing_space and data[0] == \" \":\n            self._write_data(data[1:])\n        else:\n            self._write_data(data)\n        self.follows_trailing_space = data[-1] == \" \"\n    if self._page_break_after_paragraph:\n        self._end_paragraph()",
      "language": "python"
    },
    {
      "code": "def handle_endtag(self, tag: str) -> None:\n    while (\n        self._tags_stack\n        and tag != self._tags_stack[-1]\n        and self._tags_stack[-1] in self.HTML_UNCLOSED_TAGS\n    ):\n        self._tags_stack.pop()\n    if not self._tags_stack:\n        if self.warn_on_tags_not_matching:\n            LOGGER.warning(\n                \"Unexpected HTML end tag </%s>, start tag may be missing?\", tag\n            )\n    elif tag == self._tags_stack[-1]:\n        self._tags_stack.pop()\n    elif self.warn_on_tags_not_matching:\n        LOGGER.warning(\n            \"Unexpected HTML end tag </%s>, start tag was <%s>\",\n            tag,\n            self._tags_stack[-1],\n        )\n    if tag == \"a\":\n        self.href = \"\"\n    if tag == \"p\":\n        if self.style_stack:\n            font_face = self.style_stack.pop()\n            self.font_family = font_face.family or self.font_family\n            self.font_size_pt = font_face.size_pt or self.font_size_pt\n            self.font_emphasis = font_face.emphasis or TextEmphasis.NONE\n            self.font_color = font_face.color\n        self._end_paragraph()\n        self.align = None\n    if tag in HEADING_TAGS:\n        self.heading_level = None\n        if self.style_stack:\n            font_face = self.style_stack.pop()\n            self.font_family = font_face.family or self.font_family\n            self.font_size_pt = font_face.size_pt or self.font_size_pt\n            self.font_emphasis = font_face.emphasis or TextEmphasis.NONE\n            self.font_color = font_face.color\n        self._end_paragraph()\n        self.follows_heading = True  # We don't want extra space below a heading.\n    if tag in (\n        \"b\",\n        \"blockquote\",\n        \"center\",\n        \"code\",\n        \"em\",\n        \"i\",\n        \"dd\",\n        \"dt\",\n        \"pre\",\n        \"s\",\n        \"strong\",\n        \"u\",\n    ):\n        if self.style_stack:\n            font_face = self.style_stack.pop()\n            self.font_family = font_face.family or self.font_family\n            self.font_size_pt = font_face.size_pt or self.font_size_pt\n            self.font_emphasis = font_face.emphasis or TextEmphasis.NONE\n            self.font_color = font_face.color\n        if tag == \"pre\":\n            self._pre_formatted = False\n            self._pre_started = False\n        if tag in BLOCK_TAGS:\n            self._end_paragraph()\n    if tag in (\"ul\", \"ol\"):\n        self._end_paragraph()\n        if tag == \"ol\":\n            self.ol_type.pop(self.indent)\n        self.indent -= 1\n        self.line_height_stack.pop()\n        self.bullet.pop()\n    if tag == \"table\":\n        assert self.table is not None\n        self.table.render()\n        self.table = None\n        self._ln()\n    if tag == \"tr\":\n        self.tr = None\n        self.table_row = None\n    if tag in (\"td\", \"th\"):\n        assert (\n            self.td_th is not None\n            and self.tr is not None\n            and self.table_row is not None\n        )\n        if \"inserted\" not in self.td_th:\n            # handle_data() was not called => we call it to produce an empty cell:\n            bgcolor = color_as_decimal(\n                self.td_th.get(\"bgcolor\") or self.tr.get(\"bgcolor\", None)\n            )\n            style = FontFace(fill_color=bgcolor) if bgcolor else None\n            colspan = int(self.td_th.get(\"colspan\", \"1\"))\n            rowspan = int(self.td_th.get(\"rowspan\", \"1\"))\n            self.table_row.cell(\n                text=\"\", style=style, colspan=colspan, rowspan=rowspan\n            )\n        self.td_th = None\n    if tag == \"font\":\n        if self.style_stack:\n            font_face = self.style_stack.pop()\n            self.font_family = font_face.family or self.font_family\n            self.font_size_pt = font_face.size_pt or self.font_size_pt\n            self.font_emphasis = font_face.emphasis or TextEmphasis.NONE\n            self.font_color = font_face.color\n    if tag == \"sup\":\n        self.pdf.char_vpos = CharVPos.LINE\n    if tag == \"sub\":\n        self.pdf.char_vpos = CharVPos.LINE\n    if tag == \"title\":\n        self._in_title = False",
      "language": "python"
    },
    {
      "code": "def handle_starttag(self, tag: str, attrs: list[tuple[str, str | None]]) -> None:\n    self._pre_started = False\n    attrs_dict: dict[str, str | None] = dict(attrs)\n    del attrs\n    css_style = parse_css_style(attrs_dict.get(\"style\") or \"\")\n    self._tags_stack.append(tag)\n    if css_style.get(\"break-before\") == \"page\":\n        self._end_paragraph()\n        # pylint: disable=protected-access\n        self.pdf._perform_page_break()  # pyright: ignore[reportPrivateUsage]\n    if tag in (\"b\", \"i\", \"u\") and self.td_th is not None:\n        self.td_th[tag] = True\n    if tag == \"a\":\n        self.href = attrs_dict[\"href\"] or \"\"\n        try:\n            page = int(self.href)\n            self.href = self.pdf.add_link(page=page)\n        except ValueError:\n            pass\n    if tag == \"br\":\n        self._write_paragraph(\"\\n\")\n    if tag == \"hr\":\n        self._end_paragraph()\n        width_str = css_style.get(\"width\", attrs_dict.get(\"width\"))\n        if width_str:\n            if width_str[-1] == \"%\":\n                hr_width = self.pdf.epw * float(width_str[:-1]) / 100\n            else:\n                hr_width = float(width_str) / self.pdf.k\n        else:\n            hr_width = self.pdf.epw\n        # Centering:\n        x_start = self.pdf.l_margin + (self.pdf.epw - hr_width) / 2\n        self.pdf.line(\n            x1=x_start,\n            y1=self.pdf.y,\n            x2=x_start + hr_width,\n            y2=self.pdf.y,\n        )\n        self._write_paragraph(\"\\n\")\n    if tag == \"p\":\n        self.style_stack.append(\n            FontFace(\n                family=self.font_family,\n                emphasis=self.font_emphasis,\n                size_pt=self.font_size_pt,\n                color=self.font_color,\n            )\n        )\n        align: Optional[Align] = None\n        if \"align\" in attrs_dict:\n            try:\n                align_str = attrs_dict.get(\"align\")\n                align = Align.coerce(align_str) if align_str is not None else None\n            except ValueError:\n                align = None\n        line_height_str = css_style.get(\n            \"line-height\", attrs_dict.get(\"line-height\")\n        )\n        # \"line-height\" attributes are not valid in HTML,\n        # but we support it for backward compatibility,\n        # because fpdf2 honors it since 2.6.1 and PR #629\n        line_height: Optional[float] = None\n        if line_height_str:\n            try:\n                # YYY parse and convert non-float line_height values\n                line_height = float(line_height_str)\n            except ValueError:\n                line_height = None\n        tag_style = self.tag_styles[tag]\n        if tag_style.color is not None and tag_style.color != self.font_color:\n            self.font_color = tag_style.color\n        if tag_style.family is not None and tag_style.family != self.font_family:\n            self.font_family = tag_style.family\n        if tag_style.size_pt is not None and tag_style.size_pt != self.font_size_pt:\n            self.font_size_pt = tag_style.size_pt\n        if tag_style.emphasis:\n            self.font_emphasis |= tag_style.emphasis\n        if isinstance(tag_style, TextStyle):\n            t_margin = tag_style.t_margin\n            b_margin = tag_style.b_margin\n            l_margin = tag_style.l_margin\n        else:\n            t_margin = b_margin = l_margin = 0.0\n        l_margin = self._normalize_l_margin(l_margin)\n        self._new_paragraph(\n            align=align,\n            line_height=line_height or 1.0,\n            top_margin=t_margin,\n            bottom_margin=b_margin,\n            indent=l_margin,\n        )\n    if tag in HEADING_TAGS:\n        self.style_stack.append(\n            FontFace(\n                family=self.font_family,\n                emphasis=self.font_emphasis,\n                size_pt=self.font_size_pt,\n                color=self.font_color,\n            )\n        )\n        self.heading_level = 0 if tag == \"title\" else int(tag[1:])\n        tag_style = self.tag_styles[tag]\n        hsize = (tag_style.size_pt or self.font_size_pt) / self.pdf.k\n        align = None\n        if \"align\" in attrs_dict:\n            try:\n                align_str = attrs_dict.get(\"align\")\n                align = Align.coerce(align_str) if align_str is not None else None\n            except ValueError:\n                align = None\n        if isinstance(tag_style, TextStyle):\n            t_margin = tag_style.t_margin\n            b_margin = tag_style.b_margin\n            l_margin = tag_style.l_margin\n        else:\n            t_margin = b_margin = l_margin = 0.0\n        l_margin = self._normalize_l_margin(l_margin)\n        self._new_paragraph(\n            align=align,\n            top_margin=t_margin,\n            bottom_margin=b_margin * hsize,\n            indent=l_margin,\n        )\n        if \"color\" in css_style:\n            self.font_color = color_as_decimal(css_style[\"color\"])\n        elif \"color\" in attrs_dict:\n            # \"color\" attributes are not valid in HTML,\n            # but we support it for backward compatibility:\n            self.font_color = color_as_decimal(attrs_dict[\"color\"])\n        elif tag_style.color is not None and tag_style.color != self.font_color:\n            self.font_color = tag_style.color\n        if tag_style.family is not None and tag_style.family != self.font_family:\n            self.font_family = tag_style.family\n        if tag_style.size_pt is not None and tag_style.size_pt != self.font_size_pt:\n            self.font_size_pt = tag_style.size_pt\n        if tag_style.emphasis:\n            self.font_emphasis |= tag_style.emphasis\n    if tag in (\n        \"b\",\n        \"blockquote\",\n        \"center\",\n        \"code\",\n        \"del\",\n        \"em\",\n        \"i\",\n        \"dd\",\n        \"dt\",\n        \"pre\",\n        \"s\",\n        \"strong\",\n        \"u\",\n    ):\n        if tag in BLOCK_TAGS:\n            self._end_paragraph()\n        self.style_stack.append(\n            FontFace(\n                family=self.font_family,\n                emphasis=self.font_emphasis,\n                size_pt=self.font_size_pt,\n                color=self.font_color,\n            )\n        )\n        tag_style = self.tag_styles[tag]\n        if tag_style.color:\n            self.font_color = tag_style.color\n        self.font_family = tag_style.family or self.font_family\n        self.font_size_pt = tag_style.size_pt or self.font_size_pt\n        if tag_style.emphasis:\n            self.font_emphasis |= tag_style.emphasis\n        if tag == \"pre\":\n            self._pre_formatted = True\n            self._pre_started = True\n        if tag in BLOCK_TAGS:\n            if tag == \"dd\":\n                # Not compliant with the HTML spec, but backward-compatible\n                # cf. https://github.com/py-pdf/fpdf2/pull/1217#discussion_r1666643777\n                self.follows_heading = True\n            if isinstance(tag_style, TextStyle):\n                t_margin = tag_style.t_margin\n                b_margin = tag_style.b_margin\n                l_margin = tag_style.l_margin\n            else:\n                t_margin = b_margin = l_margin = 0.0\n            l_margin = self._normalize_l_margin(l_margin)\n            self._new_paragraph(\n                line_height=(\n                    self.line_height_stack[-1] if self.line_height_stack else None\n                ),\n                top_margin=t_margin,\n                bottom_margin=b_margin,\n                indent=l_margin,\n            )\n    if tag == \"ul\":\n        self.indent += 1\n        bullet_char = attrs_dict.get(\"type\", self.ul_bullet_char)\n        assert bullet_char is not None\n        self.bullet.append(bullet_char)\n        line_height_str = css_style.get(\n            \"line-height\", attrs_dict.get(\"line-height\")\n        )\n        # \"line-height\" attributes are not valid in HTML,\n        # but we support it for backward compatibility,\n        # because fpdf2 honors it since 2.6.1 and PR #629\n        if line_height_str:\n            try:\n                # YYY parse and convert non-float line_height values\n                self.line_height_stack.append(float(line_height_str))\n            except ValueError:\n                pass\n        else:\n            self.line_height_stack.append(None)\n        if self.indent == 1:\n            tag_style = self.tag_styles[tag]\n            if isinstance(tag_style, TextStyle):\n                t_margin = tag_style.t_margin\n                b_margin = tag_style.b_margin\n                l_margin = tag_style.l_margin\n            else:\n                t_margin = b_margin = l_margin = 0.0\n            l_margin = self._normalize_l_margin(l_margin)\n            self._new_paragraph(\n                line_height=0,\n                top_margin=t_margin,\n                bottom_margin=b_margin,\n                indent=l_margin,\n            )\n            self._write_paragraph(\"\\u00a0\")\n        self._end_paragraph()\n    if tag == \"ol\":\n        self.indent += 1\n        start = 1\n        if \"start\" in attrs_dict:\n            start_str = attrs_dict[\"start\"] or \"1\"\n            try:\n                start = int(start_str)\n            except ValueError:\n                start = 1\n        self.bullet.append(start - 1)\n        self.ol_type[self.indent] = attrs_dict.get(\"type\") or \"1\"\n        line_height_str = css_style.get(\"line-height\") or attrs_dict.get(\n            \"line-height\"\n        )\n        # \"line-height\" attributes are not valid in HTML,\n        # but we support it for backward compatibility,\n        # because fpdf2 honors it since 2.6.1 and PR #629\n        if line_height_str:\n            try:\n                # YYY parse and convert non-float line_height values\n                self.line_height_stack.append(float(line_height_str))\n            except ValueError:\n                pass\n        else:\n            self.line_height_stack.append(None)\n        if self.indent == 1:\n            tag_style = self.tag_styles[tag]\n            if isinstance(tag_style, TextStyle):\n                t_margin = tag_style.t_margin\n                b_margin = tag_style.b_margin\n                l_margin = tag_style.l_margin\n            else:\n                t_margin = b_margin = l_margin = 0.0\n            l_margin = self._normalize_l_margin(l_margin)\n            self._new_paragraph(\n                line_height=0,\n                top_margin=t_margin,\n                bottom_margin=b_margin,\n                indent=l_margin,\n            )\n            self._write_paragraph(\"\\u00a0\")\n        self._end_paragraph()\n    if tag == \"li\":\n        prev_text_color = self.pdf.text_color\n        self.pdf.text_color = self.li_prefix_color\n        if self.bullet:\n            bullet = self.bullet[self.indent - 1]\n        else:\n            # Allow <li> to be used outside of <ul> or <ol>.\n            bullet = self.ul_bullet_char\n        if not isinstance(bullet, int):\n            bullet = ul_prefix(bullet, self.pdf.is_ttf_font)\n        if not isinstance(bullet, str):\n            bullet += 1\n            self.bullet[self.indent - 1] = bullet\n            ol_type = self.ol_type[self.indent]\n            bullet = f\"{ol_prefix(ol_type, bullet)}.\"\n        tag_style = self.tag_styles[tag]\n        if isinstance(tag_style, TextStyle):\n            b_margin = tag_style.b_margin\n            l_margin = tag_style.l_margin\n            t_margin = tag_style.t_margin\n        else:\n            b_margin = l_margin = t_margin = 0.0\n        l_margin = self._normalize_l_margin(l_margin)\n        self._ln(t_margin)\n        numeric_indent = 0.0 if isinstance(l_margin, Align) else l_margin\n        self._new_paragraph(\n            line_height=(\n                self.line_height_stack[-1] if self.line_height_stack else None\n            ),\n            indent=numeric_indent * self.indent,\n            bottom_margin=b_margin,\n            bullet=bullet,\n        )\n        self.pdf.text_color = prev_text_color\n    if tag == \"font\":\n        self.style_stack.append(\n            FontFace(\n                family=self.font_family,\n                emphasis=self.font_emphasis,\n                size_pt=self.font_size_pt,\n                color=self.font_color,\n            )\n        )\n        if \"color\" in attrs_dict:\n            self.font_color = color_as_decimal(attrs_dict[\"color\"])\n        if \"font-size\" in css_style:\n            font_size_str = css_style.get(\"font-size\") or \"\"\n            try:\n                self.font_size_pt = float(font_size_str)\n            except ValueError:\n                pass\n        elif \"size\" in attrs_dict:\n            font_size_str = attrs_dict.get(\"size\") or \"\"\n            try:\n                self.font_size_pt = float(font_size_str)\n            except ValueError:\n                pass\n        if \"face\" in attrs_dict:\n            font_family = attrs_dict.get(\"face\") or \"\"\n            self.font_family = font_family.lower()\n    if tag == \"table\":\n        self._end_paragraph()\n        width: Optional[float] = None\n        width_str = css_style.get(\"width\") or attrs_dict.get(\"width\")\n        if width_str:\n            if width_str[-1] == \"%\":\n                width = self.pdf.epw * float(width_str[:-1]) / 100\n            else:\n                width = float(width_str) / self.pdf.k\n        if \"border\" not in attrs_dict:  # default borders\n            borders_layout = (\n                \"HORIZONTAL_LINES\"\n                if self.table_line_separators\n                else \"SINGLE_TOP_LINE\"\n            )\n        else:\n            borders_str = attrs_dict[\"border\"] or \"\"\n            try:\n                if int(borders_str) > 0:  # explicitly enabled borders\n                    borders_layout = (\n                        \"ALL\"\n                        if self.table_line_separators\n                        else \"NO_HORIZONTAL_LINES\"\n                    )\n                else:  # explicitly disabled borders\n                    borders_layout = \"NONE\"\n            except ValueError:\n                borders_layout = \"NONE\"\n        align = Align.coerce(attrs_dict.get(\"align\") or \"CENTER\")\n        padding = (\n            float(attrs_dict[\"cellpadding\"] or 0)\n            if \"cellpadding\" in attrs_dict\n            else None\n        )\n        spacing = float(attrs_dict.get(\"cellspacing\") or 0)\n        self.table = Table(\n            self.pdf,\n            align=align,\n            borders_layout=borders_layout,\n            line_height=self.font_size_pt / self.pdf.k * self.TABLE_LINE_HEIGHT,\n            width=width,\n            padding=padding,\n            gutter_width=spacing,\n            gutter_height=spacing,\n        )\n        self._ln()\n    if tag == \"tr\":\n        if not self.table:\n            raise FPDFException(\"Invalid HTML: <tr> used outside any <table>\")\n        self.tr = {k.lower(): v for k, v in attrs_dict.items()}\n        self.table_row = self.table.row()\n    if tag in (\"td\", \"th\"):\n        if not self.table or not self.table_row:\n            raise FPDFException(f\"Invalid HTML: <{tag}> used outside any <tr>\")\n        self.td_th = {k.lower(): v for k, v in attrs_dict.items()}\n        self.td_th[\"tag\"] = tag\n        if tag == \"th\":\n            if \"align\" not in self.td_th:\n                self.td_th[\"align\"] = \"CENTER\"\n            self.td_th[\"b\"] = True\n        elif len(self.table.rows) == 1 and not self.table_row.cells:\n            # => we are in the 1st <tr>, and the 1st cell is a <td>\n            # => we do not treat the first row as a header\n            # pylint: disable=protected-access\n            self.table._first_row_as_headings = (\n                False  # pyright: ignore[reportPrivateUsage]\n            )\n            self.table._num_heading_rows = 0  # pyright: ignore[reportPrivateUsage]\n        if \"height\" in attrs_dict:\n            LOGGER.warning(\n                'Ignoring unsupported height=\"%s\" specified on a <%s>',\n                attrs_dict[\"height\"],\n                tag,\n            )\n        if \"width\" in attrs_dict:\n            width_str = attrs_dict[\"width\"] or \"0\"\n            # pylint: disable=protected-access\n            if len(self.table.rows) == 1:  # => first table row\n                if width_str[-1] == \"%\":\n                    width = float(width_str[:-1])\n                else:\n                    width = float(width_str)\n                if not self.table._col_widths:\n                    self.table._col_widths = []\n                assert isinstance(self.table._col_widths, list)\n                self.table._col_widths.append(width)\n            else:\n                LOGGER.warning(\n                    'Ignoring width=\"%s\" specified on a <%s> that is not in the first <tr>',\n                    width_str,\n                    tag,\n                )\n    if tag == \"img\" and \"src\" in attrs_dict:\n        width = float(attrs_dict.get(\"width\") or 0) / self.pdf.k\n        height = float(attrs_dict.get(\"height\") or 0) / self.pdf.k\n        if self.table_row:  # => <img> in a <table>\n            if width or height:\n                LOGGER.warning(\n                    'Ignoring unsupported \"width\" / \"height\" set on <img> element'\n                )\n            if self.align:\n                LOGGER.warning(\"Ignoring unsupported <img> alignment\")\n            self.table_row.cell(img=attrs_dict[\"src\"], img_fill_width=True)\n            assert self.td_th is not None\n            self.td_th[\"inserted\"] = True\n            return\n        x: float | Align = self.pdf.get_x()\n        if self.align:\n            x = self.align\n        self.pdf.image(\n            self.image_map(attrs_dict[\"src\"] or \"\"),\n            x=x,\n            w=width,\n            h=height,\n            link=self.href,\n        )\n    if tag == \"toc\":\n        self._end_paragraph()\n        self.pdf.insert_toc_placeholder(\n            self.render_toc, pages=int(attrs_dict.get(\"pages\") or \"1\")\n        )\n    if tag == \"sup\":\n        self.pdf.char_vpos = CharVPos.SUP\n    if tag == \"sub\":\n        self.pdf.char_vpos = CharVPos.SUB\n    if tag == \"title\":\n        self._in_title = True\n    if css_style.get(\"break-after\") == \"page\":\n        if tag in (\"br\", \"hr\", \"img\"):\n            self._end_paragraph()\n            # pylint: disable=protected-access\n            self.pdf._perform_page_break()  # pyright: ignore[reportPrivateUsage]\n        else:\n            self._page_break_after_paragraph = True",
      "language": "python"
    },
    {
      "code": "def put_link(self, text: str) -> None:\n    \"Insert a hyperlink\"\n    prev_style = FontFace(\n        family=self.font_family,\n        emphasis=self.font_emphasis,\n        size_pt=self.font_size_pt,\n        color=self.font_color,\n    )\n    tag_style = self.tag_styles[\"a\"]\n    if tag_style.color:\n        self.font_color = tag_style.color\n    self.font_family = tag_style.family or self.font_family\n    self.font_size_pt = tag_style.size_pt or self.font_size_pt\n    if tag_style.emphasis:\n        self.font_emphasis |= tag_style.emphasis\n    self._write_paragraph(text, link=self.href)\n    # Restore previous style:\n    self.font_family = prev_style.family or self.font_family\n    self.font_size_pt = prev_style.size_pt or self.font_size_pt\n    self.font_emphasis = prev_style.emphasis or TextEmphasis.NONE\n    self.font_color = prev_style.color",
      "language": "python"
    },
    {
      "code": "def render_toc(self, pdf: \"FPDF\", outline: list[OutlineSection]) -> None:\n    \"This method can be overridden by subclasses to customize the Table of Contents style.\"\n    pdf.ln()\n    for section in outline:\n        link = pdf.add_link(page=section.page_number)\n        text = f'{\" \" * section.level * 2} {section.name}'\n        text += f' {\".\" * (60 - section.level*2 - len(section.name))} {section.page_number}'\n        pdf.multi_cell(\n            w=pdf.epw,\n            h=pdf.font_size,\n            text=text,\n            new_x=XPos.LMARGIN,\n            new_y=YPos.NEXT,\n            link=link,\n        )",
      "language": "python"
    },
    {
      "code": "class HTMLMixin:\n    \"\"\"\n    [**DEPRECATED since v2.6.0**]\n    You can now directly use the `FPDF.write_html()` method\n    \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        super().__init__(*args, **kwargs)\n        warnings.warn(\n            (\n                \"The HTMLMixin class is deprecated since v2.6.0. \"\n                \"Simply use the FPDF class as a replacement.\"\n            ),\n            DeprecationWarning,\n            stacklevel=get_stack_level(),\n        )",
      "language": "python"
    }
  ],
  "patterns": [],
  "links": [
    "https://py-pdf.github.io/fpdf2/HTML.html",
    "https://py-pdf.github.io/fpdf2/fpdf/drawing_primitives.html",
    "https://py-pdf.github.io/fpdf2/fpdf/fonts.html",
    "https://py-pdf.github.io/fpdf2/fpdf/fpdf.html",
    "https://py-pdf.github.io/fpdf2/fpdf/outline.html",
    "https://py-pdf.github.io/fpdf2/fpdf/index.html",
    "https://py-pdf.github.io/fpdf2/fpdf/html.html"
  ]
}