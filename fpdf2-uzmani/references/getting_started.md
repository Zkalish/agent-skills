# Fpdf2-Uzmani - Getting Started

**Pages:** 104

---

## fpdf2¬∂

**URL:** https://py-pdf.github.io/fpdf2/

**Contents:**
- fpdf2¬∂
- Main features¬∂
- Tutorials¬∂
- Installation¬∂
  - Displaying deprecation warnings¬∂
- Community¬∂
  - Support¬∂
  - They use fpdf2¬∂
  - Usage statistics¬∂
  - Related¬∂

fpdf2 is a library for simple & fast PDF document generation in Python. It is a fork and the successor of PyFPDF (cf. history).

Latest Released Version:

Go try it now online in a Jupyter notebook: or

From PyPI: pip install fpdf2

To get the latest, unreleased, development version straight from the development branch of this repository:

Development: check the dedicated documentation page.

DeprecationWarnings are not displayed by Python by default.

Hence, every time you use a newer version of fpdf2, we strongly encourage you to execute your scripts with the -Wd option (cf. documentation) in order to get warned about deprecated features used in your code.

This can also be enabled programmatically with warnings.simplefilter('default', DeprecationWarning).

For community support, please feel free to file an issue or open a discussion.

Online classes & open source projects:

**Examples:**

Example 1 (python):
```python
from fpdf import FPDF

pdf = FPDF()
pdf.add_page()
pdf.set_font('Helvetica', size=12)
pdf.cell(text="Hello world!")
pdf.output("hello_world.pdf")
```

Example 2 (unknown):
```unknown
pip install fpdf2
```

Example 3 (python):
```python
pip install git+https://github.com/py-pdf/fpdf2.git@master
```

---

## Tutorial¬∂

**URL:** https://py-pdf.github.io/fpdf2/Tutorial.html

**Contents:**
- Tutorial¬∂
- Tuto 1 - Minimal Example¬∂
- Tuto 2 - Header, footer, page break and image¬∂
- Tuto 3 - Line breaks and colors¬∂
- Tuto 4 - Multi Columns¬∂
- Tuto 5 - Creating Tables¬∂
- Tuto 6 - Creating links and mixing text styles¬∂
- Tuto 7 - Creating PDF/A Documents¬∂
  - PDF/A Standards¬∂
  - Conformance Classes¬∂

Methods full documentation: fpdf.FPDF API doc

Let's start with the classic example:

After including the library file, we create an FPDF object. The FPDF constructor is used here with the default values: pages are in A4 portrait and the measure unit is millimeter. It could have been specified explicitly with:

It is possible to set the PDF in landscape mode (L) or to use other page formats (such as Letter and Legal) and measure units (pt, cm, in).

There is no page for the moment, so we have to add one with add_page. The origin is at the upper-left corner and the current position is by default placed at 1 cm from the borders; the margins can be changed with set_margins.

Before we can print text, it is mandatory to select a font with set_font, otherwise the document would be invalid. We choose Helvetica bold 16:

We could have specified italics with I, underlined with U or a regular font with an empty string (or any combination). Note that the font size is given in points, not millimeters (or another user unit); it is the only exception. The other built-in fonts are Times, Courier, Symbol and ZapfDingbats.

We can now print a cell with cell. A cell is a rectangular area, possibly framed, which contains some text. It is rendered at the current position. We specify its dimensions, its text (centered or aligned), if borders should be drawn, and where the current position moves after it (to the right, below or to the beginning of the next line). To add a frame, we would do this:

To add a new cell next to it with centered text and go to the next line, we would do:

Remark: the line break can also be done with ln. This method allows to specify in addition the height of the break.

Finally, the document is closed and saved under the provided file path using output. Without any parameter provided, output() returns the PDF bytearray buffer.

Here is a two page example with header, footer and logo:

This example makes use of the header and footer methods to process page headers and footers. They are called automatically. They already exist in the FPDF class but do nothing, therefore we have to extend the class and override them.

The logo is printed with the image method by specifying its upper-left corner and its width. The height is calculated automatically to respect the image proportions.

To print the page number, a null value is passed as the cell width. It means that the cell should extend up to the right margin of the page; it is handy to center text. The current page number is returned by the page_no method; as for the total number of pages, it is obtained by means of the special value {nb} which will be substituted on document closure (this special value can be changed by alias_nb_pages()). Note the use of the set_y method which allows to set position at an absolute location in the page, starting from the top or the bottom.

Another interesting feature is used here: the automatic page breaking. As soon as a cell would cross a limit in the page (at 2 centimeters from the bottom by default), a break is performed and the font restored. Although the header and footer select their own font (helvetica), the body continues with Times. This mechanism of automatic restoration also applies to colors and line width. The limit which triggers page breaks can be set with set_auto_page_break.

Let's continue with an example which prints justified paragraphs. It also illustrates the use of colors.

The get_string_width method allows determining the length of a string in the current font, which is used here to calculate the position and the width of the frame surrounding the title. Then colors are set (via set_draw_color, set_fill_color and set_text_color) and the thickness of the line is set to 1 mm (against 0.2 by default) with set_line_width. Finally, we output the cell (the last parameter to true indicates that the background must be filled).

The method used to print the paragraphs is multi_cell. Text is justified by default. Each time a line reaches the right extremity of the cell or a carriage return character (\n) is met, a line break is issued and a new cell automatically created under the current one. An automatic break is performed at the location of the nearest space or soft-hyphen (\u00ad) character before the right limit. A soft-hyphen will be replaced by a normal hyphen when triggering a line break, and ignored otherwise.

Two document properties are defined: the title (set_title) and the author (set_author). Properties can be viewed by two means. First is to open the document directly with Acrobat Reader, go to the File menu and choose the Document Properties option. The second, also available from the plug-in, is to right-click and select Document Properties.

This example is a variant of the previous one, showing how to lay the text across multiple columns.

The key difference from the previous tutorial is the use of the text_columns method. It collects all the text, possibly in increments, and distributes it across the requested number of columns, automatically inserting page breaks as necessary. Note that while the TextColumns instance is active as a context manager, text styles and other font properties can be changed. Those changes will be contained to the context. Once it is closed the previous settings will be reinstated.

This tutorial will explain how to create two different tables, to demonstrate what can be achieved with some simple adjustments.

Resulting PDF - Countries CSV data

The first example is achieved in the most basic way possible, feeding data to FPDF.table(). The result is rudimentary but very quick to obtain.

The second table brings some improvements: colors, limited table width, reduced line height, centered titles, columns with custom widths, figures right aligned... Moreover, horizontal lines have been removed. This was done by picking a borders_layout among the available values: TableBordersLayout.

This tutorial will explain several ways to insert links inside a pdf document, as well as adding links to external sources.

It will also show several ways we can use different text styles, (bold, italic, underline) within the same text.

Resulting PDF - fpdf2-logo

The new method shown here to print text is write() . It is very similar to multi_cell() , the key differences being:

The method therefore allows us to write a chunk of text, alter the font style, and continue from the exact place we left off. On the other hand, its main drawback is that we cannot justify the text like we do with the multi_cell() method.

In the first page of the example, we used write() for this purpose. The beginning of the sentence is written in regular style text, then using the set_font() method, we switched to underline and finished the sentence.

To add an internal link pointing to the second page, we used the add_link() method, which creates a clickable area which we named "link" that directs to another page within the document.

To create the external link using an image, we used image() . The method has the option to pass a link as one of its arguments. The link can be both internal or external.

As an alternative, another option to change the font style and add links is to use the write_html() method. It is an html parser, which allows adding text, changing font style and adding links using html.

PDF/A-1 uses PDF-Version 1.4. All resources (pictures, graphics, fonts) must be embedded in the document. The color management must be precise and platform independently specified with ICC-Profiles and the document metadata must be given with XMP-Metadata.

PDF/A-2 uses PDF-Version 1.7. It allows compression with JPEG2000, transparent elements, open type fonts and digital signatures.

The only extension for PDF/A-3 is the possibility to embed any possible file.

Level A (accessible) encompasses all the requirements of the standard, including mapping the content structure and the correct reading order of the document content. Text content must be extractable, and the structure must reflect the natural reading sequence.

Level B (Basic) guarantees a clear visual reproducibility of the content. Level B is generally easier to generate than Level A, but it does not ensure 100 percent text extraction or searchability. The hassle-free reuse of the content is not necessarily given.

To achieve this, here a little example:

Resulting PDF: tuto7.pdf

Tools like VeraPDF can check conformance of PDF documents produced:

**Examples:**

Example 1 (python):
```python
from fpdf import FPDF

pdf = FPDF()
pdf.add_page()
pdf.set_font("helvetica", style="B", size=16)
pdf.cell(40, 10, "Hello World!")
pdf.output("tuto1.pdf")
```

Example 2 (unknown):
```unknown
pdf = FPDF(orientation="P", unit="mm", format="A4")
```

Example 3 (unknown):
```unknown
pdf.set_font('Helvetica', style='B', size=16)
```

Example 4 (unknown):
```unknown
pdf.cell(40, 10, 'Hello World!', 1)
```

---

## Patterns and Gradients¬∂

**URL:** https://py-pdf.github.io/fpdf2/Patterns.html

**Contents:**
- Patterns and Gradients¬∂
- Overview¬∂
- 2. Gradients¬∂
  - 2.1 What is a Gradient?¬∂
  - 2.2 Linear Gradients (axial shading)¬∂
  - 2.3 Radial Gradients¬∂
- 4. Advanced Usage¬∂
  - 4.1 Multiple Colors¬∂
  - 4.2 Extending & Background for Linear Gradients¬∂
  - 4.3 Custom Bounds¬∂

In PDF (Portable Document Format), a pattern is a graphical object that can be used to fill (or stroke) shapes. Patterns can include simple color fills, images, or more advanced textures and gradients.

The patterns on PDF documents are grouped on 2 types: - Tiling patterns for any repeating patters. - Shading patterns for gradients.

fpdf2 provides a context manager pdf.use_pattern(...). Within this context, all drawn shapes or text will use the specified pattern. Once the context ends, drawing reverts to the previously defined color.

At this moment, tiling patterns are not yet supported by fpdf2.

A gradient is a progressive blend between two or more colors. In PDF terms, gradients are implemented as shading patterns‚Äîthey allow a smooth color transition based on geometry.

A linear gradient blends colors along a straight line between two points. For instance, you can define a gradient that goes:

or in any arbitrary orientation by specifying coordinates.

Example: Creating a Linear Gradient

from fpdf import FPDF from fpdf.pattern import LinearGradient pdf = FPDF() pdf.add_page() # Define a linear gradient linear_grad = LinearGradient( pdf, from_x=10, # Starting x-coordinate from_y=0, # Starting y-coordinate to_x=100, # Ending x-coordinate to_y=0, # Ending y-coordinate colors=["#C33764", "#1D2671"] # Start -> End color ) with pdf.use_pattern(linear_grad): # Draw a rectangle that will be filled with the gradient pdf.rect(x=10, y=10, w=100, h=20, style="FD") pdf.output("pattern_linear_demo.pdf") Result: pattern_linear_demo.pdf

A radial gradient blends colors in a circular or elliptical manner from an inner circle to an outer circle. This is perfect for spotlight-like effects or circular color transitions.

Example: Creating a Radial Gradient

from fpdf import FPDF from fpdf.pattern import RadialGradient pdf = FPDF() pdf.add_page() # Define a radial gradient radial_grad = RadialGradient( pdf, start_circle_x=30, # Center X of inner circle start_circle_y=30, # Center Y of inner circle start_circle_radius=0, # Radius of inner circle end_circle_x=50, # Center X of outer circle end_circle_y=50, # Center Y of outer circle end_circle_radius=25, # Radius of outer circle colors=["#FFFF00", "#FF0000"], # Inner -> Outer color ) with pdf.use_pattern(radial_grad): # Draw a circle filled with the radial gradient pdf.circle(x=50, y=50, radius=25, style="FD") pdf.output("pattern_radial_demo.pdf") Result: pattern_radial_demo.pdf

Both linear and radial gradients support multiple colors. If you pass, for example, colors=["#C33764", "#1D2671", "#FFA500"], the resulting pattern will interpolate color transitions through each color in that order.

For linear gradients or radial gradients, passing bounds=[0.2, 0.4, 0.7, ...] (values between 0 and 1) fine-tunes where each color transition occurs. For instance, if you have 5 colors, you can specify 3 boundary values that partition the color progression among them.

For example, taking a gradient with 5 colors and bounds=[0.1, 0.8, 0.9]: - The transition from color 1 to color 2 starts at the beginning (0%) and ends at 10% - The transition from color 2 to color 3 starts at 10% and ends at 80% - The transition from color 3 to color 4 starts at 80% and ends at 90% - The transition from color 4 to color 5 starts at 90% and goes to the end (100%)

In other words, each boundary value dictates where the color transitions will occur along the total gradient length.

**Examples:**

Example 1 (python):
```python
from fpdf import FPDF
from fpdf.pattern import LinearGradient

pdf = FPDF()
pdf.add_page()

# Define a linear gradient
linear_grad = LinearGradient(
    pdf,
    from_x=10,                        # Starting x-coordinate
    from_y=0,                         # Starting y-coordinate
    to_x=100,                         # Ending x-coordinate
    to_y=0,                           # Ending y-coordinate
    colors=["#C33764", "#1D2671"]     # Start -> End color
)

with pdf.use_pattern(linear_grad):
    # Draw a rectangle that will be filled with the gradient
    pdf.rect(x=10, y=10, w=100, h=20, style="FD")

pdf.output("pattern_linear_demo.pdf")
```

Example 2 (python):
```python
from fpdf import FPDF
from fpdf.pattern import RadialGradient

pdf = FPDF()
pdf.add_page()

# Define a radial gradient
radial_grad = RadialGradient(
    pdf,
    start_circle_x=30,               # Center X of inner circle
    start_circle_y=30,               # Center Y of inner circle
    start_circle_radius=0,           # Radius of inner circle
    end_circle_x=50,                 # Center X of outer circle
    end_circle_y=50,                 # Center Y of outer circle
    end_circle_radius=25,            # Radius of outer circle
    colors=["#FFFF00", "#FF0000"],   # Inner -> Outer color
)

with pdf.use_pattern(radial_grad):
    # Draw a circle filled with the radial gradient
    pdf.circle(x=50, y=50, radius=25, style="FD")

pdf.output("pattern_radial_demo.pdf")
```

---

## Combine with Markdown¬∂

**URL:** https://py-pdf.github.io/fpdf2/CombineWithMarkdown.html

**Contents:**
- Combine with Markdown¬∂
- mistletoe¬∂
  - Rendering unicode characters¬∂
- markdown-it-py¬∂
- mistune¬∂
- Python-Markdown¬∂
- Text styling, fonts, etc.¬∂

Several fpdf2 methods allow Markdown syntax elements:

But fpdf2 also allows for basic conversion from HTML to PDF (cf. HTML). This can be combined with a Markdown-rendering library in order to generate PDF documents from Markdown:

The mistletoe library follows the CommonMark specification: pip install mistletoe

The library can be easily extended: Creating a custom token and renderer.

The markdown-it-py library also follows the CommonMark specification: pip install markdown-it-py

Plugin extensions: the strikethrough & table plugins are embedded within the core package, and many other plugins are then available via the mdit-py-plugins package, including:

There is also the mistune library, that may be the fastest, but it does not follow the CommonMark spec: pip install mistune

There is also the Python-Markdown library, which is the oldest Markdown rendering Python lib still active, but it does not follow the CommonMark spec: pip install markdown

Please refer to the dedicated HTML page for information on how to style HTML tags (<a>, <blockquote>, <code>, <pre>, <h1>...) when using FPDF.write_html(), how to configure fonts, the known limitations, etc.

**Examples:**

Example 1 (unknown):
```unknown
pip install mistletoe
```

Example 2 (markdown):
```markdown
from mistletoe import markdown

html = markdown("""
# Top title (ATX)

Subtitle (setext)
-----------------

### An even lower heading (ATX)

**Text in bold**

_Text in italics_

~~Strikethrough~~

[This is a link](https://github.com/PyFPDF/fpdf2)

<https://py-pdf.github.io/fpdf2/>

This is an unordered list:
* an item
* another item

This is an ordered list:
1. first item
2. second item
3. third item with an unordered sublist:
    * an item
    * another item

Inline `code span`

A table:

| Foo | Bar | Baz |
| ---:|:---:|:--- |
| Foo | Bar | Baz |

Actual HTML:

<dl>
  <dt>Term1</dt><dd>Definition1</dd>
  <dt>Term2</dt><dd>Definition2</dd>
</dl>

Some horizontal thematic breaks:

***
---
___

![Alternate description](https://py-pdf.github.io/fpdf2/fpdf2-logo.png)
""")

from fpdf import FPDF

pdf = FPDF()
pdf.add_page()
pdf.write_html(html)
pdf.output("pdf-from-markdown-with-mistletoe.pdf")
```

Example 3 (python):
```python
from mistletoe import markdown

html = markdown("""
# Unicode:

| Emoji | Description |
| --- | - |
| üòÄ | GRINNING FACE |
| üòÅ | GRINNING FACE WITH SMILING EYES |
| üòà | SMILING FACE WITH HORNS |

# A checklist:

* ‚òê item 1
* ‚òë item 2
* ‚òê item 3
""")

from fpdf import FPDF

pdf = FPDF()
pdf.add_font("DejaVuSans", fname="test/fonts/DejaVuSans.ttf")
pdf.add_font("DejaVuSans", fname="test/fonts/DejaVuSans-Bold.ttf", style="B")
pdf.set_font("DejaVuSans", size=24)
pdf.add_page()
pdf.write_html(html)
pdf.output("pdf-from-markdown-with-mistletoe-unicode.pdf")
```

Example 4 (unknown):
```unknown
pip install markdown-it-py
```

---

## Scalable Vector Graphics (SVG)¬∂

**URL:** https://py-pdf.github.io/fpdf2/SVG.html

**Contents:**
- Scalable Vector Graphics (SVG)¬∂
- Basic usage¬∂
- Detailed example¬∂
- Converting vector graphics to raster graphics¬∂
  - Using cairosvg¬∂
  - Using svglib and reportlab¬∂
- Warning logs¬∂
- Supported SVG Features¬∂
- Currently Unsupported Notable SVG Features¬∂

fpdf2 supports basic conversion of SVG paths into PDF paths, which can be inserted into an existing PDF document or used as the contents of a new PDF document.

Not all SVGs will convert correctly. Please see the list of unsupported features for more information about what to look out for.

SVG files can be directly inserted inside a PDF file using the image() method:

Either the embedded .svg file must includes width and/or height attributes (absolute or relative), or some dimensions must be provided to .image() through its w= and/or h= parameters.

The following script will create a PDF that consists only of the graphics contents of the provided SVG file, filling the whole page:

Because this takes the PDF document size from the source SVG, it does assume that the width/height of the SVG are specified in absolute units rather than relative ones (i.e. the top-level <svg> tag has something like width="5cm" and not width=50%). In this case, if the values are percentages, they will be interpreted as their literal numeric value (i.e. 100% would be treated as 100 pt). The next example uses transform_to_page_viewport, which will scale an SVG with a percentage based width to the pre-defined PDF page size.

The converted SVG object can be returned as an fpdf.drawing.GraphicsContext collection of drawing directives for more control over how it is rendered:

Usually, embedding SVG as vector graphics in PDF documents is the best approach, as it is both lightweight and will allow for better details / precision of the images inserted.

But sometimes, SVG images cannot be directly embedded as vector graphics (SVG), and a conversion to raster graphics (PNG, JPG) must be performed.

The following sections demonstrate how to perform such conversion, using Pygal charts as examples:

A faster and efficient approach for embedding Pygal SVG charts into a PDF file is to use the cairosvg library to convert the vector graphics generated into a BytesIO instance, so that we can keep these data in an in-memory buffer:

import pygal from fpdf import FPDF from io import BytesIO import cairosvg # Create a Pygal bar chart bar_chart = pygal.Bar() bar_chart.title = 'Browser usage evolution (in %)' bar_chart.x_labels = map(str, range(2002, 2013)) bar_chart.add('Firefox', [None, None, 0, 16.6, 25, 31, 36.4, 45.5, 46.3, 42.8, 37.1]) bar_chart.add('Chrome', [None, None, None, None, None, None, 0, 3.9, 10.8, 23.8, 35.3]) bar_chart.add('IE', [85.8, 84.6, 84.7, 74.5, 66, 58.6, 54.7, 44.8, 36.2, 26.6, 20.1]) bar_chart.add('Others', [14.2, 15.4, 15.3, 8.9, 9, 10.4, 8.9, 5.8, 6.7, 6.8, 7.5]) svg_img = bar_chart.render() # Convert the SVG chart to a PNG image in a BytesIO object img_bytesio = BytesIO() cairosvg.svg2png(svg_img, write_to=img_bytesio, dpi=96) # Set the position and size of the image in the PDF x = 50 y = 50 w = 100 h = 70 # Build the PDF pdf = FPDF() pdf.add_page() pdf.image(img_bytesio, x=x, y=y, w=w, h=h) pdf.output('browser-usage-bar-chart.pdf') The above code generates a PDF with the following graph:

!! Troubleshooting advice !!

You may encounter GTK (Gnome Toolkit) errors while executing the above example in windows. Error could be like following - OSError: no library called "cairo-2" was found no library called "cairo" was found no library called "libcairo-2" was found cannot load library 'libcairo.so.2': error 0x7e cannot load library 'libcairo.2.dylib': error 0x7e cannot load library 'libcairo-2.dll': error 0x7e In this case install install GTK from GTK-for-Windows-Runtime-Environment-Installer. Restart your editor. And you are all done.

An alternative, purely pythonic but slightly slower solution is to use reportlab and svglib:

The above code generates the following output:

Performance considerations

Regarding performance, cairosvg is generally faster than svglib when it comes to rendering SVG files to other formats. This is because cairosvg is built on top of a fast C-based rendering engine, while svglib is written entirely in Python, and hence a bit slower. Additionally, cairosvg offers various options for optimizing the rendering performance, such as disabling certain features, like fonts or filters.

The fpdf.svg module produces WARNING log messages for some unsupported SVG tags & attributes. If need be, you can suppress those logs:

Everything not listed as supported is unsupported, which is a lot. SVG is a very complex format that has become increasingly complex as it absorbs more of the entire browser rendering stack into its specification.

However, there are some pretty commonly used features that are unsupported and may cause unexpected results, up to and including a normal-looking SVG rendering as a completely blank PDF.

There are some common SVG features that are currently unsupported, but that fpdf2 could end up supporting with the help of contributors :

Contributions would be very welcome to add support for more SVG features! üëç

If you are interested in contributing to fpdf2 regarding this, drop a comment on GitHub issue #537 and a maintainer will give some pointers to start poking with the code üòä

**Examples:**

Example 1 (swift):
```swift
from fpdf import FPDF

pdf = FPDF()
pdf.add_page()
pdf.image("vector.svg")
pdf.output("doc-with-svg.pdf")
```

Example 2 (python):
```python
import fpdf

svg = fpdf.svg.SVGObject.from_file("my_file.svg")

pdf = fpdf.FPDF(unit="pt", format=(svg.width, svg.height))
pdf.add_page()
svg.draw_to_page(pdf)

pdf.output("my_file.pdf")
```

Example 3 (csharp):
```csharp
import fpdf

svg = fpdf.svg.SVGObject.from_file("my_file.svg")

pdf = FPDF(unit="in", format=(8.5, 11))
pdf.add_page()

# We pass align_viewbox=False because we want to perform positioning manually
# after the size transform has been computed.
width, height, paths = svg.transform_to_page_viewport(pdf, align_viewbox=False)
# note: transformation order is important! This centers the svg drawing at the
# origin, rotates it 90 degrees clockwise, and then repositions it to the
# middle of the output page.
paths.transform = paths.transform @ fpdf.drawing.Transform.translation(
    -width / 2, -height / 2
).rotate_d(90).translate(pdf.w / 2, pdf.h / 2)

pdf.draw_path(paths)

pdf.output("my_file.pdf")
```

Example 4 (swift):
```swift
import pygal
from fpdf import FPDF
from io import BytesIO
import cairosvg

# Create a Pygal bar chart
bar_chart = pygal.Bar()
bar_chart.title = 'Browser usage evolution (in %)'
bar_chart.x_labels = map(str, range(2002, 2013))
bar_chart.add('Firefox', [None, None, 0, 16.6,   25,   31, 36.4, 45.5, 46.3, 42.8, 37.1])
bar_chart.add('Chrome',  [None, None, None, None, None, None,    0,  3.9, 10.8, 23.8, 35.3])
bar_chart.add('IE',      [85.8, 84.6, 84.7, 74.5,   66, 58.6, 54.7, 44.8, 36.2, 26.6, 20.1])
bar_chart.add('Others',  [14.2, 15.4, 15.3,  8.9,    9, 10.4,  8.9,  5.8,  6.7,  6.8,  7.5])
svg_img = bar_chart.render()

# Convert the SVG chart to a PNG image in a BytesIO object
img_bytesio = BytesIO()
cairosvg.svg2png(svg_img, write_to=img_bytesio, dpi=96)

# Set the position and size of the image in the PDF
x = 50
y = 50
w = 100
h = 70

# Build the PDF
pdf = FPDF()
pdf.add_page()
pdf.image(img_bytesio, x=x, y=y, w=w, h=h)
pdf.output('browser-usage-bar-chart.pdf')
```

---

## Transparency¬∂

**URL:** https://py-pdf.github.io/fpdf2/Transparency.html

**Contents:**
- Transparency¬∂

The alpha opacity of text, shapes and even images can be controlled through stroke_opacity (for lines) & fill_opacity (for all other content types):

**Examples:**

Example 1 (swift):
```swift
pdf = FPDF()
pdf.set_font("Helvetica", style="B", size=24)
pdf.set_line_width(1.5)
pdf.add_page()

# Draw an opaque red square:
pdf.set_fill_color(255, 0, 0)
pdf.rect(10, 10, 40, 40, "DF")

# Set alpha to semi-transparency for shape lines & filled areas:
with pdf.local_context(fill_opacity=0.5, stroke_opacity=0.5):
    # Draw a green square:
    pdf.set_fill_color(0, 255, 0)
    pdf.rect(20, 20, 40, 40, "DF")

# Set transparency for images & text:
with pdf.local_context(fill_opacity=0.25):
    # Insert an image:
    pdf.image(HERE / "../docs/fpdf2-logo.png", 30, 30, 40)
    # Print some text:
    pdf.text(22, 29, "You are...")

# Print some text with full opacity:
pdf.text(30, 45, "Over the top")

# Produce the resulting PDF:
pdf.output("transparency.pdf")
```

---

## Shapes¬∂

**URL:** https://py-pdf.github.io/fpdf2/Shapes.html

**Contents:**
- Shapes¬∂
- Lines¬∂
- Circle¬∂
- Ellipse¬∂
- Rectangle¬∂
- Polygon¬∂
- Arc¬∂
- Solid arc¬∂
- Bezier Curve¬∂
- Regular Polygon¬∂

The following code snippets show examples of rendering various shapes.

Using line() to draw a thin plain orange line: from fpdf import FPDF pdf = FPDF() pdf.add_page() pdf.set_line_width(0.5) pdf.set_draw_color(r=255, g=128, b=0) pdf.line(x1=50, y1=50, x2=150, y2=100) pdf.output("orange_plain_line.pdf")

Drawing a dashed light blue line: from fpdf import FPDF pdf = FPDF() pdf.add_page() pdf.set_line_width(0.5) pdf.set_draw_color(r=0, g=128, b=255) pdf.set_dash_pattern(dash=2, gap=3) pdf.line(x1=50, y1=50, x2=150, y2=100) pdf.output("blue_dashed_line.pdf")

Using circle() to draw a disc filled in pink with a grey outline: from fpdf import FPDF pdf = FPDF() pdf.add_page() pdf.set_line_width(2) pdf.set_draw_color(240) pdf.set_fill_color(r=230, g=30, b=180) pdf.circle(x=50, y=50, radius=50, style="FD") pdf.output("circle.pdf")

This method changed parameters in release 2.8.1

Using ellipse(), filled in grey with a pink outline: from fpdf import FPDF pdf = FPDF() pdf.add_page() pdf.set_line_width(2) pdf.set_draw_color(r=230, g=30, b=180) pdf.set_fill_color(240) pdf.ellipse(x=50, y=50, w=100, h=50, style="FD") pdf.output("ellipse.pdf")

Using rect() to draw nested squares: from fpdf import FPDF pdf = FPDF() pdf.add_page() for i in range(15): pdf.set_fill_color(255 - 15*i) pdf.rect(x=5+5*i, y=5+5*i, w=200-10*i, h=200-10*i, style="FD") pdf.output("squares.pdf")

Using rect() to draw rectangles with round corners: from fpdf import FPDF pdf = FPDF() pdf.add_page() pdf.set_draw_color(200) y = 10 pdf.rect(60, y, 33, 28, round_corners=True, style="D") pdf.set_fill_color(0, 255, 0) pdf.rect(100, y, 50, 10, round_corners=("BOTTOM_RIGHT"), style="DF") pdf.set_fill_color(255, 255, 0) pdf.rect(160, y, 10, 10, round_corners=("TOP_LEFT", "BOTTOM_LEFT"), style="F") pdf.output("round_corners_rectangles.pdf")

from fpdf import FPDF pdf = FPDF() pdf.add_page() pdf.set_line_width(2) pdf.set_fill_color(r=255, g=0, b=0) coords = ((100, 0), (5, 69), (41, 181), (159, 181), (195, 69)) pdf.polygon(coords, style="DF") pdf.output("polygon.pdf")

from fpdf import FPDF pdf = FPDF() pdf.add_page() pdf.set_line_width(2) pdf.set_fill_color(r=255, g=0, b=0) pdf.arc(x=75, y=75, a=25, b=25, start_angle=90, end_angle=260, style="FD") pdf.set_fill_color(r=255, g=0, b=255) pdf.arc(x=105, y=75, a=25, b=50, start_angle=180, end_angle=360, style="FD") pdf.set_fill_color(r=0, g=255, b=0) pdf.arc(x=135, y=75, a=25, b=25, start_angle=0, end_angle=130, style="FD") pdf.output("arc.pdf")

from fpdf import FPDF pdf = FPDF() pdf.add_page() pdf.set_line_width(2) pdf.set_fill_color(r=255, g=0, b=0) pdf.solid_arc(x=75, y=75, a=25, b=25, start_angle=90, end_angle=260, style="FD") pdf.set_fill_color(r=255, g=0, b=255) pdf.solid_arc(x=105, y=75, a=25, b=50, start_angle=180, end_angle=360, style="FD") pdf.set_fill_color(r=0, g=255, b=0) pdf.solid_arc(x=135, y=75, a=25, b=25, start_angle=0, end_angle=130, style="FD") pdf.output("solid_arc.pdf")

Using bezier() to create a cubic B√©zier curve: from fpdf import FPDF pdf = FPDF() pdf.add_page() pdf.set_fill_color(r=255, g=0, b=255) pdf.bezier([(20, 80), (40, 20), (60, 80)], style="DF") pdf.output("bezier.pdf")

One of the nice properties of B√©zier curves is that they can be chained:

Note that, for smooth joining cubic B√©zier curves, neighbor control points around the joining point must mirror each other (cf. Wikipedia).

Source code: test_bezier_chaining() in test_bezier.py

Using regular_polygon():

from fpdf import FPDF pdf = FPDF() pdf.add_page() pdf.set_line_width(0.5) pdf.set_fill_color(r=30, g=200, b=0) pdf.regular_polygon(x=40, y=80, polyWidth=30, rotateDegrees=270, numSides=3, style="FD") pdf.set_fill_color(r=10, g=30, b=255) pdf.regular_polygon(x=80, y=80, polyWidth=30, rotateDegrees=135, numSides=4, style="FD") pdf.set_fill_color(r=165, g=10, b=255) pdf.regular_polygon(x=120, y=80, polyWidth=30, rotateDegrees=198, numSides=5, style="FD") pdf.set_fill_color(r=255, g=125, b=10) pdf.regular_polygon(x=160, y=80, polyWidth=30, rotateDegrees=270, numSides=6, style="FD") pdf.output("regular_polygon.pdf")

from fpdf import FPDF pdf = FPDF() pdf.add_page() pdf.set_line_width(0.5) pdf.set_fill_color(r=255, g=0, b=0) pdf.star(x=40, y=80, r_in=5, r_out=15, rotate_degrees=0, corners=3, style="FD") pdf.set_fill_color(r=0, g=255, b=255) pdf.star(x=80, y=80, r_in=5, r_out=15, rotate_degrees=90, corners=4, style="FD") pdf.set_fill_color(r=255, g=255, b=0) pdf.star(x=120, y=80, r_in=5, r_out=15, rotate_degrees=180, corners=5, style="FD") pdf.set_fill_color(r=255, g=0, b=255) pdf.star(x=160, y=80, r_in=5, r_out=15, rotate_degrees=270, corners=6, style="FD") pdf.output("star.pdf")

line_width specifies the thickness of the line used to stroke a path

stroke_join_style defines how the corner joining two path components should be rendered:

There are even more specific path styling settings supported: dash_pattern, stroke_opacity, stroke_miter_limit...

All of those settings can be set in a local_context().

**Examples:**

Example 1 (python):
```python
from fpdf import FPDF

pdf = FPDF()
pdf.add_page()
pdf.set_line_width(0.5)
pdf.set_draw_color(r=255, g=128, b=0)
pdf.line(x1=50, y1=50, x2=150, y2=100)
pdf.output("orange_plain_line.pdf")
```

Example 2 (python):
```python
from fpdf import FPDF

pdf = FPDF()
pdf.add_page()
pdf.set_line_width(0.5)
pdf.set_draw_color(r=0, g=128, b=255)
pdf.set_dash_pattern(dash=2, gap=3)
pdf.line(x1=50, y1=50, x2=150, y2=100)
pdf.output("blue_dashed_line.pdf")
```

Example 3 (python):
```python
from fpdf import FPDF

pdf = FPDF()
pdf.add_page()
pdf.set_line_width(2)
pdf.set_draw_color(240)
pdf.set_fill_color(r=230, g=30, b=180)
pdf.circle(x=50, y=50, radius=50, style="FD")
pdf.output("circle.pdf")
```

Example 4 (python):
```python
from fpdf import FPDF

pdf = FPDF()
pdf.add_page()
pdf.set_line_width(2)
pdf.set_draw_color(r=230, g=30, b=180)
pdf.set_fill_color(240)
pdf.ellipse(x=50, y=50, w=100, h=50, style="FD")
pdf.output("ellipse.pdf")
```

---

## Kurzanleitung¬∂

**URL:** https://py-pdf.github.io/fpdf2/Tutorial-de.html

**Contents:**
- Kurzanleitung¬∂
- Lektion 1 - Minimalbeispiel¬∂
- Lektion 2 - Kopfzeile, Fu√üzeile, Seitenumbruch und Bild¬∂
- Lektion 3 - Zeilenumbr√ºche und Farben¬∂
- Lektion 4 - Mehrspaltiger Text¬∂
- Lektion 5 - Tabellen erstellen¬∂
- Lektion 6 - Links erstellen und Textstile mischen¬∂
- Lektion 7 - Ein PDF/A Dokument erstellen¬∂
  - PDF/A Standards¬∂
  - Conformance Classes¬∂

Vollst√§ndige Dokumentation der Methoden: fpdf.FPDF API doc

Beginnen wir mit dem Klassiker:

Nachdem wir die Bibliothek eingebunden haben, erstellen zuerst wir ein FPDF Objekt. Der FPDF Konstruktor wird hier mit den Standardwerten verwendet: Das Seitenformat wird auf A4-Hochformat gesetzt und als Ma√üeinheit Millimeter festgelegt.

Diese Werte h√§tten wir auch explizit angegeben k√∂nnen:

pdf = FPDF(orientation="P", unit="mm", format="A4") Es ist auch m√∂glich, eine PDF-Datei im Querformat zu erstellen (L), sowie andere Seitenformate (Letter und Legal) und Ma√üeinheiten (pt, cm, in) zu verwenden.

Bisher haben wir dem Dokument noch keine Seite hinzugef√ºgt. Um eine Seite hinzuzuf√ºgen, verwenden wir add_page. Der Ursprung der Koordinaten liegt in der oberen linken Ecke und die aktuelle Schreibposition ist standardm√§√üig jeweils 1 cm von den R√§ndern entfernt. Diese Randabst√§nde k√∂nnen mit set_margins angespasst werden.

Bevor wir Text hinzuf√ºgen k√∂nnen, m√ºssen wir zuerst mit set_font eine Schriftart festlegen, um ein g√ºltiges Dokument zu erzeugen. Wir w√§hlen Helvetica, fett in Schriftgr√∂√üe 16 pt:

Anstelle von B h√§tten wir mit I kursiv , U unterstichen oder durch die √úbergabe einer leeren Zeichenkette einen "normale" Textstil w√§hlen k√∂nnen. Beliebige Kombinationen der drei Werte sind zul√§ssig. Beachte, dass die Schriftgr√∂√üe in Punkt und nicht in Millimetern (oder einer anderen durch den Benutzer bei der Erstellung mit unit= festgelegten Ma√üeinheit) angegeben wird. Dies ist die einzige Ausnahme vom Grundsatz, dass immer die durch den Benutzer gew√§hlte Ma√üeinheit bei der Festlegung von Positions- oder Gr√∂√üenangaben genutzt wird. Neben Helvetica stehen Times, Courier, Symbol und ZapfDingbats als Standardschriftarten zur Verf√ºgung.

Wir k√∂nnen jetzt eine erste Textzelle mit cell einf√ºgen. Eine Zelle ist ein rechteckiger Bereich - optional umrahmt - der Text enthalten kann. Sie wird an der jeweils aktuellen Schreibposition gerendert. Wir k√∂nnen die Abmessungen der Zelle, den Text und dessen Formatierung (zentriert oder ausgerichtet), einen ggf. gew√ºnschten Rahmen und die Festlegung der neuen Schreibposition nach dem Schreiben der Zelle (rechts, unten oder am Anfang der n√§chsten Zeile) bestimmen.

Um einen Rahmen hinzuzuf√ºgen, w√ºrden wir die Methode folgenderma√üen einbinden:

Um eine neue Zelle mit zentriertem Text hinzuzuf√ºgen und anschlie√üend in die n√§chste Zeile zu springen, k√∂nnen wir Folgendes schreiben:

Anmerkung: Der Zeilenumbruch kann auch mit ln erfolgen. Diese Methode erlaubt es, zus√§tzlich die H√∂he des Umbruchs anzugeben.

Schlie√ülich wird das Dokument mit output geschlossen und unter dem angegebenen Dateipfad gespeichert. Ohne Angabe eines Parameters liefert output() den PDF bytearray-Puffer zur√ºck.

Hier ein zweiseitiges Beispiel mit Kopfzeile, Fu√üzeile und Logo:

Dieses Beispiel verwendet die Methoden header und footer, um Kopf- und Fu√üzeilen zu verarbeiten. Sie werden jeweils automatisch aufgerufen. Die Methode 'header' direkt nach dem Hinzug√ºgen einer neuen Seite, die Methode 'footer' wenn die Bearbeitung einer Seite durch das Hinzuf√ºgen einer weiteren Seite oder das Abspeichern des Dokuments abgeschlossen wird. Die Methoden existieren bereits in der Klasse FPDF, sind aber leer. Um sie zu nutzen, m√ºssen wir die Klasse erweitern und sie √ºberschreiben.

Das Logo wird mit der Methode image eingebunden, und auf der Seite durch die Angabe der Position der linken oberen Ecke und die gew√ºnschte Bildbreite platziert. Die H√∂he wird automatisch berechnet, um die Proportionen des Bildes zu erhalten.

Um die Seitenzahl einzuf√ºgenn, √ºbergeben wir zuerst der Zelle einen Nullwert als Breite der Zelle. Das bedeutet, dass die Zelle bis zum rechten Rand der Seite reichen soll. Das ist besonders praktisch, um Text zu zentrieren. Die aktuelle Seitenzahl wird durch die Methode page_no ermittelt und in die Zelle geschrieben. Die Gesamtseitenzahl wird mit Hilfe des speziellen Platzhalterwertes {nb} ermittelt, der beim Schlie√üen des Dokuments ersetzt wird aufgerufen. Beachte die Verwendung der Methode set_y, mit der du die vertikale Schreibposition an einer absoluten Stelle der Seite - von oben oder von unten aus - setzen kannst.

Eine weitere interessante Funktion wird hier ebenfalls verwendet: der automatische Seitenumbruch. Sobald eine Zelle eine festgelegte Grenze in der Seite √ºberschreitet (standardm√§√üig 2 Zentimeter vom unteren Rand), wird ein Seitenumbruch durchgef√ºhrt und die Einstellungen der gewahlten Schrift auf der n√§chsten Seite automatisch beibehalten. Obwohl die Kopf- und Fu√üzeilen ihre eigene Schriftart (Helvetica) w√§hlen, wird im Textk√∂rper Times verwendet. Dieser Mechanismus der automatischen √úbernahme der Einstellungen nach Seitenumbruch gilt auch f√ºr Farben und Zeilenbreite. Der Grenzwert, der den Seitenumbruch ausl√∂st, kann mit set_auto_page_break festgelegt werden .

Fahren wir mit einem Beispiel fort, das Abs√§tze im Blocksatz ausgibt. Es demonstriert auch die Verwendung von Farben.

Die Methode get_string_width erm√∂glicht die Bestimmung die Breite des √ºbergebenen Textes in der aktuellen Schriftart. Das Beispiel nutzt sie zur Berechnung der Position und der Breite des Rahmens, der den Titel umgibt. Anschlie√üend werden die Farben mit set_draw_color, set_fill_color und und set_text_color gesetzt und die Linienst√§rke mit set_line_width auf 1 mm (Abweichend vom Standardwert von 0,2) festgelegt. Schlie√ülich geben wir die Zelle aus (Der letzte Parameter True zeigt an, dass der Hintergrund gef√ºllt werden muss).

Zur Erstellung von Abs√§tzen wir die Methode multi_cell genutzt. Jedes Mal, wenn eine Zeile den rechten Rand der Zelle erreicht oder ein Zeilenumbruchzeichen \\n im Text erkannt wird, wird ein Zeilenumbruch durchgef√ºhrt und automatisch eine neue Zelle unterhalb der aktuellen Zelle erstellt. Der Text wird standardm√§√üig im Blocksatz ausgerichtet.

Es werden zwei Dokumenteigenschaften definiert: Titel (set_title) und Autor (set_author). Dokumenteneigenschaften k√∂nnen auf zwei Arten eingesehen werden. Man kann das Dokument mit dem Acrobat Reader √∂ffnen und im Men√º Datei die Option Dokumenteigenschaften ausw√§hlen. Alternativ kann man auch mit der rechten Maustaste auf das Dokument klicken und die Option Dokumenteigenschaften w√§hlen.

Dieses Beispiel ist eine Abwandlung des vorherigen Beispiels und zeigt, wie sich Text √ºber mehrere Spalten verteilen l√§sst.

Der Hauptunterschied zur vorherigen Lektion ist die Verwendung der Methode text_columns. Diese sammelt zun√§chst allen text, auch in mehreren Teilen, und verteilt ihn anschlie√üend auf die angegebene Anzahl an Spalten. Eventuell notwendige Seitenumbr√ºche werden dabei automatisch vorgenommen. Beachtenswert dabei ist, dass w√§hrend die TextColumns instanz als Kontextmanager offen ist, Schriftstile und ander Eigenschaften frei ver√§ndert werden k√∂nnen. Nach schlie√üen des Kontextes werden die Einstellungen wieder auf den vorherigen Stand zur√ºckgesetzt.

Erzeugtes PDF - L√§nderdaten

Das erste Beispiel wird auf die einfachst m√∂gliche Weise umgesetzt, und einfach nur die Daten in die Tabelle eingef√ºgt. Das Ergebnis ist eine sehr schlichte Darstellung, kann aber sehr schnell erzeugt werden.

Die zweite Tabelle bringt einige Verfeinerungen: Farben, reduzierte Gesamtbreite, geringere Zeilenh√∂he, zentrierter Text, individuelle Spaltenbreiten und rechts justierte Zahlenwerte. Zus√§tzliche wurden die horizontalen Linien ausgeblendet. Dies wird dadurch erreicht, dass das Argument borders_layout einen geeigneten Wert des Enums TableBordersLayout erh√§lt.

In dieser Lektion werden verschiedene M√∂glichkeiten der Erstellung interner und externer Links beschrieben.

Es wird auch gezeigt, wie man verschiedene Textstile (fett, kursiv, unterstrichen) innerhalb eines Textes verwenden kann.

Erzeugtes PDF - fpdf2-logo

Die hier gezeigte neue Methode zur Einbindung von Text lautet write(). Sie √§hnelt der bereits bekannten multi_cell(). Die wichtigsten Unterschiede sind:

Die Methode erm√∂glicht es uns somit, zuerst einen Textabschnitt zu schreiben, dann den Schriftstil zu √§ndern und genau an der Stelle fortzufahren, an der wir aufgeh√∂rt haben. Der gr√∂√üte Nachteil ist jedoch, dass die von multi_cell() bekannte M√∂glichkeit zur Festlegung der Textausrichtung fehlt.

Auf der ersten Seite des Beispiels nutzen wir write(). Der Anfang des Satzes wird in "normalem" Stil geschrieben, dann mit der Methode set_font() auf Unterstreichung umgestellt und der Satz beendet.

Um einen internen Link hinzuzuf√ºgen, der auf die zweite Seite verweist, nutzen wir die Methode add_link(), die einen anklickbaren Bereich erzeugt, den wir "link" nennen und der auf eine andere Stelle innerhalb des Dokuments verweist.

Um einen externen Link mit Hilfe eines Bildes zu erstellen, verwenden wir image(). Es besteht die M√∂glichkeit, der Methode ein Linkziel als eines ihrer Argumente zu √ºbergeben. Der Link kann sowohl einer interner als auch ein externer sein.

Eine weitere M√∂glichkeit, den Schriftstil zu √§ndern und Links hinzuzuf√ºgen, stellt die Verwendung der Methode write_html() dar. Sie ist ein HTML-Parser, der das Hinzuf√ºgen von Text, √Ñnderung des Schriftstils und Erstellen von Links mittels HTML erm√∂glicht.

PDF/A-1 basiert auf der PDF-Version 1.4. Alle Ressourcen (Bilder, Grafiken, Fonts) m√ºssen im Document eingebettet werden. Erforderlich sind pr√§zise und Plattform unabh√§ngig kodierte Farbangaben mittels ICC-Profilen sowie die Verwendung von XMP f√ºr die Dokumenten-Metadaten.

PDF/A-2 basiert auf PDF-Version 1.7. Es erlaubt die Komprimierung mit JPEG2000, transparente Elemente, OpenType Fonts and digitale Signaturen.

Die einzige Erweiterung f√ºr PDF/A-3 besteht aus der M√∂glichkeit, beliebige Dateien einzubetten.

Stufe A (Zug√§nglichkeit) umfasst s√§mtliche Anforderungen des Standards inklusive der Abbildung der inhaltlichen Struktur und korrekter Lesereihenfolge des Dokumenteninhalts. Textinhalte m√ºssen extrahierbar sein und die Struktur muss die nat√ºrliche Leseabfolge abbilden.

Stufe B (Basic) garantiert eine eindeutige visuelle Reproduzierbarkeit der Inhalte. Stufe B l√§sst sich meist einfacher generieren als Stufe A, gew√§hrleistet aber nicht zu 100 Prozent Textextraktion oder -Durchsuchbarkeit. Eine problemlose Wiederverwendung des Inhalts ist nicht unbedingt gegeben.

Hier ein Beispiel um das zu erreichen:

Resulting PDF: tuto7.pdf

Bitte benutzen Sie ein Programm, wie z.B. VeraPDF, um die Konformit√§t des erstellten PDF zu sicherzustellen.

**Examples:**

Example 1 (python):
```python
from fpdf import FPDF

pdf = FPDF()
pdf.add_page()
pdf.set_font("helvetica", style="B", size=16)
pdf.cell(40, 10, "Hello World!")
pdf.output("tuto1.pdf")
```

Example 2 (unknown):
```unknown
pdf = FPDF(orientation="P", unit="mm", format="A4")
```

Example 3 (unknown):
```unknown
pdf.set_font('Helvetica', style='B', size=16)
```

Example 4 (unknown):
```unknown
pdf.cell(40, 10, 'Hello World!', 1)
```

---

## Module fpdf.image_datastructures

**URL:** https://py-pdf.github.io/fpdf2/fpdf/image_datastructures.html

**Contents:**
- Module fpdf.image_datastructures
- Classes
  - Instance variables
  - Methods
  - Ancestors
  - Subclasses
  - Instance variables
  - Methods
  - Ancestors
  - Instance variables

ImageCache(images: dict[str, fpdf.image_datastructures.RasterImageInfo | fpdf.image_datastructures.VectorImageInfo] = , icc_profiles: dict[bytes, int] = , image_filter: Literal['AUTO', 'FlateDecode', 'DCTDecode', 'JPXDecode', 'LZWDecode', 'CCITTFaxDecode'] = 'AUTO')

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

Information about an image used in the PDF document (base class). We subclass this to distinguish between raster and vector images.

Intrinsic image height

Only available if the image has been placed on the document

Only available if the image has been placed on the document

Intrinsic image width

Make an image fit within a bounding box, maintaining its proportions. In the reduced dimension it will be centered within the available space.

Information about a raster image used in the PDF document

Inherited from: ImageInfo.height

Intrinsic image height

Inherited from: ImageInfo.rendered_height

Only available if the image has been placed on the document

Inherited from: ImageInfo.rendered_width

Only available if the image has been placed on the document

Inherited from: ImageInfo.width

Intrinsic image width

Inherited from: ImageInfo.scale_inside_box

Make an image fit within a bounding box, maintaining its proportions. In the reduced dimension it will be centered within the available space.

Information about a vector image used in the PDF document

Inherited from: ImageInfo.height

Intrinsic image height

Inherited from: ImageInfo.rendered_height

Only available if the image has been placed on the document

Inherited from: ImageInfo.rendered_width

Only available if the image has been placed on the document

Inherited from: ImageInfo.width

Intrinsic image width

Inherited from: ImageInfo.scale_inside_box

Make an image fit within a bounding box, maintaining its proportions. In the reduced dimension it will be centered within the available space.

**Examples:**

Example 1 (python):
```python
@dataclass
class ImageCache:
    # Map image identifiers to dicts describing raster or vector images
    images: dict[str, RasterImageInfo | VectorImageInfo] = field(default_factory=dict)
    # Map icc profiles (bytes) to their index (number)
    icc_profiles: dict[bytes, int] = field(default_factory=dict)
    # Must be one of SUPPORTED_IMAGE_FILTERS values
    image_filter: ImageFilter = "AUTO"

    def reset_usages(self) -> None:
        for img in self.images.values():
            img["usages"] = 0
```

Example 2 (python):
```python
def reset_usages(self) -> None:
    for img in self.images.values():
        img["usages"] = 0
```

Example 3 (python):
```python
class ImageInfo(dict[str, object]):
    """Information about an image used in the PDF document (base class).
    We subclass this to distinguish between raster and vector images."""

    @property
    def width(self) -> float:
        "Intrinsic image width"
        return cast(float, self["w"])

    @property
    def height(self) -> float:
        "Intrinsic image height"
        return cast(float, self["h"])

    @property
    def rendered_width(self) -> float:
        "Only available if the image has been placed on the document"
        return cast(float, self["rendered_width"])

    @property
    def rendered_height(self) -> float:
        "Only available if the image has been placed on the document"
        return cast(float, self["rendered_height"])

    def __str__(self) -> str:
        d = {
            k: ("..." if k in ("data", "iccp", "smask") else v) for k, v in self.items()
        }
        return f"self.__class__.__name__({d})"

    def scale_inside_box(
        self, x: float, y: float, w: float, h: float
    ) -> tuple[float, float, float, float]:
        """
        Make an image fit within a bounding box, maintaining its proportions.
        In the reduced dimension it will be centered within the available space.
        """
        img_w: float = self["w"]  # type: ignore
        img_h: float = self["h"]  # type: ignore
        ratio = img_w / img_h
        if h * ratio < w:
            new_w = h * ratio
            new_h = h
            x += (w - new_w) / 2
        else:  # => too wide, limiting width:
            new_h = w / ratio
            new_w = w
            y += (h - new_h) / 2
        return x, y, new_w, new_h
```

Example 4 (python):
```python
@property
def height(self) -> float:
    "Intrinsic image height"
    return cast(float, self["h"])
```

---

## borb¬∂

**URL:** https://py-pdf.github.io/fpdf2/CombineWithBorb.html

**Contents:**
- borb¬∂
- Creating a document with fpdf2 and transforming it into a borb.pdf.document.Document¬∂

Joris Schellekens made another excellent pure-Python library dedicated to reading & write PDF: borb. He even wrote a very detailed e-book about it, available publicly there: borb-examples.

The maintainer of fpdf2 wrote an article comparing it with borb: borb vs fpdf2.

**Examples:**

Example 1 (python):
```python
from io import BytesIO
from borb.pdf.pdf import PDF
from fpdf import FPDF

pdf = FPDF()
pdf.set_title('Initiating a borb doc from a FPDF instance')
pdf.set_font('helvetica', size=12)
pdf.add_page()
pdf.cell(text="Hello world!")

doc = PDF.loads(BytesIO(pdf.output()))
print(doc.get_document_info().get_title())
```

---

## Module fpdf.errors

**URL:** https://py-pdf.github.io/fpdf2/fpdf/errors.html

**Contents:**
- Module fpdf.errors
- Classes
  - Ancestors
  - Subclasses
  - Ancestors
  - Subclasses
  - Ancestors
  - Ancestors
  - Ancestors

Base class for standards-compliance violations (PDF/A, PDF/X, etc.).

Common base class for all non-exit exceptions.

Error is thrown when a bad page format is given

Error is thrown when a character that cannot be encoded by the chosen encoder is provided

Raised when an operation would produce a PDF that violates the selected PDF/A profile.

**Examples:**

Example 1 (python):
```python
class ComplianceError(FPDFException):
    """Base class for standards-compliance violations (PDF/A, PDF/X, etc.)."""
```

Example 2 (python):
```python
class FPDFException(Exception):
    pass
```

Example 3 (python):
```python
class FPDFPageFormatException(FPDFException):
    """Error is thrown when a bad page format is given"""

    def __init__(self, argument: str, unknown: bool = False, one: bool = False) -> None:
        super().__init__()
        if unknown and one:
            raise TypeError(
                "FPDF Page Format Exception cannot be both for "
                "unknown type and for wrong number of arguments"
            )
        self.argument = argument
        self.unknown = unknown
        self.one = one

    def __repr__(self) -> str:
        return (
            f"{self.__class__.__name__}"
            f"({self.argument!r}, {self.unknown!r}, {self.one!r})"
        )

    def __str__(self) -> str:
        if self.unknown:
            res = f"Unknown page format: {self.argument}"
        elif self.one:
            res = f"Only one argument given: {self.argument}. Need (height,width)"
        else:
            res = self.argument
        return f"{self.__class__.__name__ }: {res}"
```

Example 4 (python):
```python
class FPDFUnicodeEncodingException(FPDFException):
    """Error is thrown when a character that cannot be encoded by the chosen encoder is provided"""

    def __init__(self, text_index: int, character: str, font_name: str) -> None:
        super().__init__()
        self.text_index = text_index
        self.character = character
        self.font_name = font_name

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}({repr(self.text_index), repr(self.character), repr(self.font_name)})"

    def __str__(self) -> str:
        return (
            f'Character "{self.character}" at index {self.text_index} in text is outside the range of characters'
            f' supported by the font used: "{self.font_name}".'
            " Please consider using a Unicode font."
        )
```

---

## Templating with Jinja¬∂

**URL:** https://py-pdf.github.io/fpdf2/TemplatingWithJinja.html

**Contents:**
- Templating with Jinja¬∂
- Combining Jinja & write_html¬∂

Jinja is a fast, expressive, extensible templating engine.

More details about the supported HTML features: HTML

**Examples:**

Example 1 (python):
```python
from fpdf import FPDF
from jinja2 import Environment

template = Environment().from_string("""
<h1>{{ title | escape }}</h1>
<ul>
{% for item in items %}
  <li>{{ item }}</li>
{% endfor %}
</ul>
""")

title = "HTML & Jinja demo"
items = [
    "FIRST",
    "SECOND",
    "LAST"
]

pdf = FPDF()
pdf.add_page()
pdf.write_html(template.render(**globals()))
pdf.output("templating_with_jinja.pdf")
```

---

## Module fpdf.structure_tree

**URL:** https://py-pdf.github.io/fpdf2/fpdf/structure_tree.html

**Contents:**
- Module fpdf.structure_tree
- Classes
  - Ancestors
  - Instance variables
  - Methods
  - Ancestors
  - Instance variables
  - Methods
  - Ancestors
  - Instance variables

Quoting the PDF spec:

PDF‚Äôs logical structure facilities provide a mechanism for incorporating structural information about a document‚Äôs content into a PDF file.

The logical structure of a document is described by a hierarchy of objects called the structure hierarchy or structure tree. At the root of the hierarchy is a dictionary object called the structure tree root, located by means of the StructTreeRoot entry in the document catalog.

The contents of this module are internal to fpdf2, and not part of the public API. They may change at any time without prior warning or any deprecation period, in non-backward-compatible ways.

Usage documentation at: https://py-pdf.github.io/fpdf2/DocumentOutlineAndTableOfContents.html

A number tree is similar to a name tree, except that its keys are integers instead of strings and are sorted in ascending numerical order.

A name tree serves a similar purpose to a dictionary‚Äîassociating keys and values‚Äîbut by different means.

The values associated with the keys may be objects of any type. Stream objects are required to be specified by indirect object references. It is recommended, though not required, that dictionary, array, and string objects be specified by indirect object references, and other PDF objects (nulls, numbers, booleans, and names) be specified as direct objects

Inherited from: PDFObject.content_stream

Subclasses can override this method to indicate the presence of a content stream

Inherited from: PDFObject.serialize

Serialize the PDF object as an obj<</>>endobj text block

Inherited from: PDFObject.content_stream

Subclasses can override this method to indicate the presence of a content stream

Inherited from: PDFObject.serialize

Serialize the PDF object as an obj<</>>endobj text block

Inherited from: PDFObject.content_stream

Subclasses can override this method to indicate the presence of a content stream

Inherited from: PDFObject.serialize

Serialize the PDF object as an obj<</>>endobj text block

**Examples:**

Example 1 (python):
```python
class NumberTree(PDFObject):
    """A number tree is similar to a name tree, except that its keys are integers
    instead of strings and are sorted in ascending numerical order.

    A name tree serves a similar purpose to a dictionary‚Äîassociating keys and
    values‚Äîbut by different means.

    The values associated with the keys may be objects of any type. Stream objects
    are required to be specified by indirect object references. It is recommended,
    though not required, that dictionary, array, and string objects be specified by
    indirect object references, and other PDF objects (nulls, numbers, booleans,
    and names) be specified as direct objects
    """

    __slots__ = ("_id", "nums")  # RAM usage optimization

    def __init__(self) -> None:
        super().__init__()
        self.nums: DefaultDict[int, list[PDFObject]] = defaultdict(
            list
        )  # {struct_parent_id -> struct_elems}

    def serialize(
        self,
        obj_dict: Optional[Dict[str, object]] = None,
        _security_handler: Optional["StandardSecurityHandler"] = None,
    ) -> str:
        newline = "\n"
        serialized_nums = "\n".join(
            f"{struct_parent_id} [{newline.join(struct_elem.ref for struct_elem in struct_elems)}]"
            for struct_parent_id, struct_elems in self.nums.items()
        )
        return super().serialize({"/Nums": f"[{serialized_nums}]"})
```

Example 2 (python):
```python
class NumberTree(PDFObject):
    """A number tree is similar to a name tree, except that its keys are integers
    instead of strings and are sorted in ascending numerical order.

    A name tree serves a similar purpose to a dictionary‚Äîassociating keys and
    values‚Äîbut by different means.

    The values associated with the keys may be objects of any type. Stream objects
    are required to be specified by indirect object references. It is recommended,
    though not required, that dictionary, array, and string objects be specified by
    indirect object references, and other PDF objects (nulls, numbers, booleans,
    and names) be specified as direct objects
    """

    __slots__ = ("_id", "nums")  # RAM usage optimization

    def __init__(self) -> None:
        super().__init__()
        self.nums: DefaultDict[int, list[PDFObject]] = defaultdict(
            list
        )  # {struct_parent_id -> struct_elems}

    def serialize(
        self,
        obj_dict: Optional[Dict[str, object]] = None,
        _security_handler: Optional["StandardSecurityHandler"] = None,
    ) -> str:
        newline = "\n"
        serialized_nums = "\n".join(
            f"{struct_parent_id} [{newline.join(struct_elem.ref for struct_elem in struct_elems)}]"
            for struct_parent_id, struct_elems in self.nums.items()
        )
        return super().serialize({"/Nums": f"[{serialized_nums}]"})
```

Example 3 (python):
```python
def serialize(
    self,
    obj_dict: Optional[Dict[str, object]] = None,
    _security_handler: Optional["StandardSecurityHandler"] = None,
) -> str:
    newline = "\n"
    serialized_nums = "\n".join(
        f"{struct_parent_id} [{newline.join(struct_elem.ref for struct_elem in struct_elems)}]"
        for struct_parent_id, struct_elems in self.nums.items()
    )
    return super().serialize({"/Nums": f"[{serialized_nums}]"})
```

Example 4 (python):
```python
class StructElem(PDFObject):
    __slots__ = (  # RAM usage optimization
        "_id",
        "type",
        "s",
        "p",
        "k",
        "t",
        "alt",
        "pg",
        "_page_number",
    )

    def __init__(
        self,
        struct_type: str,
        parent: PDFObject,
        kids: Union[List[int], List["StructElem"]],
        page_number: Optional[int] = None,
        title: Optional[str] = None,
        alt: Optional[str] = None,
    ) -> None:
        super().__init__()
        self.type = "/StructElem"
        # A name object identifying the nature of the structure element:
        self.s = struct_type
        self.p = parent  # The structure element that is the immediate parent of this one in the structure hierarchy
        self.k = PDFArray(kids)  # The children of this structure element
        # a text string representing it in human-readable form:
        self.t = None if title is None else PDFString(title)
        # An alternate description of the structure element in human-readable form:
        self.alt = None if alt is None else PDFString(alt)
        self.pg = None  # A page object on which some or all of the content items designated by the K entry are rendered
        self._page_number = page_number  # private so that it does not get serialized

    def page_number(self) -> Optional[int]:
        return self._page_number
```

---

## Module fpdf.template

**URL:** https://py-pdf.github.io/fpdf2/fpdf/template.html

**Contents:**
- Module fpdf.template
- Classes
- Args
  - Subclasses
  - Methods
- Args
- Args
- Args
- Args
- Args

PDF template helpers for fpdf2.

Usage documentation at: https://py-pdf.github.io/fpdf2/Templates.html

A flexible templating class.

Allows to apply one or several template definitions to any page of a document in any combination.

Usage documentation at: https://py-pdf.github.io/fpdf2/Templates.html

Load a template definition.

Load the template definition from a CSV file.

Load the template definition from a JSON file. The data must be structured as an array of objects, with names and values exactly equivalent to what would get supplied to load_elements(),

Add the contents of the template to the PDF document.

Split a string between words, for the parts to fit into a given element width. Additional splits will be made replacing any '\n' characters.

A list of substrings, each of which will fit into the element width when rendered in the element font style and size.

A simple templating class.

Allows to apply a single template definition to all pages of a document.

Usage documentation at: https://py-pdf.github.io/fpdf2/Templates.html

Finish the current page, and proceed to the next one.

Inherited from: FlexTemplate.load_elements

Load a template definition ‚Ä¶

Inherited from: FlexTemplate.parse_csv

Load the template definition from a CSV file ‚Ä¶

Inherited from: FlexTemplate.parse_json

Load the template definition from a JSON file. The data must be structured as an array of objects, with names and values exactly equivalent to what ‚Ä¶

Finish the document and process all pending data.

Inherited from: FlexTemplate.split_multicell

Split a string between words, for the parts to fit into a given element width. Additional splits will be made replacing any '\n' characters ‚Ä¶

**Examples:**

Example 1 (python):
```python
class FlexTemplate:
    """
    A flexible templating class.

    Allows to apply one or several template definitions to any page of
    a document in any combination.

    Usage documentation at: <https://py-pdf.github.io/fpdf2/Templates.html>
    """

    def __init__(
        self, pdf: FPDF, elements: Optional[Sequence[dict[str, Any]]] = None
    ) -> None:
        """
        Args:
            pdf (fpdf.fpdf.FPDF): All content will be added to this `FPDF` instance.
            elements (list[dict]): A template definition in a list of dicts.
                If you omit this, then you need to call either load_elements()
                or parse_csv() before doing anything else.
        """
        if not isinstance(pdf, FPDF):
            raise TypeError("'pdf' must be an instance of fpdf.FPDF()")
        self.pdf = pdf
        self.splitting_pdf: Optional[FPDF] = None  # for split_multicell()
        if elements:
            self.load_elements(elements)
        self.handlers = {
            "T": self._text,
            "L": self._line,
            "I": self._image,
            "B": self._rect,
            "E": self._ellipse,
            "BC": self._barcode,
            "C39": self._code39,
            "W": self._write,
        }
        self.texts: dict[str, Any] = {}

    def load_elements(self, elements: Sequence[dict[str, Any]]) -> None:
        """
        Load a template definition.

        Args:
            elements (list of dicts): A template definition in a list of dicts
        """
        key_config = {
            # key: type
            "name": (str, type(None)),
            "type": (str, type(None)),
            "x1": (int, float),
            "y1": (int, float),
            "x2": (int, float),
            "y2": (int, float),
            "font": (str, type(None)),
            "size": (int, float),
            "bold": object,  # "bool or equivalent"
            "italic": object,
            "underline": object,
            "foreground": int,
            "background": int,
            "align": (str, type(None)),
            "text": (str, type(None)),
            "priority": int,
            "multiline": (bool, type(None)),
            "rotate": (int, float),
            "wrapmode": (str, type(None)),
            "dash_pattern": (dict, type(None)),
        }

        self.elements: Sequence[dict[str, Any]] = elements
        self.keys: list[str] = []
        for e in elements:
            # priority is optional, but we need a default for sorting.
            if not "priority" in e:
                e["priority"] = 0
            for k in ("name", "type", "x1", "y1", "y2"):
                if k not in e:
                    if e["type"] == "C39":
                        # lots of legacy special casing.
                        # We need to do that here, so that rotation and scaling
                        # still work.
                        if k == "x1" and "x" in e:
                            e["x1"] = e["x"]
                            continue
                        if k == "y1" and "y" in e:
                            e["y1"] = e["y"]
                            continue
                        if k == "y2" and "h" in e:
                            e["y2"] = e["y1"] + e["h"]
                            continue
                    raise KeyError(f"Mandatory key '{k}' missing in input data")
            # x2 is optional for barcode types, but needed for offset rendering
            if "x2" not in e:
                if e["type"] in ["BC", "C39"]:
                    e["x2"] = 0
                else:
                    raise KeyError("Mandatory key 'x2' missing in input data")
            if not "size" in e and e["type"] == "C39":
                if "w" in e:
                    e["size"] = e["w"]
            if "dash_pattern" in e:
                for k in e["dash_pattern"].keys():
                    if k not in ("dash", "gap", "phase"):
                        raise KeyError(f"Invalid key '{k}' in dash_pattern")
                if "dash" not in e["dash_pattern"]:
                    e["dash_pattern"]["dash"] = 0
                if "gap" not in e["dash_pattern"]:
                    e["dash_pattern"]["gap"] = e["dash_pattern"]["dash"]
                if "phase" not in e["dash_pattern"]:
                    e["dash_pattern"]["phase"] = 0

            for k, t in key_config.items():
                if k in e and not isinstance(e[k], t):  # type: ignore[arg-type]
                    ttype = (
                        t.__name__
                        if isinstance(t, type)
                        else " or ".join([f"'{x.__name__}'" for x in t])  # type: ignore[attr-defined]
                    )
                    raise TypeError(
                        f"Value of element item '{k}' must be {ttype}, not '{type(e[k]).__name__}'."
                    )
            self.keys.append(e["name"].lower())

    @staticmethod
    def _parse_colorcode(s: str) -> int:
        """Allow hex and oct values for colors"""
        if s[:2] in ["0x", "0X"]:
            return int(s, 16)
        if s[0] == "0":
            return int(s, 8)
        return int(s)

    @staticmethod
    def _parse_multiline(s: str) -> Optional[bool]:
        i = int(s)
        if i > 0:
            return True
        if i < 0:
            return False
        return None

    def parse_json(self, infile: os.PathLike[str], encoding: str = "utf-8") -> None:
        """
        Load the template definition from a JSON file.
        The data must be structured as an array of objects, with names and values exactly
        equivalent to what would get supplied to load_elements(),

        Args:
            infile (str, path-like object): The filepath of the JSON file.
            encoding (str): The character encoding of the file. Default is UTF-8.
        """
        with open(infile, encoding=encoding) as f:
            data = json.load(f)
            for d in data:
                fgval = d.get("foreground")
                if fgval and isinstance(fgval, str):
                    if fgval.lower().startswith("#"):
                        d["foreground"] = int(fgval[1:], 16)
                    else:
                        raise ValueError(
                            "If foreground is a string, it must have the form '#rrggbb'."
                        )
                bgval = d.get("background")
                if bgval and isinstance(bgval, str):
                    if bgval.lower().startswith("#"):
                        d["background"] = int(bgval[1:], 16)
                    else:
                        raise ValueError(
                            "If background is a string, it must have the form '#rrggbb'."
                        )
            self.load_elements(data)

    def parse_csv(
        self,
        infile: os.PathLike[str],
        delimiter: str = ",",
        decimal_sep: str = ".",
        encoding: Optional[str] = None,
    ) -> None:
        """
        Load the template definition from a CSV file.

        Args:
            infile (str, path-like object): The filepath of the CSV file.
            delimiter (str): The character that separates the fields in the CSV file:
                Usually a comma, semicolon, or tab.
            decimal_sep (str): The decimal separator used in the file.
                Usually either a point or a comma.
            encoding (str): The character encoding of the file.
                Default is the system default encoding.
        """

        def _varsep_float(s: str, default: str = "0") -> float:
            """Convert to float with given decimal separator"""
            # glad to have nonlocal scoping...
            return float((s.strip() or default).replace(decimal_sep, "."))

        key_config = (
            # key, converter, mandatory
            ("name", str, True),
            ("type", str, True),
            ("x1", _varsep_float, True),
            ("y1", _varsep_float, True),
            ("x2", _varsep_float, True),
            ("y2", _varsep_float, True),
            ("font", str, False),
            ("size", _varsep_float, False),
            ("bold", int, False),
            ("italic", int, False),
            ("underline", int, False),
            ("foreground", self._parse_colorcode, False),
            ("background", self._parse_colorcode, False),
            ("align", str, False),
            ("text", str, False),
            ("priority", int, False),
            ("multiline", self._parse_multiline, False),
            ("rotate", _varsep_float, False),
            ("wrapmode", str, False),
        )
        self.elements = []
        if encoding is None:
            encoding = locale.getpreferredencoding()
        with open(infile, encoding=encoding) as f:
            for row in csv.reader(f, delimiter=delimiter):
                # fill in blanks for any missing items
                row.extend([""] * (len(key_config) - len(row)))
                kargs: dict[str, Any] = {}
                for val, cfg in zip(row, key_config):
                    vs = val.strip()
                    if not vs:
                        if cfg[2]:  # mandatory
                            if cfg[0] == "x2" and row[1] in ["BC", "C39"]:
                                # two types don't need x2, but offset rendering does
                                pass
                            else:
                                raise FPDFException(
                                    f"Mandatory value '{cfg[0]}' missing in csv data"
                                )
                        elif cfg[0] == "priority":
                            # formally optional, but we need some value for sorting
                            kargs["priority"] = 0
                        # otherwise, let the type handlers use their own defaults
                    else:
                        kargs[cfg[0]] = cfg[1](vs)  # type: ignore[operator]
                self.elements.append(kargs)
        self.keys = [val["name"].lower() for val in self.elements]

    def __setitem__(self, name: str, value: Any) -> None:
        assert isinstance(
            name, str
        ), f"name must be of type 'str', not '{type(name).__name__}'."
        # value has too many valid types to reasonably check here
        if name.lower() not in self.keys:
            raise FPDFException(f"Element not loaded, cannot set item: {name}")
        self.texts[name.lower()] = value

    # setitem shortcut (may be further extended)
    set = __setitem__

    def __contains__(self, name: str) -> bool:
        assert isinstance(
            name, str
        ), f"name must be of type 'str', not '{type(name).__name__}'."
        return name.lower() in self.keys

    def __getitem__(self, name: str) -> Any:
        assert isinstance(
            name, str
        ), f"name must be of type 'str', not '{type(name).__name__}'."
        if name not in self.keys:
            raise KeyError(name)
        key = name.lower()
        if key in self.texts:
            # text for this page:
            return self.texts[key]
        # find first element for default text:
        return next(
            (x["text"] for x in self.elements if x["name"].lower() == key), None
        )

    def split_multicell(self, text: str, element_name: str) -> list[str]:
        """
        Split a string between words, for the parts to fit into a given element
        width. Additional splits will be made replacing any '\\n' characters.

        Args:
            text (str): The input text string.
            element_name (str): The name of the template element to fit the text inside.

        Returns:
            A list of substrings, each of which will fit into the element width
            when rendered in the element font style and size.
        """
        element = next(
            element
            for element in self.elements
            if element["name"].lower() == element_name.lower()
        )
        if not self.splitting_pdf:
            self.splitting_pdf = FPDF()
            self.splitting_pdf.add_page()
        assert self.splitting_pdf is not None
        style = ""
        if element.get("bold"):
            style += "B"
        if element.get("italic"):
            style += "I"
        if element.get("underline"):
            style += "U"
        self.splitting_pdf.set_font(element["font"], style, element["size"])
        return self.splitting_pdf.multi_cell(  # type: ignore[return-value]
            w=element["x2"] - element["x1"],
            h=element["y2"] - element["y1"],
            text=str(text),
            align=element.get("align", ""),
            dry_run=True,
            output="LINES",
            wrapmode=element.get("wrapmode", "WORD"),
        )

    def _text(
        self,
        *_: Any,
        x1: float = 0,
        y1: float = 0,
        x2: float = 0,
        y2: float = 0,
        text: str = "",
        font: str = "helvetica",
        size: float = 10,
        scale: float = 1.0,
        bold: bool = False,
        italic: bool = False,
        underline: bool = False,
        align: str = "",
        foreground: int = 0,
        background: Optional[int] = None,
        multiline: Optional[bool] = None,
        wrapmode: str = "WORD",
        **__: Any,
    ) -> None:
        if not text:
            return
        pdf = self.pdf
        if pdf.text_color != _rgb_as_str(foreground):  # type: ignore[comparison-overlap]
            pdf.set_text_color(*_rgb(foreground))
        if background is None:
            fill = False
        else:
            fill = True
            if pdf.fill_color != _rgb_as_str(background):  # type: ignore[comparison-overlap]
                pdf.set_fill_color(*_rgb(background))

        font = font.strip().lower()
        style = ""
        for tag in "B", "I", "U":
            if text.startswith(f"<{tag}>") and text.endswith(f"</{tag}>"):
                text = text[3:-4]
                style += tag
        if bold:
            style += "B"
        if italic:
            style += "I"
        if underline:
            style += "U"
        pdf.set_font(font, style, size * scale)
        pdf.set_xy(x1, y1)
        width, height = x2 - x1, y2 - y1
        if multiline is None:  # write without wrapping/trimming (default)
            pdf.cell(w=width, h=height, text=text, border=0, align=align, fill=fill)
        elif multiline:  # automatic word - warp
            pdf.multi_cell(
                w=width,
                h=height,
                text=text,
                border=0,
                align=align,
                fill=fill,
                wrapmode=WrapMode.coerce(wrapmode),
            )
        else:  # trim to fit exactly the space defined
            text = pdf.multi_cell(  # type: ignore[index,assignment]
                w=width,
                h=height,
                text=text,
                align=align,
                wrapmode=WrapMode.coerce(wrapmode),
                dry_run=True,
                output="LINES",
            )[0]
            pdf.cell(w=width, h=height, text=text, border=0, align=align, fill=fill)

    def _line(
        self,
        *_: Any,
        x1: float = 0,
        y1: float = 0,
        x2: float = 0,
        y2: float = 0,
        size: float = 0,
        scale: float = 1.0,
        foreground: int = 0,
        dash_pattern: Optional[tuple[float, float, float]] = None,
        **__: Any,
    ) -> None:
        assert self.pdf.draw_color is not None
        if self.pdf.draw_color.serialize().lower() != _rgb_as_str(foreground):
            self.pdf.set_draw_color(*_rgb(foreground))
        self.pdf.set_line_width(size * scale)
        if dash_pattern is not None:
            # Save dash_pattern to restore after this line
            restore_dash_pattern = self.pdf.dash_pattern
            if isinstance(dash_pattern, dict):
                self.pdf.set_dash_pattern(
                    dash_pattern.get(  # pyright: ignore[reportUnknownMemberType, reportUnknownArgumentType]
                        "dash", 0
                    ),
                    dash_pattern.get(  # pyright: ignore[reportUnknownMemberType, reportUnknownArgumentType]
                        "gap", 0
                    ),
                    dash_pattern.get(  # pyright: ignore[reportUnknownMemberType, reportUnknownArgumentType]
                        "phase", 0
                    ),
                )
            else:
                self.pdf.set_dash_pattern(
                    dash_pattern[0], dash_pattern[1], dash_pattern[2]
                )
        self.pdf.line(x1, y1, x2, y2)
        if dash_pattern is not None:
            self.pdf.set_dash_pattern(
                **restore_dash_pattern  # pyright: ignore[reportPossiblyUnboundVariable]
            )

    def _rect(
        self,
        *_: Any,
        x1: float = 0,
        y1: float = 0,
        x2: float = 0,
        y2: float = 0,
        size: float = 0,
        scale: float = 1.0,
        foreground: int = 0,
        background: Optional[int] = None,
        dash_pattern: Optional[tuple[float, float, float]] = None,
        **__: Any,
    ) -> None:
        pdf = self.pdf
        assert pdf.draw_color is not None
        if pdf.draw_color.serialize().lower() != _rgb_as_str(foreground):
            pdf.set_draw_color(*_rgb(foreground))
        if background is None:
            style = "D"
        else:
            style = "FD"
            if pdf.fill_color != _rgb_as_str(background):  # type: ignore[comparison-overlap]
                pdf.set_fill_color(*_rgb(background))
        pdf.set_line_width(size * scale)
        if dash_pattern is not None:
            # Save dash_pattern to restore after this rect
            restore_dash_pattern = self.pdf.dash_pattern
            if isinstance(dash_pattern, dict):
                pdf.set_dash_pattern(
                    dash_pattern.get(  # pyright: ignore[reportUnknownMemberType, reportUnknownArgumentType]
                        "dash", 0
                    ),
                    dash_pattern.get(  # pyright: ignore[reportUnknownMemberType, reportUnknownArgumentType]
                        "gap", 0
                    ),
                    dash_pattern.get(  # pyright: ignore[reportUnknownMemberType, reportUnknownArgumentType]
                        "phase", 0
                    ),
                )
            else:
                pdf.set_dash_pattern(dash_pattern[0], dash_pattern[1], dash_pattern[2])
        pdf.rect(x1, y1, x2 - x1, y2 - y1, style=style)
        if dash_pattern is not None:
            self.pdf.set_dash_pattern(
                **restore_dash_pattern  # pyright: ignore[reportPossiblyUnboundVariable]
            )

    def _ellipse(
        self,
        *_: Any,
        x1: float = 0,
        y1: float = 0,
        x2: float = 0,
        y2: float = 0,
        size: float = 0,
        scale: float = 1.0,
        foreground: int = 0,
        background: Optional[int] = None,
        dash_pattern: Optional[tuple[float, float, float]] = None,
        **__: Any,
    ) -> None:
        pdf = self.pdf
        assert pdf.draw_color is not None
        if pdf.draw_color.serialize().lower() != _rgb_as_str(foreground):
            pdf.set_draw_color(*_rgb(foreground))
        if background is None:
            style = "D"
        else:
            style = "FD"
            if pdf.fill_color != _rgb_as_str(background):  # type: ignore[comparison-overlap]
                pdf.set_fill_color(*_rgb(background))
        pdf.set_line_width(size * scale)
        if dash_pattern is not None:
            # Save dash_pattern to restore after this ellipse
            restore_dash_pattern = self.pdf.dash_pattern
            if isinstance(dash_pattern, dict):
                pdf.set_dash_pattern(
                    dash_pattern.get(  # pyright: ignore[reportUnknownMemberType, reportUnknownArgumentType]
                        "dash", 0
                    ),
                    dash_pattern.get(  # pyright: ignore[reportUnknownMemberType, reportUnknownArgumentType]
                        "gap", 0
                    ),
                    dash_pattern.get(  # pyright: ignore[reportUnknownMemberType, reportUnknownArgumentType]
                        "phase", 0
                    ),
                )
            else:
                pdf.set_dash_pattern(dash_pattern[0], dash_pattern[1], dash_pattern[2])
        pdf.ellipse(x1, y1, x2 - x1, y2 - y1, style=style)
        if dash_pattern is not None:
            self.pdf.set_dash_pattern(
                **restore_dash_pattern  # pyright: ignore[reportPossiblyUnboundVariable]
            )

    def _image(
        self,
        *_: Any,
        x1: float = 0,
        y1: float = 0,
        x2: float = 0,
        y2: float = 0,
        text: str = "",
        **__: Any,
    ) -> None:
        if text:
            self.pdf.image(text, x1, y1, w=x2 - x1, h=y2 - y1, link="")

    def _barcode(
        self,
        *_: Any,
        x1: float = 0,
        y1: float = 0,
        x2: float = 0,
        y2: float = 0,
        text: str = "",
        font: str = "interleaved 2of5 nt",
        size: float = 1,
        scale: float = 1.0,
        foreground: int = 0,
        **__: Any,
    ) -> None:
        # pylint: disable=unused-argument
        pdf = self.pdf
        assert pdf.fill_color is not None
        if pdf.fill_color.serialize().lower() != _rgb_as_str(foreground):
            pdf.set_fill_color(*_rgb(foreground))
        font = font.lower().strip()
        if font == "interleaved 2of5 nt":
            pdf.interleaved2of5(text, x1, y1, w=size * scale, h=y2 - y1)

    def _code39(
        self,
        *_: Any,
        x1: float = 0,
        y1: float = 0,
        y2: float = 0,
        text: str = "",
        size: float = 1.5,
        scale: float = 1.0,
        foreground: int = 0,
        x: Optional[float] = None,
        y: Optional[float] = None,
        w: Optional[float] = None,
        h: Optional[float] = None,
        **__: Any,
    ) -> None:
        if x is not None or y is not None or w is not None or h is not None:
            warnings.warn(
                (
                    "code39 arguments x/y/w/h are deprecated since v2.4.4,"
                    " please use x1/y1/y2/size instead"
                ),
                DeprecationWarning,
                stacklevel=get_stack_level(),
            )
        pdf = self.pdf
        assert pdf.fill_color is not None
        if pdf.fill_color.serialize().lower() != _rgb_as_str(foreground):
            pdf.set_fill_color(*_rgb(foreground))
        h = y2 - y1
        if h <= 0:
            h = 5
        pdf.code39(text, x1, y1, size * scale, h)

    # Added by Derek Schwalenberg Schwalenberg1013@gmail.com to allow (url) links in
    # templates (using write method) 2014-02-22
    def _write(
        self,
        *_: Any,
        x1: float = 0,
        y1: float = 0,
        x2: float = 0,
        y2: float = 0,
        text: str = "",
        font: str = "helvetica",
        size: float = 10,
        scale: float = 1.0,
        bold: bool = False,
        italic: bool = False,
        underline: bool = False,
        link: Optional[int | str] = "",
        foreground: int = 0,
        **__: Any,
    ) -> None:
        # pylint: disable=unused-argument
        if not text:
            return
        pdf = self.pdf
        if pdf.text_color != _rgb_as_str(foreground):  # type: ignore[comparison-overlap]
            pdf.set_text_color(*_rgb(foreground))
        font = font.strip().lower()
        style = ""
        for tag in "B", "I", "U":
            if text.startswith(f"<{tag}>") and text.endswith(f"</{tag}>"):
                text = text[3:-4]
                style += tag
        if bold:
            style += "B"
        if italic:
            style += "I"
        if underline:
            style += "U"
        pdf.set_font(font, style, size * scale)
        pdf.set_xy(x1, y1)
        pdf.write(5, text, link)

    def render(
        self,
        offsetx: float = 0.0,
        offsety: float = 0.0,
        rotate: float = 0.0,
        scale: float = 1.0,
    ) -> None:
        """
        Add the contents of the template to the PDF document.

        Args:
            offsetx, offsety (float): Place the template to move its origin to the given coordinates.
            rotate (float): Rotate the inserted template around its (offset) origin.
            scale (float): Scale the inserted template by this factor.
        """
        sorted_elements = sorted(self.elements, key=lambda x: x["priority"])
        with self.pdf.local_context():
            for element in sorted_elements:
                ele = element.copy()  # don't want to modify the callers original
                ele["text"] = self.texts.get(ele["name"].lower(), ele.get("text", ""))
                if scale != 1.0:
                    ele["x1"] = ele["x1"] * scale
                    ele["y1"] = ele["y1"] * scale
                    ele["x2"] = ele["x1"] + ((ele["x2"] - element["x1"]) * scale)
                    ele["y2"] = ele["y1"] + ((ele["y2"] - element["y1"]) * scale)
                if offsetx:
                    ele["x1"] = ele["x1"] + offsetx
                    ele["x2"] = ele["x2"] + offsetx
                if offsety:
                    ele["y1"] = ele["y1"] + offsety
                    ele["y2"] = ele["y2"] + offsety
                ele["scale"] = scale
                handler_name = ele["type"].upper()
                if rotate:  # don't rotate by 0.0 degrees
                    with self.pdf.rotation(rotate, offsetx, offsety):
                        if "rotate" in ele and ele["rotate"]:
                            with self.pdf.rotation(ele["rotate"], ele["x1"], ele["y1"]):
                                self.handlers[handler_name](**ele)  # type: ignore[operator]
                        else:
                            self.handlers[handler_name](**ele)  # type: ignore[operator]
                else:
                    if "rotate" in ele and ele["rotate"]:
                        with self.pdf.rotation(ele["rotate"], ele["x1"], ele["y1"]):
                            self.handlers[handler_name](**ele)  # type: ignore[operator]
                    else:
                        self.handlers[handler_name](**ele)  # type: ignore[operator]
        self.texts = {}  # reset modified entries for the next page
```

Example 2 (python):
```python
def load_elements(self, elements: Sequence[dict[str, Any]]) -> None:
    """
    Load a template definition.

    Args:
        elements (list of dicts): A template definition in a list of dicts
    """
    key_config = {
        # key: type
        "name": (str, type(None)),
        "type": (str, type(None)),
        "x1": (int, float),
        "y1": (int, float),
        "x2": (int, float),
        "y2": (int, float),
        "font": (str, type(None)),
        "size": (int, float),
        "bold": object,  # "bool or equivalent"
        "italic": object,
        "underline": object,
        "foreground": int,
        "background": int,
        "align": (str, type(None)),
        "text": (str, type(None)),
        "priority": int,
        "multiline": (bool, type(None)),
        "rotate": (int, float),
        "wrapmode": (str, type(None)),
        "dash_pattern": (dict, type(None)),
    }

    self.elements: Sequence[dict[str, Any]] = elements
    self.keys: list[str] = []
    for e in elements:
        # priority is optional, but we need a default for sorting.
        if not "priority" in e:
            e["priority"] = 0
        for k in ("name", "type", "x1", "y1", "y2"):
            if k not in e:
                if e["type"] == "C39":
                    # lots of legacy special casing.
                    # We need to do that here, so that rotation and scaling
                    # still work.
                    if k == "x1" and "x" in e:
                        e["x1"] = e["x"]
                        continue
                    if k == "y1" and "y" in e:
                        e["y1"] = e["y"]
                        continue
                    if k == "y2" and "h" in e:
                        e["y2"] = e["y1"] + e["h"]
                        continue
                raise KeyError(f"Mandatory key '{k}' missing in input data")
        # x2 is optional for barcode types, but needed for offset rendering
        if "x2" not in e:
            if e["type"] in ["BC", "C39"]:
                e["x2"] = 0
            else:
                raise KeyError("Mandatory key 'x2' missing in input data")
        if not "size" in e and e["type"] == "C39":
            if "w" in e:
                e["size"] = e["w"]
        if "dash_pattern" in e:
            for k in e["dash_pattern"].keys():
                if k not in ("dash", "gap", "phase"):
                    raise KeyError(f"Invalid key '{k}' in dash_pattern")
            if "dash" not in e["dash_pattern"]:
                e["dash_pattern"]["dash"] = 0
            if "gap" not in e["dash_pattern"]:
                e["dash_pattern"]["gap"] = e["dash_pattern"]["dash"]
            if "phase" not in e["dash_pattern"]:
                e["dash_pattern"]["phase"] = 0

        for k, t in key_config.items():
            if k in e and not isinstance(e[k], t):  # type: ignore[arg-type]
                ttype = (
                    t.__name__
                    if isinstance(t, type)
                    else " or ".join([f"'{x.__name__}'" for x in t])  # type: ignore[attr-defined]
                )
                raise TypeError(
                    f"Value of element item '{k}' must be {ttype}, not '{type(e[k]).__name__}'."
                )
        self.keys.append(e["name"].lower())
```

Example 3 (python):
```python
def parse_csv(
    self,
    infile: os.PathLike[str],
    delimiter: str = ",",
    decimal_sep: str = ".",
    encoding: Optional[str] = None,
) -> None:
    """
    Load the template definition from a CSV file.

    Args:
        infile (str, path-like object): The filepath of the CSV file.
        delimiter (str): The character that separates the fields in the CSV file:
            Usually a comma, semicolon, or tab.
        decimal_sep (str): The decimal separator used in the file.
            Usually either a point or a comma.
        encoding (str): The character encoding of the file.
            Default is the system default encoding.
    """

    def _varsep_float(s: str, default: str = "0") -> float:
        """Convert to float with given decimal separator"""
        # glad to have nonlocal scoping...
        return float((s.strip() or default).replace(decimal_sep, "."))

    key_config = (
        # key, converter, mandatory
        ("name", str, True),
        ("type", str, True),
        ("x1", _varsep_float, True),
        ("y1", _varsep_float, True),
        ("x2", _varsep_float, True),
        ("y2", _varsep_float, True),
        ("font", str, False),
        ("size", _varsep_float, False),
        ("bold", int, False),
        ("italic", int, False),
        ("underline", int, False),
        ("foreground", self._parse_colorcode, False),
        ("background", self._parse_colorcode, False),
        ("align", str, False),
        ("text", str, False),
        ("priority", int, False),
        ("multiline", self._parse_multiline, False),
        ("rotate", _varsep_float, False),
        ("wrapmode", str, False),
    )
    self.elements = []
    if encoding is None:
        encoding = locale.getpreferredencoding()
    with open(infile, encoding=encoding) as f:
        for row in csv.reader(f, delimiter=delimiter):
            # fill in blanks for any missing items
            row.extend([""] * (len(key_config) - len(row)))
            kargs: dict[str, Any] = {}
            for val, cfg in zip(row, key_config):
                vs = val.strip()
                if not vs:
                    if cfg[2]:  # mandatory
                        if cfg[0] == "x2" and row[1] in ["BC", "C39"]:
                            # two types don't need x2, but offset rendering does
                            pass
                        else:
                            raise FPDFException(
                                f"Mandatory value '{cfg[0]}' missing in csv data"
                            )
                    elif cfg[0] == "priority":
                        # formally optional, but we need some value for sorting
                        kargs["priority"] = 0
                    # otherwise, let the type handlers use their own defaults
                else:
                    kargs[cfg[0]] = cfg[1](vs)  # type: ignore[operator]
            self.elements.append(kargs)
    self.keys = [val["name"].lower() for val in self.elements]
```

Example 4 (python):
```python
def parse_json(self, infile: os.PathLike[str], encoding: str = "utf-8") -> None:
    """
    Load the template definition from a JSON file.
    The data must be structured as an array of objects, with names and values exactly
    equivalent to what would get supplied to load_elements(),

    Args:
        infile (str, path-like object): The filepath of the JSON file.
        encoding (str): The character encoding of the file. Default is UTF-8.
    """
    with open(infile, encoding=encoding) as f:
        data = json.load(f)
        for d in data:
            fgval = d.get("foreground")
            if fgval and isinstance(fgval, str):
                if fgval.lower().startswith("#"):
                    d["foreground"] = int(fgval[1:], 16)
                else:
                    raise ValueError(
                        "If foreground is a string, it must have the form '#rrggbb'."
                    )
            bgval = d.get("background")
            if bgval and isinstance(bgval, str):
                if bgval.lower().startswith("#"):
                    d["background"] = int(bgval[1:], 16)
                else:
                    raise ValueError(
                        "If background is a string, it must have the form '#rrggbb'."
                    )
        self.load_elements(data)
```

---

## Links¬∂

**URL:** https://py-pdf.github.io/fpdf2/Links.html

**Contents:**
- Links¬∂
- Hyperlink with FPDF.cell¬∂
- Hyperlink with FPDF.multi_cell¬∂
- Hyperlink with FPDF.link¬∂
- Hyperlink with write_html¬∂
- Internal links¬∂
- Links to other documents on the filesystem¬∂
- Alternative description¬∂

fpdf2 can generate both internal links (to other pages in the document) & hyperlinks (links to external URLs that will be opened in a browser).

This method makes the whole cell clickable (not only the text):

Links defined this way in Markdown can be styled by setting FPDF class attributes MARKDOWN_LINK_COLOR (default: None) & MARKDOWN_LINK_UNDERLINE (default: True).

link="https://...your-url" can also be used to make the whole cell clickable.

The FPDF.link is a low-level method that defines a rectangular clickable area.

There is an example showing how to place such rectangular link over some text:

An alternative method using FPDF.write_html:

The hyperlinks defined this way will be rendered in blue with underline.

Internal links are links redirecting to other pages in the document.

There are some situations where a user wants to create an internal link to another page in the PDF document, but the page number is not known at the time of link creation. In this case, the link can be created using pdf.add_link() as before, and then later re-reference to a specific page using pdf.set_link(). In this example our goal is to link to a page that occurs after a section with a variable amount of text, potentially occupying multiple pages:

from fpdf import FPDF import random pdf = FPDF() pdf.set_font("helvetica", size=24) pdf.add_page() # create a link to a page that will be created later link_to_summary_page = pdf.add_link() pdf.cell(text="Link to summary after elements", border=1, link=link_to_summary_page) pdf.ln(20) pdf.cell(text="List of elements", align="C", center=True) pdf.ln(20) # this num_elements variable can vary across runs # resulting in a different number of pages num_elements = random.randint(10,30) for i in range(num_elements): pdf.cell(text=f"Element {i+1}", align="C", center=True) pdf.ln(20) # `set_link` to change page referenced by the link pdf.add_page() pdf.set_link(link_to_summary_page) pdf.cell(text=f"Summary: there are {num_elements} elements", align="C", center=True) pdf.ln(20) # link back to the first page link = pdf.add_link(page=1) pdf.cell(text="Internal link to first page", border=1, link=link) pdf.output("internal_link_unknown_pages.pdf") Other methods can also insert internal links:

The unit tests test_internal_links() in test_links.py provides examples for all of those methods.

Other methods can also insert internal links:

The unit test test_link_to_other_document() in test_links.py provides examples for all of those methods.

An optional textual description of the link can be provided, for accessibility purposes:

**Examples:**

Example 1 (python):
```python
from fpdf import FPDF

pdf = FPDF()
pdf.add_page()
pdf.set_font("helvetica", size=24)
pdf.cell(text="Cell link", border=1, center=True,
         link="https://github.com/py-pdf/fpdf2")
pdf.output("hyperlink.pdf")
```

Example 2 (python):
```python
from fpdf import FPDF

pdf = FPDF()
pdf.set_font("helvetica", size=24)
pdf.add_page()
pdf.multi_cell(
    pdf.epw,
    text="**Website:** [fpdf2](https://py-pdf.github.io/fpdf2/) __Go visit it!__",
    markdown=True,
)
pdf.output("hyperlink.pdf")
```

Example 3 (swift):
```swift
from fpdf import FPDF

pdf = FPDF()
pdf.add_page()
pdf.set_font("helvetica", size=36)
line_height = 10
text = "Text link"
pdf.text(x=0, y=line_height, text=text)
width = pdf.get_string_width(text)
pdf.link(x=0, y=0, w=width, h=line_height, link="https://github.com/py-pdf/fpdf2")
pdf.output("hyperlink.pdf")
```

Example 4 (jsx):
```jsx
from fpdf import FPDF

pdf = FPDF()
pdf.set_font_size(16)
pdf.add_page()
pdf.write_html('<a href="https://github.com/py-pdf/fpdf2">Link defined as HTML</a>')
pdf.output("hyperlink.pdf")
```

---

## Module fpdf.text_region

**URL:** https://py-pdf.github.io/fpdf2/fpdf/text_region.html

**Contents:**
- Module fpdf.text_region
- Classes
  - Methods
  - Ancestors
  - Instance variables
  - Methods
  - Ancestors
  - Instance variables
  - Methods
  - Ancestors

Usage documentation at: https://py-pdf.github.io/fpdf2/TextRegion.html

Alias for field number 0

Alias for field number 1

Connects each TextLine with the Paragraph it was written to. This allows to access paragraph specific attributes like top/bottom margins when rendering the line.

Alias for field number 2

Alias for field number 3

Alias for field number 0

Alias for field number 1

Helper class that provides a standard way to create an ABC using inheritance.

Enable a TextRegion to perform page breaks

The type of the None singleton.

Abstract base class for all text region subclasses.

Inherited from: TextColumnarMixin.pdf

The type of the None singleton.

Inherited from: TextRegion.current_x_extents

Return the horizontal extents of the current line. Columnar regions simply return the boundaries of the column. Regions with non-vertical boundaries ‚Ä¶

End the current column and continue at the top of the next one.

Inherited from: TextRegion.paragraph

Abstract base class for all text region subclasses.

Return the horizontal extents of the current line. Columnar regions simply return the boundaries of the column. Regions with non-vertical boundaries need to check how the largest font-height in the current line actually fits in there. For that reason we include the current y and the line height.

Inherited from: ParagraphCollectorMixin.paragraph

Mix-in to be added to FPDF() in order to support text regions.

**Examples:**

Example 1 (python):
```python
class Bullet:
    def __init__(
        self,
        bullet_fragments: Sequence["Fragment"],
        text_line: Optional["TextLine"],
        bullet_r_margin: float,
    ) -> None:
        self.fragments: Sequence["Fragment"] = bullet_fragments
        self.text_line = text_line
        self.r_margin = bullet_r_margin
        self.rendered_flag: bool = False

    def get_fragments_width(self) -> float:
        fragments_width: float = 0
        for frag in self.fragments:
            fragments_width += frag.get_width()
        return fragments_width
```

Example 2 (python):
```python
def get_fragments_width(self) -> float:
    fragments_width: float = 0
    for frag in self.fragments:
        fragments_width += frag.get_width()
    return fragments_width
```

Example 3 (python):
```python
class Extents(NamedTuple):
    left: float
    right: float
```

Example 4 (python):
```python
class Extents(NamedTuple):
    left: float
    right: float
```

---

## Metadata¬∂

**URL:** https://py-pdf.github.io/fpdf2/Metadata.html

**Contents:**
- Metadata¬∂

The PDF specification contain two types of metadata, the newer XMP (Extensible Metadata Platform, XML-based) and older DocumentInformation dictionary. The PDF 2.0 specification removes the DocumentInformation dictionary.

Currently, the following methods on fpdf.FPDF allow to set metadata information in the DocumentInformation dictionary:

---

## Module fpdf.recorder

**URL:** https://py-pdf.github.io/fpdf2/fpdf/recorder.html

**Contents:**
- Module fpdf.recorder
- Classes
  - Class variables
  - Methods

A wrapper class to allow rewinding/replaying changes made to a FPDF instance.

The contents of this module are internal to fpdf2, and not part of the public API. They may change at any time without prior warning or any deprecation period, in non-backward-compatible ways.

The class is aimed to be used as wrapper around fpdf.FPDF:

Its aim is dual: * allow to rewind to the state of the FPDF instance passed to its constructor, reverting all changes made to its internal state * allow to replay again all the methods calls performed on the recorder instance between its creation and the last call to rewind()

Note that method can be called on a FPDFRecorder instance using its .pdf attribute so that they are not recorded & replayed later, on a call to .replay().

Note that using this class means to duplicate the FPDF bytearray buffer: when generating large PDFs, doubling memory usage may be troublesome.

The type of the None singleton.

**Examples:**

Example 1 (python):
```python
class CallRecorder:
    def __init__(self, func: Callable[..., Any], calls: list[CallRecord]) -> None:
        self._func: Callable[..., Any] = func
        self._calls: list[CallRecord] = calls

    def __call__(self, *args: Any, **kwargs: Any) -> Any:
        self._calls.append((self._func, args, kwargs))
        return self._func(*args, **kwargs)
```

Example 2 (python):
```python
class FPDFRecorder:
    """
    The class is aimed to be used as wrapper around fpdf.FPDF:

        pdf = FPDF()
        recorder = FPDFRecorder(pdf)

    Its aim is dual:
      * allow to **rewind** to the state of the FPDF instance passed to its constructor,
        reverting all changes made to its internal state
      * allow to **replay** again all the methods calls performed
        on the recorder instance between its creation and the last call to rewind()

    Note that method can be called on a FPDFRecorder instance using its .pdf attribute
    so that they are not recorded & replayed later, on a call to .replay().

    Note that using this class means to duplicate the FPDF `bytearray` buffer:
    when generating large PDFs, doubling memory usage may be troublesome.
    """

    page_break_triggered: bool

    def __init__(self, pdf: "FPDF", accept_page_break: bool = True) -> None:
        self.pdf = pdf
        self._initial: dict[str, Any] = deepcopy(vars(self.pdf))
        self._calls: list[CallRecord] = []
        if not accept_page_break:
            self.accept_page_break = False

    def __getattr__(self, name: str) -> Any:
        attr = getattr(self.pdf, name)
        if callable(attr):
            return CallRecorder(attr, self._calls)
        return attr

    def rewind(self) -> None:
        pdf_dict = vars(self.pdf)
        pdf_dict.clear()
        pdf_dict.update(self._initial)
        self._initial = deepcopy(pdf_dict)

    def replay(self) -> None:
        for call in self._calls:
            func, args, kwargs = call
            try:
                result = func(*args, **kwargs)
                if isinstance(result, types.GeneratorType):
                    warnings.warn(
                        "Detected usage of a context manager inside an unbreakable() section, which is not supported",
                        stacklevel=get_stack_level(),
                    )
                # The results of other methods can also be invalidated: .pages_count, page_no(), get_x() / get_y(), will_page_break()
            except Exception as error:
                raise FPDFException(
                    f"Failed to replay FPDF call: {func}(*{args}, **{kwargs})"
                ) from error
        self._calls = []
```

Example 3 (unknown):
```unknown
pdf = FPDF()
recorder = FPDFRecorder(pdf)
```

Example 4 (python):
```python
def replay(self) -> None:
    for call in self._calls:
        func, args, kwargs = call
        try:
            result = func(*args, **kwargs)
            if isinstance(result, types.GeneratorType):
                warnings.warn(
                    "Detected usage of a context manager inside an unbreakable() section, which is not supported",
                    stacklevel=get_stack_level(),
                )
            # The results of other methods can also be invalidated: .pages_count, page_no(), get_x() / get_y(), will_page_break()
        except Exception as error:
            raise FPDFException(
                f"Failed to replay FPDF call: {func}(*{args}, **{kwargs})"
            ) from error
    self._calls = []
```

---

## Handleiding¬∂

**URL:** https://py-pdf.github.io/fpdf2/Tutorial-nl.html

**Contents:**
- Handleiding¬∂
- Tuto 1 - Minimaal voorbeeld¬∂
- Tuto 2 - Koptekst, voettekst, pagina-einde en afbeelding¬∂
- Tuto 3 - Line breaks and colors¬∂
- Tuto 4 - Meerdere kolommen¬∂
- Tuto 5 - Tabellen maken¬∂
- Tuto 6 - Koppelingen maken en tekststijlen mixen¬∂

Methoden volledige documentatie: fpdf.FPDF API doc

Eerste, het klassieke voorbeeld:

Nadat u het bibliotheekbestand hebt toegevoegd, maakt u een FPDF-object. De FPDF constructor wordt hier gebruikt met de standaardwaarden: pagina's zijn in A4 staand en de maateenheid is millimeter. Het had expliciet vermeld kunnen worden met:

Het is mogelijk om de PDF in landscape-modus (L) te zetten of om andere paginaformaten te gebruiken (zoals Letter en Legal) en maateenheden (pt, cm, in).

Er is momenteel geen pagina, dus we moeten er een toevoegen add_page. De oorsprong bevindt zich in de linkerbovenhoek en de de huidige positie wordt standaard op 1 cm van de randen geplaatst; de marges kunnen worden gewijzigd met set_margins.

Voordat we tekst kunnen afdrukken, is het verplicht om een lettertype te selecteren set_font, anders zou het document ongeldig zijn. Wij kiezen voor Helvetica bold 16:

We hadden cursief kunnen specificeren met I, onderstreept met U of een gewoon lettertype met een lege string (of een combinatie daarvan). Houd er rekening mee dat de lettergrootte is opgegeven punten, geen millimeters (of een andere gebruikerseenheid); het is de enige uitzondering. De andere ingebouwde lettertypen zijn Times, Courier, Symbol en ZapfDingbats.

We kunnen nu een cel afdrukken met cell.Een cel is een rechthoekig gebied, eventueel omkaderd, dat wat tekst bevat. Het wordt weergegeven op de huidige positie.

We specificeren de afmetingen, de tekst (gecentreerd of uitgelijnd), of er randen moeten worden getekend en waar de huidige positie daarnaheen beweegt (naar rechts, onder of naar het begin van de volgende regel). Om een frame toe te voegen, doen we dit:

Om er een nieuwe cel met gecentreerde tekst naast toe te voegen en naar de volgende regel te gaan, wij zou doen:

Let op!: het regeleinde kan ook met ln. Dit methode maakt het mogelijk om bovendien de hoogte van de pauze te specificeren.

Ten slotte wordt het document gesloten en opgeslagen onder het opgegeven bestandspad met behulp van output. Zonder dat er een parameter is opgegeven, wordt output() retourneert de PDF bytearray-buffer.

Hier is een voorbeeld van twee pagina's met koptekst, voettekst en logo:

Dit voorbeeld maakt gebruik van de header en footer methoden om paginakop- en voetteksten te verwerken. Zij worden automatisch gebeld. Ze bestaan al in de FPDF-klasse, maar doen niets, daarom moeten we de klasse uitbreiden en overschrijven.

Het logo wordt afgedrukt met de methode image door op te geven de linkerbovenhoek en de breedte ervan. De hoogte wordt automatisch berekend respecteer de beeldverhoudingen.

Om het paginanummer af te drukken, wordt een nulwaarde doorgegeven als celbreedte. Het betekent dat de cel zich moet uitstrekken tot aan de rechtermarge van de pagina; het is handig om middelste tekst. Het huidige paginanummer wordt geretourneerd door de page_no methode; wat betreft het totale aantal pagina's wordt verkregen door middel van de speciale waarde {nb} die wordt vervangen bij het sluiten van het document (deze speciale waarde kan worden gewijzigd door alias_nb_pages()).

Let op het gebruik van de set_y methode waarmee positie op een absolute locatie op de pagina, beginnend vanaf de bovenkant of de onderkant.

Hier wordt een andere interessante functie gebruikt: het automatisch afbreken van pagina's. Zo snel omdat een cel een limiet op de pagina zou overschrijden (op 2 centimeter van de onderkant door standaard), wordt er een pauze uitgevoerd en wordt het lettertype hersteld. Hoewel de kop en voettekst hun eigen lettertype selecteren (helvetica), de hoofdtekst gaat verder met Times. Dit mechanisme van automatisch herstel is ook van toepassing op kleuren en lijndikte. Met de limiet waarmee pagina-einden worden geactiveerd, kan worden ingesteld set_auto_page_break.

Laten we doorgaan met een voorbeeld waarin uitgevulde alinea's worden afgedrukt. Het ook illustreert het gebruik van kleuren.

Met de methode get_string_width kunt u bepalen de lengte van een string in het huidige lettertype, die hier wordt gebruikt om de positie en de breedte van het kader rond de titel. Vervolgens worden de kleuren ingesteld (via set_draw_color, set_fill_color en set_text_color) en de dikte van de lijn is ingesteld tot 1 mm (standaard tegen 0,2) met set_line_width. Ten slotte voeren we de cel uit (de laatste parameter op true geeft aan dat de achtergrond moet worden gevuld).

De methode die wordt gebruikt om de alinea's af te drukken is multi_cell. Tekst wordt standaard uitgevuld. Elke keer dat een regel het rechteruiteinde van de cel bereikt of een regelterugloopteken (\n) wordt tegengekomen, er wordt een regeleinde weergegeven en er wordt automatisch een nieuwe cel aangemaakt onder de huidige. Er wordt automatisch een pauze uitgevoerd op de locatie van de dichtstbijzijnde spatie of het zachte koppelteken (\u00ad) v√≥√≥r de rechterlimiet. Een zacht afbreekstreepje wordt vervangen door een normaal afbreekstreepje bij het activeren van een regeleinde, en wordt anders genegeerd.

Er worden twee documenteigenschappen gedefinieerd: de titel (set_title) en de auteur (set_author). Eigenschappen kunnen op twee manieren worden bekeken. Ten eerste opent u het document rechtstreeks met Acrobat Reader, ga naar het menu Bestand en kies de optie Documenteigenschappen. De tweede, ook verkrijgbaar bij de plug-in, is door met de rechtermuisknop te klikken en Documenteigenschappen te selecteren.

Dit voorbeeld is een variant van het vorige en laat zien hoe u de tekst over meerdere kolommen kunt plaatsen.

Het belangrijkste verschil met de vorige tutorial is het gebruik van de text_columns methode. Het verzamelt alle tekst, mogelijk in stappen, en verdeelt deze over het gevraagde aantal kolommen, waarbij indien nodig automatisch pagina-einden worden ingevoegd. Houd er rekening mee dat, hoewel de instantie TextColumns actief is als contextmanager, tekststijlen en andere lettertype-eigenschappen kunnen worden gewijzigd. Deze wijzigingen zullen in de context worden opgenomen. Zodra het wordt gesloten, worden de vorige instellingen hersteld.

In deze tutorial wordt uitgelegd hoe u twee verschillende tabellen kunt maken, om te demonstreren wat met enkele eenvoudige aanpassingen kan worden bereikt.

Resulting PDF - Countries CSV data

Het eerste voorbeeld wordt op de meest basale manier gerealiseerd, door gegevens toe te voeren FPDF.table(). Het resultaat is rudimentair, maar zeer snel te verkrijgen.

De tweede tabel brengt enkele verbeteringen met zich mee: kleuren, beperkte tafelbreedte, verminderde lijnhoogte, gecentreerde titels, kolommen met aangepaste breedtes, cijfers rechts uitgelijnd... Bovendien zijn horizontale lijnen verwijderd. Dit werd gedaan door een borders_layout te kiezen uit de beschikbare waarden: TableBordersLayout.

In deze tutorial worden verschillende manieren uitgelegd om links in een pdf-document in te voegen, evenals het toevoegen van links naar externe bronnen.

Het laat ook verschillende manieren zien waarop we verschillende tekststijlen kunnen gebruiken, (vet, cursief, onderstreept) binnen dezelfde tekst.

Resulting PDF - fpdf2-logo

De nieuwe methode die hier wordt getoond om tekst af te drukken is write() . Het lijkt erg op multi_cell() , de belangrijkste verschillen zijn:

Met deze methode kunnen we dus een stuk tekst schrijven, de lettertypestijl wijzigen, en ga verder vanaf de exacte plek waar we gebleven waren. Aan de andere kant is het belangrijkste nadeel dat we de tekst niet kunnen rechtvaardigen wij doen met de multi_cell() methode.

Op de eerste pagina van het voorbeeld gebruikten we write() Voor dit doeleinde. Het begin van de zin is in normale stijl geschreven tekst en gebruik vervolgens de set_font() methode schakelden we over op onderstrepen en maakten de zin af.

Om een interne link toe te voegen die naar de tweede pagina verwijst, hebben we de add_link() methode, die een klikbaar gebied cre√´ert dat we "link" noemden en dat naar een andere pagina in het document verwijst.

Om de externe link te maken met behulp van een afbeelding, hebben we gebruikt image() . De methode heeft de mogelijkheid om een link als een van zijn argumenten door te geven. De link kan zowel intern als extern zijn.

Als alternatief is een andere optie om de lettertypestijl te wijzigen en links toe te voegen het gebruik van de methode write_html(). Het is een html-parser waarmee u tekst kunt toevoegen, de lettertypestijl kunt wijzigen en links kunt toevoegen met behulp van html.

**Examples:**

Example 1 (python):
```python
from fpdf import FPDF

pdf = FPDF()
pdf.add_page()
pdf.set_font("helvetica", style="B", size=16)
pdf.cell(40, 10, "Hello World!")
pdf.output("tuto1.pdf")
```

Example 2 (unknown):
```unknown
pdf = FPDF(orientation="P", unit="mm", format="A4")
```

Example 3 (unknown):
```unknown
pdf.set_font('Helvetica', style='B', size=16)
```

Example 4 (unknown):
```unknown
pdf.cell(40, 10, 'Hello World!', 1)
```

---

## Charts & graphs¬∂

**URL:** https://py-pdf.github.io/fpdf2/Maths.html

**Contents:**
- Charts & graphs¬∂
- Charts¬∂
  - Using Matplotlib¬∂
  - Using Pandas¬∂
  - Using Ibis¬∂
  - Using Plotly¬∂
  - Using Pygal¬∂
- Mathematical formulas¬∂
  - Using Google Charts API¬∂
  - Using LaTeX & Matplotlib¬∂

Before running this example, please install the required dependencies using the command below: pip install fpdf2 matplotlib Example taken from Matplotlib artist tutorial:

You can also embed a figure as SVG (but there may be some limitations):

The dependencies required for the following examples can be installed using this command: pip install fpdf2 matplotlib pandas

Create a plot using pandas.DataFrame.plot:

Create a table with pandas DataFrame:

The Ibis library provides a unified interface for analytical workflows across different backends (such as DuckDB, BigQuery, pandas, and more). Ibis table expressions are lazy and backend-agnostic; to retrieve the actual data, you need to execute the expression, which typically returns a pandas DataFrame.

This makes it straightforward to use Ibis with fpdf2: simply execute your Ibis table expression to get a DataFrame, then render it as a table in your PDF using the same approach as with pandas.

Before running the following example, please install the required dependencies: pip install "ibis-framework[duckdb]" fpdf2 pandas

Example: Render an Ibis table as a table in a PDF document:

This approach works with any Ibis backend (DuckDB, pandas, BigQuery, etc.)‚Äîjust use .execute() to get a DataFrame, then render as shown above.

Before running this example, please install the required dependencies using the command below:

kaleido is a cross-platform library for generating static images that is used by plotly.

Example taken from Plotly static image export tutorial:

While you can also embed a figure as SVG, this is not recommended as text data - such as the x and y axis bars - might not be displayed, because plotly places this data in a SVG text tag which is currently not supported by fpdf2.

Before running this example, please install the required dependencies:

Pygal is a Python graph plotting library. You can install it using: pip install pygal

fpdf2 can embed graphs and charts generated using Pygal library. However, they cannot be embedded as SVG directly, because Pygal inserts <style> & <script> tags in the images it produces (cf. pygal/svg.py), which is currently not supported by fpdf2. The full list of supported & unsupported SVG features can be found there: SVG page.

You can find documentation on how to convert vector images (SVG) to raster images (PNG, JPG), with a practical example of embedding PyGal charts, there: SVG page > Converting vector graphics to raster graphics.

fpdf2 can only insert mathematical formula in the form of images. The following sections will explain how to generate and embed such images.

Official documentation: Google Charts Infographics - Mathematical Formulas.

Matplotlib can render LaTeX: Text rendering With LaTeX.

If you have trouble with the SVG export, you can also render the matplotlib figure as pixels:

**Examples:**

Example 1 (unknown):
```unknown
pip install fpdf2 matplotlib
```

Example 2 (typescript):
```typescript
from fpdf import FPDF
from matplotlib.backends.backend_agg import FigureCanvasAgg as FigureCanvas
from matplotlib.figure import Figure
import numpy as np
from PIL import Image

fig = Figure(figsize=(6, 4), dpi=300)
fig.subplots_adjust(top=0.8)
ax1 = fig.add_subplot(211)
ax1.set_ylabel("volts")
ax1.set_title("a sine wave")

t = np.arange(0.0, 1.0, 0.01)
s = np.sin(2 * np.pi * t)
(line,) = ax1.plot(t, s, color="blue", lw=2)

# Fixing random state for reproducibility
np.random.seed(19680801)

ax2 = fig.add_axes([0.15, 0.1, 0.7, 0.3])
n, bins, patches = ax2.hist(
    np.random.randn(1000), 50, facecolor="yellow", edgecolor="yellow"
)
ax2.set_xlabel("time (s)")

# Converting Figure to an image:
canvas = FigureCanvas(fig)
canvas.draw()
img = Image.fromarray(np.asarray(canvas.buffer_rgba()))

pdf = FPDF()
pdf.add_page()
pdf.image(img, w=pdf.epw)  # Make the image full width
pdf.output("matplotlib.pdf")
```

Example 3 (swift):
```swift
from fpdf import FPDF
import matplotlib.pyplot as plt
import numpy as np

plt.figure(figsize=[2, 2])
x = np.arange(0, 10, 0.00001)
y = x*np.sin(2* np.pi * x)
plt.plot(y)
plt.savefig("figure.svg", format="svg")

pdf = FPDF()
pdf.add_page()
pdf.image("figure.svg")
pdf.output("doc-with-figure.pdf")
```

Example 4 (unknown):
```unknown
pip install fpdf2 matplotlib pandas
```

---

## Module fpdf.fpdf

**URL:** https://py-pdf.github.io/fpdf2/fpdf/fpdf.html

**Contents:**
- Module fpdf.fpdf
- Global variables
- Functions
- Classes
- Args
  - Ancestors
  - Class variables
  - Instance variables
  - Methods
- Args

Supported page format names & dimensions

Return page width and height size in points.

Throws FPDFPageFormatException

format can be either a 2-tuple or one of 'a3', 'a4', 'a5', 'letter', or 'legal'.

If format is a tuple, then the return value is the tuple's values given in the units specified on this document in the constructor, multiplied by the corresponding scale factor k, taken from instance variable self.k.

If format is a string, the (width, height) tuple returned is in points. For a width and height of 8.5 * 11, 72 dpi is assumed, so the value returned is (8.5 * 72, 11 * 72), or (612, 792). Additional formats can be added by adding fields to the PAGE_FORMATS dictionary with a case insensitive key (the name of the new format) and 2-tuple value of (width, height) in dots per inch with a 72 dpi resolution.

Inherited from: GraphicsStateMixin.DEFAULT_DRAW_COLOR

The type of the None singleton.

Inherited from: GraphicsStateMixin.DEFAULT_FILL_COLOR

The type of the None singleton.

Inherited from: GraphicsStateMixin.DEFAULT_TEXT_COLOR

The type of the None singleton.

Render basic HTML to FPDF

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

Convert a string or number to a floating-point number, if possible.

The type of the None singleton.

Returns True when the argument is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.

The type of the None singleton.

Whenever a page break condition is met, this @property method is called, and the break is issued or not depending on the returned value.

The default implementation returns self.auto_page_break, a value according to the mode selected by FPDF.set_auto_page_break().

This method is called automatically and should not be called directly by the application.

Detailed documentation on page breaks: https://py-pdf.github.io/fpdf2/PageBreaks.html

Inherited from: GraphicsStateMixin.char_vpos

Return vertical character position relative to line. (docs)

Font encoding, Latin-1 by default

Return a pair (width, height) in points units (1/72 of inch)

Inherited from: GraphicsStateMixin.denom_lift

Return lift factor for denominator text. (docs)

Inherited from: GraphicsStateMixin.denom_scale

Return scale factor for denominator text. (docs)

The current text emphasis: bold, italics, underline and/or strikethrough.

Effective page height: the page height minus its vertical margins.

Effective page width: the page width minus its horizontal margins.

Inherited from: GraphicsStateMixin.nom_lift

Return lift factor for nominator text. (docs)

Inherited from: GraphicsStateMixin.nom_scale

Return scale factor for nominator text. (docs)

Note: Setting the page manually may result in unexpected behavior. pdf.add_page() takes special care to ensure the page's content stream matches FPDF's instance attributes. Manually setting the page does not.

Returns the total pages of the document, at the time it is called.

Do not use this in FPDF.header() or FPDF.footer(), as its value will not be the total page count. Uses {nb} instead, cf. FPDF.alias_nb_pages().

Setting this to True restore the old behaviour before 2.7.9. Using a single /Resources object makes the resulting PDF document smaller, but is less compatible with the PDF spec.

Inherited from: GraphicsStateMixin.sub_lift

Return lift factor for subscript text. (docs)

Inherited from: GraphicsStateMixin.sub_scale

Return scale factor for subscript text. (docs)

Inherited from: GraphicsStateMixin.sup_lift

Return lift factor for superscript text. (docs)

Inherited from: GraphicsStateMixin.sup_scale

Return scale factor for superscript text. (docs)

Inherited from: GraphicsStateMixin._get_current_graphics_state

Retrieve the current graphics state

Inherited from: GraphicsStateMixin._is_current_graphics_state_nested

Indicate if a nested graphics state is active

Inherited from: GraphicsStateMixin._pop_local_stack

Pop the last graphics state on the stack

Inherited from: GraphicsStateMixin._push_local_stack

Push a graphics state on the stack

Puts an Action annotation on a rectangular area of the page.

Imports a TrueType or OpenType font and makes it available for later calls to the FPDF.set_font() method.

You will find more information on the "Unicode" documentation page.

Creates a new internal link and returns its identifier. An internal link is a clickable area which directs to another place within the document.

The identifier can then be passed to the FPDF.cell(), FPDF.write(), FPDF.image() or FPDF.link() methods.

If a name is provided, creates a named destination that can be referenced later. Named destinations are more stable than plain links when pages are added or removed.

Adds desired Output Intent to the Output Intents array:

dest_output_profile (PDFICCProfile, required/optional): PDFICCProfile | None # (required if output_condition_identifier does not specify a standard production condition; optional otherwise) info (str, required/optional see dest_output_profile): human readable description of profile

Adds a new page to the document. If a page is already present, the FPDF.footer() method is called first. Then the page is added, the current position is set to the top-left corner, with respect to the left and top margins, and the FPDF.header() method is called.

Adds a text markup annotation on some quadrilateral areas of the page.

Defines an alias for the total number of pages. It will be substituted as the document is closed.

This is useful to insert the number of pages of the document at a time when this number is not known by the program.

This substitution can be disabled for performances reasons, by calling alias_nb_pages(None).

When using this feature with the FPDF.cell() / FPDF.multi_cell() methods, or the .underline / .strikethrough attributes of FPDF class, the width of the text rendered will take into account the alias length, not the length of the "actual number of pages" string, which can causes slight positioning differences.

Outputs an arc. It can be drawn (border only), filled (with no border) or both.

Outputs a quadratic or cubic B√©zier curve, defined by three or four coordinates.

Prints a cell (rectangular area) with optional borders, background color and character string. The upper-left corner of the cell corresponds to the current position. The text can be aligned or centered. After the call, the current position moves to the selected new_x/new_y position. It is possible to put a link on the text. A cell has an horizontal padding, on the left & right sides, defined by the.c_margin property.

If automatic page breaking is enabled and the cell goes beyond the limit, a page break is performed before outputting.

Returns: a boolean indicating if page break was triggered

Outputs a circle. It can be drawn (border only), filled (with no border) or both.

WARNING: This method changed parameters in release 2.8.0

Draw a dashed line between two points.

Deprecated since version: 2.4.6

Use FPDF.set_dash_pattern() and the normal drawing operations instead.

Add a pre-constructed path to the document.

Add a pre-constructed path to the document.

Create a context for drawing paths on the current page.

If this context manager is called again inside of an active context, it will raise an exception, as base drawing contexts cannot be nested.

Outputs an ellipse. It can be drawn (border only), filled (with no border) or both.

Context manager that defines an elliptic crop zone, useful to render only part of an image.

Embed a file into the PDF as an attachment (and, for PDF/A-3 or PDF/A-4f, as an Associated File).

Returns: a PDFEmbeddedFile instance, with a .basename string attribute representing the internal file name

Puts a file attachment annotation on a rectangular area of the page.

This method can be overridden in inherited classes in order to define a custom file identifier. Its output must have the format "". If this method returns a falsy value (None, empty string), no /ID will be inserted in the generated PDF document.

Inherited from: GraphicsStateMixin.font_face

Return a FontFace instance representing a subset of properties of this GraphicsState.

Footer to be implemented in your own inherited class.

This is automatically called by FPDF.add_page() and FPDF.output() and should not be called directly by the user application. The default implementation performs nothing: you have to override this method in a subclass to implement your own rendering logic.

Puts a free text annotation on a rectangular area of the page.

Returns which fallback font has the requested glyph. This method can be overridden to provide more control than the select_mode parameter of FPDF.set_fallback_fonts() provides.

Retrieves a named destination by its name and creates a link to it.

Return the current page PDFPageLabel. This will be displayed by some PDF readers to identify pages. FPDF.set_page_label() needs to be called first for those to be inserted.

Returns the length of a string in user unit. A font must be selected. The value is calculated with stretching and spacing.

Note that the width of a cell has some extra padding added to this width, on the left & right sides, equal to the .c_margin property.

Returns the abscissa of the current position.

Returns the ordinate of the current position.

Create a context for drawing paths for type 3 font glyphs, without writing on the current page.

Header to be implemented in your own inherited class

This is automatically called by FPDF.add_page() and should not be called directly by the user application. The default implementation performs nothing: you have to override this method in a subclass to implement your own rendering logic.

Note that header rendering can have an impact on the initial (x,y) position when starting to render the page content.

Context manager that adds a single highlight annotation based on the text lines inserted inside its indented block.

Put an image on the page.

The size of the image on the page can be specified in different ways: * explicit width and height (expressed in user units) * one explicit dimension, the other being calculated automatically in order to keep the original proportions * no explicit dimension, in which case the image is put at 72 dpi. * explicit width and height (expressed in user units) and keep_aspect_ratio=True

Remarks: * if an image is used several times, only one copy is embedded in the file. * when using an animated GIF, only the first frame is used.

If y is provided, this method will not trigger any page break; otherwise, auto page break detection will be performed.

Returns: an instance of a subclass of ImageInfo.

Adds add an ink annotation on the page.

Configure Table Of Contents rendering at the end of the document generation, and reserve some vertical space right now in order to insert it. At least one page break is triggered by this method.

Barcode I2of5 (numeric), adds a 0 if odd length

Draw a line between two points.

Puts a link annotation on a rectangular area of the page. Text or image links are generally put via FPDF.cell(), FPDF.write() or FPDF.image(), but this method can be useful for instance to define a clickable area inside an image.

Line Feed. The current abscissa goes back to the left margin and the ordinate increases by the amount passed as parameter.

Creates a local graphics state, which won't affect the surrounding code. This method must be used as a context manager using with:

The affected settings are those controlled by GraphicsStateMixin and drawing.GraphicsStyle:

Font size can be specified in document units with font_size or in points with font_size_pt.

Method to perform a reflection transformation over a given mirror line. It must be used as a context-manager using with:

The mirror transformation affects all elements which are rendered inside the indented context (with the exception of clickable areas).

This method allows printing text with line breaks. They can be automatic (breaking at the most recent space or soft-hyphen character) as soon as the text reaches the right border of the cell, or explicit (via the \n character). As many cells as necessary are stacked, one below the other. Text can be aligned, centered or justified. The cell block can be framed and the background painted. A cell has an horizontal padding, on the left & right sides, defined by the.c_margin property.

Center overrides values for horizontal padding

Using new_x=XPos.RIGHT, new_y=XPos.TOP, maximum height=pdf.font_size is useful to build tables with multiline text in cells.

Returns: a single value or a tuple, depending on the output parameter value

Create a path for appending lines and curves to.

Check that text input is in the correct format/encoding

All rendering performed in this context is made on a dummy FPDF object. This allows to test the results of some operations on the global layout before performing them "for real".

Output PDF to some destination. The method first calls close if necessary to terminate the document. After calling this method, content cannot be added to the document anymore.

By default the bytearray buffer is returned. If a name is given, the PDF is written to a new file.

Get the current page number

Outputs a polygon defined by three or more points.

Draws lines between two or more points.

Read an image and load it into memory.

Deprecated since version: 2.7.7

Use preload_image() instead.

Outputs a rectangle. It can be drawn (border only), filled (with no border) or both.

TOP_LEFT: a rectangle with round top left corner TOP_RIGHT: a rectangle with round top right corner BOTTOM_LEFT: a rectangle with round bottom left corner BOTTOM_RIGHT: a rectangle with round bottom right corner True: a rectangle with all round corners False: a rectangle with no round corners

Context manager that defines a rectangular crop zone, useful to render only part of an image.

Outputs a regular polygon with n sides It can be rotated Style can also be applied (fill, border‚Ä¶)

Deprecated since version: 2.1.0

Use FPDF.rotation() instead.

Method to perform a rotation around a given center. It must be used as a context-manager using with:

The rotation affects all elements which are printed inside the indented context (with the exception of clickable areas).

Only the rendering is altered. The FPDF.get_x() and FPDF.get_y() methods are not affected, nor the automatic page break mechanism. The rotation also establishes a local graphics state, so that any graphics state settings changed within will not affect the operations invoked after it has finished.

Context manager that defines a circular crop zone, useful to render only part of an image.

Defines the author of the document.

author(str): the name of the author

Set auto page break mode, and optionally the bottom margin that triggers it. By default, the mode is on and the bottom margin is 2 cm.

Detailed documentation on page breaks: https://py-pdf.github.io/fpdf2/PageBreaks.html

Sets horizontal character spacing. A positive value increases the space between characters, a negative value reduces it (which may result in glyph overlap). By default, no spacing is set (which is equivalent to a value of 0).

Activates or deactivates page compression.

When activated, the internal representation of each page is compressed using the zlib/deflate method (FlateDecode), which leads to a compression ratio of about 2 for the resulting document.

Page compression is enabled by default.

Sets Creation of Date time, or current time if None given.

Defines the creator of the document. This is typically the name of the application that generates the PDF.

Set the current dash pattern for lines and curves.

Omitting 'dash' (= 0) resets the pattern to a solid line.

Defines the way the document is to be displayed by the viewer.

It allows to set the zoom level: pages can be displayed entirely on screen, occupy the full width of the window, use the real size, be scaled by a specific zooming factor or use the viewer default (configured in its Preferences menu).

The page layout can also be specified: single page at a time, continuous display, two columns or viewer default.

Defines a document option.

value (str) option value

Deprecated since version: 2.4.0

Simply set the FPDF.core_fonts_encoding property as a replacement.

Defines the color used for all stroking operations (lines, rectangles and cell borders). Accepts either a single greyscale value, 3 values as RGB components, a single #abc or #abcdef hexadecimal color string, or an instance of fpdf.drawing.DeviceCMYK, fpdf.drawing.DeviceRGB or fpdf.drawing.DeviceGray. The method can be called before the first page is created and the value is retained from page to page.

Activate encryption of the document content.

Allows you to specify a list of fonts to be used if any character is not available on the font currently set. Detailed documentation: https://py-pdf.github.io/fpdf2/Unicode.html#fallback-fonts

Defines the color used for all filling operations (filled rectangles and cell backgrounds). Accepts either a single greyscale value, 3 values as RGB components, a single #abc or #abcdef hexadecimal color string, or an instance of fpdf.drawing.DeviceCMYK, fpdf.drawing.DeviceRGB or fpdf.drawing.DeviceGray. The method can be called before the first page is created and the value is retained from page to page.

Sets the font used to print character strings. It is mandatory to call this method at least once before printing text.

Default encoding is not specified, but all text writing methods accept only unicode for external fonts and one byte encoding for standard.

Standard fonts use Latin-1 encoding by default, but Windows encoding cp1252 (Western Europe) can be used with self.core_fonts_encoding = encoding.

The font specified is retained from page to page. The method can be called before the first page is created.

Configure the font size in points

[NEW in 2.8.4] Note that, when using LZWDecode, having NumPy installed will improve performances, reducing execution time.

Associate keywords with the document

A language identifier specifying the natural language for all text in the document except where overridden by language specifications for structure elements or marked content. A language identifier can either be the empty text string, to indicate that the language is unknown, or a Language-Tag as defined in RFC 3066, "Tags for the Identification of Languages".

Sets the document left margin. Also sets the current FPDF.x on the page to this minimum horizontal position.

Defines the line width of all stroking operations (lines, rectangles and cell borders). By default, the value equals 0.2 mm. The method can be called before the first page is created and the value is retained from page to page.

Defines the page and position a link points to.

Sets the document right, left, top & bottom margins to the same value.

Sets the document left, top & optionally right margins to the same value. By default, they equal 1 cm. Also sets the current FPDF.y on the page to this minimum vertical position.

Sets a background color or image to be drawn every time FPDF.add_page() is called, or removes a previously set background. The method can be called before the first page is created and the value is retained from page to page.

Enable PDFPageLabel to be inserted on every page. This will be displayed by some PDF readers to identify pages.

Sets the document right margin.

Defines a style for section titles. After calling this method, calls to FPDF.start_section() will render section names visually.

Sets horizontal font stretching. By default, no stretching is set (which is equivalent to a value of 100).

Defines the subject of the document.

Defines the color used for text. Accepts either a single greyscale value, 3 values as RGB components, a single #abc or #abcdef hexadecimal color string, or an instance of fpdf.drawing.DeviceCMYK, fpdf.drawing.DeviceRGB or fpdf.drawing.DeviceGray. The method can be called before the first page is created and the value is retained from page to page.

Enable or disable text shaping engine when rendering text. If features, direction, script or language are not specified the shaping engine will try to guess the values based on the input text.

Defines the title of the document.

Most PDF readers will display it when viewing the document. There is also a related ViewerPreferences entry:

Sets the document top margin.

Defines the abscissa of the current position. If the value provided is negative, it is relative to the right of the page.

Defines the abscissa and ordinate of the current position. If the values provided are negative, they are relative respectively to the right and bottom of the page.

Moves the current abscissa back to the left margin and sets the ordinate. If the value provided is negative, it is relative to the bottom of the page.

Method to perform a skew transformation originating from a given center. It must be used as a context-manager using with:

The skew transformation affects all elements which are printed inside the indented context (with the exception of clickable areas).

Outputs a solid arc. A solid arc combines an arc and a triangle to form a pie slice It can be drawn (border only), filled (with no border) or both.

Outputs a regular star with n corners. It can be rotated. It can be drawn (border only), filled (with no border) or both.

Start a section in the document outline. If section_title_styles have been configured, render the section name visually as a title.

Inserts a table, that can be built using the Table object yield. Detailed usage documentation: https://py-pdf.github.io/fpdf2/Tables.html

Prints a character string. The origin is on the left of the first character, on the baseline. This method allows placing a string precisely on the page, but it is usually easier to use the FPDF.cell(), FPDF.multi_cell() or FPDF.write()` methods.

text() lacks many of the features available in FPDF.write(), FPDF.cell() and FPDF.multi_cell() like markdown and text shaping.

Puts a text annotation on a rectangular area of the page.

Establish a layout with multiple columns to fill with text.

Ensures that all rendering performed in this context appear on a single page by performing page break beforehand if need be.

Detailed documentation on page breaks: https://py-pdf.github.io/fpdf2/PageBreaks.html

Using this method means to duplicate the FPDF bytearray buffer: when generating large PDFs, doubling memory usage may be troublesome.

Sets the provided FontFace in a local context, then restore font settings back to they were initially. This method must be used as a context manager using with:

Known limitation: in case of a page jump in this local context, the temporary style may "leak" in the header() & footer().

Create a context for using a shading pattern on the current page.

Let you know if adding an element will trigger a page break, based on its height and the current ordinate (y position).

Detailed documentation on page breaks: https://py-pdf.github.io/fpdf2/PageBreaks.html

Returns: a boolean indicating if a page break would occur

Prints text from the current position. When the right margin is reached, a line break occurs at the most recent space or soft-hyphen character, and text continues from the left margin. A manual break happens any time the \n character is met, Upon method exit, the current position is left just at the end of the text.

Parse HTML and convert it to PDF. cf. https://py-pdf.github.io/fpdf2/HTML.html

Information about an image used in the PDF document (base class). We subclass this to distinguish between raster and vector images.

Intrinsic image height

Only available if the image has been placed on the document

Only available if the image has been placed on the document

Intrinsic image width

Make an image fit within a bounding box, maintaining its proportions. In the reduced dimension it will be centered within the available space.

Information about a raster image used in the PDF document

Inherited from: ImageInfo.height

Intrinsic image height

Inherited from: ImageInfo.rendered_height

Only available if the image has been placed on the document

Inherited from: ImageInfo.rendered_width

Only available if the image has been placed on the document

Inherited from: ImageInfo.width

Intrinsic image width

Inherited from: ImageInfo.scale_inside_box

Make an image fit within a bounding box, maintaining its proportions. In the reduced dimension it will be centered within the available space.

Values described in PDF spec section 'Text Rendering Mode'

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

Inherited from: CoerciveIntEnum.coerce

Attempt to coerce value into a member of this enumeration ‚Ä¶

Subclass of FontFace that allows to specify vertical & horizontal spacing

Inherited from: TextStyle.combine

Create a combined FontFace with all the supplied features of the two styles. When both the default and override styles provide a feature, prefer the ‚Ä¶

Inherited from: TextStyle.replace

Create a new TextStyle instance, with new values for some attributes. Same as dataclasses.replace()

Information about a vector image used in the PDF document

Inherited from: ImageInfo.height

Intrinsic image height

Inherited from: ImageInfo.rendered_height

Only available if the image has been placed on the document

Inherited from: ImageInfo.rendered_width

Only available if the image has been placed on the document

Inherited from: ImageInfo.width

Intrinsic image width

Inherited from: ImageInfo.scale_inside_box

Make an image fit within a bounding box, maintaining its proportions. In the reduced dimension it will be centered within the available space.

Positional values in horizontal direction for use after printing text.

center of actual text

right end of actual text

left page margin (start of printable area)

right end of the cell (default)

right page margin (end of printable area)

left start of actual text

for write() to continue next (slightly left of END)

Inherited from: CoerciveEnum.coerce

Attempt to coerce value into a member of this enumeration ‚Ä¶

Positional values in vertical direction for use after printing text

bottom page margin (end of printable area)

top of the last line (same as TOP for single-line text)

top of next line (bottom of current text)

top page margin (start of printable area)

top of the first line (default)

Inherited from: CoerciveEnum.coerce

Attempt to coerce value into a member of this enumeration ‚Ä¶

**Examples:**

Example 1 (python):
```python
def get_page_format(
    format: str | tuple[float, float], k: Optional[float] = None
) -> tuple[float, float]:
    """Return page width and height size in points.

    Throws FPDFPageFormatException

    `format` can be either a 2-tuple or one of 'a3', 'a4', 'a5', 'letter', or
    'legal'.

    If format is a tuple, then the return value is the tuple's values
    given in the units specified on this document in the constructor,
    multiplied by the corresponding scale factor `k`, taken from instance
    variable `self.k`.

    If format is a string, the (width, height) tuple returned is in points.
    For a width and height of 8.5 * 11, 72 dpi is assumed, so the value
    returned is (8.5 * 72, 11 * 72), or (612, 792). Additional formats can be
    added by adding fields to the `PAGE_FORMATS` dictionary with a
    case insensitive key (the name of the new format) and 2-tuple value of
    (width, height) in dots per inch with a 72 dpi resolution.
    """
    if isinstance(format, str):
        format = format.lower()
        if format in PAGE_FORMATS:
            if format == "a5":
                warnings.warn(
                    # This warning should be removed in the next release:
                    "Dimensions for page format A5 were fixed in release 2.8.5"
                )
            return PAGE_FORMATS[format]
        raise FPDFPageFormatException(format, unknown=True)

    if k is None:
        raise FPDFPageFormatException(str(format), one=True)

    try:
        return format[0] * k, format[1] * k
    except Exception as e:
        args = f"{format}, {k}"
        raise FPDFPageFormatException(f"Arguments must be numbers: {args}") from e
```

Example 2 (python):
```python
class FPDF(GraphicsStateMixin, TextRegionMixin):
    "PDF Generation class"

    MARKDOWN_BOLD_MARKER = "**"
    MARKDOWN_ITALICS_MARKER = "__"
    MARKDOWN_STRIKETHROUGH_MARKER = "~~"
    MARKDOWN_UNDERLINE_MARKER = "--"
    MARKDOWN_ESCAPE_CHARACTER = "\\"
    MARKDOWN_LINK_REGEX = re.compile(r"^\[([^][]+)\]\(([^()]+)\)(.*)$", re.DOTALL)
    MARKDOWN_LINK_COLOR = None
    MARKDOWN_LINK_UNDERLINE = True

    HTML2FPDF_CLASS = HTML2FPDF

    def __init__(
        self,
        orientation: Union[str, PageOrientation] = PageOrientation.PORTRAIT,
        unit: Union[str, float] = "mm",
        format: Union[str, tuple[float, float]] = "A4",
        font_cache_dir: Literal["DEPRECATED"] = "DEPRECATED",
        *,
        enforce_compliance: Optional[Union[str, DocumentCompliance]] = None,
    ) -> None:
        """
        Args:
            orientation (str): possible values are "portrait" (can be abbreviated "P")
                or "landscape" (can be abbreviated "L"). Default to "portrait".
            unit (str, int, float): possible values are "pt", "mm", "cm", "in", or a number.
                A point equals 1/72 of an inch, that is to say about 0.35 mm (an inch being 2.54 cm).
                This is a very common unit in typography; font sizes are expressed in this unit.
                If given a number, then it will be treated as the number of points per unit.  (eg. 72 = 1 in)
                Default to "mm".
            format (str): possible values are "a3", "a4", "a5", "letter", "legal" or a tuple
                (width, height) expressed in the given unit. Default to "a4".
            font_cache_dir (Path or str): [**DEPRECATED since v2.5.1**] unused
        """
        if font_cache_dir != "DEPRECATED":
            warnings.warn(
                (
                    '"font_cache_dir" parameter is deprecated since v2.5.1, '
                    "unused and will soon be removed"
                ),
                DeprecationWarning,
                stacklevel=get_stack_level(),
            )
        super().__init__()
        self.single_resources_object = False
        """
        Setting this to True restore the old behaviour before 2.7.9.
        Using a single /Resources object makes the resulting PDF document smaller,
        but is less compatible with the PDF spec.
        """
        self.page = 0  # current page number
        """
        Note: Setting the page manually may result in unexpected behavior.
        `pdf.add_page()` takes special care to ensure the page's content stream
        matches FPDF's instance attributes. Manually setting the page does not.
        """
        # array of PDFPage objects starting at index 1:
        self.pages: dict[int, PDFPage] = {}
        # map page numbers to a set of font indices:
        self.links: dict[int, DestinationXYZ] = (
            {}
        )  # Destination objects starting at index 1
        self.named_destinations: dict[str, DestinationXYZ] = (
            {}
        )  # map names to Destination objects
        self.embedded_files: list[PDFEmbeddedFile] = []  # array of PDFEmbeddedFile
        self.image_cache = ImageCache()
        self.in_footer = False  # flag set while rendering footer
        # indicates that we are inside an .unbreakable() code block:
        self._in_unbreakable = False
        self._lasth: float = 0  # height of last cell printed
        self.alias_nb_pages()  # enable alias by default

        self._angle: float = 0  # used by deprecated method: rotate()
        self.xmp_metadata = None
        # Define the compression algorithm used when embedding images:
        self.page_duration = 0  # optional pages display duration, cf. add_page()
        self.page_transition = None  # optional pages transition, cf. add_page()
        self.allow_images_transparency = True
        # Do nothing by default. Allowed values: 'WARN', 'DOWNSCALE':
        self.oversized_images: Optional[Literal["WARN", "DOWNSCALE"]] = None
        self.oversized_images_ratio = 2  # number of pixels per UserSpace point
        self.struct_builder = StructureTreeBuilder()

        self.toc_placeholder: Optional[ToCPlaceholder] = None
        self._outline: list[OutlineSection] = []
        # flag set true while rendering the table of contents
        self.in_toc_rendering = False
        # allow page insertion when writing the table of contents
        self._toc_allow_page_insertion = False
        self._toc_inserted_pages = 0  # number of pages inserted
        # dict of Output Intents, with keys beings their subtypes:
        self._output_intents: dict[Name, OutputIntentDictionary] = {}

        self._sign_key = None
        self.title = None
        self.section_title_styles: dict[int, TextStyle] = {}  # level -> TextStyle

        self.core_fonts_encoding = "latin-1"
        "Font encoding, Latin-1 by default"
        # Replace these fonts with these core fonts
        self.font_aliases = {
            "arial": "helvetica",
            "couriernew": "courier",
            "timesnewroman": "times",
        }
        # Scale factor
        self.k = get_scale_factor(unit)

        # Graphics state variables defined as properties by GraphicsStateMixin.
        # We set their default values here.
        self.font_family = ""  # current font family
        # current font style (BOLD/ITALICS - does not handle UNDERLINE nor STRIKETHROUGH):
        self.font_style = ""
        self.underline = False
        self.strikethrough = False
        self.font_size_pt: float = 12  # current font size in points
        self.font_stretching = 100  # current font stretching
        self.char_spacing = 0  # current character spacing
        self.current_font: Optional[CoreFont | TTFFont] = (
            None  # None or an instance of CoreFont or TTFFont
        )
        self.current_font_is_set_on_page = False  # current font and size are already added to current page contents with _out
        self.draw_color = self.DEFAULT_DRAW_COLOR
        self.fill_color = self.DEFAULT_FILL_COLOR
        self.text_color = self.DEFAULT_TEXT_COLOR
        self.page_background = None
        self.dash_pattern = dict(dash=0, gap=0, phase=0)
        self.line_width = 0.567 / self.k  # line width (0.2 mm)
        self.text_mode = TextMode.FILL
        # end of graphics state variables

        self.dw_pt, self.dh_pt = get_page_format(format, self.k)
        self._set_orientation(orientation, self.dw_pt, self.dh_pt)
        self.def_orientation = self.cur_orientation
        # Page spacing
        # Page margins (1 cm)
        margin: float = (7200 / 254) / self.k
        self.x: float = 0
        self.y: float = 0
        self.l_margin: float = 0
        self.t_margin: float = 0
        self.set_margins(margin, margin)
        self.x, self.y = self.l_margin, self.t_margin
        self.c_margin: float = margin / 10.0  # Interior cell margin (1 mm)
        # sets self.auto_page_break, self.b_margin & self.page_break_trigger:
        self.set_auto_page_break(True, 2 * margin)
        self.set_display_mode("fullwidth")  # Full width display mode
        self._page_mode: Optional[PageMode] = None
        self.viewer_preferences: Optional["ViewerPreferences"] = (
            None  # optional instance of ViewerPreferences
        )
        self.compress: bool = True  # switch enabling pages content compression
        self.pdf_version: str = "1.3"  # Set default PDF version No.
        self.creation_date: datetime = datetime.now(timezone.utc)
        self._security_handler: Optional[StandardSecurityHandler] = None
        self._fallback_font_ids: list[str] = []
        self._fallback_font_exact_match = False
        self.render_color_fonts: bool = True
        self._compliance: Optional[DocumentCompliance] = (
            DocumentCompliance.coerce(enforce_compliance)
            if enforce_compliance
            else None
        )
        if self._compliance:
            if self._compliance.profile == "PDFA" and self._compliance.part == 1:
                self._set_min_pdf_version("1.4")
                self.allow_images_transparency = False
            if self._compliance.profile == "PDFA" and self._compliance.part in (2, 3):
                self._set_min_pdf_version("1.7")
            if self._compliance.profile == "PDFA" and self._compliance.part == 4:
                self._set_min_pdf_version("2.0")

        self._current_draw_context: Optional[DrawingContext] = None
        # map page numbers to a set of GraphicsState names:
        self._record_text_quad_points = False
        self._resource_catalog: ResourceCatalog = ResourceCatalog()

        # page number -> array of 8 √ó n numbers:
        self._text_quad_points: dict[int, list[float]] = defaultdict(list)

        # final buffer holding the PDF document in-memory - defined only after calling output():
        self.buffer: Optional[bytearray] = None

    @property
    def fonts(self) -> dict[str, CoreFont | TTFFont]:
        return self._resource_catalog.font_registry

    def set_encryption(
        self,
        owner_password: str,
        user_password: Optional[str] = None,
        encryption_method: EncryptionMethod = EncryptionMethod.RC4,
        permissions: int = AccessPermission.all(),
        encrypt_metadata: bool = False,
    ) -> None:
        """
        Activate encryption of the document content.

        Args:
            owner_password (str): mandatory. The owner password allows to perform any change on the document,
                including removing all encryption and access permissions.
            user_password (str): optional. If a user password is set, the content of the document will be encrypted
                and a password prompt displayed when a user opens the document.
                The document will only be displayed after either the user or owner password is entered.
            encryption_method (fpdf.enums.EncryptionMethod, str): algorithm to be used to encrypt the document.
                Defaults to RC4.
            permissions (fpdf.enums.AccessPermission): specify access permissions granted
                when the document is opened with user access. Defaults to ALL.
            encrypt_metadata (bool): whether to also encrypt document metadata (author, creation date, etc.).
                Defaults to False.
        """
        if self._compliance and self._compliance.profile == "PDFA":
            raise PDFAComplianceError(
                f"Encryption is now allowed for documents compliant with {self._compliance.label}"
            )

        self._security_handler = StandardSecurityHandler(
            self,
            owner_password=owner_password,
            user_password=user_password,
            permission=permissions,
            encryption_method=encryption_method,
            encrypt_metadata=encrypt_metadata,
        )

    def write_html(self, text: str, *args: Any, **kwargs: Any) -> None:
        """
        Parse HTML and convert it to PDF.
        cf. https://py-pdf.github.io/fpdf2/HTML.html

        Args:
            text (str): HTML content to render
            image_map (function): an optional one-argument function that map `<img>` "src" to new image URLs
            li_tag_indent (int): [**DEPRECATED since v2.7.9**]
                numeric indentation of `<li>` elements - Set `tag_styles` instead
            dd_tag_indent (int): [**DEPRECATED since v2.7.9**]
                numeric indentation of `<dd>` elements - Set `tag_styles` instead
            table_line_separators (bool): enable horizontal line separators in `<table>`. Defaults to `False`.
            ul_bullet_char (str): bullet character preceding `<li>` items in `<ul>` lists.
                Can also be configured using the HTML `type` attribute of `<ul>` tags.
            li_prefix_color (tuple, str, fpdf.drawing.DeviceCMYK, fpdf.drawing.DeviceGray, fpdf.drawing.DeviceRGB): color for bullets
                or numbers preceding `<li>` tags. This applies to both `<ul>` & `<ol>` lists.
            heading_sizes (dict): [**DEPRECATED since v2.7.9**]
                font size per heading level names ("h1", "h2"...) - Set `tag_styles` instead
            pre_code_font (str): [**DEPRECATED since v2.7.9**]
                font to use for `<pre>` & `<code>` blocks - Set `tag_styles` instead
            warn_on_tags_not_matching (bool): control warnings production for unmatched HTML tags. Defaults to `True`.
            tag_indents (dict): [**DEPRECATED since v2.8.0**]
                mapping of HTML tag names to numeric values representing their horizontal left indentation. - Set `tag_styles` instead
            tag_styles (dict[str, fpdf.fonts.TextStyle]): mapping of HTML tag names to `fpdf.fonts.TextStyle` or `fpdf.fonts.FontFace` instances
        """
        html2pdf = self.HTML2FPDF_CLASS(self, *args, **kwargs)
        with self.local_context():
            html2pdf.feed(text)

    def _set_min_pdf_version(self, version: str) -> None:
        self.pdf_version = max(self.pdf_version, version)

    @property
    def emphasis(self) -> TextEmphasis:
        "The current text emphasis: bold, italics, underline and/or strikethrough."
        font_style = self.font_style
        if self.strikethrough:
            font_style += "S"
        if self.underline:
            font_style += "U"
        return TextEmphasis.coerce(font_style)

    @property
    def is_ttf_font(self) -> bool:
        return self.current_font is not None and self.current_font.type == "TTF"

    @property
    def page_mode(self) -> Optional[PageMode]:
        return self._page_mode

    @page_mode.setter
    def page_mode(self, page_mode: PageMode | str) -> None:
        self._page_mode = PageMode.coerce(page_mode)
        if self._page_mode == PageMode.USE_ATTACHMENTS:
            self._set_min_pdf_version("1.6")
        elif self._page_mode == PageMode.USE_OC:
            self._set_min_pdf_version("1.5")

    @property
    def output_intents(self) -> ValuesView[OutputIntentDictionary]:
        return self._output_intents.values()

    def add_output_intent(
        self,
        subtype: OutputIntentSubType,
        output_condition_identifier: Optional[str] = None,
        output_condition: Optional[str] = None,
        registry_name: Optional[str] = None,
        dest_output_profile: Optional[PDFICCProfile] = None,
        info: Optional[str] = None,
    ) -> None:
        """
        Adds desired Output Intent to the Output Intents array:

        Args:
            subtype (OutputIntentSubType, required): PDFA, PDFX or ISOPDF
            output_condition_identifier (str, required): see the Name in
                https://www.color.org/registry.xalter
            output_condition (str, optional): see the Definition in
                https://www.color.org/registry.xalter
            registry_name (str, optional): "https://www.color.org"
            dest_output_profile (PDFICCProfile, required/optional):
                PDFICCProfile | None # (required  if
                output_condition_identifier does not specify a standard
                production condition; optional otherwise)
            info (str, required/optional see dest_output_profile): human
                readable description of profile
        """
        if subtype.value in self._output_intents:
            raise ValueError(
                "add_output_intent: subtype '" + subtype.value + "' already exists."
            )
        self._output_intents[subtype.value] = OutputIntentDictionary(
            subtype,
            output_condition_identifier,
            output_condition,
            registry_name,
            dest_output_profile,
            info,
        )
        self._set_min_pdf_version("1.4")

    @property
    def epw(self) -> float:
        """
        Effective page width: the page width minus its horizontal margins.
        """
        return self.w - self.l_margin - self.r_margin

    @property
    def eph(self) -> float:
        """
        Effective page height: the page height minus its vertical margins.
        """
        return self.h - self.t_margin - self.b_margin

    @property
    def pages_count(self) -> int:
        """
        Returns the total pages of the document, at the time it is called.

        Do not use this in `fpdf.fpdf.FPDF.header()` or `fpdf.fpdf.FPDF.footer()`,
        as its value will not be the total page count.
        Uses `{nb}` instead, _cf._ `fpdf.fpdf.FPDF.alias_nb_pages()`.
        """
        return len(self.pages)

    def set_margin(self, margin: float) -> None:
        """
        Sets the document right, left, top & bottom margins to the same value.

        Args:
            margin (float): margin in the unit specified to FPDF constructor
        """
        self.set_margins(margin, margin)
        self.set_auto_page_break(self.auto_page_break, margin)

    def set_margins(self, left: float, top: float, right: float = -1) -> None:
        """
        Sets the document left, top & optionally right margins to the same value.
        By default, they equal 1 cm.
        Also sets the current FPDF.y on the page to this minimum vertical position.

        Args:
            left (float): left margin in the unit specified to FPDF constructor
            top (float): top margin in the unit specified to FPDF constructor
            right (float): optional right margin in the unit specified to FPDF constructor
        """
        self.set_left_margin(left)
        if self.y < top or self.y == self.t_margin:
            self.y = top
        self.t_margin = top
        if right == -1:
            right = left
        self.r_margin = right

    def set_left_margin(self, margin: float) -> None:
        """
        Sets the document left margin.
        Also sets the current FPDF.x on the page to this minimum horizontal position.

        Args:
            margin (float): margin in the unit specified to FPDF constructor
        """
        if self.x < margin or self.x == self.l_margin:
            self.x = margin
        self.l_margin = margin

    def set_top_margin(self, margin: float) -> None:
        """
        Sets the document top margin.

        Args:
            margin (float): margin in the unit specified to FPDF constructor
        """
        self.t_margin = margin

    def set_right_margin(self, margin: float) -> None:
        """
        Sets the document right margin.

        Args:
            margin (float): margin in the unit specified to FPDF constructor
        """
        self.r_margin = margin

    def set_auto_page_break(self, auto: bool, margin: float = 0) -> None:
        """
        Set auto page break mode, and optionally the bottom margin that triggers it.
        By default, the mode is on and the bottom margin is 2 cm.

        Detailed documentation on page breaks: https://py-pdf.github.io/fpdf2/PageBreaks.html

        Args:
            auto (bool): enable or disable this mode
            margin (float): optional bottom margin (distance from the bottom of the page)
                in the unit specified to FPDF constructor
        """
        self.auto_page_break: bool = auto
        self.b_margin: float = margin
        self.page_break_trigger: float = self.h - self.b_margin

    @property
    def default_page_dimensions(self) -> tuple[float, float]:
        "Return a pair (width, height) in points units (1/72 of inch)"
        return (
            (self.dw_pt, self.dh_pt)
            if self.def_orientation == PageOrientation.PORTRAIT
            else (self.dh_pt, self.dw_pt)
        )

    def _set_orientation(
        self,
        orientation: str | PageOrientation,
        page_width_pt: float,
        page_height_pt: float,
    ) -> None:
        self.cur_orientation = PageOrientation.coerce(orientation)
        if self.cur_orientation is PageOrientation.PORTRAIT:
            self.w_pt = page_width_pt
            self.h_pt = page_height_pt
        else:
            self.w_pt = page_height_pt
            self.h_pt = page_width_pt
        self.w = self.w_pt / self.k
        self.h = self.h_pt / self.k
        if hasattr(self, "auto_page_break"):  # not set when called from constructor
            # When self.h is modified, the .page_break_trigger must be re-computed:
            self.set_auto_page_break(self.auto_page_break, self.b_margin)

    def set_display_mode(
        self,
        zoom: str | float,
        layout: str = "continuous",
    ) -> None:
        """
        Defines the way the document is to be displayed by the viewer.

        It allows to set the zoom level: pages can be displayed entirely on screen,
        occupy the full width of the window, use the real size,
        be scaled by a specific zooming factor or use the viewer default (configured in its Preferences menu).

        The page layout can also be specified: single page at a time, continuous display, two columns or viewer default.

        Args:
            zoom: either "fullpage", "fullwidth", "real", "default",
                or a number indicating the zooming factor to use, interpreted as a percentage.
                The zoom level set by default is "default".
            layout (fpdf.enums.PageLayout, str): allowed layout aliases are "single", "continuous", "two" or "default",
                meaning to use the viewer default mode.
                The layout set by default is "continuous".
        """
        if zoom in ZOOM_CONFIGS or not isinstance(zoom, str):
            self.zoom_mode = zoom
        elif zoom != "default":
            raise FPDFException(f"Incorrect zoom display mode: {zoom}")
        if isinstance(layout, PageLayout):
            self.page_layout = layout
        else:
            # First support legacy aliases like "continuous"/"single"/"default"
            alias_layout = LAYOUT_ALIASES.get(str(layout))
            if alias_layout is not None or str(layout) in LAYOUT_ALIASES:
                self.page_layout = alias_layout
            else:
                try:
                    self.page_layout = PageLayout.coerce(str(layout))
                except (ValueError, TypeError) as exc:
                    raise FPDFException(
                        f"Incorrect layout display mode: {layout}"
                    ) from exc

    def set_text_shaping(
        self,
        use_shaping_engine: bool = True,
        features: Optional[dict[str, Any]] = None,
        direction: Optional[str | TextDirection] = None,
        script: Optional[str] = None,
        language: Optional[str] = None,
    ) -> None:
        """
        Enable or disable text shaping engine when rendering text.
        If features, direction, script or language are not specified the shaping engine will try
        to guess the values based on the input text.

        Args:
            use_shaping_engine: enable or disable the use of the shaping engine to process the text
            features: a dictionary containing 4 digit OpenType features and whether each feature
                should be enabled or disabled
                example: features={"kern": False, "liga": False}
            direction: the direction the text should be rendered, either "ltr" (left to right)
                or "rtl" (right to left).
            script: a valid OpenType script tag like "arab" or "latn"
            language: a valid OpenType language tag like "eng" or "fra"
        """
        if not use_shaping_engine:
            self.text_shaping = None
            return

        try:
            # pylint: disable=import-outside-toplevel, unused-import
            import uharfbuzz  # pyright: ignore[reportUnusedImport]
        except ImportError as exc:
            raise FPDFException(
                "The uharfbuzz package could not be imported, but is required for text shaping. Try: pip install uharfbuzz"
            ) from exc

        #
        # Features must be a dictionary containing opentype features and a boolean flag
        # stating whether the feature should be enabled or disabled.
        #
        # e.g. features={"liga": True, "kern": False}
        #
        # https://harfbuzz.github.io/shaping-opentype-features.html
        #

        if features and not isinstance(features, dict):
            raise FPDFException(
                "Features must be a dictionary. See text shaping documentation"
            )
        if not features:
            features = {}

        # Buffer properties (direction, script and language)
        # if the properties are not provided, Harfbuzz "guessing" logic is used.
        # https://harfbuzz.github.io/setting-buffer-properties.html
        # Valid harfbuzz directions are ltr (left to right), rtl (right to left),
        # ttb (top to bottom) or btt (bottom to top)

        text_direction = None
        if direction:
            text_direction = (
                direction
                if isinstance(direction, TextDirection)
                else TextDirection.coerce(direction)
            )
            if text_direction not in [TextDirection.LTR, TextDirection.RTL]:
                raise FPDFException(
                    "FPDF2 only accept ltr (left to right) or rtl (right to left) directions for now."
                )

        self.text_shaping = {
            "use_shaping_engine": True,
            "features": features,
            "direction": text_direction,
            "script": script,
            "language": language,
            "fragment_direction": None,
            "paragraph_direction": None,
        }

    @property
    def page_layout(self) -> Optional[PageLayout]:
        return self._page_layout

    @page_layout.setter
    def page_layout(self, page_layout: Optional[str | PageLayout]) -> None:
        self._page_layout = PageLayout.coerce(page_layout) if page_layout else None
        if self._page_layout in (PageLayout.TWO_PAGE_LEFT, PageLayout.TWO_PAGE_RIGHT):
            self._set_min_pdf_version("1.5")

    def set_compression(self, compress: bool) -> None:
        """
        Activates or deactivates page compression.

        When activated, the internal representation of each page is compressed
        using the zlib/deflate method (FlateDecode), which leads to a compression ratio
        of about 2 for the resulting document.

        Page compression is enabled by default.

        Args:
            compress (bool): indicates if compression should be enabled
        """
        self.compress = compress

    def set_title(self, title: str) -> None:
        """
        Defines the title of the document.

        Most PDF readers will display it when viewing the document.
        There is also a related `fpdf.prefs.ViewerPreferences` entry:

            pdf.viewer_preferences = ViewerPreferences(display_doc_title=True)

        Args:
            title (str): the title
        """
        self.title = title

    def set_lang(self, lang: str) -> None:
        """
        A language identifier specifying the natural language for all text in the document
        except where overridden by language specifications for structure elements or marked content.
        A language identifier can either be the empty text string, to indicate that the language is unknown,
        or a Language-Tag as defined in RFC 3066, "Tags for the Identification of Languages".

        Args:
            lang (str): the document main language
        """
        self.lang = lang
        if lang:
            self._set_min_pdf_version("1.4")

    def set_subject(self, subject: str) -> None:
        """
        Defines the subject of the document.

        Args:
            subject (str): the document main subject
        """
        self.subject = subject

    def set_author(self, author: str | Sequence[str]) -> None:
        """
        Defines the author of the document.

        Args:
            author(str): the name of the author
        """
        self.author = author

    def set_keywords(self, keywords: str | Sequence[str]) -> None:
        """
        Associate keywords with the document

        Args:
            keywords (str): a space-separated list of words
        """
        self.keywords = keywords

    def set_creator(self, creator: str) -> None:
        """
        Defines the creator of the document.
        This is typically the name of the application that generates the PDF.

        Args:
            creator (str): name of the PDF creator
        """
        self.creator = creator

    def set_producer(self, producer: str) -> None:
        """Producer of document"""
        self.producer = producer

    def set_creation_date(self, date: Optional[datetime] = None) -> None:
        """Sets Creation of Date time, or current time if None given."""
        if self._sign_key:
            raise FPDFException(
                ".set_creation_date() must always be called before .sign*() methods"
            )
        if not isinstance(date, datetime):
            raise TypeError(f"date should be a datetime but is a {type(date)}")
        if not date.tzinfo:
            date = date.astimezone()
        self.creation_date = date

    def set_xmp_metadata(self, xmp_metadata: str) -> None:
        if "<?xpacket" in xmp_metadata[:50]:
            raise ValueError(
                "fpdf2 already performs XMP metadata wrapping in a <?xpacket> tag"
            )
        self.xmp_metadata = xmp_metadata
        if xmp_metadata:
            self._set_min_pdf_version("1.4")

    def set_doc_option(self, opt: Literal["core_fonts_encoding"], value: str) -> None:
        """
        Defines a document option.

        Args:
            opt (str): name of the option to set
            value (str) option value

        .. deprecated:: 2.4.0
            Simply set the `FPDF.core_fonts_encoding` property as a replacement.
        """
        warnings.warn(
            (
                "set_doc_option() is deprecated since v2.4.0 "
                "and will be removed in a future release. "
                "Simply set the `.core_fonts_encoding` property as a replacement."
            ),
            DeprecationWarning,
            stacklevel=get_stack_level(),
        )
        if opt != "core_fonts_encoding":
            raise FPDFException(f'Unknown document option "{opt}"')
        self.core_fonts_encoding = value

    def set_image_filter(self, image_filter: str) -> None:
        """
        Args:
            image_filter (str): name of a the image filter to use
                when embedding images in the document, or "AUTO",
                meaning to use the best image filter given the images provided.
                Allowed values: `FlateDecode` (lossless zlib/deflate compression),
                `DCTDecode` (lossy compression with JPEG)
                `LZWDecode` (Lempel-Ziv-Welch aka LZW compression)
                and `JPXDecode` (lossy compression with JPEG2000).

        [**NEW in 2.8.4**] Note that, when using `LZWDecode`, having NumPy installed
        will improve performances, reducing execution time.
        """
        if image_filter not in SUPPORTED_IMAGE_FILTERS:
            raise ValueError(
                f"'{image_filter}' is not a supported image filter"
                f" - Allowed values: {''.join(SUPPORTED_IMAGE_FILTERS)}"
            )
        self.image_cache.image_filter = cast(ImageFilter, image_filter)
        if image_filter == "JPXDecode":
            self._set_min_pdf_version("1.5")

    def alias_nb_pages(self, alias: str = "{nb}") -> None:
        """
        Defines an alias for the total number of pages.
        It will be substituted as the document is closed.

        This is useful to insert the number of pages of the document
        at a time when this number is not known by the program.

        This substitution can be disabled for performances reasons, by calling `alias_nb_pages(None)`.

        Args:
            alias (str): the alias. Defaults to `"{nb}"`.

        Notes
        -----

        When using this feature with the `FPDF.cell` / `FPDF.multi_cell` methods,
        or the `.underline` / `.strikethrough` attributes of `FPDF` class,
        the width of the text rendered will take into account the alias length,
        not the length of the "actual number of pages" string,
        which can causes slight positioning differences.
        """
        self.str_alias_nb_pages = alias

    @check_page
    def set_page_label(
        self,
        label_style: Optional[str | PageLabelStyle] = None,
        label_prefix: Optional[str] = None,
        label_start: Optional[int] = None,
    ) -> None:
        """
        Enable `fpdf.output.PDFPageLabel` to be inserted on every page.
        This will be displayed by some PDF readers to identify pages.
        """
        current_page_label = None
        if self.page in self.pages:
            current_page_label = self.pages[self.page].get_page_label()
        elif self.page > 1:
            current_page_label = self.pages[self.page - 1].get_page_label()
        new_page_label = None
        if label_style or label_prefix or label_start:
            if current_page_label:
                if label_style is None:
                    label_style = current_page_label.get_style()
                if label_prefix is None:
                    label_prefix = current_page_label.get_prefix()
                if label_start is None and not (
                    self.toc_placeholder and self.toc_placeholder.reset_page_indices
                ):
                    label_start = current_page_label.get_start()
            label_style = (
                PageLabelStyle.coerce(label_style, case_sensitive=True)
                if label_style
                else None
            )
            new_page_label = PDFPageLabel(label_style, label_prefix, label_start)
        self.pages[self.page].set_page_label(current_page_label, new_page_label)

    def add_page(
        self,
        orientation: str = "",
        format: str = "",
        same: bool = False,
        duration: float = 0,
        transition: Optional[Transition] = None,
        label_style: Optional[str | PageLabelStyle] = None,
        label_prefix: Optional[str] = None,
        label_start: Optional[int] = None,
    ) -> None:
        """
        Adds a new page to the document.
        If a page is already present, the `FPDF.footer()` method is called first.
        Then the page  is added, the current position is set to the top-left corner,
        with respect to the left and top margins, and the `FPDF.header()` method is called.

        Args:
            orientation (str): "portrait" (can be abbreviated "P")
                or "landscape" (can be abbreviated "L"). Default to "portrait".
            format (str): "a3", "a4", "a5", "letter", "legal" or a tuple
                (width, height). Default to "a4".
            same (bool): indicates to use the same page format as the previous page.
                Default to False.
            duration (float): optional page‚Äôs display duration, i.e. the maximum length of time,
                in seconds, that the page is displayed in presentation mode,
                before the viewer application automatically advances to the next page.
                Can be configured globally through the `.page_duration` FPDF property.
                As of june 2021, onored by Adobe Acrobat reader, but ignored by Sumatra PDF reader.
            transition (Transition child class): optional visual transition to use when moving
                from another page to the given page during a presentation.
                Can be configured globally through the `.page_transition` FPDF property.
                As of june 2021, onored by Adobe Acrobat reader, but ignored by Sumatra PDF reader.
            label_style (str or PageLabelStyle): Defines the numbering style for the numeric portion of each
                page label. Possible values are:
                - "D": Decimal Arabic numerals.
                - "R": Uppercase Roman numerals.
                - "r": Lowercase Roman numerals.
                - "A": Uppercase letters (A to Z for the first 26 pages, followed by AA to ZZ, etc.).
                - "a": Lowercase letters (a to z for the first 26 pages, followed by aa to zz, etc.).
            label_prefix (str): Prefix string applied to the page label, preceding the numeric portion.
            label_start (int): Starting number for the first page of a page label range.
        """
        if self.buffer:
            raise FPDFException(
                "A page cannot be added on a closed document, after calling output()"
            )

        self.current_font_is_set_on_page = False

        family = self.font_family
        emphasis = self.emphasis
        size = self.font_size_pt
        lw = self.line_width
        dc = self.draw_color
        fc = self.fill_color
        tc = self.text_color
        stretching = self.font_stretching
        char_spacing = self.char_spacing
        dash_pattern = self.dash_pattern

        in_toc_extra_page = (
            self.in_toc_rendering
            and self._toc_allow_page_insertion
            and self.page > self.toc_placeholder.start_page  # type: ignore[union-attr]
        )
        if self.page > 0 and (not self.in_toc_rendering or in_toc_extra_page):
            # Page footer
            self._render_footer()

        current_page_label = (
            None if self.page == 0 else self.pages[self.page].get_page_label()
        )
        new_page_label = None
        if label_style or label_prefix or label_start:
            label_style = (
                PageLabelStyle.coerce(label_style, case_sensitive=True)
                if label_style
                else None
            )
            new_page_label = PDFPageLabel(label_style, label_prefix, label_start)

        # Start new page
        self._beginpage(
            orientation,
            format,
            same,
            duration or self.page_duration,
            transition or self.page_transition,
            new_page=not self._has_next_page(),
        )

        self.pages[self.page].set_page_label(current_page_label, new_page_label)

        if self.page_background:
            if isinstance(self.page_background, tuple):
                self.set_fill_color(*self.page_background)
                self.rect(0, 0, self.w, self.h, style="F")
                assert isinstance(fc, (DeviceRGB, DeviceGray))
                self.set_fill_color(*fc.colors255)
            else:
                self.image(
                    self.page_background,  # pyright: ignore[reportArgumentType]
                    0,
                    0,
                    self.w,
                    self.h,
                )

        self._out("2 J")  # Set line cap style to square
        self.line_width = lw  # Set line width
        self._out(f"{lw * self.k:.2f} w")

        # Set font
        if family:
            self.set_font(family, emphasis, size)

        # Set colors
        self.draw_color = dc
        if dc != self.DEFAULT_DRAW_COLOR and dc is not None:
            self._out(dc.serialize().upper())
        self.fill_color = fc
        if fc != self.DEFAULT_FILL_COLOR and fc is not None:
            self._out(fc.serialize().lower())
        self.text_color = tc

        # BEGIN Page header
        if (not self.in_toc_rendering) or self._toc_allow_page_insertion:
            self.header()

        if self.line_width != lw:  # Restore line width
            self.line_width = lw
            self._out(f"{lw * self.k:.2f} w")

        if family:
            self.set_font(family, emphasis, size)  # Restore font

        if self.draw_color != dc and dc is not None:  # Restore colors
            self.draw_color = dc
            self._out(dc.serialize().upper())
        if self.fill_color != fc and fc is not None:
            self.fill_color = fc
            self._out(fc.serialize().lower())
        self.text_color = tc

        if stretching != 100:  # Restore stretching
            self.set_stretching(stretching)
        if char_spacing != 0:
            self.set_char_spacing(char_spacing)
        if dash_pattern != dict(dash=0, gap=0, phase=0):
            self._write_dash_pattern(
                dash_pattern["dash"], dash_pattern["gap"], dash_pattern["phase"]
            )
        # END Page header

    def _render_footer(self) -> None:
        self.in_footer = True
        if self.toc_placeholder:
            # The ToC is rendered AFTER the footer,
            # so we must ensure there is no "style leak":
            self._push_local_stack()
            self._start_local_context()
        self.footer()
        if self.toc_placeholder:
            self._end_local_context()
            self._pop_local_stack()
        self.in_footer = False

    def _beginpage(
        self,
        orientation: str | PageOrientation,
        format: str | tuple[float, float],
        same: bool,
        duration: Optional[float],
        transition: Optional[Transition],
        new_page: bool = True,
    ) -> None:
        self.page += 1
        if self.in_toc_rendering and self._toc_allow_page_insertion:
            self._toc_inserted_pages += 1
            self.page = len(self.pages) + 1
            new_page = True
        if new_page:
            page = PDFPage(
                contents=bytearray(),
                duration=duration,
                transition=transition,
                index=self.page,
            )
            self.pages[self.page] = page
            if transition:
                self._set_min_pdf_version("1.5")
        else:
            page = self.pages[self.page]
        self.x = self.l_margin
        self.y = self.t_margin
        self.font_family = ""
        self.font_stretching = 100
        self.char_spacing = 0
        if same:
            if orientation or format:
                raise ValueError(
                    f"Inconsistent parameters: same={same} but orientation={orientation} format={format}"
                )
        else:
            # Set page format if provided, else use default value:
            page_width_pt, page_height_pt = (
                get_page_format(format, self.k) if format else (self.dw_pt, self.dh_pt)
            )
            self._set_orientation(
                orientation or self.def_orientation, page_width_pt, page_height_pt
            )
        page.set_dimensions(self.w_pt, self.h_pt)

    def header(self) -> None:
        """
        Header to be implemented in your own inherited class

        This is automatically called by `FPDF.add_page()`
        and should not be called directly by the user application.
        The default implementation performs nothing: you have to override this method
        in a subclass to implement your own rendering logic.

        Note that header rendering can have an impact on the initial
        (x,y) position when starting to render the page content.
        """

    def footer(self) -> None:
        """
        Footer to be implemented in your own inherited class.

        This is automatically called by `FPDF.add_page()` and `FPDF.output()`
        and should not be called directly by the user application.
        The default implementation performs nothing: you have to override this method
        in a subclass to implement your own rendering logic.
        """

    def page_no(self) -> int:
        """Get the current page number"""
        return self.page

    def get_page_label(self) -> str:
        """
        Return the current page `fpdf.output.PDFPageLabel`.
        This will be displayed by some PDF readers to identify pages.
        `FPDF.set_page_label()` needs to be called first for those to be inserted.
        """
        return self.pages[self.page].get_label()

    def set_draw_color(
        self, r: Number | Color | str | Sequence[Number], g: Number = -1, b: Number = -1
    ) -> None:
        """
        Defines the color used for all stroking operations (lines, rectangles and cell borders).
        Accepts either a single greyscale value, 3 values as RGB components, a single `#abc` or `#abcdef` hexadecimal color string,
        or an instance of `fpdf.drawing.DeviceCMYK`, `fpdf.drawing.DeviceRGB` or `fpdf.drawing.DeviceGray`.
        The method can be called before the first page is created and the value is retained from page to page.

        Args:
            r (int, tuple, fpdf.drawing.DeviceGray, fpdf.drawing.DeviceRGB): if `g` and `b` are given, this indicates the red component.
                Else, this indicates the grey level. The value must be between 0 and 255.
            g (int): green component (between 0 and 255)
            b (int): blue component (between 0 and 255)
        """
        draw_color = convert_to_device_color(r, g, b)
        if draw_color != self.draw_color:
            self.draw_color = draw_color
            if self.page > 0:
                self._out(
                    self.draw_color.serialize().upper()  # pyright: ignore[reportOptionalMemberAccess]
                )

    def set_fill_color(
        self, r: Number | Color | str | Sequence[Number], g: Number = -1, b: Number = -1
    ) -> None:
        """
        Defines the color used for all filling operations (filled rectangles and cell backgrounds).
        Accepts either a single greyscale value, 3 values as RGB components, a single `#abc` or `#abcdef` hexadecimal color string,
        or an instance of `fpdf.drawing.DeviceCMYK`, `fpdf.drawing.DeviceRGB` or `fpdf.drawing.DeviceGray`.
        The method can be called before the first page is created and the value is retained from page to page.

        Args:
            r (int, tuple, fpdf.drawing.DeviceGray, fpdf.drawing.DeviceRGB): if `g` and `b` are given, this indicates the red component.
                Else, this indicates the grey level. The value must be between 0 and 255.
            g (int): green component (between 0 and 255)
            b (int): blue component (between 0 and 255)
        """
        fill_color = convert_to_device_color(r, g, b)
        if fill_color != self.fill_color:
            self.fill_color = fill_color
            if self.page > 0:
                self._out(
                    self.fill_color.serialize().lower()  # pyright: ignore[reportOptionalMemberAccess]
                )

    def set_text_color(
        self,
        r: (
            Number
            | Color
            | str
            | Sequence[Number]
            | DeviceCMYK
            | DeviceGray
            | DeviceRGB
        ),
        g: Number = -1,
        b: Number = -1,
    ) -> None:
        """
        Defines the color used for text.
        Accepts either a single greyscale value, 3 values as RGB components, a single `#abc` or `#abcdef` hexadecimal color string,
        or an instance of `fpdf.drawing.DeviceCMYK`, `fpdf.drawing.DeviceRGB` or `fpdf.drawing.DeviceGray`.
        The method can be called before the first page is created and the value is retained from page to page.

        Args:
            r (int, tuple, fpdf.drawing.DeviceGray, fpdf.drawing.DeviceRGB): if `g` and `b` are given, this indicates the red component.
                Else, this indicates the grey level. The value must be between 0 and 255.
            g (int): green component (between 0 and 255)
            b (int): blue component (between 0 and 255)
        """
        self.text_color = convert_to_device_color(r, g, b)

    def get_string_width(
        self, s: str, normalized: bool = False, markdown: bool = False
    ) -> float:
        """
        Returns the length of a string in user unit. A font must be selected.
        The value is calculated with stretching and spacing.

        Note that the width of a cell has some extra padding added to this width,
        on the left & right sides, equal to the .c_margin property.

        Args:
            s (str): the string whose length is to be computed.
            normalized (bool): whether normalization needs to be performed on the input string.
            markdown (bool): indicates if basic markdown support is enabled
        """
        if not self.font_family:
            raise FPDFException("No font set, you need to call set_font() beforehand")
        # normalized is parameter for internal use
        s = s if normalized else self.normalize_text(s)
        return sum(
            frag.get_width() for frag in self._preload_bidirectional_text(s, markdown)
        )

    def set_line_width(self, width: float) -> None:
        """
        Defines the line width of all stroking operations (lines, rectangles and cell borders).
        By default, the value equals 0.2 mm.
        The method can be called before the first page is created and the value is retained from page to page.

        Args:
            width (float): the width in user unit
        """
        if width != self.line_width:
            self.line_width = width
            if self.page > 0:
                self._out(f"{width * self.k:.2f} w")

    def set_page_background(
        self, background: Optional[str | BinaryIO | Image | DeviceRGB | tuple[float]]
    ) -> None:
        """
        Sets a background color or image to be drawn every time `FPDF.add_page()` is called, or removes a previously set background.
        The method can be called before the first page is created and the value is retained from page to page.

        Args:
            background: either a string representing a file path or URL to an image,
                an io.BytesIO containing an image as bytes, an instance of `PIL.Image.Image`, drawing.DeviceRGB
                or a RGB tuple representing a color to fill the background with or `None` to remove the background
        """

        if isinstance(
            background, (str, io.BytesIO, Image, DeviceRGB, tuple, type(None))
        ):
            if isinstance(background, DeviceRGB):
                self.page_background = background.colors255
            else:
                self.page_background = background
        else:
            raise TypeError(
                f"""background must be of type str, io.BytesIO, PIL.Image.Image, drawing.DeviceRGB, tuple or None
        got: {type(background)}"""
            )

    @contextmanager
    @check_page
    def drawing_context(
        self, debug_stream: Optional[bool] = None  # pylint: disable=unused-argument
    ) -> Iterator[DrawingContext]:
        """
        Create a context for drawing paths on the current page.

        If this context manager is called again inside of an active context, it will
        raise an exception, as base drawing contexts cannot be nested.
        """

        if self._current_draw_context is not None:
            raise FPDFException(
                "cannot create a drawing context while one is already open"
            )

        context = DrawingContext()
        self._current_draw_context = context
        try:
            yield context
        finally:
            self._current_draw_context = None

        starting_style = self._current_graphic_style()
        render_args = (
            self._resource_catalog,
            Point(self.x, self.y),
            self.k,
            self.h,
            starting_style,
        )

        rendered = context.render(*render_args)

        # Let the catalog scan & register resources used by this drawing:
        self._resource_catalog.index_stream_resources(rendered, self.page)
        # Once we handle text-rendering SVG tags (cf. PR #1029),
        # we should also detect fonts used and add them to the resource catalog

        self._out(rendered)
        # The drawing API makes use of features (notably transparency and blending modes) that were introduced in PDF 1.4:
        self._set_min_pdf_version("1.4")

    @contextmanager
    @check_page
    def use_pattern(self, shading: Gradient) -> Iterator[None]:
        """
        Create a context for using a shading pattern on the current page.
        """
        self._resource_catalog.add(PDFResourceType.SHADING, shading, self.page)
        pattern = shading.get_pattern()
        pattern_name = self._resource_catalog.add(
            PDFResourceType.PATTERN, pattern, self.page
        )
        self._out(f"/Pattern cs /{pattern_name} scn")
        try:
            yield
        finally:
            assert self.draw_color is not None
            self._out(self.draw_color.serialize().lower())

    def _current_graphic_style(self) -> GraphicsStyle:
        gs = GraphicsStyle()
        gs.allow_transparency = self.allow_images_transparency

        # This initial stroke_width is ignored when embedding SVGs,
        # as the value in SVGObject.convert_graphics() takes precedence,
        # so this probably creates an unnecessary PDF dict entry:
        gs.stroke_width = self.line_width

        if self.draw_color != self.DEFAULT_DRAW_COLOR:
            gs.stroke_color = self.draw_color
        if self.fill_color != self.DEFAULT_FILL_COLOR:
            gs.fill_color = self.fill_color

        dash_info = self.dash_pattern
        dash_pattern: Optional[tuple[float, float]] = (
            (dash_info["dash"], dash_info["gap"])
            if dash_info["dash"] != 0 and dash_info["gap"] != 0
            else None
        )

        gs.stroke_dash_pattern = dash_pattern
        gs.stroke_dash_phase = dash_info["phase"]

        return gs

    @contextmanager
    def new_path(
        self,
        x: float = 0,
        y: float = 0,
        paint_rule: PathPaintRule = PathPaintRule.AUTO,
        debug_stream: Optional[bool] = None,  # pylint: disable=unused-argument
    ) -> Iterator[PaintedPath]:
        """
        Create a path for appending lines and curves to.

        Args:
            x (float): Abscissa of the path starting point
            y (float): Ordinate of the path starting point
            paint_rule (PathPaintRule): Optional choice of how the path should
                be painted. The default (AUTO) automatically selects stroke/fill based
                on the path style settings.
        """
        with self.drawing_context() as ctxt:
            path = PaintedPath(x=x, y=y)
            path.style.paint_rule = paint_rule
            yield path
            ctxt.add_item(path)

    def draw_path(
        self,
        path: GraphicsContext,
        debug_stream: Optional[bool] = None,  # pylint: disable=unused-argument
        copy: bool = True,
    ) -> None:
        """
        Add a pre-constructed path to the document.

        Args:
            path (drawing.PaintedPath): the path to be drawn.
            copy (bool): if true (the default), the path will be copied before being
                added. This prevents modifications to a referenced object from
                "retroactively" altering its style/shape and should be disabled with
                caution.
        """
        with self.drawing_context() as ctxt:
            ctxt.add_item(path, copy)

    def set_dash_pattern(
        self, dash: float = 0, gap: float = 0, phase: float = 0
    ) -> None:
        """
        Set the current dash pattern for lines and curves.

        Args:
            dash (float): The length of the dashes in current units.

            gap (float): The length of the gaps between dashes in current units.
                If omitted, the dash length will be used.

            phase (float): Where in the sequence to start drawing.

        Omitting 'dash' (= 0) resets the pattern to a solid line.
        """
        if not (isinstance(dash, (int, float)) and dash >= 0):
            raise ValueError("Dash length must be zero or a positive number.")
        if not (isinstance(gap, (int, float)) and gap >= 0):
            raise ValueError("gap length must be zero or a positive number.")
        if not (isinstance(phase, (int, float)) and phase >= 0):
            raise ValueError("Phase must be zero or a positive number.")

        pattern: dict[str, float] = dict(
            dash=float(dash), gap=float(gap), phase=float(phase)
        )

        if pattern != self.dash_pattern:
            self.dash_pattern = pattern
            self._write_dash_pattern(dash, gap, phase)

    def _write_dash_pattern(self, dash: float, gap: float, phase: float) -> None:
        if dash:
            if gap:
                dstr = f"[{dash * self.k:.3f} {gap * self.k:.3f}] {phase *self.k:.3f} d"
            else:
                dstr = f"[{dash * self.k:.3f}] {phase *self.k:.3f} d"
        else:
            dstr = "[] 0 d"
        self._out(dstr)

    @contextmanager
    def glyph_drawing_context(self) -> Iterator[DrawingContext]:
        """
        Create a context for drawing paths for type 3 font glyphs, without writing on the current page.
        """

        if self._current_draw_context is not None:
            raise FPDFException(
                "cannot create a drawing context while one is already open"
            )

        context = DrawingContext()
        self._current_draw_context = context
        try:
            yield context
        finally:
            self._current_draw_context = None

        self._set_min_pdf_version("1.4")

    def draw_vector_glyph(
        self, path: Union[PaintedPath, GraphicsContext], font: "Type3Font"
    ) -> str:
        """
        Add a pre-constructed path to the document.
        """
        output_stream: str = ""
        with self.glyph_drawing_context() as ctxt:
            ctxt.add_item(path)

            starting_style = GraphicsStyle()
            render_args = (
                self._resource_catalog,
                Point(0, 0),
                1,
                0,
                starting_style,
            )

            output_stream = ctxt.render(*render_args)
            # Registering raster images embedded in the vector graphics:
            for resource_type, resource_id in self._resource_catalog.scan_stream(
                output_stream
            ):
                if resource_type == PDFResourceType.X_OBJECT:
                    font.images_used.add(int(resource_id))
                if resource_type == PDFResourceType.EXT_G_STATE:
                    font.graphics_style_used.add(resource_id)
                if resource_type == PDFResourceType.PATTERN:
                    font.patterns_used.add(resource_id)

        return output_stream

    @check_page
    def line(self, x1: float, y1: float, x2: float, y2: float) -> None:
        """
        Draw a line between two points.

        Args:
            x1 (float): Abscissa of first point
            y1 (float): Ordinate of first point
            x2 (float): Abscissa of second point
            y2 (float): Ordinate of second point
        """
        self._out(
            f"{x1 * self.k:.2f} {(self.h - y1) * self.k:.2f} m {x2 * self.k:.2f} "
            f"{(self.h - y2) * self.k:.2f} l S"
        )

    @check_page
    def polyline(
        self,
        point_list: Sequence[tuple[float, float]],
        fill: bool = False,
        polygon: bool = False,
        style: Optional[RenderStyle | str] = None,
    ) -> None:
        """
        Draws lines between two or more points.

        Args:
            point_list (list of tuples): List of Abscissa and Ordinate of
                                        segments that should be drawn
            fill (bool): [**DEPRECATED since v2.5.4**] Use `style="F"` or `style="DF"` instead
            polygon (bool): If true, close path before stroking, to fill the inside of the polyline
            style (fpdf.enums.RenderStyle, str): Optional style of rendering. Possible values are:

            * `D` or None: draw border. This is the default value.
            * `F`: fill
            * `DF` or `FD`: draw and fill
        """
        if fill:
            warnings.warn(
                (
                    '"fill" parameter is deprecated since v2.5.4, '
                    'use style="F" or style="DF" instead'
                ),
                DeprecationWarning,
                stacklevel=get_stack_level(),
            )
        if fill and style is None:
            style = RenderStyle.DF
        else:
            style = RenderStyle.coerce(style) if style is not None else RenderStyle.D
            if fill and style == RenderStyle.D:
                raise ValueError(
                    f"Conflicting values provided: fill={fill} & style={style}"
                )
        operator = "m"
        for point in point_list:
            self._out(
                f"{point[0] * self.k:.2f} {(self.h - point[1]) * self.k:.2f} {operator}"
            )
            operator = "l"
        if polygon:
            self._out(" h")
        self._out(f" {style.operator}")

    @check_page
    def polygon(
        self,
        point_list: Sequence[tuple[float, float]],
        fill: bool = False,
        style: Optional[RenderStyle | str] = None,
    ) -> None:
        """
        Outputs a polygon defined by three or more points.

        Args:
            point_list (list of tuples): List of coordinates defining the polygon to draw
            fill (bool): [**DEPRECATED since v2.5.4**] Use `style="F"` or `style="DF"` instead
            style (fpdf.enums.RenderStyle, str): Optional style of rendering. Possible values are:

            * `D` or None: draw border. This is the default value.
            * `F`: fill
            * `DF` or `FD`: draw and fill
        """
        self.polyline(point_list, fill=fill, polygon=True, style=style)

    @check_page
    def dashed_line(
        self,
        x1: float,
        y1: float,
        x2: float,
        y2: float,
        dash_length: float = 1,
        space_length: float = 1,
    ) -> None:
        """
        Draw a dashed line between two points.

        Args:
            x1 (float): Abscissa of first point
            y1 (float): Ordinate of first point
            x2 (float): Abscissa of second point
            y2 (float): Ordinate of second point
            dash_length (float): Length of the dash
            space_length (float): Length of the space between 2 dashes

        .. deprecated:: 2.4.6
            Use `FPDF.set_dash_pattern()` and the normal drawing operations instead.
        """
        warnings.warn(
            (
                "dashed_line() is deprecated since v2.4.6, "
                "and will be removed in a future release. "
                "Use set_dash_pattern() and the normal drawing operations instead."
            ),
            DeprecationWarning,
            stacklevel=get_stack_level(),
        )
        self.set_dash_pattern(dash_length, space_length)
        self.line(x1, y1, x2, y2)
        self.set_dash_pattern()

    @check_page
    def rect(
        self,
        x: float,
        y: float,
        w: float,
        h: float,
        style: Optional[RenderStyle | str] = None,
        round_corners: bool = False,
        corner_radius: float = 0,
    ) -> None:
        """
        Outputs a rectangle.
        It can be drawn (border only), filled (with no border) or both.

        Args:
            x (float): Abscissa of upper-left bounding box.
            y (float): Ordinate of upper-left bounding box.
            w (float): Width.
            h (float): Height.
            style (fpdf.enums.RenderStyle, str): Optional style of rendering. Possible values are:

            * `D` or empty string: draw border. This is the default value.
            * `F`: fill
            * `DF` or `FD`: draw and fill

            round_corners (tuple of str, tuple of fpdf.enums.Corner, bool): Optional draw a rectangle with round corners.
            Possible values are:

            *`TOP_LEFT`: a rectangle with round top left corner
            *`TOP_RIGHT`: a rectangle with round top right corner
            *`BOTTOM_LEFT`: a rectangle with round bottom left corner
            *`BOTTOM_RIGHT`: a rectangle with round bottom right corner
            *`True`: a rectangle with all round corners
            *`False`: a rectangle with no round corners

            corner_radius: Optional radius of the corners
        """

        style = RenderStyle.coerce(style) if style is not None else RenderStyle.D
        if round_corners is not False:
            self._draw_rounded_rect(x, y, w, h, style, round_corners, corner_radius)
        else:
            self._out(
                f"{x * self.k:.2f} {(self.h - y) * self.k:.2f} {w * self.k:.2f} "
                f"{-h * self.k:.2f} re {style.operator}"
            )

    def _draw_rounded_rect(
        self,
        x: float,
        y: float,
        w: float,
        h: float,
        style: RenderStyle,
        round_corners: bool | tuple[Corner | str, ...],
        r: float,
    ) -> None:
        min = h
        if w < h:
            min = w

        if r == 0:
            r = min / 5

        if r >= min / 2:
            r /= min

        # Calculate corner points
        point_1 = point_8 = (x, y)
        point_2 = (x + w, y)
        point_4 = (x + w, y + h)
        point_6 = (x, y + h)

        if round_corners is True:
            round_corners = (
                Corner.TOP_RIGHT.value,
                Corner.TOP_LEFT.value,
                Corner.BOTTOM_RIGHT.value,
                Corner.BOTTOM_LEFT.value,
            )
        assert not isinstance(round_corners, bool)
        round_corners_list: tuple[Corner, ...] = tuple(
            Corner.coerce(rc) for rc in round_corners
        )

        # Update points based on which corners are rounded
        if Corner.TOP_RIGHT in round_corners_list:
            point_1 = (x + r, y)
            point_8 = (x, y + r)

        if Corner.TOP_LEFT in round_corners_list:
            point_2 = (x + w - r, y)
            _point_3 = (x + w, y + r)

        if Corner.BOTTOM_LEFT in round_corners_list:
            point_4 = (x + w, y + h - r)
            _point_5 = (x + w - r, y + h)

        if Corner.BOTTOM_RIGHT in round_corners_list:
            point_6 = (x + r, y + h)
            _point_7 = (x, y + h - r)

        # Build a single continuous path
        # Start at point_1
        self._out(f"{point_1[0] * self.k:.2f} {(self.h - point_1[1]) * self.k:.2f} m")

        # Top edge: point_1 to point_2
        self._out(f"{point_2[0] * self.k:.2f} {(self.h - point_2[1]) * self.k:.2f} l")

        # Top-left corner arc
        if Corner.TOP_LEFT in round_corners_list:
            self._draw_arc_segment(x + w - 2 * r, y, 2 * r, 270, 0)

        # Right edge: point_3 to point_4
        self._out(f"{point_4[0] * self.k:.2f} {(self.h - point_4[1]) * self.k:.2f} l")

        # Bottom-left corner arc
        if Corner.BOTTOM_LEFT in round_corners_list:
            self._draw_arc_segment(x + w - 2 * r, y + h - 2 * r, 2 * r, 0, 90)

        # Bottom edge: point_5 to point_6
        self._out(f"{point_6[0] * self.k:.2f} {(self.h - point_6[1]) * self.k:.2f} l")

        # Bottom-right corner arc
        if Corner.BOTTOM_RIGHT in round_corners_list:
            self._draw_arc_segment(x, y + h - 2 * r, 2 * r, 90, 180)

        # Left edge: point_7 to point_8
        self._out(f"{point_8[0] * self.k:.2f} {(self.h - point_8[1]) * self.k:.2f} l")

        # Top-right corner arc
        if Corner.TOP_RIGHT in round_corners_list:
            self._draw_arc_segment(x, y, 2 * r, 180, 270)

        # Close path and apply style
        self._out(f"h {style.operator}")

    def _draw_arc_segment(
        self,
        x: float,
        y: float,
        a: float,
        start_angle: float,
        end_angle: float,
        b: Optional[float] = None,
    ) -> None:
        """
        Draw an arc segment as part of an existing path (no move, no style application).
        Used internally for building complex shapes like rounded rectangles.
        """
        if b is None:
            b = a

        a /= 2
        b /= 2

        cx = x + a
        cy = y + b

        def deg_to_rad(deg: float) -> float:
            return deg * math.pi / 180

        def angle_to_param(angle: float) -> float:
            angle = deg_to_rad(angle % 360)
            eta = math.atan2(math.sin(angle) / b, math.cos(angle) / a)
            if eta < 0:
                eta += 2 * math.pi
            return eta

        def evaluate(eta: float) -> list[float]:
            a_cos_eta = a * math.cos(eta)
            b_sin_eta = b * math.sin(eta)
            return [cx + a_cos_eta, cy + b_sin_eta]

        def derivative_evaluate(eta: float) -> list[float]:
            a_sin_eta = a * math.sin(eta)
            b_cos_eta = b * math.cos(eta)
            return [-a_sin_eta, b_cos_eta]

        start_eta = angle_to_param(start_angle)
        end_eta = angle_to_param(end_angle)

        if end_eta <= start_eta:
            end_eta += 2 * math.pi

        max_curves = 4
        n = min(
            max_curves, math.ceil(abs(end_eta - start_eta) / (2 * math.pi / max_curves))
        )
        d_eta = (end_eta - start_eta) / n

        alpha = math.sin(d_eta) * (math.sqrt(4 + 3 * math.tan(d_eta / 2) ** 2) - 1) / 3

        eta2 = start_eta
        p2 = evaluate(eta2)
        p2_prime = derivative_evaluate(eta2)

        for _ in range(n):
            p1 = p2
            p1_prime = p2_prime

            eta2 += d_eta
            p2 = evaluate(eta2)
            p2_prime = derivative_evaluate(eta2)

            control_point_1 = [p1[0] + alpha * p1_prime[0], p1[1] + alpha * p1_prime[1]]
            control_point_2 = [p2[0] - alpha * p2_prime[0], p2[1] - alpha * p2_prime[1]]

            self._out(
                f"{control_point_1[0] * self.k:.2f} {(self.h - control_point_1[1]) * self.k:.2f} "
                f"{control_point_2[0] * self.k:.2f} {(self.h - control_point_2[1]) * self.k:.2f} "
                f"{p2[0] * self.k:.2f} {(self.h - p2[1]) * self.k:.2f} c"
            )

    @check_page
    def ellipse(
        self,
        x: float,
        y: float,
        w: float,
        h: float,
        style: Optional[RenderStyle | str] = None,
    ) -> None:
        """
        Outputs an ellipse.
        It can be drawn (border only), filled (with no border) or both.

        Args:
            x (float): Abscissa of upper-left bounding box.
            y (float): Ordinate of upper-left bounding box.
            w (float): Width
            h (float): Height
            style (fpdf.enums.RenderStyle, str): Optional style of rendering. Possible values are:

            * `D` or empty string: draw border. This is the default value.
            * `F`: fill
            * `DF` or `FD`: draw and fill
        """
        style = RenderStyle.coerce(style) if style is not None else RenderStyle.D
        self._draw_ellipse(x, y, w, h, style.operator)

    def _draw_ellipse(
        self, x: float, y: float, w: float, h: float, operator: str
    ) -> None:
        cx = x + w / 2
        cy = y + h / 2
        rx = w / 2
        ry = h / 2

        lx = 4 / 3 * (math.sqrt(2) - 1) * rx
        ly = 4 / 3 * (math.sqrt(2) - 1) * ry

        self._out(
            (
                f"{(cx + rx) * self.k:.2f} {(self.h - cy) * self.k:.2f} m "
                f"{(cx + rx) * self.k:.2f} {(self.h - cy + ly) * self.k:.2f} "
                f"{(cx + lx) * self.k:.2f} {(self.h - cy + ry) * self.k:.2f} "
                f"{cx * self.k:.2f} {(self.h - cy + ry) * self.k:.2f} c"
            )
        )
        self._out(
            (
                f"{(cx - lx) * self.k:.2f} {(self.h - cy + ry) * self.k:.2f} "
                f"{(cx - rx) * self.k:.2f} {(self.h - cy + ly) * self.k:.2f} "
                f"{(cx - rx) * self.k:.2f} {(self.h - cy) * self.k:.2f} c"
            )
        )
        self._out(
            (
                f"{(cx - rx) * self.k:.2f} {(self.h - cy - ly) * self.k:.2f} "
                f"{(cx - lx) * self.k:.2f} {(self.h - cy - ry) * self.k:.2f} "
                f"{cx * self.k:.2f} {(self.h - cy - ry) * self.k:.2f} c"
            )
        )
        self._out(
            (
                f"{(cx + lx) * self.k:.2f} {(self.h - cy - ry) * self.k:.2f} "
                f"{(cx + rx) * self.k:.2f} {(self.h - cy - ly) * self.k:.2f} "
                f"{(cx + rx) * self.k:.2f} {(self.h - cy) * self.k:.2f} c {operator}"
            )
        )

    @check_page
    def circle(
        self,
        x: float,
        y: float,
        radius: float,
        style: Optional[RenderStyle | str] = None,
    ) -> None:
        """
        Outputs a circle.
        It can be drawn (border only), filled (with no border) or both.

        WARNING: This method changed parameters in [release 2.8.0](https://github.com/py-pdf/fpdf2/releases/tag/2.8.0)

        Args:
            x (float): Abscissa of upper-left bounding box.
            y (float): Ordinate of upper-left bounding box.
            radius (float): Radius of the circle.
            style (str): Style of rendering. Possible values are:

            * `D` or None: draw border. This is the default value.
            * `F`: fill
            * `DF` or `FD`: draw and fill
        """
        self.ellipse(x - radius, y - radius, 2 * radius, 2 * radius, style)

    @check_page
    def regular_polygon(
        self,
        x: float,
        y: float,
        numSides: int,
        polyWidth: float,
        rotateDegrees: float = 0,
        style: Optional[RenderStyle | str] = None,
    ) -> None:
        """
        Outputs a regular polygon with n sides
        It can be rotated
        Style can also be applied (fill, border...)

        Args:
            x (float): Abscissa of upper-left bounding box.
            y (float): Ordinate of upper-left bounding box.
            numSides (int): Number of sides for polygon.
            polyWidth (float): Width of the polygon.
            rotateDegrees (float): Optional degree amount to rotate polygon.
            style (fpdf.enums.RenderStyle, str): Optional style of rendering. Possible values are:

            * `D` or None: draw border. This is the default value.
            * `F`: fill
            * `DF` or `FD`: draw and fill
        """
        radius = polyWidth / 2
        centerX = x + radius
        centerY = y - radius
        # center point is (centerX, centerY)
        points: list[tuple[float, float]] = []
        for i in range(1, numSides + 1):
            point = centerX + radius * math.cos(
                math.radians((360 / numSides) * i) + math.radians(rotateDegrees)
            ), centerY + radius * math.sin(
                math.radians((360 / numSides) * i) + math.radians(rotateDegrees)
            )
            points.append(point)
        # creates list of tuples containing coordinate points of vertices

        self.polygon(points, style=style)
        # passes points through polygon function

    @check_page
    def star(
        self,
        x: float,
        y: float,
        r_in: float,
        r_out: float,
        corners: int,
        rotate_degrees: float = 0,
        style: Optional[RenderStyle | str] = None,
    ) -> None:
        """
        Outputs a regular star with n corners.
        It can be rotated.
        It can be drawn (border only), filled (with no border) or both.

        Args:
            x (float): Abscissa of star's centre.
            y (float): Ordinate of star's centre.
            r_in (float): radius of internal circle.
            r_out (float): radius of external circle.
            corners (int): number of star's corners.
            rotate_degrees (float): Optional degree amount to rotate star clockwise.

            style (fpdf.enums.RenderStyle, str): Optional style of rendering. Possible values are:
            * `D`: draw border. This is the default value.
            * `F`: fill.
            * `DF` or `FD`: draw and fill.
        """
        th = math.radians(rotate_degrees)
        point_list: list[tuple[float, float]] = []
        for i in range(0, (corners * 2) + 1):
            corner_x = x + (r_out if i % 2 == 0 else r_in) * math.sin(th)
            corner_y = y + (r_out if i % 2 == 0 else r_in) * math.cos(th)
            point_list.append((corner_x, corner_y))

            th += math.radians(180 / corners)

        self.polyline(point_list, polygon=True, style=style)

    @check_page
    def arc(
        self,
        x: float,
        y: float,
        a: float,
        start_angle: float,
        end_angle: float,
        b: Optional[float] = None,
        inclination: float = 0,
        clockwise: bool = False,
        start_from_center: bool = False,
        end_at_center: bool = False,
        style: Optional[RenderStyle | str] = None,
    ) -> None:
        """
        Outputs an arc.
        It can be drawn (border only), filled (with no border) or both.

        Args:
            x (float): Abscissa of upper-left corner of the bounding box of the full ellipse.
            y (float): Ordinate of upper-left corner of the bounding box of the full ellipse.
            a (float): Major axis diameter (width of bounding box).
            b (float): Minor axis diameter (height of bounding box), if None, equals to a (default: None).
            start_angle (float): Start angle of the arc (in degrees).
            end_angle (float): End angle of the arc (in degrees).
            inclination (float): Inclination of the arc in respect of the x-axis (default: 0).
            clockwise (bool): Way of drawing the arc (True: clockwise, False: counterclockwise) (default: False).
            start_from_center (bool): Start drawing from the center of the ellipse (default: False).
            end_at_center (bool): End drawing at the center of the ellipse (default: False).
            style (fpdf.enums.RenderStyle, str): Optional style of rendering. Allowed values are:

            * `D` or None: draw border. This is the default value.
            * `F`: fill
            * `DF` or `FD`: draw and fill
        """
        style = RenderStyle.coerce(style) if style is not None else RenderStyle.D

        if b is None:
            b = a

        a /= 2
        b /= 2

        cx = x + a
        cy = y + b

        # Functions used only to construct other points of the bezier curve
        def deg_to_rad(deg: float) -> float:
            return deg * math.pi / 180

        def angle_to_param(angle: float) -> float:
            angle = deg_to_rad(angle % 360)
            eta = math.atan2(math.sin(angle) / b, math.cos(angle) / a)

            if eta < 0:
                eta += 2 * math.pi
            return eta

        theta = deg_to_rad(inclination)
        cos_theta = math.cos(theta)
        sin_theta = math.sin(theta)

        def evaluate(eta: float) -> list[float]:
            a_cos_eta = a * math.cos(eta)
            b_sin_eta = b * math.sin(eta)

            return [
                cx + a_cos_eta * cos_theta - b_sin_eta * sin_theta,
                cy + a_cos_eta * sin_theta + b_sin_eta * cos_theta,
            ]

        def derivative_evaluate(eta: float) -> list[float]:
            a_sin_eta = a * math.sin(eta)
            b_cos_eta = b * math.cos(eta)

            return [
                -a_sin_eta * cos_theta - b_cos_eta * sin_theta,
                -a_sin_eta * sin_theta + b_cos_eta * cos_theta,
            ]

        # Calculating start_eta and end_eta so that
        #   start_eta < end_eta   <= start_eta + 2*PI if counterclockwise
        #   end_eta   < start_eta <= end_eta + 2*PI   if clockwise
        start_eta = angle_to_param(start_angle)
        end_eta = angle_to_param(end_angle)

        if not clockwise and end_eta <= start_eta:
            end_eta += 2 * math.pi
        elif clockwise and end_eta >= start_eta:
            start_eta += 2 * math.pi

        start_point = evaluate(start_eta)

        # Move to the start point
        if start_from_center:
            self._out(f"{cx * self.k:.2f} {(self.h - cy) * self.k:.2f} m")
            self._out(
                f"{start_point[0] * self.k:.2f} {(self.h - start_point[1]) * self.k:.2f} l"
            )
        else:
            self._out(
                f"{start_point[0] * self.k:.2f} {(self.h - start_point[1]) * self.k:.2f} m"
            )

        # Number of curves to use, maximal segment angle is 2*PI/max_curves
        max_curves = 4
        n = min(
            max_curves, math.ceil(abs(end_eta - start_eta) / (2 * math.pi / max_curves))
        )
        d_eta = (end_eta - start_eta) / n

        alpha = math.sin(d_eta) * (math.sqrt(4 + 3 * math.tan(d_eta / 2) ** 2) - 1) / 3

        eta2 = start_eta
        p2 = evaluate(eta2)
        p2_prime = derivative_evaluate(eta2)

        for i in range(n):
            p1 = p2
            p1_prime = p2_prime

            eta2 += d_eta
            p2 = evaluate(eta2)
            p2_prime = derivative_evaluate(eta2)

            control_point_1 = [p1[0] + alpha * p1_prime[0], p1[1] + alpha * p1_prime[1]]
            control_point_2 = [p2[0] - alpha * p2_prime[0], p2[1] - alpha * p2_prime[1]]

            end = ""
            if i == n - 1 and not end_at_center:
                end = f" {style.operator}"

            self._out(
                (
                    f"{control_point_1[0] * self.k:.2f} {(self.h - control_point_1[1]) * self.k:.2f} "
                    f"{control_point_2[0] * self.k:.2f} {(self.h - control_point_2[1]) * self.k:.2f} "
                    f"{p2[0] * self.k:.2f} {(self.h - p2[1]) * self.k:.2f} c" + end
                )
            )

        if end_at_center:
            if start_from_center:
                self._out(f"h {style.operator}")
            else:
                self._out(
                    f"{cx * self.k:.2f} {(self.h - cy) * self.k:.2f} l {style.operator}"
                )

    def solid_arc(
        self,
        x: float,
        y: float,
        a: float,
        start_angle: float,
        end_angle: float,
        b: Optional[float] = None,
        inclination: float = 0,
        clockwise: bool = False,
        style: Optional[RenderStyle | str] = None,
    ) -> None:
        """
        Outputs a solid arc. A solid arc combines an arc and a triangle to form a pie slice
        It can be drawn (border only), filled (with no border) or both.

        Args:
            x (float): Abscissa of upper-left bounding box.
            y (float): Ordinate of upper-left bounding box.
            a (float): Semi-major axis.
            b (float): Semi-minor axis, if None, equals to a (default: None).
            start_angle (float): Start angle of the arc (in degrees).
            end_angle (float): End angle of the arc (in degrees).
            inclination (float): Inclination of the arc in respect of the x-axis (default: 0).
            clockwise (bool): Way of drawing the arc (True: clockwise, False: counterclockwise) (default: False).
            style (str): Style of rendering. Possible values are:

            * `D` or None: draw border. This is the default value.
            * `F`: fill
            * `DF` or `FD`: draw and fill
        """
        self.arc(
            x,
            y,
            a,
            start_angle,
            end_angle,
            b,
            inclination,
            clockwise,
            True,
            True,
            style,
        )

    def bezier(
        self,
        point_list: Sequence[tuple[float, float]],
        closed: bool = False,
        style: Optional[RenderStyle | str] = None,
    ) -> None:
        """
        Outputs a quadratic or cubic B√©zier curve, defined by three or four coordinates.

        Args:
            point_list (list of tuples): List of Abscissa and Ordinate of
                                        segments that should be drawn. Should be
                                        three or four tuples. The first and last
                                        points are the start and end point. The
                                        middle point(s) are the control point(s).
            closed (bool): True to draw the curve as a closed path, False (default)
                                        for it to be drawn as an open path.
            style (fpdf.enums.RenderStyle, str): Optional style of rendering. Allowed values are:
            * `D` or None: draw border. This is the default value.
            * `F`: fill
            * `DF` or `FD`: draw and fill
        """
        points = len(point_list)
        if points not in (3, 4):
            raise ValueError(
                "point_list should contain 3 tuples for a quadratic curve"
                " or 4 tuples for a cubic curve."
            )
        style = RenderStyle.coerce(style) if style is not None else RenderStyle.D

        # QuadraticBezierCurve and BezierCurve make use of `initial_point` when instantiated.
        # If we want to define all 3 (quad.) or 4 (cubic) points, we can set `initial_point`
        # to be the first point given in `point_list` by creating a separate dummy path at that pos.
        with self.drawing_context() as ctxt:
            p1 = point_list[0]
            x1, y1 = p1[0], p1[1]

            dummy_path = PaintedPath(x1, y1)
            ctxt.add_item(dummy_path)

            p2 = point_list[1]
            x2, y2 = p2[0], p2[1]

            p3 = point_list[2]
            x3, y3 = p3[0], p3[1]

            if points == 4:
                p4 = point_list[3]
                x4, y4 = p4[0], p4[1]

            path = PaintedPath(x1, y1)

            # Translate enum style (RenderStyle) into rule (PathPaintRule)
            rule = PathPaintRule.STROKE_FILL_NONZERO
            if style.is_draw and not style.is_fill:
                rule = PathPaintRule.STROKE
            elif style.is_fill and not style.is_draw:
                rule = PathPaintRule.FILL_NONZERO

            path.style.paint_rule = rule
            path.style.auto_close = closed

            if points == 4:
                path.curve_to(
                    x2,
                    y2,
                    x3,
                    y3,
                    x4,  # pyright: ignore[reportPossiblyUnboundVariable]
                    y4,  # pyright: ignore[reportPossiblyUnboundVariable]
                )
            elif points == 3:
                path.curve_to(x2, y2, x2, y2, x3, y3)

            ctxt.add_item(path)

    @deprecated_parameter([("uni", "2.5.1")])
    def add_font(
        self,
        family: Optional[str] = None,
        style: str = "",
        fname: Optional[str] = None,
        *,
        unicode_range: Optional[str | Sequence[str | int | tuple[int, int]]] = None,
        variations: Optional[dict[str, dict[str, float]] | dict[str, float]] = None,
        palette: Optional[int] = None,
    ) -> None:
        """
        Imports a TrueType or OpenType font and makes it available
        for later calls to the `FPDF.set_font()` method.

        You will find more information on the "Unicode" documentation page.

        Args:
            family (str): optional name of the font family. Used as a reference for `FPDF.set_font()`.
                If not provided, use the base name of the `fname` font path, without extension.
            style (str): font style. "" for regular, include 'B' for bold, and/or 'I' for italic.
            fname (str): font file name. You can specify a relative or full path.
                If the file is not found, it will be searched in `FPDF_FONT_DIR`.
            unicode_range (Optional[Union[str, int, tuple, list]]): subset of Unicode codepoints to embed.
                Accepts CSS-style strings (e.g. "U+1F600-1F64F, U+2600"), integers, tuples, or lists.
                Defaults to None, which embeds the full cmap.
            variations (dict[style, dict]): maps style to limits of axes for the variable font.
            palette (int): optional palette index for color fonts (COLR/CPAL). Defaults to 0 (first palette).
                Only applicable to fonts with CPAL table (color fonts).
        """
        if not fname:
            raise ValueError('"fname" parameter is required')

        ext = splitext(str(fname))[1].lower()
        if ext not in (".otf", ".otc", ".ttf", ".ttc", ".woff", ".woff2"):
            raise ValueError(
                f"Unsupported font file extension: {ext}."
                " add_font() used to accept .pkl file as input, but for security reasons"
                " this feature is deprecated since v2.5.1 and has been removed in v2.5.3."
            )

        for parent in (Path("."), FPDF_FONT_DIR):
            if (parent / fname).exists():
                font_file_path = parent / fname
                break
        else:
            raise FileNotFoundError(f"TTF Font file not found: {fname}")

        if family is None:
            family = font_file_path.stem

        parsed_unicode_range = None
        if unicode_range is not None:
            parsed_unicode_range = get_parsed_unicode_range(unicode_range)

        style = "".join(sorted(style.upper()))
        if any(letter not in "BI" for letter in style):
            raise ValueError(
                f"Unknown style provided (only B & I letters are allowed): {style}"
            )

        # Handle variable font.
        if variations is not None:
            if not isinstance(variations, dict):
                raise TypeError("Variations, if specified, must be a dictionary")

            # Check variations dictionary
            if all(
                key.upper() in ("", "B", "I", "BI") and isinstance(value, dict)
                for key, value in variations.items()
            ):
                for var_style, axes_dict in variations.items():
                    self.add_font(
                        family=family,
                        style=var_style,
                        fname=fname,
                        unicode_range=unicode_range,
                        variations=axes_dict,  # type: ignore[arg-type]
                        palette=palette,
                    )
                return
        fontkey = f"{family.lower()}{style}"

        if fontkey in self.fonts or fontkey in CORE_FONTS:
            warnings.warn(
                f"Core font or font already added '{fontkey}': doing nothing",
                stacklevel=get_stack_level(),
            )
            return

        self.fonts[fontkey] = TTFFont(
            self,
            font_file_path,
            fontkey,
            style,
            parsed_unicode_range,
            variations,  # type: ignore[arg-type]
            palette,
        )

    def set_font(
        self,
        family: Optional[str] = None,
        style: Union[str, TextEmphasis] = "",
        size: float = 0,
    ) -> None:
        """
        Sets the font used to print character strings.
        It is mandatory to call this method at least once before printing text.

        Default encoding is not specified, but all text writing methods accept only
        unicode for external fonts and one byte encoding for standard.

        Standard fonts use `Latin-1` encoding by default, but Windows
        encoding `cp1252` (Western Europe) can be used with
        `self.core_fonts_encoding = encoding`.

        The font specified is retained from page to page.
        The method can be called before the first page is created.

        Args:
            family (str): name of a font added with `FPDF.add_font`,
                or name of one of the 14 standard "PostScript" fonts:
                Courier (fixed-width), Helvetica (sans serif), Times (serif),
                Symbol (symbolic) or ZapfDingbats (symbolic)
                If an empty string is provided, the current family is retained.
            style (str, fpdf.enums.TextEmphasis): empty string (by default) or a combination
                of one or several letters among B (bold), I (italic), S (strikethrough) and U (underline).
                Bold and italic styles do not apply to Symbol and ZapfDingbats fonts.
            size (float): in points. The default value is the current size.
        """
        if not family:
            family = self.font_family

        family = family.lower()
        if isinstance(style, TextEmphasis):
            style = style.style
        style = "".join(sorted(style.upper()))
        if any(letter not in "BISU" for letter in style):
            raise ValueError(
                f"Unknown style provided (only B/I/S/U letters are allowed): {style}"
            )
        if "U" in style:
            self.underline = True
            style = style.replace("U", "")
        else:
            self.underline = False
        if "S" in style:
            self.strikethrough = True
            style = style.replace("S", "")
        else:
            self.strikethrough = False

        if family in self.font_aliases and family + style not in self.fonts:
            warnings.warn(
                f"Substituting font {family} by core font {self.font_aliases[family]}"
                " - This is deprecated since v2.7.8, and will soon be removed",
                DeprecationWarning,
                stacklevel=get_stack_level(),
            )
            family = self.font_aliases[family]
        elif family in ("symbol", "zapfdingbats") and style:
            warnings.warn(
                f"Built-in font {family} only has a single 'style' "
                "and can't be bold or italic",
                stacklevel=get_stack_level(),
            )
            style = ""

        if not size:
            size = self.font_size_pt

        # Test if font is already selected
        if (
            self.font_family == family
            and self.font_style == style
            and isclose(self.font_size_pt, size)
        ):
            return

        # Test if used for the first time
        fontkey = family + style
        if fontkey not in self.fonts:
            if fontkey not in CORE_FONTS:
                raise FPDFException(
                    f"Undefined font: {fontkey} - "
                    f"Use built-in fonts or FPDF.add_font() beforehand"
                )
            # If it's one of the core fonts, add it to self.fonts
            if self._compliance and self._compliance.profile == "PDFA":
                raise PDFAComplianceError(
                    f"Usage of base fonts is now allowed for documents compliant with {self._compliance.label}. Use add_font() to embed a font file"
                )

            self.fonts[fontkey] = CoreFont(len(self.fonts) + 1, fontkey, style)

        # Select it
        self.font_family = family
        self.font_style = style
        self.font_size_pt = size
        self.current_font = self.fonts[fontkey]
        self.current_font_is_set_on_page = False

    def set_font_size(self, size: float) -> None:
        """
        Configure the font size in points

        Args:
            size (float): font size in points
        """
        if isclose(self.font_size_pt, size):
            return
        self.font_size_pt = size
        self.current_font_is_set_on_page = False

    def _set_font_for_page(
        self,
        font: CoreFont | TTFFont,
        font_size_pt: float,
        wrap_in_text_object: bool = True,
    ) -> str:
        """
        Set font and size for current page.
        This step is needed before adding text into page and not needed in set_font and set_font_size.
        """
        sl = f"/F{font.i} {font_size_pt:.2f} Tf"
        if wrap_in_text_object:
            sl = f"BT {sl} ET"
        self._resource_catalog.add(PDFResourceType.FONT, font.i, self.page)
        self.current_font_is_set_on_page = True
        return sl

    def set_char_spacing(self, spacing: float) -> None:
        """
        Sets horizontal character spacing.
        A positive value increases the space between characters, a negative value
        reduces it (which may result in glyph overlap).
        By default, no spacing is set (which is equivalent to a value of 0).

        Args:
            spacing (float): horizontal spacing in document units
        """
        if self.char_spacing == spacing:
            return
        self.char_spacing = spacing
        if self.page > 0:
            self._out(f"BT {spacing:.2f} Tc ET")

    def set_stretching(self, stretching: float) -> None:
        """
        Sets horizontal font stretching.
        By default, no stretching is set (which is equivalent to a value of 100).

        Args:
            stretching (float): horizontal stretching (scaling) in percents.
        """
        if self.font_stretching == stretching:
            return
        self.font_stretching = stretching
        if self.page > 0:
            self._out(f"BT {stretching:.2f} Tz ET")

    def set_fallback_fonts(
        self, fallback_fonts: Sequence[str], exact_match: bool = True
    ) -> None:
        """
        Allows you to specify a list of fonts to be used if any character is not available on the font currently set.
        Detailed documentation: https://py-pdf.github.io/fpdf2/Unicode.html#fallback-fonts

        Args:
            fallback_fonts: sequence of fallback font IDs
            exact_match (bool): when a glyph cannot be rendered uing the current font,
                fpdf2 will look for a fallback font matching the current character emphasis (bold/italics).
                If it does not find such matching font, and `exact_match` is True, no fallback font will be used.
                If it does not find such matching font, and `exact_match` is False, a fallback font will still be used.
                To get even more control over this logic, you can also override `FPDF.get_fallback_font()`
        """
        fallback_font_ids: list[str] = []
        for fallback_font in fallback_fonts:
            found = False
            for fontkey in self.fonts:
                # will add all font styles on the same family
                if fontkey.replace("B", "").replace("I", "") == fallback_font.lower():
                    if fontkey not in fallback_font_ids:
                        fallback_font_ids.append(fontkey)
                    found = True
            if not found:
                raise FPDFException(
                    f"Undefined fallback font: {fallback_font} - Use FPDF.add_font() beforehand"
                )
        self._fallback_font_ids = fallback_font_ids
        self._fallback_font_exact_match = exact_match

    def add_link(
        self,
        y: float = 0,
        x: float = 0,
        page: int = -1,
        zoom: str | float = "null",
        name: Optional[str] = None,
    ) -> int:
        """
        Creates a new internal link and returns its identifier.
        An internal link is a clickable area which directs to another place within the document.

        The identifier can then be passed to the `FPDF.cell()`, `FPDF.write()`, `FPDF.image()`
        or `FPDF.link()` methods.

        If a name is provided, creates a named destination that can be referenced later.
        Named destinations are more stable than plain links when pages are added or removed.

        Args:
            y (float): optional ordinate of target position.
                The default value is 0 (top of page).
            x (float): optional abscissa of target position.
                The default value is 0 (top of page).
            page (int): optional number of target page.
                -1 indicates the current page, which is the default value.
            zoom (float): optional new zoom level after following the link.
                Currently ignored by Sumatra PDF Reader, but observed by Adobe Acrobat reader.
            name (str, optional): Name for the destination. If provided, creates a named
                destination in the PDF that can be referenced from other parts of the document
                or from external documents.
        """
        # Create destination
        link = DestinationXYZ(
            self.page if page == -1 else page,
            top=self.h_pt - y * self.k,
            left=x * self.k,
            zoom=zoom,
        )

        # Handle named destinations
        if name is not None:
            if not name or name.isspace():
                raise ValueError("Destination name cannot be empty or whitespace")
            self.named_destinations[name] = link

        # Store link and return index
        link_index = len(self.links) + 1
        self.links[link_index] = link
        return link_index

    def get_named_destination(self, name: str) -> str:
        """
        Retrieves a named destination by its name and creates a link to it.

        Args:
            name (str): The name of the destination to retrieve.

        Returns:
            str: A string with format "#name" that can be used with cell(), write(), image(), or link()

        Raises:
            KeyError: If no destination exists with the given name
        """
        if name not in self.named_destinations:
            # Create a placeholder named destination pointing to page 0
            # This will be caught during output if never set properly
            self.named_destinations[name] = DestinationXYZ(0, top=self.h_pt * self.k)

        # Return the name prefixed with # to indicate it's a named destination
        # This way, the link() method will use the named destination string
        return f"#{name}"

    def set_link(
        self,
        link: Optional[int] = None,
        y: float = 0,
        x: float = 0,
        page: int = -1,
        zoom: float | str = "null",
        name: Optional[str] = None,
    ) -> DestinationXYZ | str:
        """
        Defines the page and position a link points to.

        Args:
            link (int, optional): a link identifier returned by `FPDF.add_link()`.
                If None and name is provided, will create or update a named destination.
            y (float): optional ordinate of target position.
                The default value is 0 (top of page).
            x (float): optional abscissa of target position.
                The default value is 0 (top of page).
            page (int): optional number of target page.
                -1 indicates the current page, which is the default value.
            zoom (float): optional new zoom level after following the link.
                Currently ignored by Sumatra PDF Reader, but observed by Adobe Acrobat reader.
            name (str, optional): Name for the destination. If provided, creates or updates a named
                destination in the PDF that can be referenced from other parts of the document
                or from external documents.
        """
        # Handle named destination case
        if name and link is None:
            # Create the destination
            dest = DestinationXYZ(
                self.page if page == -1 else page,
                top=self.h_pt - y * self.k,
                left=x * self.k,
                zoom=zoom,
            )
            # Store it in the named destinations dictionary
            self.named_destinations[name] = dest
            # Return the name for reference
            return name

        # Regular link handling (backward compatibility)
        # We must take care to update the existing DestinationXYZ,
        # and NOT re-assign self.links[link] to a new instance,
        # as a reference to self.links[link] is kept in self.pages[].annots:
        assert link is not None
        destination = self.links[link]
        destination.page_number = self.page if page == -1 else page
        destination.top = self.h_pt - y * self.k
        destination.left = x * self.k
        destination.zoom = zoom

        # If a name is provided with an existing link, associate the name with this link
        if name:
            self.named_destinations[name] = destination
            return name

        # Return link index for backward compatibility
        return destination

    def link(
        self,
        x: float,
        y: float,
        w: float,
        h: float,
        link: str | int,
        alt_text: Optional[str] = None,
        **kwargs: Any,
    ) -> AnnotationDict:
        """
        Puts a link annotation on a rectangular area of the page.
        Text or image links are generally put via `FPDF.cell`,
        `FPDF.write` or `FPDF.image`,
        but this method can be useful for instance to define a clickable area inside an image.

        Args:
            x (float): horizontal position (from the left) to the left side of the link rectangle
            y (float): vertical position (from the top) to the bottom side of the link rectangle
            w (float): width of the link rectangle
            h (float): height of the link rectangle
            link: can be one of the following:
                - a URL string to create an external link
                - an integer returned by `FPDF.add_link`, defining an internal link to a page
                - a named destination string prefixed with '#' (e.g., '#chapter1')
            alt_text (str): optional textual description of the link, for accessibility purposes
            border_width (int): thickness of an optional black border surrounding the link.
                Not all PDF readers honor this: Acrobat renders it but not Sumatra.
        """
        action: Optional[URIAction] = None
        dest: Optional[PDFString | DestinationXYZ] = None
        if link:
            if isinstance(link, str):
                # Check if this is a named destination (prefixed with '#')
                if link.startswith("#"):
                    dest_name = link[1:]  # Remove the '#' prefix
                    # If the named destination doesn't exist yet, create a placeholder
                    # destination pointing to page 0 (which doesn't exist)
                    # This will be caught during output if never set properly
                    if dest_name not in self.named_destinations:
                        self.named_destinations[dest_name] = DestinationXYZ(
                            0, top=self.h_pt * self.k
                        )
                    # Use destination name instead of destination object for named destinations
                    dest = PDFString(dest_name, encrypt=True)
                else:
                    # Regular URL
                    action = URIAction(link)
            else:  # Dest type ending of annotation entry
                assert (
                    link in self.links
                ), f"Link with an invalid index: {link} (doc #links={len(self.links)})"
                dest = self.links[link]
                if not dest.page_number:
                    raise ValueError(
                        f"Cannot insert link {link} with no page number assigned"
                    )
        link_annot = AnnotationDict(
            "Link",
            x=x * self.k,
            y=self.h_pt - y * self.k,
            width=w * self.k,
            height=h * self.k,
            action=action,
            dest=dest,
            **kwargs,
        )
        self.pages[self.page].add_annotation(link_annot)
        if alt_text is not None:
            # Note: the spec indicates that a /StructParent could be added **inside* this /Annot,
            # but tests with Adobe Acrobat Reader reveal that the page /StructParents inserted below
            # is enough to link the marked content in the hierarchy tree with this annotation link.
            self._add_marked_content(struct_type="/Link", alt_text=alt_text)
        return link_annot

    def embed_file(
        self,
        file_path: Optional[Union[str, Path]] = None,
        bytes: Optional[bytes] = None,
        basename: Optional[str] = None,
        modification_date: Optional[datetime] = None,
        mime_type: Optional[str] = None,
        associated_file_relationship: Optional[str] = None,
        **kwargs: Any,
    ) -> PDFEmbeddedFile:
        """
        Embed a file into the PDF as an attachment (and, for PDF/A-3 or PDF/A-4f, as an
        Associated File).

        Args:
            file_path (str or Path): filesystem path to the existing file to embed
            bytes (bytes): optional, as an alternative to file_path, bytes content of the file to embed
            basename (str): optional, required if bytes is provided, file base name
            creation_date (datetime): date and time when the file was created
            modification_date (datetime): date and time when the file was last modified
            desc (str): optional description of the file
            mime_type: MIME type of the embedded content (e.g., "application/pdf", "text/csv", "image/png")
            associated_file_relationship: For PDF/A-3/A-4f, the AF relationship to declare in the FileSpec
                (e.g., "Data", "Source", "Alternative", "Supplement", or "Unspecified").

            **kwargs:
            desc (str): Optional human-readable description for the FileSpec.
            creation_date (datetime): Original creation time of the file.
            compress (bool): enabled zlib compression of the file - False by default
            checksum (bool): insert a MD5 checksum of the file content - False by default

        Returns: a PDFEmbeddedFile instance, with a .basename string attribute representing the internal file name
        """
        if file_path:
            if bytes:
                raise ValueError("'bytes' cannot be provided with 'file_path'")
            if basename:
                raise ValueError("'basename' cannot be provided with 'file_path'")
            file_path = Path(file_path)
            with file_path.open("rb") as input_file:
                bytes = input_file.read()
            basename = file_path.name
            stats = file_path.stat()
            if modification_date is None:
                modification_date = datetime.fromtimestamp(stats.st_mtime).astimezone()
        else:
            if not bytes:
                raise ValueError("'bytes' is required if 'file_path' is not provided")
            if not basename:
                raise ValueError(
                    "'basename' is required if 'file_path' is not provided"
                )
        if mime_type is None:
            mime_type = mimetypes.guess_type(basename)[0] or "application/octet-stream"
        mime_type = mime_type.lower()
        af_relationship = (
            AssociatedFileRelationship.coerce(associated_file_relationship)
            if associated_file_relationship is not None
            else None
        )
        already_embedded_basenames = set(
            file.basename() for file in self.embedded_files
        )
        if basename in already_embedded_basenames:
            raise ValueError(f"{basename} has already been embedded in this file")

        if self._compliance and self._compliance.profile == "PDFA":
            if self._compliance.part == 1:
                raise PDFAComplianceError(
                    f"Embedding files is not allowed for documents compliant with {self._compliance.label}"
                )
            if self._compliance.part == 2 or (
                self._compliance.part == 4 and self._compliance.conformance is None
            ):
                if (mime_type == "application/pdf") or basename.lower().endswith(
                    ".pdf"
                ):
                    LOGGER.warning(
                        "%s: ensure the embedded PDF '%s' is itself PDF/A to remain compliant.",
                        self._compliance.label,
                        basename,
                    )
                else:
                    raise PDFAComplianceError(
                        f"{self._compliance.label} permits embedding only PDF files, which must themselves be PDF/A."
                    )
            if self._compliance.part in (3, 4):
                if af_relationship is None:
                    af_relationship = AssociatedFileRelationship.UNSPECIFIED

        embedded_file = PDFEmbeddedFile(
            basename=basename,
            contents=bytes,
            modification_date=modification_date,
            mime_type=mime_type,
            af_relationship=af_relationship,
            **kwargs,
        )
        self.embedded_files.append(embedded_file)
        self._set_min_pdf_version("1.4")
        return embedded_file

    @check_page
    def file_attachment_annotation(
        self,
        file_path: str | Path,
        x: float,
        y: float,
        w: float = 1,
        h: float = 1,
        name: Optional[FileAttachmentAnnotationName | str] = None,
        flags: tuple[AnnotationFlag | str, ...] = DEFAULT_ANNOT_FLAGS,
        **kwargs: Any,
    ) -> AnnotationDict:
        """
        Puts a file attachment annotation on a rectangular area of the page.

        Args:
            file_path (str or Path): filesystem path to the existing file to embed
            x (float): horizontal position (from the left) to the left side of the link rectangle
            y (float): vertical position (from the top) to the bottom side of the link rectangle
            w (float): optional width of the link rectangle
            h (float): optional height of the link rectangle
            name (fpdf.enums.FileAttachmentAnnotationName, str): optional icon that shall be used in displaying the annotation
            flags (Tuple[fpdf.enums.AnnotationFlag], Tuple[str]): optional list of flags defining annotation properties
            bytes (bytes): optional, as an alternative to file_path, bytes content of the file to embed
            basename (str): optional, required if bytes is provided, file base name
            creation_date (datetime): date and time when the file was created
            modification_date (datetime): date and time when the file was last modified
            desc (str): optional description of the file
            compress (bool): enabled zlib compression of the file - False by default
            checksum (bool): insert a MD5 checksum of the file content - False by default
        """
        embedded_file = self.embed_file(file_path, **kwargs)
        # Attachment annotations should not be listed in the document-level AF entry
        # (they are reachable through the annotation itself), so keep them out of AF:
        embedded_file.set_globally_enclosed(False)
        annotation = AnnotationDict(
            "FileAttachment",
            x * self.k,
            self.h_pt - y * self.k,
            w * self.k,
            h * self.k,
            file_spec=embedded_file.file_spec(),
            name=FileAttachmentAnnotationName.coerce(name) if name else None,
            flags=flags,
        )
        self.pages[self.page].add_annotation(annotation)
        return annotation

    @check_page
    def text_annotation(
        self,
        x: float,
        y: float,
        text: str,
        w: float = 1,
        h: float = 1,
        name: Optional[AnnotationName | str] = None,
        **kwargs: Any,
    ) -> AnnotationDict:
        """
        Puts a text annotation on a rectangular area of the page.

        Args:
            x (float): horizontal position (from the left) to the left side of the link rectangle
            y (float): vertical position (from the top) to the bottom side of the link rectangle
            text (str): text to display
            w (float): optional width of the link rectangle
            h (float): optional height of the link rectangle
            name (fpdf.enums.AnnotationName, str): optional icon that shall be used in displaying the annotation
            flags (Tuple[fpdf.enums.AnnotationFlag], Tuple[str]): optional list of flags defining annotation properties
            title (str): the text label that shall be displayed in the title bar of the annotation‚Äôs
                pop-up window when open and active. This entry shall identify the user who added the annotation.
        """
        annotation = AnnotationDict(
            "Text",
            x * self.k,
            self.h_pt - y * self.k,
            w * self.k,
            h * self.k,
            contents=text,
            name=AnnotationName.coerce(name) if name else None,
            **kwargs,
        )
        self.pages[self.page].add_annotation(annotation)
        return annotation

    @check_page
    def free_text_annotation(
        self,
        text: str,
        x: Optional[float] = None,
        y: Optional[float] = None,
        w: Optional[float] = None,
        h: Optional[float] = None,
        **kwargs: Any,
    ) -> AnnotationDict:
        """
        Puts a free text annotation on a rectangular area of the page.

        Args:
            text (str): text to display
            x (float): optional horizontal position (from the left) to the left side of the link rectangle.
                Default value: None, meaning the current abscissa is used
            y (float): vertical position (from the top) to the bottom side of the link rectangle.
                Default value: None, meaning the current ordinate is used
            w (float): optional width of the link rectangle. Default value: None, meaning the length of text in user unit
            h (float): optional height of the link rectangle. Default value: None, meaning an height equal
                to the current font size
            flags (Tuple[fpdf.enums.AnnotationFlag], Tuple[str]): optional list of flags defining annotation properties
            color (tuple): a tuple of numbers in the range 0.0 to 1.0, representing a colour used for the annotation background
            border_width (float): width of the annotation border
        """
        if not self.font_family:
            raise FPDFException("No font set, you need to call set_font() beforehand")
        if not self.current_font_is_set_on_page:
            assert self.current_font is not None
            self._out(self._set_font_for_page(self.current_font, self.font_size_pt))
        if x is None:
            x = self.x
        if y is None:
            y = self.y
        if h is None:
            h = self.font_size
        if w is None:
            w = self.get_string_width(text, normalized=True, markdown=False)

        assert self.draw_color is not None and self.current_font is not None
        annotation = AnnotationDict(
            "FreeText",
            x * self.k,
            self.h_pt - y * self.k,
            w * self.k,
            h * self.k,
            contents=text,
            default_appearance=f"({self.draw_color.serialize()} /F{self.current_font.i} {self.font_size_pt:.2f} Tf)",
            **kwargs,
        )
        self.pages[self.page].add_annotation(annotation)
        return annotation

    @check_page
    def add_action(
        self, action: Action, x: float, y: float, w: float, h: float, **kwargs: Any
    ) -> AnnotationDict:
        """
        Puts an Action annotation on a rectangular area of the page.

        Args:
            action (fpdf.actions.Action): the action to add
            x (float): horizontal position (from the left) to the left side of the link rectangle
            y (float): vertical position (from the top) to the bottom side of the link rectangle
            w (float): width of the link rectangle
            h (float): height of the link rectangle
        """
        annotation_action_type = "Action"
        if isinstance(action, GoToAction):
            annotation_action_type = "Link"
        annotation = AnnotationDict(
            annotation_action_type,
            x * self.k,
            self.h_pt - y * self.k,
            w * self.k,
            h * self.k,
            action=action,
            **kwargs,
        )
        self.pages[self.page].add_annotation(annotation)
        return annotation

    @contextmanager
    def highlight(
        self,
        text: str,
        type: TextMarkupType | str = "Highlight",
        color: tuple[float, float, float] = (1, 1, 0),
        modification_time: Optional[datetime] = None,
        **kwargs: Any,
    ) -> Iterator[None]:
        """
        Context manager that adds a single highlight annotation based on the text lines inserted
        inside its indented block.

        Args:
            text (str): text of the annotation
            title (str): the text label that shall be displayed in the title bar of the annotation‚Äôs
                pop-up window when open and active. This entry shall identify the user who added the annotation.
            type (fpdf.enums.TextMarkupType, str): "Highlight", "Underline", "Squiggly" or "StrikeOut".
            color (tuple): a tuple of numbers in the range 0.0 to 1.0, representing a colour used for
                the title bar of the annotation‚Äôs pop-up window. Defaults to yellow.
            modification_time (datetime): date and time when the annotation was most recently modified
        """
        if self._record_text_quad_points:
            raise FPDFException("highlight() cannot be nested")
        self._record_text_quad_points = True
        yield
        for page, quad_points in self._text_quad_points.items():
            self.add_text_markup_annotation(
                type,
                text,
                quad_points=quad_points,
                modification_time=modification_time,
                page=page,
                color=color,
                **kwargs,
            )
        self._text_quad_points = defaultdict(list)
        self._record_text_quad_points = False

    @contextmanager
    def add_highlight(self, *args: Any, **kwargs: Any) -> Iterator[None]:
        warnings.warn(
            "add_highlight() has been renamed to highlight() in v2.5.5.",
            DeprecationWarning,
            stacklevel=get_stack_level(),
        )
        with self.highlight(*args, **kwargs):
            yield

    @check_page
    def add_text_markup_annotation(
        self,
        type: TextMarkupType | str,
        text: str,
        quad_points: Sequence[float],
        color: tuple[float, float, float] = (1, 1, 0),
        modification_time: Optional[datetime] = None,
        page: Optional[int] = None,
        **kwargs: Any,
    ) -> AnnotationDict:
        """
        Adds a text markup annotation on some quadrilateral areas of the page.

        Args:
            type (fpdf.enums.TextMarkupType, str): "Highlight", "Underline", "Squiggly" or "StrikeOut"
            text (str): text of the annotation
            quad_points (tuple): array of 8 √ó n numbers specifying the coordinates of n quadrilaterals
                in default user space that comprise the region in which the link should be activated.
                The coordinates for each quadrilateral are given in the order: x1 y1 x2 y2 x3 y3 x4 y4
                specifying the four vertices of the quadrilateral in counterclockwise order
            title (str): the text label that shall be displayed in the title bar of the annotation‚Äôs
                pop-up window when open and active. This entry shall identify the user who added the annotation.
            color (tuple): a tuple of numbers in the range 0.0 to 1.0, representing a colour used for
                the title bar of the annotation‚Äôs pop-up window. Defaults to yellow.
            modification_time (datetime): date and time when the annotation was most recently modified
            page (int): index of the page where this annotation is added
        """
        self._set_min_pdf_version("1.6")
        type = TextMarkupType.coerce(type).value
        if modification_time is None:
            modification_time = self.creation_date
        if page is None:
            page = self.page
        x_min = min(quad_points[0::2])
        y_min = min(quad_points[1::2])
        x_max = max(quad_points[0::2])
        y_max = max(quad_points[1::2])
        annotation = AnnotationDict(
            type,
            contents=text,
            x=y_min,
            y=y_max,
            width=x_max - x_min,
            height=y_max - y_min,
            modification_time=modification_time,
            quad_points=quad_points,
            color=color,
            **kwargs,
        )
        self.pages[page].add_annotation(annotation)
        return annotation

    @check_page
    def ink_annotation(
        self,
        coords: Sequence[tuple[float, float]],
        text: str = "",
        color: tuple[float, float, float] = (1, 1, 0),
        border_width: float = 1,
        **kwargs: Any,
    ) -> AnnotationDict:
        """
        Adds add an ink annotation on the page.

        Args:
            coords (tuple): an iterable of coordinates (pairs of numbers) defining a path
            text (str): textual description
            title (str): the text label that shall be displayed in the title bar of the annotation‚Äôs
                pop-up window when open and active. This entry shall identify the user who added the annotation.
            color (tuple): a tuple of numbers in the range 0.0 to 1.0, representing a colour used for
                the title bar of the annotation‚Äôs pop-up window. Defaults to yellow.
            border_width (float): thickness of the path stroke.
        """
        ink_list = sum(((x * self.k, (self.h - y) * self.k) for (x, y) in coords), ())
        x_min = min(ink_list[0::2])
        y_min = min(ink_list[1::2])
        x_max = max(ink_list[0::2])
        y_max = max(ink_list[1::2])
        annotation = AnnotationDict(
            "Ink",
            x=y_min,
            y=y_max,
            width=x_max - x_min,
            height=y_max - y_min,
            ink_list=ink_list,
            contents=text,
            border_width=border_width,
            color=color,
            **kwargs,
        )
        self.pages[self.page].add_annotation(annotation)
        return annotation

    @check_page
    @support_deprecated_txt_arg
    def text(self, x: float, y: float, text: str = "") -> None:
        """
        Prints a character string. The origin is on the left of the first character,
        on the baseline. This method allows placing a string precisely on the page,
        but it is usually easier to use the `FPDF.cell()`, `FPDF.multi_cell() or `FPDF.write()` methods.

        Args:
            x (float): abscissa of the origin
            y (float): ordinate of the origin
            text (str): string to print
            txt (str): [**DEPRECATED since v2.7.6**] string to print

        Notes
        -----

        `text()` lacks many of the features available in `FPDF.write()`,
        `FPDF.cell()` and `FPDF.multi_cell()` like markdown and text shaping.
        """
        if not self.font_family:
            raise FPDFException("No font set, you need to call set_font() beforehand")
        text = self.normalize_text(text)
        assert self.current_font is not None
        if not self.current_font_is_set_on_page:
            self._out(self._set_font_for_page(self.current_font, self.font_size_pt))
        sl = [f"BT {x * self.k:.2f} {(self.h - y) * self.k:.2f} Td"]
        if self.text_mode != TextMode.FILL:
            sl.append(f" {self.text_mode} Tr {self.line_width:.2f} w")
        sl.append(f"{self.current_font.encode_text(text)} ET")
        if (
            text != "" and (self.underline or self.strikethrough)
        ) or self._record_text_quad_points:
            w = self.get_string_width(text, normalized=True, markdown=False)
            if text != "":
                if self.underline:
                    sl.append(self._do_underline(x, y, w))
                if self.strikethrough:
                    sl.append(self._do_strikethrough(x, y, w))
            if self._record_text_quad_points:
                h = self.font_size
                y -= 0.8 * h  # same coefficient as in _render_styled_text_line()
                self._add_quad_points(x, y, w, h)
        attr_l: list[str] = []
        if self.fill_color != self.text_color:
            assert self.text_color is not None
            attr_l.append(f"{self.text_color.serialize().lower()}")
        if attr_l:
            sl = ["q"] + attr_l + sl + ["Q"]
        self._out(" ".join(sl))

    @check_page
    def rotate(
        self, angle: float, x: Optional[float] = None, y: Optional[float] = None
    ) -> None:
        """
        .. deprecated:: 2.1.0
            Use `FPDF.rotation()` instead.
        """
        warnings.warn(
            (
                "rotate() can produces malformed PDFs and is deprecated since v2.1.0. "
                "It will be removed in a future release. "
                "Use the rotation() context manager instead."
            ),
            DeprecationWarning,
            stacklevel=get_stack_level(),
        )
        if x is None:
            x = self.x
        if y is None:
            y = self.y

        if self._angle != 0:
            self._out("Q")
        self._angle = angle
        if angle != 0:
            angle *= math.pi / 180
            c = math.cos(angle)
            s = math.sin(angle)
            cx = x * self.k
            cy = (self.h - y) * self.k
            output = (
                f"q {c:.5F} {s:.5F} {-s:.5F} {c:.5F} {cx:.2F} {cy:.2F} cm "
                f"1 0 0 1 {-cx:.2F} {-cy:.2F} cm"
            )
            self._out(output)

    @check_page
    @contextmanager
    def rotation(
        self, angle: float, x: Optional[float] = None, y: Optional[float] = None
    ) -> Iterator[None]:
        """
        Method to perform a rotation around a given center.
        It must be used as a context-manager using `with`:

            with rotation(angle=90, x=x, y=y):
                pdf.something()

        The rotation affects all elements which are printed inside the indented
        context (with the exception of clickable areas).

        Args:
            angle (float): angle in degrees
            x (float): abscissa of the center of the rotation
            y (float): ordinate of the center of the rotation

        Notes
        -----

        Only the rendering is altered. The `FPDF.get_x()` and `FPDF.get_y()` methods are
        not affected, nor the automatic page break mechanism.
        The rotation also establishes a local graphics state, so that any
        graphics state settings changed within will not affect the operations
        invoked after it has finished.
        """
        if x is None:
            x = self.x
        if y is None:
            y = self.y
        angle *= math.pi / 180
        c, s = math.cos(angle), math.sin(angle)
        cx, cy = x * self.k, (self.h - y) * self.k
        with self.local_context():
            self._out(
                f"{c:.5F} {s:.5F} {-s:.5F} {c:.5F} {cx:.2F} {cy:.2F} cm "
                f"1 0 0 1 {-cx:.2F} {-cy:.2F} cm"
            )
            yield

    @check_page
    @contextmanager
    def skew(
        self,
        ax: float = 0,
        ay: float = 0,
        x: Optional[float] = None,
        y: Optional[float] = None,
    ) -> Iterator[None]:
        """
        Method to perform a skew transformation originating from a given center.
        It must be used as a context-manager using `with`:

            with skew(ax=15, ay=15, x=x, y=y):
                pdf.something()

        The skew transformation affects all elements which are printed inside the indented
        context (with the exception of clickable areas).

        Args:
            ax (float): angle of skew in the horizontal direction in degrees
            ay (float): angle of skew in the vertical direction in degrees
            x (float): abscissa of the center of the skew transformation
            y (float): ordinate of the center of the skew transformation
        """
        lim_val = 2**32
        if x is None:
            x = self.x
        if y is None:
            y = self.y
        ax = max(min(math.tan(ax * (math.pi / 180)), lim_val), -lim_val)
        ay = max(min(math.tan(ay * (math.pi / 180)), lim_val), -lim_val)
        cx, cy = x * self.k, (self.h - y) * self.k
        with self.local_context():
            self._out(
                f"1 {ay:.5f} {ax:.5f} 1 {cx:.2f} {cy:.2f} cm "
                f"1 0 0 1 -{cx:.2f} -{cy:.2f} cm"
            )
            yield

    @check_page
    @contextmanager
    def mirror(
        self, origin: tuple[float, float], angle: Angle | str | float
    ) -> Iterator[None]:
        """
        Method to perform a reflection transformation over a given mirror line.
        It must be used as a context-manager using `with`:

            with mirror(origin=(15,15), angle="SOUTH"):
                pdf.something()

        The mirror transformation affects all elements which are rendered inside the indented
        context (with the exception of clickable areas).

        Args:
            origin (float, Sequence(float, float)): a point on the mirror line
            angle: (fpdf.enums.Angle): the direction of the mirror line
        """
        x, y = origin

        try:
            if isinstance(angle, (str, Angle)):
                theta = float(Angle.coerce(angle).value)
            else:
                theta = float(angle)
        except ValueError:
            theta = float(angle)

        a = math.cos(math.radians(theta * 2))
        b = math.sin(math.radians(theta * 2))
        cx, cy = x * self.k, (self.h - y) * self.k

        with self.local_context():
            self._out(
                f"{a:.5f} {b:.5f} {b:.5f} {a*-1:.5f} {cx:.2f} {cy:.2f} cm "
                f"1 0 0 1 -{cx:.2f} -{cy:.2f} cm"
            )
            yield

    @check_page
    @contextmanager
    def local_context(self, **kwargs: Any) -> Iterator[None]:
        """
        Creates a local graphics state, which won't affect the surrounding code.
        This method must be used as a context manager using `with`:

            with pdf.local_context():
                set_some_state()
                draw_some_stuff()

        The affected settings are those controlled by GraphicsStateMixin and drawing.GraphicsStyle:

        * allow_transparency
        * auto_close
        * blend_mode
        * char_vpos
        * char_spacing
        * dash_pattern
        * denom_lift
        * denom_scale
        * draw_color
        * fill_color
        * fill_opacity
        * font_family
        * font_size
        * font_size_pt
        * font_style
        * font_stretching
        * intersection_rule
        * line_width
        * nom_lift
        * nom_scale
        * paint_rule
        * strikethrough
        * stroke_cap_style
        * stroke_join_style
        * stroke_miter_limit
        * stroke_opacity
        * sub_lift
        * sub_scale
        * sup_lift
        * sup_scale
        * text_color
        * text_mode
        * text_shaping
        * underline

        Font size can be specified in document units with `font_size` or in points with `font_size_pt`.

        Args:
            **kwargs: key-values settings to set at the beginning of this context.
        """
        if self._in_unbreakable:
            raise FPDFException(
                "cannot create a local context inside an unbreakable() code block"
            )
        self._push_local_stack()
        self._start_local_context(**kwargs)
        yield
        self._end_local_context()
        self._pop_local_stack()

    def _start_local_context(
        self,
        font_family: Optional[str] = None,
        font_style: Optional[str] = None,
        font_size_pt: Optional[float] = None,
        line_width: Optional[float] = None,
        draw_color: Optional[ColorInput] = None,
        fill_color: Optional[ColorInput] = None,
        text_color: Optional[ColorInput] = None,
        dash_pattern: Optional[
            Union[tuple[float, float, float], dict[str, float]]
        ] = None,
        **kwargs: Any,
    ) -> None:
        """
        This method starts a "q/Q" context in the page content stream,
        and inserts operators in it to initialize all the PDF settings specified.
        """
        if "font_size" in kwargs:
            # At some point we may want to deprecate font_size here in favour of font_size_pt,
            # and raise a warning if font_size is provided:
            # * font_size_pt is more consistent with the size parameter of .set_font(), provided in points.
            # * font_size can be misused, as users may not be aware of the difference between the 2 properties,
            #   and may erroneously provide a value in points as font_size.
            if font_size_pt is not None:
                raise ValueError("font_size & font_size_pt cannot be both provided")
            font_size_pt = kwargs["font_size"] * self.k
            del kwargs["font_size"]
        gs = None
        for key, value in kwargs.items():
            if key in (
                "stroke_color",
                "stroke_dash_phase",
                "stroke_dash_pattern",
                "stroke_width",
            ):
                raise ValueError(
                    f"Unsupported setting: {key} - This can be controlled through dash_pattern / draw_color / line_width"
                )
            if key in GraphicsStyle.MERGE_PROPERTIES:
                if gs is None:
                    gs = GraphicsStyle()
                setattr(gs, key, value)
                if key == "blend_mode":
                    self._set_min_pdf_version("1.4")
            elif key in (
                "char_vpos",
                "char_spacing",
                "current_font",
                "denom_lift",
                "denom_scale",
                "font_stretching",
                "nom_lift",
                "nom_scale",
                "strikethrough",
                "sub_lift",
                "sub_scale",
                "sup_lift",
                "sup_scale",
                "text_mode",
                "text_shaping",
                "underline",
                "current_font_is_set_on_page",
            ):
                setattr(self, key, value)
            else:
                raise ValueError(f"Unsupported setting: {key}")
        if gs:
            gs_name = self._resource_catalog.register_graphics_style(gs)
            assert gs_name is not None
            self._resource_catalog.add(PDFResourceType.EXT_G_STATE, gs_name, self.page)
            self._out(f"q /{gs_name} gs")
        else:
            self._out("q")
        # All the following calls to .set*() methods invoke .out() and write to the stream buffer:
        if (
            font_family is not None
            or font_style is not None
            or font_size_pt is not None
        ):
            self.set_font(
                font_family or self.font_family,
                # Beware: font_style='' must be handled distinctly from font_style=None
                self.font_style if font_style is None else font_style,
                font_size_pt or self.font_size_pt,
            )
        if line_width is not None:
            self.set_line_width(line_width)
        if draw_color is not None:
            self.set_draw_color(draw_color)
        if fill_color is not None:
            self.set_fill_color(fill_color)
        if text_color is not None:
            self.set_text_color(text_color)
        if dash_pattern is not None:
            if isinstance(dash_pattern, dict):
                self.set_dash_pattern(
                    dash_pattern.get("dash", 0),
                    dash_pattern.get("gap", 0),
                    dash_pattern.get("phase", 0),
                )
            else:
                self.set_dash_pattern(dash_pattern[0], dash_pattern[1], dash_pattern[2])

    def _end_local_context(self) -> None:
        """
        This method ends a "q/Q" context in the page content stream.
        """
        self._out("Q")

    @property
    def accept_page_break(self) -> bool:
        """
        Whenever a page break condition is met, this `@property` method is called,
        and the break is issued or not depending on the returned value.

        The default implementation returns `self.auto_page_break`,
        a value according to the mode selected by `FPDF.set_auto_page_break()`.

        This method is called automatically and should not be called directly by the application.

        Detailed documentation on page breaks: https://py-pdf.github.io/fpdf2/PageBreaks.html
        """
        return self.auto_page_break

    @check_page
    @support_deprecated_txt_arg
    def cell(
        self,
        w: Optional[float] = None,
        h: Optional[float] = None,
        text: str = "",
        border: Literal[0, 1] | str = 0,
        ln: Literal["DEPRECATED"] = "DEPRECATED",
        align: str | Align = Align.L,
        fill: bool = False,
        link: Optional[str | int] = "",
        center: bool = False,
        markdown: bool = False,
        new_x: str | XPos = XPos.RIGHT,
        new_y: str | YPos = YPos.TOP,
    ) -> bool:
        """
        Prints a cell (rectangular area) with optional borders, background color and
        character string. The upper-left corner of the cell corresponds to the current
        position. The text can be aligned or centered. After the call, the current
        position moves to the selected `new_x`/`new_y` position. It is possible to put a link
        on the text. A cell has an horizontal padding, on the left & right sides, defined by
        the.c_margin property.

        If automatic page breaking is enabled and the cell goes beyond the limit, a
        page break is performed before outputting.

        Args:
            w (float): Cell width. Default value: None, meaning to fit text width.
                If 0, the cell extends up to the right margin.
            h (float): Cell height. Default value: None, meaning an height equal
                to the current font size.
            text (str): String to print. Default value: empty string.
            border: Indicates if borders must be drawn around the cell.
                The value can be either a number (`0`: no border ; `1`: frame)
                or a string containing some or all of the following characters
                (in any order):
                `L`: left ; `T`: top ; `R`: right ; `B`: bottom. Default value: 0.
            new_x (fpdf.enums.XPos, str): New current position in x after the call. Default: RIGHT
            new_y (fpdf.enums.YPos, str): New current position in y after the call. Default: TOP
            ln (int): **DEPRECATED since 2.5.1**: Use `new_x` and `new_y` instead.
            align (fpdf.enums.Align, str): Set text alignment inside the cell.
                Possible values are: `L` or empty string: left align (default value) ;
                `C`: center; `X`: center around current x position; `R`: right align
            fill (bool): Indicates if the cell background must be painted (`True`)
                or transparent (`False`). Default value: False.
            link (str): optional link to add on the cell, internal
                (identifier returned by `FPDF.add_link`) or external URL.
            center (bool): center the cell horizontally on the page.
            markdown (bool): enable minimal markdown-like markup to render part
                of text as bold / italics / strikethrough / underlined.
                Supports `\\` as escape character. Default to False.
            txt (str): [**DEPRECATED since v2.7.6**] String to print. Default value: empty string.

        Returns: a boolean indicating if page break was triggered
        """
        if not self.font_family:
            raise FPDFException("No font set, you need to call set_font() beforehand")
        if isinstance(w, str) or isinstance(h, str):
            raise ValueError(
                "Parameter 'w' and 'h' must be numbers, not strings."
                " You can omit them by passing string content with text="
            )
        if isinstance(border, int) and border not in (0, 1):
            warnings.warn(
                'Integer values for "border" parameter other than 1 are currently ignored',
                stacklevel=get_stack_level(),
            )
            border = 1
        new_x = XPos.coerce(new_x)
        new_y = YPos.coerce(new_y)
        align = Align.coerce(align)
        if align == Align.J:
            raise ValueError(
                "cell() only produces one text line, justified alignment is not possible"
            )
        if ln != "DEPRECATED":
            # For backwards compatibility, if "ln" is used we overwrite "new_[xy]".
            if ln == 0:
                new_x = XPos.RIGHT
                new_y = YPos.TOP
            elif ln == 1:
                new_x = XPos.LMARGIN
                new_y = YPos.NEXT
            elif ln == 2:
                new_x = XPos.LEFT
                new_y = YPos.NEXT
            else:
                raise ValueError(
                    f'Invalid value for parameter "ln" ({ln}),'
                    " must be an int between 0 and 2."
                )
            warnings.warn(
                (
                    'The parameter "ln" is deprecated since v2.5.2.'
                    f" Instead of ln={ln} use new_x=XPos.{new_x.name}, new_y=YPos.{new_y.name}."
                ),
                DeprecationWarning,
                stacklevel=get_stack_level(),
            )
        # Font styles preloading must be performed before any call to FPDF.get_string_width:
        text = self.normalize_text(text)
        styled_txt_frags = (
            self._preload_bidirectional_text(text, markdown)
            if self.text_shaping
            else self._preload_font_styles(text, markdown)
        )
        line_height = self.font_size if h is None else h
        return self._render_styled_text_line(
            TextLine(
                styled_txt_frags,
                text_width=0,
                number_of_spaces=0,
                align=align,
                height=line_height,
                max_width=w,
                trailing_nl=False,
            ),
            line_height,
            border,
            new_x=new_x,
            new_y=new_y,
            fill=fill,
            link=link,
            center=center,
            prevent_font_change=markdown,
        )

    def _render_styled_text_line(
        self,
        text_line: TextLine,
        h: Optional[float] = None,
        border: Union[str, int] = 0,
        new_x: XPos = XPos.RIGHT,
        new_y: YPos = YPos.TOP,
        fill: bool = False,
        link: Optional[str | int] = "",
        center: bool = False,
        padding: Optional[Padding] = None,
        prevent_font_change: bool = False,
    ) -> bool:
        """
        Prints a cell (rectangular area) with optional borders, background color and
        character string. The upper-left corner of the cell corresponds to the current
        position. The text can be aligned, centered or justified. After the call, the
        current position moves to the requested new position. It is possible to put a
        link on the text.

        If automatic page breaking is enabled and the cell goes beyond the limit, a
        page break is performed before outputting.

        Args:
            text_line (TextLine instance): Contains the (possibly empty) tuple of
                fragments to render.
            h (float): Cell height. Default value: None, meaning an height equal
                to the current font size.
            border: Indicates if borders must be drawn around the cell.
                The value can be either a number (`0`: no border ; `1`: frame)
                or a string containing some or all of the following characters
                (in any order):
                `L`: left ; `T`: top ; `R`: right ; `B`: bottom. Default value: 0.
            new_x (fpdf.enums.XPos): New current position in x after the call.
            new_y (fpdf.enums.YPos): New current position in y after the call.
            fill (bool): Indicates if the cell background must be painted (`True`)
                or transparent (`False`). Default value: False.
            link (str): optional link to add on the cell, internal
                (identifier returned by `FPDF.add_link`) or external URL.
            center (bool): center the cell horizontally on the page.
            padding (Padding or None): optional padding to apply to the cell content.
                If padding for left and right is non-zero then c_margin is ignored.
            prevent_font_change (bool): ensure no font settings (family / size / style)
                change during this call.

        Returns: a boolean indicating if page break was triggered
        """
        if isinstance(border, int) and border not in (0, 1):
            warnings.warn(
                'Integer values for "border" parameter other than 1 are currently ignored',
                stacklevel=get_stack_level(),
            )
            border = 1
        elif isinstance(border, str) and set(border).issuperset("LTRB"):
            border = 1

        if padding is None:
            padding = Padding(0, 0, 0, 0)
        l_c_margin = r_c_margin = float(0)
        if padding.left == 0:
            l_c_margin = self.c_margin
        if padding.right == 0:
            r_c_margin = self.c_margin

        styled_txt_width = text_line.text_width
        if not styled_txt_width:
            for i, frag in enumerate(text_line.fragments):
                unscaled_width = frag.get_width(initial_cs=i != 0)
                styled_txt_width += unscaled_width

        w = text_line.max_width
        if w is None:
            if not text_line.fragments:
                raise ValueError(
                    "'text_line' must have fragments if 'text_line.text_width' is None"
                )
            w = styled_txt_width + l_c_margin + r_c_margin
        elif w == 0:
            w = self.w - self.r_margin - self.x
        if center:
            self.x = self.l_margin + (self.epw - w) / 2
        elif text_line.align == Align.X:
            self.x -= w / 2

        max_font_size: float = 0  # how much height we need to accommodate.
        # currently all font sizes within a line are vertically aligned on the baseline.
        fragments = text_line.get_ordered_fragments()
        for frag in fragments:
            if frag.font_size > max_font_size:
                max_font_size = frag.font_size
        if h is None:
            h = max_font_size
        page_break_triggered = self._perform_page_break_if_need_be(h)
        sl: list[str] = []

        k = self.k

        # pre-calc border edges with padding

        left = (self.x - padding.left) * k
        right = (self.x + w + padding.right) * k
        top = (self.h - self.y + padding.top) * k
        bottom = (self.h - (self.y + h) - padding.bottom) * k

        if fill:
            op = "B" if border == 1 else "f"
            sl.append(f"{left:.2f} {top:.2f} {right-left:.2f} {bottom-top:.2f} re {op}")
        elif border == 1:
            sl.append(f"{left:.2f} {top:.2f} {right-left:.2f} {bottom-top:.2f} re S")
        # pylint: enable=invalid-unary-operand-type

        if isinstance(border, str):
            if "L" in border:
                sl.append(f"{left:.2f} {top:.2f} m {left:.2f} {bottom:.2f} l S")
            if "T" in border:
                sl.append(f"{left:.2f} {top:.2f} m {right:.2f} {top:.2f} l S")
            if "R" in border:
                sl.append(f"{right:.2f} {top:.2f} m {right:.2f} {bottom:.2f} l S")
            if "B" in border:
                sl.append(f"{left:.2f} {bottom:.2f} m {right:.2f} {bottom:.2f} l S")

        if self._record_text_quad_points:
            self._add_quad_points(self.x, self.y, w, h)

        s_start = self.x
        s_width: float = 0
        # We try to avoid modifying global settings for temporary changes.
        current_ws = frag_ws = 0.0
        current_lift = 0.0
        current_char_vpos = CharVPos.LINE
        current_font = self.current_font
        current_font_size_pt = self.font_size_pt
        current_font_style = self.font_style
        current_text_mode = self.text_mode
        current_font_stretching = self.font_stretching
        current_char_spacing = self.char_spacing
        fill_color_changed = False
        last_used_color = self.fill_color
        if fragments:
            if text_line.align == Align.R:
                dx = w - l_c_margin - styled_txt_width
            elif text_line.align in [Align.C, Align.X]:
                dx = (w - styled_txt_width) / 2
            else:
                dx = l_c_margin
            s_start += dx
            word_spacing: float = 0
            if text_line.align == Align.J and text_line.number_of_spaces:
                word_spacing = (
                    w - l_c_margin - r_c_margin - styled_txt_width
                ) / text_line.number_of_spaces
            sl.append(
                f"BT {(self.x + dx) * k:.2f} "
                f"{(self.h - self.y - 0.5 * h - 0.3 * max_font_size) * k:.2f} Td"
            )
            underlines: list[tuple[float, float, CoreFont | TTFFont, float]] = []
            strikethroughs: list[tuple[float, float, CoreFont | TTFFont, float]] = []
            for i, frag in enumerate(fragments):
                if isinstance(frag, TotalPagesSubstitutionFragment):
                    self.pages[self.page].add_text_substitution(frag)
                if frag.text_color != last_used_color:
                    # allow to change color within the line of text.
                    last_used_color = frag.text_color
                    assert last_used_color is not None
                    sl.append(last_used_color.serialize().lower())
                    fill_color_changed = True
                if word_spacing and frag.font_stretching != 100:
                    # Space character is already stretched, extra spacing is absolute.
                    frag_ws = word_spacing * 100 / frag.font_stretching
                else:
                    frag_ws = word_spacing
                if current_font_stretching != frag.font_stretching:
                    current_font_stretching = frag.font_stretching
                    sl.append(f"{frag.font_stretching:.2f} Tz")
                if current_char_spacing != frag.char_spacing:
                    current_char_spacing = frag.char_spacing
                    sl.append(f"{frag.char_spacing:.2f} Tc")
                if not self.current_font_is_set_on_page:
                    if prevent_font_change:
                        # This is "local" to the current BT / ET context:
                        current_font = frag.font
                        current_font_size_pt = frag.font_size_pt
                        current_font_style = frag.font_style
                        sl.append(f"/F{current_font.i} {current_font_size_pt:.2f} Tf")
                        self._resource_catalog.add(
                            PDFResourceType.FONT, current_font.i, self.page
                        )
                        current_char_vpos = frag.char_vpos
                    else:
                        # This is "global" to the page,
                        # as it is rendered in the content stream
                        # BEFORE the text_lines /fragments,
                        # wrapped into BT / ET operators:
                        current_font = self.current_font = frag.font
                        current_font_size_pt = self.font_size_pt = frag.font_size_pt
                        current_font_style = self.font_style = frag.font_style
                        self._out(
                            self._set_font_for_page(
                                current_font,
                                current_font_size_pt,
                            )
                        )
                        current_char_vpos = frag.char_vpos
                elif (
                    current_font != frag.font
                    or current_font_size_pt != frag.font_size_pt
                    or current_font_style != frag.font_style
                    or current_char_vpos != frag.char_vpos
                ):
                    # This is "local" to the current BT / ET context:
                    current_font = frag.font
                    current_font_size_pt = frag.font_size_pt
                    current_font_style = frag.font_style
                    sl.append(
                        self._set_font_for_page(
                            current_font,
                            current_font_size_pt,
                            wrap_in_text_object=False,
                        )
                    )
                    current_char_vpos = frag.char_vpos
                lift = frag.lift
                if lift != current_lift:
                    # Use text rise operator:
                    sl.append(f"{lift:.2f} Ts")
                    current_lift = lift
                if (
                    frag.text_mode != TextMode.FILL
                    or frag.text_mode != current_text_mode
                ):
                    current_text_mode = frag.text_mode
                    sl.append(f"{frag.text_mode} Tr {frag.line_width:.2f} w")

                r_text = frag.render_pdf_text(
                    frag_ws,
                    current_ws,
                    word_spacing,
                    self.x + dx + s_width,
                    self.y + (0.5 * h + 0.3 * max_font_size),
                    self.h,
                )
                if r_text:
                    sl.append(r_text)

                frag_width = frag.get_width(
                    initial_cs=i != 0
                ) + word_spacing * frag.characters.count(" ")
                if frag.underline:
                    underlines.append(
                        (self.x + dx + s_width, frag_width, frag.font, frag.font_size)
                    )
                if frag.strikethrough:
                    strikethroughs.append(
                        (self.x + dx + s_width, frag_width, frag.font, frag.font_size)
                    )
                if frag.link:
                    self.link(
                        x=self.x + dx + s_width,
                        y=self.y + (0.5 * h) - (0.5 * frag.font_size),
                        w=frag_width,
                        h=frag.font_size,
                        link=frag.link,
                    )
                if not frag.is_ttf_font:
                    current_ws = frag_ws
                s_width += frag_width

            sl.append("ET")

            # Underlines & strikethrough must be rendred OUTSIDE BT/ET contexts,
            # cf. https://github.com/py-pdf/fpdf2/issues/1456
            if underlines:
                for start_x, width, font, font_size in underlines:
                    sl.append(
                        self._do_underline(
                            start_x, self.y + (0.5 * h) + (0.3 * font_size), width, font
                        )
                    )
            if strikethroughs:
                for start_x, width, font, font_size in strikethroughs:
                    sl.append(
                        self._do_strikethrough(
                            start_x, self.y + (0.5 * h) + (0.3 * font_size), width, font
                        )
                    )
            if link:
                self.link(
                    self.x + dx,
                    self.y
                    + (0.5 * h)
                    - (
                        0.5
                        * frag.font_size  # pyright: ignore[reportPossiblyUnboundVariable]
                    ),
                    styled_txt_width,
                    frag.font_size,  # pyright: ignore[reportPossiblyUnboundVariable]
                    link,
                )

        if sl:
            # If any PDF settings have been left modified, wrap the line
            # in a local context.
            # pylint: disable=too-many-boolean-expressions
            if (
                current_ws != 0.0
                or current_lift != 0.0
                or current_char_vpos != CharVPos.LINE
                or current_font != self.current_font
                or current_font_size_pt != self.font_size_pt
                or current_font_style != self.font_style
                or current_text_mode != self.text_mode
                or fill_color_changed
                or current_font_stretching != self.font_stretching
                or current_char_spacing != self.char_spacing
            ):
                s = f"q {' '.join(sl)} Q"
            else:
                s = " ".join(sl)
            # pylint: enable=too-many-boolean-expressions
            self._out(s)
        # If the text is empty, h = max_font_size ends up as 0.
        # We still need a valid default height for self.ln() (issue #601).
        self._lasth = h or self.font_size

        # XPos.LEFT -> self.x stays the same
        if new_x == XPos.RIGHT:
            self.x += w
        elif new_x == XPos.START:
            self.x = s_start
        elif new_x == XPos.END:
            self.x = s_start + s_width
        elif new_x == XPos.WCONT:
            if s_width:
                self.x = s_start + s_width - r_c_margin
            else:
                self.x = s_start
        elif new_x == XPos.CENTER:
            self.x = s_start + s_width / 2.0
        elif new_x == XPos.LMARGIN:
            self.x = self.l_margin
        elif new_x == XPos.RMARGIN:
            self.x = self.w - self.r_margin

        # YPos.TOP:  -> self.y stays the same
        # YPos.LAST: -> self.y stays the same (single line)
        if new_y == YPos.NEXT:
            self.y += h
        if new_y == YPos.TMARGIN:
            self.y = self.t_margin
        if new_y == YPos.BMARGIN:
            self.y = self.h - self.b_margin

        return page_break_triggered

    def _add_quad_points(self, x: float, y: float, w: float, h: float) -> None:
        self._text_quad_points[self.page].extend(
            [
                x * self.k,
                (self.h - y) * self.k,
                (x + w) * self.k,
                (self.h - y) * self.k,
                x * self.k,
                (self.h - y - h) * self.k,
                (x + w) * self.k,
                (self.h - y - h) * self.k,
            ]
        )

    def _preload_bidirectional_text(
        self, text: str, markdown: bool
    ) -> Sequence[Fragment]:
        """ "
        Break the text into bidirectional segments and preload font styles for each fragment
        """
        if not self.text_shaping:
            return self._preload_font_styles(text, markdown)
        paragraph_direction = (
            self.text_shaping["direction"]
            if self.text_shaping["direction"]
            else auto_detect_base_direction(text)
        )

        paragraph = BidiParagraph(text=text, base_direction=paragraph_direction)
        directional_segments = paragraph.get_bidi_fragments()
        self.text_shaping["paragraph_direction"] = paragraph.base_direction

        fragments: list[Fragment] = []
        for bidi_text, bidi_direction in directional_segments:
            self.text_shaping["fragment_direction"] = bidi_direction
            fragments += self._preload_font_styles(bidi_text, markdown)
        return tuple(fragments)

    def _preload_font_styles(
        self, text: Optional[str], markdown: bool
    ) -> Sequence[Fragment]:
        """
        When Markdown styling is enabled, we require secondary fonts
        to ender text in bold & italics.
        This function ensure that those fonts are available.
        It needs to perform Markdown parsing,
        so we return the resulting `styled_txt_frags` tuple
        to avoid repeating this processing later on.
        """
        if not text:
            return tuple()
        prev_font_style = self.font_style
        if self.underline:
            prev_font_style += "U"
        if self.strikethrough:
            prev_font_style += "S"
        styled_txt_frags = tuple(self._parse_chars(text, markdown))
        if markdown:
            page = self.page
            # We set the current to page to zero so that
            # set_font() does not produce any text object on the stream buffer:
            self.page = 0
            if any(frag.font_style == "B" for frag in styled_txt_frags):
                # Ensuring bold font is supported:
                self.set_font(style="B")
            if any(frag.font_style == "I" for frag in styled_txt_frags):
                # Ensuring italics font is supported:
                self.set_font(style="I")
            if any(frag.font_style == "BI" for frag in styled_txt_frags):
                # Ensuring bold italics font is supported:
                self.set_font(style="BI")
            if any(frag.font_style == "" for frag in styled_txt_frags):
                # Ensuring base font is supported:
                self.set_font(style="")
            for frag in styled_txt_frags:
                frag.font = self.fonts[frag.font_family + frag.font_style]
            # Restoring initial style:
            self.set_font(style=prev_font_style)
            self.page = page
        return styled_txt_frags

    def get_fallback_font(self, char: str, style: str = "") -> Optional[str]:
        """
        Returns which fallback font has the requested glyph.
        This method can be overridden to provide more control than the `select_mode` parameter
        of `FPDF.set_fallback_fonts()` provides.
        """
        emphasis = TextEmphasis.coerce(style)
        fonts_with_char = [
            font_id
            for font_id in self._fallback_font_ids
            if ord(char) in self.fonts[font_id].cmap  # type: ignore[union-attr]
        ]
        if not fonts_with_char:
            return None
        font_with_matching_emphasis = next(
            (font for font in fonts_with_char if self.fonts[font].emphasis == emphasis),
            None,
        )
        if font_with_matching_emphasis:
            return font_with_matching_emphasis
        if self._fallback_font_exact_match:
            return None
        return fonts_with_char[0]

    def _parse_chars(self, text: str, markdown: bool) -> Iterator[Fragment]:
        "Split text into fragments"
        if not markdown and not self.text_shaping and not self._fallback_font_ids:
            if self.str_alias_nb_pages:
                for seq, fragment_text in enumerate(
                    text.split(self.str_alias_nb_pages)
                ):
                    if seq > 0:
                        yield TotalPagesSubstitutionFragment(
                            self.str_alias_nb_pages,
                            self._get_current_graphics_state(),
                            self.k,
                        )
                    if fragment_text:
                        yield Fragment(
                            fragment_text, self._get_current_graphics_state(), self.k
                        )
                return

            yield Fragment(text, self._get_current_graphics_state(), self.k)
            return
        txt_frag: list[str] = []
        in_bold: bool = "B" in self.font_style
        in_italics: bool = "I" in self.font_style
        in_strikethrough: bool = bool(self.strikethrough)
        in_underline: bool = bool(self.underline)
        current_fallback_font = None
        current_text_script = None

        def frag() -> Fragment:
            nonlocal txt_frag, current_fallback_font, current_text_script
            gstate = self._get_current_graphics_state()
            gstate.font_style = ("B" if in_bold else "") + ("I" if in_italics else "")
            gstate.strikethrough = in_strikethrough
            gstate.underline = in_underline
            if current_fallback_font:
                style = "".join(c for c in current_fallback_font if c in ("BI"))
                family = current_fallback_font.replace("B", "").replace("I", "")
                gstate.font_family = family
                gstate.font_style = style
                gstate.current_font = self.fonts[current_fallback_font]
                current_fallback_font = None
                current_text_script = None
            fragment = Fragment(
                txt_frag,
                gstate,
                self.k,
            )
            txt_frag = []
            return fragment

        if self.is_ttf_font:
            font_glyphs = self.current_font.cmap  # type: ignore[union-attr]
        else:
            font_glyphs = []
        num_escape_chars = 0

        while text:
            is_marker = text[:2] in (
                self.MARKDOWN_BOLD_MARKER,
                self.MARKDOWN_ITALICS_MARKER,
                self.MARKDOWN_STRIKETHROUGH_MARKER,
                self.MARKDOWN_UNDERLINE_MARKER,
            )
            half_marker = text[0]
            text_script = get_unicode_script(text[0])
            if text_script not in (
                UnicodeScript.COMMON,
                UnicodeScript.UNKNOWN,
                current_text_script,
            ):
                if txt_frag and current_text_script:
                    yield frag()
                current_text_script = text_script

            if self.str_alias_nb_pages:
                if text[: len(self.str_alias_nb_pages)] == self.str_alias_nb_pages:
                    if txt_frag:
                        yield frag()
                    gstate = self._get_current_graphics_state()
                    gstate.font_style = ("B" if in_bold else "") + (
                        "I" if in_italics else ""
                    )
                    gstate.strikethrough = in_strikethrough
                    gstate.underline = in_underline
                    yield TotalPagesSubstitutionFragment(
                        self.str_alias_nb_pages,
                        gstate,
                        self.k,
                    )
                    text = text[len(self.str_alias_nb_pages) :]
                    continue

            # Check that previous & next characters are not identical to the marker:
            if markdown:
                if (
                    is_marker
                    and (not txt_frag or txt_frag[-1] != half_marker)
                    and (len(text) < 3 or text[2] != half_marker)
                ):
                    txt_frag = (
                        txt_frag[: -((num_escape_chars + 1) // 2)]
                        if num_escape_chars > 0
                        else txt_frag
                    )
                    if num_escape_chars % 2 == 0:
                        if txt_frag:
                            yield frag()
                        if text[:2] == self.MARKDOWN_BOLD_MARKER:
                            in_bold = not in_bold
                        if text[:2] == self.MARKDOWN_ITALICS_MARKER:
                            in_italics = not in_italics
                        if text[:2] == self.MARKDOWN_STRIKETHROUGH_MARKER:
                            in_strikethrough = not in_strikethrough
                        if text[:2] == self.MARKDOWN_UNDERLINE_MARKER:
                            in_underline = not in_underline
                        text = text[2:]
                        continue
                num_escape_chars = (
                    num_escape_chars + 1
                    if text[0] == self.MARKDOWN_ESCAPE_CHARACTER
                    else 0
                )
                is_link = self.MARKDOWN_LINK_REGEX.match(text)
                if is_link:
                    link_text, link_dest, text = is_link.groups()
                    if txt_frag:
                        yield frag()
                    gstate = self._get_current_graphics_state()
                    gstate.underline = self.MARKDOWN_LINK_UNDERLINE
                    if self.MARKDOWN_LINK_COLOR:
                        gstate.text_color = convert_to_device_color(
                            self.MARKDOWN_LINK_COLOR
                        )
                    try:
                        page = int(link_dest)
                        link_dest = self.add_link(page=page)
                    except ValueError:
                        pass
                    yield Fragment(
                        list(link_text),
                        gstate,
                        self.k,
                        link=link_dest,
                    )
                    continue
            if self.is_ttf_font and text[0] != "\n" and not ord(text[0]) in font_glyphs:
                style = ("B" if in_bold else "") + ("I" if in_italics else "")
                fallback_font = self.get_fallback_font(text[0], style)
                if fallback_font:
                    if fallback_font == current_fallback_font:
                        txt_frag.append(text[0])
                        text = text[1:]
                        continue
                    if txt_frag:
                        yield frag()
                    current_fallback_font = fallback_font
                    txt_frag.append(text[0])
                    text = text[1:]
                    continue
            if current_fallback_font:
                if txt_frag:
                    yield frag()
                current_fallback_font = None
            txt_frag.append(text[0])
            text = text[1:]
        if txt_frag:
            yield frag()

    def will_page_break(self, height: float) -> bool:
        """
        Let you know if adding an element will trigger a page break,
        based on its height and the current ordinate (`y` position).

        Detailed documentation on page breaks: https://py-pdf.github.io/fpdf2/PageBreaks.html

        Args:
            height (float): height of the section that would be added, e.g. a cell

        Returns: a boolean indicating if a page break would occur
        """
        return (
            self.y + height > self.page_break_trigger
            and not self.in_footer
            and self.accept_page_break
        )

    def _perform_page_break_if_need_be(self, h: float) -> bool:
        if self.will_page_break(h):
            LOGGER.debug(
                "Page break on page %d at y=%d for element of height %d > %d",
                self.page,
                self.y,
                h,
                self.page_break_trigger,
            )
            self._perform_page_break()
            return True
        return False

    def _perform_page_break(self) -> None:
        """
        Performs a page break, taking care to preserve self.x
        and a potential existing `fpdf.fpdf.FPDF.local_context()`.
        A call to `fpdf.fpdf.FPDF.will_page_break()` should be performed beforehand.
        """
        x = self.x
        # If we are in a .local_context(), we need to temporarily leave it,
        # by popping out every GraphicsState:
        gs_stack: list[StateStackType] = []
        while self._is_current_graphics_state_nested():
            gs_stack.append(self._get_current_graphics_state())
            self._pop_local_stack()
            # This code assumes that every Graphics State in the stack
            # has been pushed in it while adding a "q" in the PDF stream
            # (which is what FPDF.local_context() does):
            self._end_local_context()
        # Using a temporary GS to render header & footer:
        self.current_font_is_set_on_page = False
        self._push_local_stack()
        self.add_page(same=True)
        self._pop_local_stack()
        for prev_gs in reversed(gs_stack):
            self._push_local_stack()
            prev_gs.current_font_is_set_on_page = False
            self._start_local_context(**prev_gs.as_kwargs())
        self.x = x  # restore x but not y after drawing header

    def _has_next_page(self) -> bool:
        return self.pages_count > self.page

    @contextmanager
    def _disable_writing(self) -> Iterator[None]:
        if not isinstance(self._out, types.MethodType):
            # This mean that self._out has already been redefined.
            # This is the case of a nested call to this method: we do nothing
            yield
            return
        self._out = lambda *args, **kwargs: None  # type: ignore[method-assign]
        prev_page, prev_pages_count, prev_x, prev_y = (
            self.page,
            self.pages_count,
            self.x,
            self.y,
        )
        annots = self.pages[self.page].annots or PDFArray()
        self._push_local_stack()
        try:
            yield
        finally:
            self._pop_local_stack()
            # restore location:
            for p in range(prev_pages_count + 1, self.pages_count + 1):
                del self.pages[p]
            self.page = prev_page
            self.pages[self.page].annots = annots
            self.set_xy(prev_x, prev_y)
            # restore writing function:
            del self._out

    # multi_cell has dynamic results depending on the `output` parameter
    MultiCellPageBreakResult: TypeAlias = bool
    MultiCellLinesResult: TypeAlias = list[str]
    MultiCellHeightResult: TypeAlias = float

    MultiCellResult: TypeAlias = (
        MultiCellPageBreakResult
        | MultiCellLinesResult
        | MultiCellHeightResult
        | tuple[MultiCellPageBreakResult, MultiCellLinesResult]
        | tuple[MultiCellPageBreakResult, MultiCellHeightResult]
        | tuple[MultiCellLinesResult, MultiCellHeightResult]
        | tuple[MultiCellPageBreakResult, MultiCellLinesResult, MultiCellHeightResult]
    )

    @check_page
    @support_deprecated_txt_arg
    def multi_cell(
        self,
        w: float,
        h: Optional[float] = None,
        text: str = "",
        border: Literal[0, 1] | str = 0,
        align: str | Align = Align.J,
        fill: bool = False,
        split_only: bool = False,  # DEPRECATED
        link: Optional[int | str] = None,
        ln: Literal["DEPRECATED"] = "DEPRECATED",
        max_line_height: Optional[float] = None,
        markdown: bool = False,
        print_sh: bool = False,
        new_x: str | XPos = XPos.RIGHT,
        new_y: str | YPos = YPos.NEXT,
        wrapmode: WrapMode = WrapMode.WORD,
        dry_run: bool = False,
        output: str | MethodReturnValue = MethodReturnValue.PAGE_BREAK,
        center: bool = False,
        padding: int | Sequence[int] | Padding = 0,
    ) -> MultiCellResult:
        """
        This method allows printing text with line breaks. They can be automatic
        (breaking at the most recent space or soft-hyphen character) as soon as the text
        reaches the right border of the cell, or explicit (via the `\\n` character).
        As many cells as necessary are stacked, one below the other.
        Text can be aligned, centered or justified. The cell block can be framed and
        the background painted. A cell has an horizontal padding, on the left & right sides,
        defined by the.c_margin property.

        Args:
            w (float): cell width. If 0, they extend up to the right margin of the page.
            h (float): height of a single line of text.  Default value: None, meaning to use the current font size.
            text (str): string to print.
            border: Indicates if borders must be drawn around the cell.
                The value can be either a number (`0`: no border ; `1`: frame)
                or a string containing some or all of the following characters
                (in any order):
                `L`: left ; `T`: top ; `R`: right ; `B`: bottom. Default value: 0.
            align (fpdf.enums.Align, str): Set text alignment inside the cell.
                Possible values are:
                `J`: justify (default value); `L` or empty string: left align;
                `C`: center; `X`: center around current x position; `R`: right align
            fill (bool): Indicates if the cell background must be painted (`True`)
                or transparent (`False`). Default value: False.
            split_only (bool): **DEPRECATED since 2.7.4**:
                Use `dry_run=True` and `output=("LINES",)` instead.
            link (str): optional link to add on the cell, internal
                (identifier returned by `add_link`) or external URL.
            new_x (fpdf.enums.XPos, str): New current position in x after the call. Default: RIGHT
            new_y (fpdf.enums.YPos, str): New current position in y after the call. Default: NEXT
            ln (int): **DEPRECATED since 2.5.1**: Use `new_x` and `new_y` instead.
            max_line_height (float): optional maximum height of each sub-cell generated
            markdown (bool): enable minimal markdown-like markup to render part
                of text as bold / italics / strikethrough / underlined.
                Supports `\\` as escape character. Default to False.
            print_sh (bool): Treat a soft-hyphen (\\u00ad) as a normal printable
                character, instead of a line breaking opportunity. Default value: False
            wrapmode (fpdf.enums.WrapMode): "WORD" for word based line wrapping (default),
                "CHAR" for character based line wrapping.
            dry_run (bool): if `True`, does not output anything in the document.
                Can be useful when combined with `output`.
            output (fpdf.enums.MethodReturnValue): defines what this method returns.
                If several enum values are joined, the result will be a tuple.
            txt (str): [**DEPRECATED since v2.7.6**] string to print.
            center (bool): center the cell horizontally on the page.
            padding (float or Sequence): padding to apply around the text. Default value: 0.
                When one value is specified, it applies the same padding to all four sides.
                When two values are specified, the first padding applies to the top and bottom, the second to
                the left and right. When three values are specified, the first padding applies to the top,
                the second to the right and left, the third to the bottom. When four values are specified,
                the paddings apply to the top, right, bottom, and left in that order (clockwise)
                If padding for left or right ends up being non-zero then respective c_margin is ignored.

        Center overrides values for horizontal padding

        Using `new_x=XPos.RIGHT, new_y=XPos.TOP, maximum height=pdf.font_size` is
        useful to build tables with multiline text in cells.

        Returns: a single value or a tuple, depending on the `output` parameter value
        """

        padding = Padding.new(padding)
        wrapmode = WrapMode.coerce(wrapmode)

        if split_only:
            warnings.warn(
                (
                    'The parameter "split_only" is deprecated since v2.7.4.'
                    ' Use instead dry_run=True and output="LINES".'
                ),
                DeprecationWarning,
                stacklevel=get_stack_level(),
            )
        if dry_run or split_only:
            with self._disable_writing():
                return self.multi_cell(
                    w=w,
                    h=h,
                    text=text,
                    border=border,
                    align=align,
                    fill=fill,
                    link=link,
                    ln=ln,
                    max_line_height=max_line_height,
                    markdown=markdown,
                    print_sh=print_sh,
                    new_x=new_x,
                    new_y=new_y,
                    wrapmode=wrapmode,
                    dry_run=False,
                    split_only=False,
                    output=MethodReturnValue.LINES if split_only else output,
                    center=center,
                    padding=padding,
                )
        if not self.font_family:
            raise FPDFException("No font set, you need to call set_font() beforehand")
        if isinstance(w, str) or isinstance(h, str):
            raise ValueError(
                "Parameter 'w' and 'h' must be numbers, not strings."
                " You can omit them by passing string content with text="
            )
        new_x = XPos.coerce(new_x)
        new_y = YPos.coerce(new_y)
        if ln != "DEPRECATED":
            # For backwards compatibility, if "ln" is used we overwrite "new_[xy]".
            if ln == 0:
                new_x = XPos.RIGHT
                new_y = YPos.NEXT
            elif ln == 1:
                new_x = XPos.LMARGIN
                new_y = YPos.NEXT
            elif ln == 2:
                new_x = XPos.LEFT
                new_y = YPos.NEXT
            elif ln == 3:
                new_x = XPos.RIGHT
                new_y = YPos.TOP
            else:
                raise ValueError(
                    f'Invalid value for parameter "ln" ({ln}),'
                    " must be an int between 0 and 3."
                )
            warnings.warn(
                (
                    'The parameter "ln" is deprecated since v2.5.2.'
                    f" Instead of ln={ln} use new_x=XPos.{new_x.name}, new_y=YPos.{new_y.name}."
                ),
                DeprecationWarning,
                stacklevel=get_stack_level(),
            )
        align = Align.coerce(align)

        page_break_triggered = False

        if h is None:
            h = self.font_size

        # If width is 0, set width to available width between margins
        if w == 0:
            w = self.w - self.r_margin - self.x

        # Store the starting position before applying padding
        prev_x, prev_y = self.x, self.y

        # Apply padding to contents
        # decrease maximum allowed width by padding
        # shift the starting point by padding
        maximum_allowed_width = w = w - padding.right - padding.left
        clearance_margins: list[float] = []
        # If we don't have padding on either side, we need a clearance margin.
        if not padding.left:
            clearance_margins.append(self.c_margin)
        if not padding.right:
            clearance_margins.append(self.c_margin)
        if align != Align.X:
            self.x += padding.left
        self.y += padding.top

        # Center overrides padding
        if center:
            self.x = (
                self.w / 2 if align == Align.X else self.l_margin + (self.epw - w) / 2
            )
            prev_x = self.x

        # Calculate text length
        text = self.normalize_text(text)
        normalized_string = text.replace("\r", "")
        styled_text_fragments = (
            self._preload_bidirectional_text(normalized_string, markdown)
            if self.text_shaping
            else self._preload_font_styles(normalized_string, markdown)
        )

        prev_current_font = self.current_font
        prev_font_style = self.font_style
        prev_underline = self.underline
        total_height: float = 0

        text_lines: list[TextLine] = []
        multi_line_break = MultiLineBreak(
            styled_text_fragments,
            maximum_allowed_width,
            clearance_margins,
            align=align,
            print_sh=print_sh,
            wrapmode=wrapmode,
        )
        text_line = multi_line_break.get_line()
        while (text_line) is not None:
            text_lines.append(text_line)
            text_line = multi_line_break.get_line()

        if not text_lines:  # ensure we display at least one cell - cf. issue #349
            text_lines = [
                TextLine(
                    [],
                    text_width=0,
                    number_of_spaces=0,
                    align=align,
                    height=h,
                    max_width=w,
                    trailing_nl=False,
                )
            ]

        if max_line_height is None or len(text_lines) == 1:
            line_height = h
        else:
            line_height = min(h, max_line_height)

        box_required = fill or border
        page_break_triggered = False

        for text_line_index, text_line in enumerate(text_lines):
            start_of_new_page = self._perform_page_break_if_need_be(h + padding.bottom)
            if start_of_new_page:
                page_break_triggered = True
                self.y += padding.top

            if box_required and (text_line_index == 0 or start_of_new_page):
                # estimate how many cells can fit on this page
                top_gap = self.y  # Top padding has already been added
                bottom_gap = padding.bottom + self.b_margin
                lines_before_break = int((self.h - top_gap - bottom_gap) // line_height)
                # check how many cells should be rendered
                num_lines = min(lines_before_break, len(text_lines) - text_line_index)
                box_height = max(
                    h - text_line_index * line_height, num_lines * line_height
                )
                # render the box
                x = self.x - (w / 2 if align == Align.X else 0)
                draw_box_borders(
                    self,
                    x - padding.left,
                    self.y - padding.top,
                    x + w + padding.right,
                    self.y + box_height + padding.bottom,
                    border,
                    self.fill_color if fill else None,
                )
            is_last_line = text_line_index == len(text_lines) - 1
            self._render_styled_text_line(
                text_line,
                h=line_height,
                new_x=new_x if is_last_line else XPos.LEFT,
                new_y=new_y if is_last_line else YPos.NEXT,
                border=0,  # already rendered
                fill=False,  # already rendered
                link=link,
                padding=Padding(0, padding.right, 0, padding.left),
                prevent_font_change=markdown,
            )
            total_height += line_height
            if not is_last_line and align == Align.X:
                # prevent cumulative shift to the left
                self.x = prev_x

        if total_height < h:
            # Move to the bottom of the multi_cell
            if new_y == YPos.NEXT:
                self.y += h - total_height
            total_height = h

        if page_break_triggered and new_y == YPos.TOP:
            # When a page jump is performed and the requested y is TOP,
            # pretend we started at the top of the text block on the new page.
            # cf. test_multi_cell_table_with_automatic_page_break
            prev_y = self.y

        last_line = text_lines[-1]
        if last_line and last_line.trailing_nl and new_y in (YPos.LAST, YPos.NEXT):
            # The line renderer can't handle trailing newlines in the text.
            self.ln()

        if new_y == YPos.TOP:  # We may have jumped a few lines -> reset
            self.y = prev_y
        elif new_y == YPos.NEXT:  # move down by bottom padding
            self.y += padding.bottom

        if markdown:
            self.font_style = prev_font_style
            self.current_font = prev_current_font
            self.underline = prev_underline

        if new_x == XPos.RIGHT:  # move right by right padding to align outer RHS edge
            self.x += padding.right
        elif new_x == XPos.LEFT:  # move left by left padding to align outer LHS edge
            self.x -= padding.left

        output = MethodReturnValue.coerce(output)
        return_value = ()
        if output & MethodReturnValue.PAGE_BREAK:
            return_value += (page_break_triggered,)  # type: ignore[assignment]
        if output & MethodReturnValue.LINES:
            output_lines: list[str] = []
            for text_line in text_lines:
                characters: list[str] = []
                for frag in text_line.fragments:
                    characters.extend(frag.characters)
                output_lines.append("".join(characters))
            return_value += (output_lines,)  # type: ignore[assignment]
        if output & MethodReturnValue.HEIGHT:
            return_value += (total_height + padding.top + padding.bottom,)  # type: ignore[assignment]
        if len(return_value) == 1:
            return return_value[0]
        return return_value  # type: ignore[return-value]

    @check_page
    @support_deprecated_txt_arg
    def write(
        self,
        h: Optional[float] = None,
        text: str = "",
        link: Optional[str | int] = "",
        print_sh: bool = False,
        wrapmode: WrapMode = WrapMode.WORD,
    ) -> bool:
        """
        Prints text from the current position.
        When the right margin is reached, a line break occurs at the most recent
        space or soft-hyphen character, and text continues from the left margin.
        A manual break happens any time the \\n character is met,
        Upon method exit, the current position is left just at the end of the text.

        Args:
            h (float): line height. Default value: None, meaning to use the current font size.
            text (str): text content
            link (str): optional link to add on the text, internal
                (identifier returned by `FPDF.add_link`) or external URL.
            print_sh (bool): Treat a soft-hyphen (\\u00ad) as a normal printable
                character, instead of a line breaking opportunity. Default value: False
            wrapmode (fpdf.enums.WrapMode): "WORD" for word based line wrapping (default),
                "CHAR" for character based line wrapping.
            txt (str): [**DEPRECATED since v2.7.6**] text content
        """
        wrapmode = WrapMode.coerce(wrapmode)
        if not self.font_family:
            raise FPDFException("No font set, you need to call set_font() beforehand")
        if isinstance(h, str):
            raise ValueError(
                "Parameter 'h' must be a number, not a string."
                " You can omit it by passing string content with text="
            )
        if h is None:
            h = self.font_size

        page_break_triggered = False
        normalized_string = self.normalize_text(text).replace("\r", "")
        styled_text_fragments = (
            self._preload_bidirectional_text(normalized_string, False)
            if self.text_shaping
            else self._preload_font_styles(normalized_string, False)
        )

        text_lines: list[TextLine] = []
        multi_line_break = MultiLineBreak(
            styled_text_fragments,
            lambda _height: max_width,  # pyright: ignore[reportUnknownLambdaType]
            (self.c_margin, self.c_margin),
            print_sh=print_sh,
            wrapmode=wrapmode,
        )
        # first line from current x position to right margin
        first_width = self.w - self.x - self.r_margin
        max_width = first_width
        text_line = multi_line_break.get_line()
        # remaining lines fill between margins
        full_width = self.w - self.l_margin - self.r_margin
        max_width = full_width
        while (text_line) is not None:
            text_lines.append(text_line)
            text_line = multi_line_break.get_line()
        if not text_lines:
            return False

        for text_line_index, text_line in enumerate(text_lines):
            if text_line_index > 0:
                self.ln()
            new_page = self._render_styled_text_line(
                text_line,
                h=h,
                border=0,
                new_x=XPos.WCONT,
                new_y=YPos.TOP,
                fill=False,
                link=link,
            )
            page_break_triggered = page_break_triggered or new_page
        if text_line is not None and text_line.trailing_nl:
            # The line renderer can't handle trailing newlines in the text.
            self.ln()
        return page_break_triggered

    @check_page
    def text_columns(
        self,
        text: Optional[str] = None,
        img: Optional[str] = None,
        img_fill_width: bool = False,
        ncols: int = 1,
        gutter: Optional[float] = 10,
        balance: bool = False,
        text_align: Optional[Align | str] = "LEFT",
        line_height: Optional[float] = 1,
        l_margin: Optional[float] = None,
        r_margin: Optional[float] = None,
        print_sh: Optional[bool] = False,
        wrapmode: Optional[WrapMode] = WrapMode.WORD,
        skip_leading_spaces: Optional[bool] = False,
    ) -> TextColumns:
        """Establish a layout with multiple columns to fill with text.
        Args:
            text (str, optional): A first piece of text to insert.
            ncols (int, optional): the number of columns to create. (Default: 1).
            gutter (float, optional): The distance between the columns. (Default: 10).
            balance: (bool, optional): Specify whether multiple columns should end at approximately
                the same height, if they don't fill the page. (Default: False)
            text_align (Align or str, optional): The alignment of the text within the region.
                (Default: "LEFT")
            line_height (float, optional): A multiplier relative to the font size changing the
                vertical space occupied by a line of text. (Default: 1.0).
            l_margin (float, optional): Override the current left page margin.
            r_margin (float, optional): Override the current right page margin.
            print_sh (bool, optional): Treat a soft-hyphen (\\u00ad) as a printable character,
                instead of a line breaking opportunity. (Default: False)
            wrapmode (fpdf.enums.WrapMode, optional): "WORD" for word based line wrapping,
                "CHAR" for character based line wrapping. (Default: "WORD")
            skip_leading_spaces (bool, optional): On each line, any space characters at the
                beginning will be skipped if True. (Default: False)
        """
        return TextColumns(
            self,
            text=text,
            img=img,
            img_fill_width=img_fill_width,
            ncols=ncols,
            gutter=gutter or 10,
            balance=balance,
            text_align=text_align,
            line_height=line_height,
            l_margin=l_margin,
            r_margin=r_margin,
            print_sh=print_sh,
            wrapmode=wrapmode,
            skip_leading_spaces=skip_leading_spaces,
        )

    def image(
        self,
        name: ImageType,
        x: Optional[float | Align] = None,
        y: Optional[float] = None,
        w: float = 0,
        h: float = 0,
        type: str | Literal["DEPRECATED"] | None = "",
        link: Optional[str | int] = "",
        title: Optional[str] = None,
        alt_text: Optional[str] = None,
        dims: Optional[tuple[float, float]] = None,
        keep_aspect_ratio: bool = False,
    ) -> RasterImageInfo | VectorImageInfo:
        """
        Put an image on the page.

        The size of the image on the page can be specified in different ways:
        * explicit width and height (expressed in user units)
        * one explicit dimension, the other being calculated automatically
          in order to keep the original proportions
        * no explicit dimension, in which case the image is put at 72 dpi.
        * explicit width and height (expressed in user units) and `keep_aspect_ratio=True`

        **Remarks**:
        * if an image is used several times, only one copy is embedded in the file.
        * when using an animated GIF, only the first frame is used.

        Args:
            name: either a string representing a file path to an image, an URL to an image,
                bytes, an io.BytesIO, or a instance of `PIL.Image.Image`
            x (float, fpdf.enums.Align): optional horizontal position where to put the image on the page.
                If not specified or equal to None, the current abscissa is used.
                `fpdf.enums.Align.C` can also be passed to center the image horizontally;
                and `fpdf.enums.Align.R` to place it along the right page margin
            y (float): optional vertical position where to put the image on the page.
                If not specified or equal to None, the current ordinate is used.
                After the call, the current ordinate is moved to the bottom of the image
            w (float): optional width of the image. If not specified or equal to zero,
                it is automatically calculated from the image size.
                Pass `pdf.epw` to scale horizontally to the full page width.
            h (float): optional height of the image. If not specified or equal to zero,
                it is automatically calculated from the image size.
                Pass `pdf.eph` to scale horizontally to the full page height.
            type (str): [**DEPRECATED since 2.2.0**] unused, will be removed in a later version.
            link (str): optional link to add on the image, internal
                (identifier returned by `FPDF.add_link`) or external URL.
            title (str): optional. Currently, never seem rendered by PDF readers.
            alt_text (str): optional alternative text describing the image,
                for accessibility purposes. Displayed by some PDF readers on hover.
            dims (Tuple[float]): optional dimensions as a tuple (width, height) to resize the image
                before storing it in the PDF. Note that those are the **intrinsic** image dimensions,
                but the image will still be rendered on the page with the width (`w`) and height (`h`)
                provided as parameters. Note also that the `.oversized_images` attribute of FPDF
                provides an automated way to auto-adjust those intrinsic image dimensions.
            keep_aspect_ratio (bool): ensure the image fits in the rectangle defined by `x`, `y`, `w` & `h`
                while preserving its original aspect ratio. Defaults to False.
                Only meaningful if both `w` & `h` are provided.

        If `y` is provided, this method will not trigger any page break;
        otherwise, auto page break detection will be performed.

        Returns: an instance of a subclass of `ImageInfo`.
        """
        if not self.page:
            raise FPDFException("No page open, you need to call add_page() first")
        if type:
            warnings.warn(
                (
                    '"type" parameter is deprecated since v2.2.0, '
                    "unused and will soon be removed"
                ),
                DeprecationWarning,
                stacklevel=get_stack_level(),
            )

        name, img, info = preload_image(self.image_cache, name, dims)
        if isinstance(info, VectorImageInfo):
            return self._vector_image(
                name,
                cast(SVGObject, img),
                info,
                x,
                y,
                w,
                h,
                link,
                title,
                alt_text,
                keep_aspect_ratio,
            )
        if TYPE_CHECKING:
            assert not isinstance(img, SVGObject)
        return self._raster_image(
            name,
            img,
            info,
            x,
            y,
            w,
            h,
            link,
            title,
            alt_text,
            dims,
            keep_aspect_ratio,
        )

    def _raster_image(
        self,
        name: str,
        img: ImageType,
        info: RasterImageInfo,
        x: Optional[float | Align] = None,
        y: Optional[float] = None,
        w: float = 0,
        h: float = 0,
        link: Optional[str | int] = "",
        title: Optional[str] = None,
        alt_text: Optional[str] = None,
        dims: Optional[tuple[float, float]] = None,
        keep_aspect_ratio: bool = False,
    ) -> RasterImageInfo:
        if "smask" in info:
            self._set_min_pdf_version("1.4")

        # Automatic width and height calculation if needed
        w, h = info.size_in_document_units(w, h, scale=self.k)

        # Flowing mode
        if y is None:
            self._perform_page_break_if_need_be(h)
            y = self.y
            self.y += h
        if x is None:
            x = self.x

        if not isinstance(x, NumberClass):
            x = self.x_by_align(x, w, h, info, keep_aspect_ratio)
        if TYPE_CHECKING:
            x = float(x)
        if keep_aspect_ratio:
            x, y, w, h = info.scale_inside_box(x, y, w, h)
        if self.oversized_images and info["usages"] == 1 and not dims:
            info = self._downscale_image(name, img, info, w, h, scale=self.k)

        stream_content = stream_content_for_raster_image(
            info, x, y, w, h, keep_aspect_ratio, scale=self.k, pdf_height_to_flip=self.h
        )

        if title or alt_text:
            with self._marked_sequence(title=title, alt_text=alt_text):
                self._out(stream_content)
        else:
            self._out(stream_content)
        if link:
            self.link(x, y, w, h, link)

        self._resource_catalog.add(
            PDFResourceType.X_OBJECT, info["i"], self.page  # type: ignore
        )
        info["rendered_width"] = w
        info["rendered_height"] = h
        return info

    def x_by_align(
        self,
        x: Align | str,
        w: float,
        h: float,
        img_info: RasterImageInfo | VectorImageInfo,
        keep_aspect_ratio: bool,
    ) -> float:
        if keep_aspect_ratio:
            _, _, w, h = img_info.scale_inside_box(0, 0, w, h)
        x = Align.coerce(x)
        if x == Align.C:
            return (self.w - w) / 2
        if x == Align.R:
            return self.w - w - self.r_margin
        if x == Align.L:
            return self.l_margin
        raise ValueError(f"Unsupported 'x' value passed to .image(): {x}")

    def _vector_image(
        self,
        name: str,
        svg: SVGObject,
        info: VectorImageInfo,
        x: Optional[float | Align] = None,
        y: Optional[float] = None,
        w: float = 0,
        h: float = 0,
        link: Optional[str | int] = "",
        title: Optional[str] = None,
        alt_text: Optional[str] = None,
        keep_aspect_ratio: bool = False,
    ) -> VectorImageInfo:
        if not svg.viewbox and svg.width and svg.height:
            warnings.warn(
                '<svg> has no "viewBox", using its "width" & "height" as default "viewBox"',
                stacklevel=get_stack_level(),
            )
            svg.viewbox = [float(0), float(0), svg.width, svg.height]
        if w == 0 and h == 0:
            if svg.width and svg.height:
                w = (
                    svg.width * self.epw / 100
                    if isinstance(svg.width, Percent)
                    else svg.width
                )
                h = (
                    svg.height * self.eph / 100
                    if isinstance(svg.height, Percent)
                    else svg.height
                )
            elif svg.viewbox:
                _, _, w, h = svg.viewbox
            else:
                svg_id = "<svg>" if isinstance(name, bytes) else name
                raise ValueError(
                    f'{svg_id} has no "viewBox" nor "height" / "width": w= and h= must be provided to FPDF.image()'
                )
        elif w == 0 or h == 0:
            if svg.width and svg.height:
                svg_width, svg_height = svg.width, svg.height
            elif svg.viewbox:
                _, _, svg_width, svg_height = svg.viewbox
            else:
                raise ValueError(
                    '<svg> has no "viewBox" nor "height" / "width": w= and h= must be provided to FPDF.image()'
                )
            if w == 0:
                w = h * svg_width / svg_height
            else:  # h == 0
                h = w * svg_height / svg_width

        # Flowing mode
        if y is None:
            self._perform_page_break_if_need_be(h)
            y = self.y
            self.y += h
        if x is None:
            x = self.x

        if not isinstance(x, NumberClass):
            x = self.x_by_align(x, w, h, info, keep_aspect_ratio)
        x = float(x)
        if keep_aspect_ratio:
            x, y, w, h = info.scale_inside_box(x, y, w, h)

        _, _, path = svg.transform_to_rect_viewport(
            scale=1, width=w, height=h, ignore_svg_top_attrs=True
        )
        assert path.transform is not None
        path.transform = path.transform @ Transform.translation(x, y)

        old_x, old_y = self.x, self.y
        try:
            self.set_xy(0, 0)
            if title or alt_text:
                # Alt text of vector graphics does NOT show as tool-tip in viewers, but should
                # be processed by screen readers.
                with self._marked_sequence(title=title, alt_text=alt_text):
                    self.draw_path(path, copy=False)
            else:
                self.draw_path(path, copy=False)
        finally:
            self.set_xy(old_x, old_y)
        if link:
            self.link(x, y, w, h, link)

        return VectorImageInfo(rendered_width=w, rendered_height=h)

    def _downscale_image(
        self,
        name: str,
        img: ImageType,
        info: RasterImageInfo,
        w: float,
        h: float,
        scale: float,
    ) -> RasterImageInfo:
        images = self.image_cache.images
        width_in_pt, height_in_pt = w * scale, h * scale
        lowres_name = f"lowres-{name}"
        w = float(info["w"])  # type: ignore[arg-type]
        h = float(info["h"])  # type: ignore[arg-type]
        assert self.oversized_images is not None
        if (
            w > width_in_pt * self.oversized_images_ratio
            and h > height_in_pt * self.oversized_images_ratio
        ):
            factor = (
                min(w / width_in_pt, h / height_in_pt) / self.oversized_images_ratio
            )
            if self.oversized_images.lower().startswith("warn"):
                LOGGER.warning(
                    (
                        "OVERSIZED: Image %s with size %.1fx%.1fpx is rendered at size %.1fx%.1fpt."
                        " Set pdf.oversized_images = 'DOWNSCALE' to reduce embedded image size by a factor %.1f"
                    ),
                    name,
                    w,
                    h,
                    width_in_pt,
                    height_in_pt,
                    factor,
                )
            elif self.oversized_images.lower() == "downscale":
                dims = (
                    round(width_in_pt * self.oversized_images_ratio),
                    round(height_in_pt * self.oversized_images_ratio),
                )
                info["usages"] -= 1  # type: ignore[operator] # no need to embed highres version
                if info["usages"] == 0:
                    resources_per_page = self._resource_catalog.resources_per_page
                    for (_, rtype), resource in resources_per_page.items():
                        if rtype == PDFResourceType.X_OBJECT and info["i"] in resource:
                            resource.remove(cast(int, info["i"]))
                lowres_info = images.get(lowres_name)
                if lowres_info:  # Great, we've already done the job!
                    info = cast(RasterImageInfo, lowres_info)
                    lowres_w = float(info["w"])  # type: ignore[arg-type]
                    lowres_h = float(info["h"])  # type: ignore[arg-type]
                    if lowres_w * lowres_h < dims[0] * dims[1]:
                        # The existing low-res image is too small, we need a bigger low-res image:
                        info.update(
                            get_img_info(
                                name,
                                img or load_image(name),
                                self.image_cache.image_filter,
                                dims,
                            )
                        )
                        LOGGER.debug(
                            "OVERSIZED: Updated low-res image with name=%s id=%d to dims=%s",
                            lowres_name,
                            info["i"],
                            dims,
                        )
                    info["usages"] += 1  # type: ignore[operator]
                else:
                    info = RasterImageInfo(
                        get_img_info(
                            name,
                            img or load_image(name),
                            self.image_cache.image_filter,
                            dims,
                        )
                    )
                    info["i"] = len(images) + 1
                    info["usages"] = 1
                    images[lowres_name] = info
                    LOGGER.debug(
                        "OVERSIZED: Generated new low-res image with name=%s dims=%s id=%d",
                        lowres_name,
                        dims,
                        info["i"],
                    )
            else:
                raise ValueError(
                    f"Invalid value for attribute .oversized_images: {self.oversized_images}"
                )
        return info

    def preload_image(
        self,
        name: str | bytes | BinaryIO | Image | Path,
        dims: tuple[float, float] | None = None,
    ) -> tuple[
        str,
        SVGObject | Image | bytes | BinaryIO | Path | None,
        RasterImageInfo | VectorImageInfo,
    ]:
        """
        Read an image and load it into memory.

        .. deprecated:: 2.7.7
            Use `fpdf.image_parsing.preload_image` instead.
        """
        warnings.warn(
            (
                "FPDF.preload_image() is deprecated since v2.7.7 "
                "and will be removed in a future release. "
                "Use `fpdf.image_parsing.preload_image` instead."
            ),
            DeprecationWarning,
            stacklevel=get_stack_level(),
        )
        return preload_image(
            self.image_cache,
            name,  # pyright: ignore[reportArgumentType, reportReturnType]
            dims,
        )

    def preload_glyph_image(self, glyph_image_bytes: bytes | BinaryIO) -> tuple[
        str,
        SVGObject | Image | bytes | BinaryIO | Path | None,
        RasterImageInfo | VectorImageInfo,
    ]:
        return preload_image(
            image_cache=self.image_cache,
            name=glyph_image_bytes,
            dims=None,  # pyright: ignore[reportArgumentType, reportReturnType]
        )

    @contextmanager
    def _marked_sequence(self, **kwargs: Any) -> Iterator[StructElem]:
        """
        Can receive as named arguments any of the entries described in section 14.7.2 'Structure Hierarchy'
        of the PDF spec: iD, a, c, r, lang, e, actualText
        """
        mcid = self.struct_builder.next_mcid_for_page(self.page)
        struct_elem = self._add_marked_content(
            struct_type="/Figure", mcid=mcid, **kwargs
        )
        start_page = self.page
        self._out(f"/P <</MCID {mcid}>> BDC")
        yield struct_elem
        if self.page != start_page:
            raise FPDFException("A page jump occurred inside a marked sequence")
        self._out("EMC")

    def _add_marked_content(self, **kwargs: Any) -> StructElem:
        """
        Can receive as named arguments any of the entries described in section 14.7.2 'Structure Hierarchy'
        of the PDF spec: iD, a, c, r, lang, e, actualText
        """
        struct_elem, spid = self.struct_builder.add_marked_content(
            page_number=self.page, **kwargs
        )
        self.pages[self.page].struct_parents = spid
        self._set_min_pdf_version("1.4")  # due to using /MarkInfo
        return struct_elem

    @check_page
    def ln(self, h: Optional[float] = None) -> None:
        """
        Line Feed.
        The current abscissa goes back to the left margin and the ordinate increases by
        the amount passed as parameter.

        Args:
            h (float): The height of the break.
                By default, the value equals the height of the last printed text line
                (except when written by `.text()`). If no text has been written yet to
                the document, then the current font height is used.
        """
        self.x = self.l_margin
        if h is not None:
            self.y += h
        elif self._lasth:
            self.y += self._lasth
        else:
            self.y += self.font_size

    def get_x(self) -> float:
        """Returns the abscissa of the current position."""
        return self.x

    def set_x(self, x: float) -> None:
        """
        Defines the abscissa of the current position.
        If the value provided is negative, it is relative to the right of the page.

        Args:
            x (float): the new current abscissa
        """
        self.x = x if x >= 0 else self.w + x

    def get_y(self) -> float:
        """Returns the ordinate of the current position."""
        if self._in_unbreakable:
            raise FPDFException(
                "Using get_y() inside an unbreakable() code block is error-prone"
            )
        return self.y

    def set_y(self, y: float) -> None:
        """
        Moves the current abscissa back to the left margin and sets the ordinate.
        If the value provided is negative, it is relative to the bottom of the page.

        Args:
            y (float): the new current ordinate
        """
        self.x = self.l_margin
        self.y = y if y >= 0 else self.h + y

    def set_xy(self, x: float, y: float) -> None:
        """
        Defines the abscissa and ordinate of the current position.
        If the values provided are negative, they are relative respectively to the right and bottom of the page.

        Args:
            x (float): the new current abscissa
            y (float): the new current ordinate
        """
        self.set_y(y)
        self.set_x(x)

    def normalize_text(self, text: str) -> str:
        """Check that text input is in the correct format/encoding"""
        # - for TTF unicode fonts: unicode object (utf8 encoding)
        # - for built-in fonts: string instances (encoding: latin-1, cp1252)
        if not self.is_ttf_font and self.core_fonts_encoding:
            try:
                return text.encode(self.core_fonts_encoding).decode("latin-1")
            except UnicodeEncodeError as error:
                raise FPDFUnicodeEncodingException(
                    text_index=error.start,
                    character=text[error.start],
                    font_name=self.font_family + self.font_style,
                ) from error
        return text

    def sign_pkcs12(
        self,
        pkcs_filepath: str | Path,
        password: Optional[bytes] = None,
        hashalgo: str = "sha256",
        contact_info: Optional[str] = None,
        location: Optional[str] = None,
        signing_time: Optional[datetime] = None,
        reason: Optional[str] = None,
        flags: tuple[AnnotationFlag | str, ...] = (
            AnnotationFlag.PRINT,
            AnnotationFlag.LOCKED,
        ),
    ) -> None:
        """
        Args:
            pkcs_filepath (str): file path to a .pfx or .p12 PKCS12,
                in the binary format described by RFC 7292
            password (bytes-like): the password to use to decrypt the data.
                `None` if the PKCS12 is not encrypted.
            hashalgo (str): hashing algorithm used, passed to `hashlib.new`
            contact_info (str): optional information provided by the signer to enable
                a recipient to contact the signer to verify the signature
            location (str): optional CPU host name or physical location of the signing
            signing_time (datetime): optional time of signing
            reason (str): optional signing reason
            flags (Tuple[fpdf.enums.AnnotationFlag], Tuple[str]): optional list of flags defining annotation properties
        """
        if not signer:
            raise EnvironmentError(
                "endesive.signer not available - PDF cannot be signed - Try: pip install endesive"
            )
        with open(pkcs_filepath, "rb") as pkcs_file:
            key, cert, extra_certs = (
                pkcs12.load_key_and_certificates(  # pyright: ignore[reportOptionalMemberAccess]
                    pkcs_file.read(), password
                )
            )
        assert cert is not None
        self.sign(
            key=key,
            cert=cert,
            extra_certs=extra_certs,
            hashalgo=hashalgo,
            contact_info=contact_info,
            location=location,
            signing_time=signing_time,
            reason=reason,
            flags=flags,
        )

    @check_page
    def sign(
        self,
        key: Optional["PrivateKeyTypes"],
        cert: "Certificate",
        extra_certs: Optional[list["Certificate"]] = None,
        hashalgo: str = "sha256",
        contact_info: Optional[str] = None,
        location: Optional[str] = None,
        signing_time: Optional[datetime] = None,
        reason: Optional[str] = None,
        flags: tuple[AnnotationFlag | str, ...] = (
            AnnotationFlag.PRINT,
            AnnotationFlag.LOCKED,
        ),
    ) -> None:
        """
        Args:
            key: certificate private key
            cert (cryptography.x509.Certificate): certificate
            extra_certs (list[cryptography.x509.Certificate]): list of additional PKCS12 certificates
            hashalgo (str): hashing algorithm used, passed to `hashlib.new`
            contact_info (str): optional information provided by the signer to enable
                a recipient to contact the signer to verify the signature
            location (str): optional CPU host name or physical location of the signing
            signing_time (datetime): optional time of signing
            reason (str): optional signing reason
            flags (Tuple[fpdf.enums.AnnotationFlag], Tuple[str]): optional list of flags defining annotation properties
        """
        if not signer:
            raise EnvironmentError(
                "endesive.signer not available - PDF cannot be signed - Try: pip install endesive"
            )
        if self._sign_key:
            raise FPDFException(".sign* methods should be called only once")

        self._sign_key = key
        self._sign_cert = cert
        self._sign_extra_certs = extra_certs if extra_certs is not None else []
        self._sign_hashalgo = hashalgo
        self._sign_time: datetime = signing_time or self.creation_date

        annotation = PDFAnnotation(
            "Widget",
            field_type="Sig",
            x=0,
            y=0,
            width=0,
            height=0,
            flags=flags,
            title="signature",
            value=Signature(
                contact_info=contact_info,
                location=location,
                m=PDFDate(self._sign_time),
                reason=reason,
            ),
        )
        self.pages[self.page].add_annotation(annotation)

    def _insert_table_of_contents(self) -> None:
        # Doc has been closed but we want to write to self.pages[self.page] instead of self.buffer:
        tocp = self.toc_placeholder
        assert tocp is not None
        prev_page, prev_y = self.page, self.y
        self.page, self.y = tocp.start_page, tocp.y
        # flag rendering ToC for page breaking function
        self.in_toc_rendering = True
        self._set_orientation(tocp.page_orientation, self.dw_pt, self.dh_pt)
        tocp.render_function(self, self._outline)
        self.in_toc_rendering = False  # set ToC rendering flag off
        expected_final_page = tocp.start_page + tocp.pages - 1
        if self.page != expected_final_page and not self._toc_allow_page_insertion:
            too = "many" if self.page > expected_final_page else "few"
            error_msg = f"The rendering function passed to FPDF.insert_toc_placeholder triggered too {too} page breaks: "
            error_msg += f"ToC ended on page {self.page} while it was expected to span exactly {tocp.pages} pages"
            raise FPDFException(error_msg)
        if self._toc_inserted_pages:
            # Generating final page footer after more pages were inserted:
            self._render_footer()
            # We need to reorder the pages, because some new pages have been inserted in the ToC,
            # but they have been inserted at the end of self.pages:
            new_pages = [
                self.pages.pop(len(self.pages)) for _ in range(self._toc_inserted_pages)
            ]
            new_pages = list(reversed(new_pages))
            indices_remap: dict[int, int] = {}
            for page_index in range(
                tocp.start_page + 1, self.pages_count + len(new_pages) + 1
            ):
                if page_index in self.pages:
                    new_pages.append(self.pages.pop(page_index))
                page = self.pages[page_index] = new_pages.pop(0)
                # Fix page indices:
                indices_remap[page.index()] = page_index
                page.set_index(page_index)
                # Fix page labels:
                if tocp.reset_page_indices is False:
                    page.get_page_label().st = page_index  # type: ignore[union-attr]
            assert len(new_pages) == 0, f"#new_pages: {len(new_pages)}"
            # Fix links:
            for dest in self.links.values():
                assert dest.page_number is not None
                new_index = indices_remap.get(dest.page_number)
                if new_index is not None:
                    dest.page_number = new_index
            # Fix outline:
            for section in self._outline:
                new_index = indices_remap.get(section.page_number)
                if new_index is not None:
                    section.dest = section.dest.replace(page=new_index)
                    section.page_number = new_index
                    if section.struct_elem:
                        # pylint: disable=protected-access
                        section.struct_elem._page_number = (  # pyright: ignore[reportPrivateUsage]
                            new_index
                        )
            # Fix resource catalog:
            resources_per_page = self._resource_catalog.resources_per_page
            new_resources_per_page: dict[
                tuple[int, PDFResourceType], set[ResourceTypes]
            ] = defaultdict(set)
            for (page_number, resource_type), resource in resources_per_page.items():
                key = (indices_remap.get(page_number, page_number), resource_type)
                new_resources_per_page[key] = resource
            self._resource_catalog.resources_per_page = new_resources_per_page
        self.page, self.y = prev_page, prev_y

    def file_id(self) -> Optional[str | Literal[-1]]:  # pylint: disable=no-self-use
        """
        This method can be overridden in inherited classes
        in order to define a custom file identifier.
        Its output must have the format "<hex_string1><hex_string2>".
        If this method returns a falsy value (None, empty string),
        no /ID will be inserted in the generated PDF document.
        """
        return -1

    def _default_file_id(self, buffer: bytearray) -> str:
        # Quoting the PDF 1.7 spec, section 14.4 File Identifiers:
        # > The value of this entry shall be an array of two byte strings.
        # > The first byte string shall be a permanent identifier
        # > based on the contents of the file at the time it was originally created
        # > and shall not change when the file is incrementally updated.
        # > The second byte string shall be a changing identifier
        # > based on the file‚Äôs contents at the time it was last updated.
        # > When a file is first written, both identifiers shall be set to the same value.
        id_hash = hashlib.new("md5", usedforsecurity=False)  # nosec B324
        id_hash.update(buffer)
        if self.creation_date:
            id_hash.update(self.creation_date.strftime("%Y%m%d%H%M%S").encode("utf8"))
        hash_hex = id_hash.hexdigest().upper()
        return f"<{hash_hex}><{hash_hex}>"

    def _do_underline(
        self, x: float, y: float, w: float, font: Optional[CoreFont | TTFFont] = None
    ) -> str:
        """
        Draw an horizontal line under some text,
        starting from (x, y) with a length equal to 'w'
        """
        if font is None:
            font = self.current_font
        assert font is not None
        return (
            f"{x * self.k:.2f} "
            f"{(self.h - y + font.up / 1000 * self.font_size) * self.k:.2f} "  # pyright: ignore[reportUnknownMemberType]
            f"{w * self.k:.2f} "
            f"{-font.ut / 1000 * self.font_size_pt:.2f} re f"  # pyright: ignore[reportUnknownMemberType]
        )

    def _do_strikethrough(
        self, x: float, y: float, w: float, font: Optional[CoreFont | TTFFont] = None
    ) -> str:
        """
        Draw an horizontal line through some text,
        starting from (x, y) with a length equal to 'w'
        """
        if font is None:
            font = self.current_font
        assert font is not None
        return (
            f"{x * self.k:.2f} "
            f"{(self.h - y + font.sp / 1000 * self.font_size) * self.k:.2f} "  # pyright: ignore[reportUnknownMemberType]
            f"{w * self.k:.2f} "
            f"{-font.ss / 1000 * self.font_size_pt:.2f} re f"  # pyright: ignore[reportUnknownMemberType]
        )

    def _out(self, s: str | bytes) -> None:
        if self.buffer:
            raise FPDFException(
                "Content cannot be added on a finalized document, after calling output()"
            )
        if not isinstance(s, bytes):
            if not isinstance(s, str):
                s = str(s)
            s = s.encode("latin1")
        if not self.page:
            raise FPDFException("No page open, you need to call add_page() first")
        page_contents = self.pages[self.page].contents
        if isinstance(page_contents, bytearray):
            page_contents.extend(s)
            page_contents.append(0x0A)  # newline
        else:
            page_contents += s + b"\n"  # type: ignore[operator]

    @check_page
    @support_deprecated_txt_arg
    def interleaved2of5(
        self, text: str, x: float, y: float, w: float = 1, h: float = 10
    ) -> None:
        """Barcode I2of5 (numeric), adds a 0 if odd length"""
        narrow = w / 3
        wide = w

        # wide/narrow codes for the digits
        bar_char = {
            "0": "nnwwn",
            "1": "wnnnw",
            "2": "nwnnw",
            "3": "wwnnn",
            "4": "nnwnw",
            "5": "wnwnn",
            "6": "nwwnn",
            "7": "nnnww",
            "8": "wnnwn",
            "9": "nwnwn",
            "A": "nn",
            "Z": "wn",
        }
        # The caller should do this, or we can't rotate the thing.
        # self.set_fill_color(0)
        code = text
        # add leading zero if code-length is odd
        if len(code) % 2 != 0:
            code = f"0{code}"

        # add start and stop codes
        code = f"AA{code.lower()}ZA"

        for i in range(0, len(code), 2):
            # choose next pair of digits
            char_bar = code[i]
            char_space = code[i + 1]
            # check whether it is a valid digit
            if char_bar not in bar_char:
                raise RuntimeError(f'Char "{char_bar}" invalid for I25:')
            if char_space not in bar_char:
                raise RuntimeError(f'Char "{char_space}" invalid for I25: ')

            # create a wide/narrow-seq (first digit=bars, second digit=spaces)
            seq = "".join(
                f"{cb}{cs}" for cb, cs in zip(bar_char[char_bar], bar_char[char_space])
            )

            for bar_index, char in enumerate(seq):
                # set line_width depending on value
                line_width = narrow if char == "n" else wide

                # draw every second value, the other is represented by space
                if bar_index % 2 == 0:
                    self.rect(x, y, line_width, h, "F")

                x += line_width

    @check_page
    @support_deprecated_txt_arg
    def code39(
        self, text: str, x: float, y: float, w: float = 1.5, h: float = 5
    ) -> None:
        """Barcode 3of9"""
        dim = {"w": w, "n": w / 3}
        if not text.startswith("*") or not text.endswith("*"):
            warnings.warn(
                (
                    "Code 39 input must start and end with a '*' character to be valid."
                    " This method does not insert it automatically."
                ),
                stacklevel=get_stack_level(),
            )
        chars = {
            "0": "nnnwwnwnn",
            "1": "wnnwnnnnw",
            "2": "nnwwnnnnw",
            "3": "wnwwnnnnn",
            "4": "nnnwwnnnw",
            "5": "wnnwwnnnn",
            "6": "nnwwwnnnn",
            "7": "nnnwnnwnw",
            "8": "wnnwnnwnn",
            "9": "nnwwnnwnn",
            "A": "wnnnnwnnw",
            "B": "nnwnnwnnw",
            "C": "wnwnnwnnn",
            "D": "nnnnwwnnw",
            "E": "wnnnwwnnn",
            "F": "nnwnwwnnn",
            "G": "nnnnnwwnw",
            "H": "wnnnnwwnn",
            "I": "nnwnnwwnn",
            "J": "nnnnwwwnn",
            "K": "wnnnnnnww",
            "L": "nnwnnnnww",
            "M": "wnwnnnnwn",
            "N": "nnnnwnnww",
            "O": "wnnnwnnwn",
            "P": "nnwnwnnwn",
            "Q": "nnnnnnwww",
            "R": "wnnnnnwwn",
            "S": "nnwnnnwwn",
            "T": "nnnnwnwwn",
            "U": "wwnnnnnnw",
            "V": "nwwnnnnnw",
            "W": "wwwnnnnnn",
            "X": "nwnnwnnnw",
            "Y": "wwnnwnnnn",
            "Z": "nwwnwnnnn",
            "-": "nwnnnnwnw",
            ".": "wwnnnnwnn",
            " ": "nwwnnnwnn",
            "*": "nwnnwnwnn",
            "$": "nwnwnwnnn",
            "/": "nwnwnnnwn",
            "+": "nwnnnwnwn",
            "%": "nnnwnwnwn",
        }
        # The caller should do this, or we can't rotate the thing.
        # self.set_fill_color(0)
        for c in text.upper():
            if c not in chars:
                raise RuntimeError(f'Invalid char "{c}" for Code39')
            for i, d in enumerate(chars[c]):
                if i % 2 == 0:
                    self.rect(x, y, dim[d], h, "F")
                x += dim[d]
            x += dim["n"]

    @check_page
    @contextmanager
    def rect_clip(self, x: float, y: float, w: float, h: float) -> Iterator[None]:
        """
        Context manager that defines a rectangular crop zone,
        useful to render only part of an image.

        Args:
            x (float): abscissa of the clipping region top left corner
            y (float): ordinate of the clipping region top left corner
            w (float): width of the clipping region
            h (float): height of the clipping region
        """
        self._out(
            (
                f"q {x * self.k:.2f} {(self.h - y - h) * self.k:.2f} {w * self.k:.2f} "
                f"{h * self.k:.2f} re W n"
            )
        )
        yield
        self._out("Q")

    @check_page
    @contextmanager
    def elliptic_clip(self, x: float, y: float, w: float, h: float) -> Iterator[None]:
        """
        Context manager that defines an elliptic crop zone,
        useful to render only part of an image.

        Args:
            x (float): abscissa of the clipping region top left corner
            y (float): ordinate of the clipping region top left corner
            w (float): ellipse width
            h (float): ellipse height
        """
        self._out("q")
        self._draw_ellipse(x, y, w, h, "W n")
        yield
        self._out("Q")

    @check_page
    @contextmanager
    def round_clip(self, x: float, y: float, r: float) -> Iterator[None]:
        """
        Context manager that defines a circular crop zone,
        useful to render only part of an image.

        Args:
            x (float): abscissa of the clipping region top left corner
            y (float): ordinate of the clipping region top left corner
            r (float): radius of the clipping region
        """
        with self.elliptic_clip(x, y, r, r):
            yield

    @contextmanager
    def unbreakable(self) -> Iterator[FPDFRecorder]:
        """
        Ensures that all rendering performed in this context appear on a single page
        by performing page break beforehand if need be.

        Detailed documentation on page breaks: https://py-pdf.github.io/fpdf2/PageBreaks.html

        Notes
        -----

        Using this method means to duplicate the FPDF `bytearray` buffer:
        when generating large PDFs, doubling memory usage may be troublesome.
        """
        prev_page, prev_y = self.page, self.y
        recorder = FPDFRecorder(self, accept_page_break=False)
        recorder.page_break_triggered = False
        self._in_unbreakable = True
        LOGGER.debug("Starting unbreakable block")
        yield recorder
        y_scroll = recorder.y - prev_y + (recorder.page - prev_page) * self.eph
        if prev_y + y_scroll > self.page_break_trigger or recorder.page > prev_page:
            LOGGER.debug("Performing page jump due to unbreakable height")
            recorder.rewind()
            # pylint: disable=protected-access
            # Performing this call through .pdf so that it does not get recorded & replayed:
            recorder.pdf._perform_page_break()
            recorder.replay()
            recorder.page_break_triggered = True
        self._in_unbreakable = False
        LOGGER.debug("Ending unbreakable block")

    @contextmanager
    def offset_rendering(self) -> Iterator[FPDFRecorder]:
        """
        All rendering performed in this context is made on a dummy FPDF object.
        This allows to test the results of some operations on the global layout
        before performing them "for real".
        """
        prev_page, prev_y = self.page, self.y
        recorder = FPDFRecorder(self, accept_page_break=False)
        recorder.page_break_triggered = False
        yield recorder
        y_scroll = recorder.y - prev_y + (recorder.page - prev_page) * self.eph
        if prev_y + y_scroll > self.page_break_trigger or recorder.page > prev_page:
            recorder.page_break_triggered = True
        recorder.rewind()

    @check_page
    def insert_toc_placeholder(
        self,
        render_toc_function: Callable[["FPDF", list[OutlineSection]], None],
        pages: int = 1,
        allow_extra_pages: bool = False,
        reset_page_indices: bool = True,
    ) -> None:
        """
        Configure Table Of Contents rendering at the end of the document generation,
        and reserve some vertical space right now in order to insert it.
        At least one page break is triggered by this method.

        Args:
            render_toc_function (function): a function that will be invoked to render the ToC.
                This function will receive 2 parameters: `pdf`, an instance of FPDF, and `outline`,
                a list of `fpdf.outline.OutlineSection`.
            pages (int): the number of pages that the Table of Contents will span,
                including the current one that will. As many page breaks as the value of this argument
                will occur immediately after calling this method.
            allow_extra_pages (bool): If set to `True`, allows for an unlimited number of
                extra pages in the ToC, which may cause discrepancies with pre-rendered
                page numbers. For consistent numbering, using page labels to create a
                separate numbering style for the ToC is recommended.
            reset_page_indices (bool): Whether to reset the pages indices after the ToC. Default to True.
        """
        if pages < 1:
            raise ValueError(
                f"'pages' parameter must be equal or greater than 1: {pages}"
            )
        if not callable(render_toc_function):
            raise TypeError(
                f"The first argument must be a callable, got: {type(render_toc_function)}"
            )
        if self.toc_placeholder:
            raise FPDFException(
                "A placeholder for the table of contents has already been defined"
                f" on page {self.toc_placeholder.start_page}"
            )
        self.toc_placeholder = ToCPlaceholder(
            render_toc_function,
            self.page,
            self.y,
            self.cur_orientation,
            pages,
            reset_page_indices,
        )
        self._toc_allow_page_insertion = allow_extra_pages
        for _ in range(pages):
            self._perform_page_break()

    def set_section_title_styles(
        self,
        level0: TextStyle,
        level1: Optional[TextStyle] = None,
        level2: Optional[TextStyle] = None,
        level3: Optional[TextStyle] = None,
        level4: Optional[TextStyle] = None,
        level5: Optional[TextStyle] = None,
        level6: Optional[TextStyle] = None,
    ) -> None:
        """
        Defines a style for section titles.
        After calling this method, calls to `FPDF.start_section` will render section names visually.

        Args:
            level0 (TextStyle): style for the top level section titles
            level1 (TextStyle): optional style for the level 1 section titles
            level2 (TextStyle): optional style for the level 2 section titles
            level3 (TextStyle): optional style for the level 3 section titles
            level4 (TextStyle): optional style for the level 4 section titles
            level5 (TextStyle): optional style for the level 5 section titles
            level6 (TextStyle): optional style for the level 6 section titles
        """
        index: int
        level: Optional[TextStyle]
        for index, level in enumerate(
            [level0, level1, level2, level3, level4, level5, level6]
        ):
            if level is not None:
                if not isinstance(level, TextStyle):
                    raise TypeError(
                        f"Arguments must all be TextStyle instances, got: {type(level)}"
                    )
                self.section_title_styles[index] = level

    @check_page
    def start_section(self, name: str, level: int = 0, strict: bool = True) -> None:
        """
        Start a section in the document outline.
        If section_title_styles have been configured,
        render the section name visually as a title.

        Args:
            name (str): section name
            level (int): section level in the document outline. 0 means top-level.
            strict (bool): whether to raise an exception if levels increase incorrectly,
                for example with a level-3 section following a level-1 section.
        """
        if level < 0:
            raise ValueError('"level" mut be equal or greater than zero')
        if strict and self._outline and level > self._outline[-1].level + 1:
            raise ValueError(
                f"Incoherent hierarchy: cannot start a level {level} section after a level {self._outline[-1].level} one"
            )
        dest = DestinationXYZ(self.page, top=self.h_pt - self.y * self.k)
        outline_struct_elem = None
        if self.section_title_styles:
            text_style = self.section_title_styles[level]
            # We first check if adding this multi-cell will trigger a page break:
            if text_style.size_pt is not None:
                prev_font_size_pt = self.font_size_pt
                self.font_size_pt = text_style.size_pt
            # check if l_margin value is of type Align or string
            align = Align.L
            if isinstance(text_style.l_margin, (Align, str)):
                align = Align.coerce(text_style.l_margin)
            page_break_triggered = self.multi_cell(
                w=self.epw,
                h=self.font_size,
                text=name,
                new_x=XPos.LMARGIN,
                new_y=YPos.NEXT,
                dry_run=True,  # => does not produce any output
                output=MethodReturnValue.PAGE_BREAK,
                align=align,
                padding=Padding(
                    top=text_style.t_margin or 0,
                    left=(
                        text_style.l_margin
                        if isinstance(text_style.l_margin, (int, float))
                        else 0
                    ),
                    bottom=text_style.b_margin or 0,
                ),
            )
            if text_style.size_pt is not None:
                self.font_size_pt = (
                    prev_font_size_pt  # pyright: ignore[reportPossiblyUnboundVariable]
                )
            if page_break_triggered:
                # If so, we trigger a page break manually beforehand:
                self.add_page()
            with self._marked_sequence(title=name) as struct_elem:
                outline_struct_elem = struct_elem
                with self.use_text_style(text_style):
                    self.multi_cell(
                        w=self.epw,
                        h=self.font_size,
                        text=name,
                        align=align,
                        new_x=XPos.LMARGIN,
                        new_y=YPos.NEXT,
                        center=text_style.l_margin == Align.C,
                    )
        self._outline.append(
            OutlineSection(name, level, self.page, dest, outline_struct_elem)
        )

    @contextmanager
    def use_text_style(self, text_style: TextStyle) -> Iterator[None]:
        prev_l_margin = None
        if text_style:
            if text_style.t_margin:
                self.ln(text_style.t_margin)
            if text_style.l_margin:
                if isinstance(text_style.l_margin, (float, int)):
                    prev_l_margin = self.l_margin
                    self.l_margin = text_style.l_margin
                    self.x = self.l_margin
                else:
                    LOGGER.debug(
                        "Unsupported '%s' value provided as l_margin to .use_text_style()",
                        text_style.l_margin,
                    )
        with self.use_font_face(text_style):
            yield
        if text_style and text_style.b_margin:
            self.ln(text_style.b_margin)
        if prev_l_margin is not None:
            self.l_margin = prev_l_margin
            self.x = self.l_margin

    @contextmanager
    def use_font_face(self, font_face: FontFace) -> Iterator[None]:
        """
        Sets the provided `fpdf.fonts.FontFace` in a local context,
        then restore font settings back to they were initially.
        This method must be used as a context manager using `with`:

            with pdf.use_font_face(FontFace(emphasis="BOLD", color=255, size_pt=42)):
                put_some_text()

        Known limitation: in case of a page jump in this local context,
        the temporary style may "leak" in the header() & footer().
        """
        if not font_face:
            yield
            return
        prev_font = (self.font_family, self.font_style, self.font_size_pt)
        self.set_font(
            font_face.family or self.font_family,
            (
                font_face.emphasis.style
                if font_face.emphasis is not None
                else self.font_style
            ),
            font_face.size_pt or self.font_size_pt,
        )
        self.current_font_is_set_on_page = False
        prev_text_color = self.text_color
        if font_face.color is not None and font_face.color != self.text_color:
            self.set_text_color(font_face.color)
        prev_fill_color = self.fill_color
        if font_face.fill_color is not None:
            self.set_fill_color(font_face.fill_color)
        yield
        if font_face.fill_color is not None:
            assert prev_fill_color is not None
            self.set_fill_color(prev_fill_color)
        self.text_color = prev_text_color
        self.set_font(*prev_font)

    @check_page
    @contextmanager
    def table(self, *args: Any, **kwargs: Any) -> Iterator[Table]:
        """
        Inserts a table, that can be built using the `fpdf.table.Table` object yield.
        Detailed usage documentation: https://py-pdf.github.io/fpdf2/Tables.html

        Args:
            rows: optional. Sequence of rows (iterable) of str to initiate the table cells with text content.
            align (str, fpdf.enums.Align): optional, default to CENTER. Sets the table horizontal position
                relative to the page, when it's not using the full page width.
            borders_layout (str, fpdf.enums.TableBordersLayout): optional, default to ALL. Control what cell
                borders are drawn.
            cell_fill_color (int, tuple, fpdf.drawing.DeviceCMYK, fpdf.drawing.DeviceGray, fpdf.drawing.DeviceRGB): optional.
                Defines the cells background color.
            cell_fill_mode (str, fpdf.enums.TableCellFillMode): optional. Defines which cells are filled
                with color in the background.
            col_widths (int, tuple): optional. Sets column width. Can be a single number or a sequence of numbers.
            first_row_as_headings (bool): optional, default to True. If False, the first row of the table
                is not styled differently from the others.
            gutter_height (float): optional vertical space between rows.
            gutter_width (float): optional horizontal space between columns.
            headings_style (fpdf.fonts.FontFace): optional, default to bold.
                Defines the visual style of the top headings row: size, color, emphasis...
            line_height (number): optional. Defines how much vertical space a line of text will occupy.
            markdown (bool): optional, default to False. Enable markdown interpretation of cells textual content.
            text_align (str, fpdf.enums.Align): optional, default to JUSTIFY. Control text alignment inside cells.
            v_align (str, fpdf.enums.VAlign): optional, default to CENTER. Control vertical alignment of cells content.
            width (number): optional. Sets the table width.
            wrapmode (fpdf.enums.WrapMode): "WORD" for word based line wrapping (default),
                "CHAR" for character based line wrapping.
            padding (number, tuple, Padding): optional. Sets the cell padding. Can be a single number or a sequence
                of numbers, default:0
                If padding for left or right ends up being non-zero then the respective c_margin is ignored.
            outer_border_width (number): optional. The outer_border_width will trigger rendering of the outer
                border of the table with the given width regardless of any other defined border styles.
            num_heading_rows (number): optional. Sets the number of heading rows, default value is 1. If this value is not 1,
                first_row_as_headings needs to be True if num_heading_rows>1 and False if num_heading_rows=0. For backwards compatibility,
                first_row_as_headings is used in case num_heading_rows is 1.
            repeat_headings (fpdf.enums.TableHeadingsDisplay): optional, indicates whether to print table headings on every page, default to 1.
        """
        table = Table(self, *args, **kwargs)
        yield table
        table.render()

    @deprecated_parameter([("dest", "2.2.0")])
    def output(
        self,
        name: str | os.PathLike[str] | BinaryIO = "",
        *,
        linearize: bool = False,
        output_producer_class: Type[OutputProducer] = OutputProducer,
    ) -> Optional[bytearray]:
        """
        Output PDF to some destination.
        The method first calls [close](close.md) if necessary to terminate the document.
        After calling this method, content cannot be added to the document anymore.

        By default the bytearray buffer is returned.
        If a `name` is given, the PDF is written to a new file.

        Args:
            name (str): optional File object or file path where to save the PDF under
            output_producer_class (class): use a custom class for PDF file generation
        """
        # Clear cache of cached functions to free up memory after output
        get_unicode_script.cache_clear()
        # Finish document if necessary:
        if not self.buffer:
            if self.page == 0:
                self.add_page()
            # Generating final page footer:
            self._render_footer()
            # Generating .buffer based on .pages:
            if self.toc_placeholder:
                self._insert_table_of_contents()
            if self.str_alias_nb_pages:
                for page in self.pages.values():
                    for substitution_item in page.get_text_substitutions():
                        page.contents = page.contents.replace(  # type: ignore[union-attr]
                            substitution_item.get_placeholder_string().encode(
                                "latin-1"
                            ),
                            substitution_item.render_text_substitution(
                                str(self.pages_count)
                            ).encode("latin-1"),
                        )
            for _, font in self.fonts.items():
                if isinstance(font, TTFFont) and font.color_font:
                    font.color_font.load_glyphs()
            if self._compliance and self._compliance.profile == "PDFA":
                if len(self._output_intents) == 0:
                    self.add_output_intent(
                        OutputIntentSubType.PDFA,
                        output_condition_identifier="sRGB",
                        output_condition="IEC 61966-2-1:1999",
                        registry_name="http://www.color.org",
                        dest_output_profile=PDFICCProfile(
                            contents=builtin_srgb2014_bytes(),
                            n=3,
                            alternate="DeviceRGB",
                        ),
                        info="sRGB2014 (v2)",
                    )
                if (
                    self._compliance.part == 4
                    and self._compliance.conformance == "F"
                    and len(self.embedded_files) == 0
                ):
                    raise PDFAComplianceError(
                        f"{self._compliance.label} requires at least one embedded file"
                    )
            if linearize:
                output_producer_class = LinearizedOutputProducer
            output_producer = output_producer_class(self)
            self.buffer = output_producer.bufferize()
        if name:
            if isinstance(name, (str, os.PathLike)):
                Path(name).write_bytes(self.buffer)
            else:
                name.write(self.buffer)
            return None
        return self.buffer
```

Example 3 (python):
```python
@property
def accept_page_break(self) -> bool:
    """
    Whenever a page break condition is met, this `@property` method is called,
    and the break is issued or not depending on the returned value.

    The default implementation returns `self.auto_page_break`,
    a value according to the mode selected by `FPDF.set_auto_page_break()`.

    This method is called automatically and should not be called directly by the application.

    Detailed documentation on page breaks: https://py-pdf.github.io/fpdf2/PageBreaks.html
    """
    return self.auto_page_break
```

Example 4 (python):
```python
@property
def default_page_dimensions(self) -> tuple[float, float]:
    "Return a pair (width, height) in points units (1/72 of inch)"
    return (
        (self.dw_pt, self.dh_pt)
        if self.def_orientation == PageOrientation.PORTRAIT
        else (self.dh_pt, self.dw_pt)
    )
```

---

## Module fpdf.drawing_primitives

**URL:** https://py-pdf.github.io/fpdf2/fpdf/drawing_primitives.html

**Contents:**
- Module fpdf.drawing_primitives
- Functions
- Args
- Returns
- Raises
- Args
- Returns
- Args
- Returns
- Args

Core drawing primitives for fpdf2.

This module defines the fundamental data structures used throughout the drawing API, including:

These classes are intentionally lightweight and self-contained so they can be safely imported from any other drawing-related module without creating circular dependencies.

All higher-level drawing features (paths, patterns, gradients, etc.) build on top of these primitives.

Produce a DeviceCMYK color from the given 8-bit CMYK values.

DeviceCMYK color representation.

Parse an RGB color from a css-style 8-bit hexadecimal color string.

of the form #RGB, #RGBA, #RRGGBB, or #RRGGBBAA (case insensitive). Must include the leading octothorp. Forms omitting the alpha field are interpreted as not specifying the opacity, so it will not be explicitly set.

An alpha value of 00 is fully transparent and FF is fully opaque.

DeviceRGB representation of the color.

Parse an RGB color from a css-style rgb(R, G, B, A) color string.

DeviceRGB representation of the color.

Produce a DeviceGray color from the given 8-bit gray value.

DeviceGray color representation.

Produce a DeviceRGB color from the given 8-bit RGB values.

DeviceRGB color representation.

A class representing a PDF DeviceCMYK color.

The alpha color component (i.e. opacity). Must be None or in the interval [0, 1].

An alpha value of 0 makes the color fully transparent, and a value of 1 makes it fully opaque. If None, the color will be interpreted as not specifying a particular transparency rather than specifying fully transparent or fully opaque.

The cyan color component. Must be in the interval [0, 1].

The color components as a tuple in order (c, m, y, k) with alpha omitted, in range 0-1.

The black color component. Must be in the interval [0, 1].

The magenta color component. Must be in the interval [0, 1].

The PDF drawing operator used to specify this type of color.

The yellow color component. Must be in the interval [0, 1].

A class representing a PDF DeviceGray color.

The alpha color component (i.e. opacity). Must be None or in the interval [0, 1].

An alpha value of 0 makes the color fully transparent, and a value of 1 makes it fully opaque. If None, the color will be interpreted as not specifying a particular transparency rather than specifying fully transparent or fully opaque.

The color components as a tuple in order (r, g, b) with alpha omitted, in range 0-1.

The color components as a tuple in order (r, g, b) with alpha omitted, in range 0-255.

The gray color component. Must be in the interval [0, 1].

A value of 0 represents black and a value of 1 represents white.

The PDF drawing operator used to specify this type of color.

A class representing a PDF DeviceRGB color.

The alpha color component (i.e. opacity). Must be None or in the interval [0, 1].

An alpha value of 0 makes the color fully transparent, and a value of 1 makes it fully opaque. If None, the color will be interpreted as not specifying a particular transparency rather than specifying fully transparent or fully opaque.

The blue color component. Must be in the interval [0, 1].

The color components as a tuple in order (r, g, b) with alpha omitted, in range 0-1.

The color components as a tuple in order (r, g, b) with alpha omitted, in range 0-255.

The green color component. Must be in the interval [0, 1].

The PDF drawing operator used to specify this type of color.

The red color component. Must be in the interval [0, 1].

An x-y coordinate pair within the two-dimensional coordinate frame.

The abscissa of the point.

The ordinate of the point.

Produce the sum of two points.

Adding two points is the same as translating the source point by interpreting the other point's x and y coordinates as distances.

A Point which is the sum of the two source points.

Divide a point by a scalar value using integer division.

Because division is not commutative, Point // scalar is implemented, but scalar // Point is nonsensical and not implemented.

A Point whose coordinates are the result of the division.

Transform a point with the given transform matrix.

This operator is only implemented for Transforms. This transform is not commutative, so Point @ Transform is implemented, but Transform @ Point is not implemented (technically speaking, the current implementation is commutative because of the way points and transforms are represented, but if that representation were to change this operation could stop being commutative)

A Point whose coordinates are the result of applying the transform.

Multiply a point by a scalar value.

A Point whose coordinates are the result of the multiplication.

Produce a point by negating this point's coordinates.

A Point whose coordinates are this points coordinates negated.

Produce the difference between two points.

Unlike addition, this is not a commutative operation!

A Point which is the difference of the two source points.

Divide a point by a scalar value.

Because division is not commutative, Point / scalar is implemented, but scalar / Point is nonsensical and not implemented.

A Point whose coordinates are the result of the division.

Compute the angle between two points (interpreted as vectors from the origin).

The return value is in the interval (-pi, pi]. Sign is dependent on ordering, with clockwise angle travel considered to be positive due to the orientation of the coordinate frame basis vectors (i.e. the angle between (1, 0) and (0, 1) is +pi/2, the angle between (1, 0) and (0, -1) is -pi/2, and the angle between (0, -1) and (1, 0) is +pi/2).

The scalar angle between the two points in radians.

Compute the dot product of two points.

The scalar result of the dot product computation.

Compute the Cartesian distance from this point to the origin

This is the same as computing the magnitude of the vector represented by this point.

The scalar result of the distance computation.

Render the point to the string "x y" for emitting to a PDF.

A representation of an affine transformation matrix for 2D shapes.

The actual matrix is:

Complex transformation operations can be composed via a sequence of simple transformations by performing successive matrix multiplication of the simple transformations.

For example, scaling a set of points around a specific center point can be represented by a translation-scale-translation sequence, where the first translation translates the center to the origin, the scale transform scales the points relative to the origin, and the second translation translates the points back to the specified center point. Transform multiplication is performed using python's dedicated matrix multiplication operator, @

The semantics of this representation mean composed transformations are specified left-to-right in order of application (some other systems provide transposed representations, in which case the application order is right-to-left).

For example, to rotate the square (1,1) (1,3) (3,3) (3,1) 45 degrees clockwise about its center point (which is (2,2)) , the translate-rotate-translate process described above may be applied:

Instances of this class provide a chaining API, so the above transform could also be constructed as follows:

Or, because the particular operation of performing some transformations about a specific point is pretty common,

By convention, this class provides class method constructors following noun-ish naming (translation, scaling, rotation, shearing) and instance method manipulations following verb-ish naming (translate, scale, rotate, shear).

Create a transform representing the identity transform.

The identity transform is a no-op.

Create a transform that performs rotation.

A Transform representing the specified rotation.

Create a transform that performs rotation in degrees.

A Transform representing the specified rotation.

Create a transform that performs scaling.

A Transform representing the specified scaling.

Create a transform that performs shearing (not of sheep).

A Transform representing the specified shearing.

Create a skew (shear) transform using angles in radians.

A Transform representing the specified skew.

Create a skew (shear) transform using angles in degrees.

A Transform representing the specified skew.

Create a transform that performs translation.

A Transform representing the specified translation.

Compose two transforms into a single transform.

A Transform representing the composed transform.

Multiply the individual transform parameters by a scalar value.

A Transform with the modified parameters.

Bracket the given transform in a pair of translations to make it appear about a point that isn't the origin.

This is a useful shorthand for performing a transform like a rotation around the center point of an object that isn't centered at the origin.

Transforms are immutable, so this returns a new transform rather than mutating self.

A Transform representing the composed transform.

Produce a transform that is the inverse of this transform.

A Transform representing the inverse of this transform.

Render the transform to its PDF output representation.

A tuple of (str, last_item). last_item is returned unchanged.

Produce a transform by composing the current transform with a rotation.

Transforms are immutable, so this returns a new transform rather than mutating self.

A Transform representing the composed transform.

Produce a transform by composing the current transform with a rotation in degrees.

Transforms are immutable, so this returns a new transform rather than mutating self.

A Transform representing the composed transform.

Returns (sqrt(a¬≤ + c¬≤), sqrt(b¬≤ + d¬≤)), i.e. the Euclidean norms of those rows. These values bound how much the transform can stretch geometry along the device X and Y axes, respectively, and are useful for inflating axis-aligned bounding boxes to account for stroke width under the CTM.

Produce a transform by composing the current transform with a scaling.

Transforms are immutable, so this returns a new transform rather than mutating self.

A Transform representing the composed transform.

Produce a transform by composing the current transform with a shearing.

Transforms are immutable, so this returns a new transform rather than mutating self.

A Transform representing the composed transform.

Compose with a skew (radians).

Compose with a skew (degrees).

Produce a transform by composing the current transform with a translation.

Transforms are immutable, so this returns a new transform rather than mutating self.

A Transform representing the composed transform.

**Examples:**

Example 1 (python):
```python
def check_range(value: Number, minimum: float = 0.0, maximum: float = 1.0) -> Number:
    if not minimum <= value <= maximum:
        raise ValueError(f"{value} not in range [{minimum}, {maximum}]")

    return value
```

Example 2 (python):
```python
def cmyk8(
    c: Number, m: Number, y: Number, k: Number, a: Optional[Number] = None
) -> DeviceCMYK:
    """
    Produce a DeviceCMYK color from the given 8-bit CMYK values.

    Args:
        c (Number): red color component. Must be in the interval [0, 255].
        m (Number): green color component. Must be in the interval [0, 255].
        y (Number): blue color component. Must be in the interval [0, 255].
        k (Number): blue color component. Must be in the interval [0, 255].
        a (Optional[Number]): alpha component. Must be `None` or in the interval
            [0, 255]. 0 is fully transparent, 255 is fully opaque

    Returns:
        DeviceCMYK color representation.

    Raises:
        ValueError: if any components are not in their valid interval.
    """
    if a is not None:
        a = float(a) / 255.0

    return DeviceCMYK(
        float(c) / 255.0, float(m) / 255.0, float(y) / 255.0, float(k) / 255.0, a
    )
```

Example 3 (python):
```python
def color_from_hex_string(hexstr: str) -> DeviceRGB | DeviceGray:
    """
    Parse an RGB color from a css-style 8-bit hexadecimal color string.

    Args:
        hexstr (str): of the form `#RGB`, `#RGBA`, `#RRGGBB`, or `#RRGGBBAA` (case
            insensitive). Must include the leading octothorp. Forms omitting the alpha
            field are interpreted as not specifying the opacity, so it will not be
            explicitly set.

            An alpha value of `00` is fully transparent and `FF` is fully opaque.

    Returns:
        DeviceRGB representation of the color.
    """
    if not isinstance(hexstr, str):
        raise TypeError(f"{hexstr} is not of type str")

    if not hexstr.startswith("#"):
        raise ValueError(f"{hexstr} does not start with #")

    hlen = len(hexstr)

    if hlen == 4:  # #RGB
        r = int(hexstr[1] * 2, 16)
        g = int(hexstr[2] * 2, 16)
        b = int(hexstr[3] * 2, 16)
        a = None

    elif hlen == 5:  # #RGBA
        r = int(hexstr[1] * 2, 16)
        g = int(hexstr[2] * 2, 16)
        b = int(hexstr[3] * 2, 16)
        a = int(hexstr[4] * 2, 16)

    elif hlen == 7:  # #RRGGBB
        r = int(hexstr[1:3], 16)
        g = int(hexstr[3:5], 16)
        b = int(hexstr[5:7], 16)
        a = None

    elif hlen == 9:  # #RRGGBBAA
        r = int(hexstr[1:3], 16)
        g = int(hexstr[3:5], 16)
        b = int(hexstr[5:7], 16)
        a = int(hexstr[7:9], 16)

    else:
        raise ValueError(f"{hexstr} could not be interpreted as a RGB(A) hex string")

    return rgb8(r, g, b, a)
```

Example 4 (python):
```python
def color_from_rgb_string(rgbstr: str) -> DeviceRGB | DeviceGray:
    """
    Parse an RGB color from a css-style rgb(R, G, B, A) color string.

    Args:
        rgbstr (str): of the form `rgb(R, G, B)` or `rgb(R, G, B, A)`.

    Returns:
        DeviceRGB representation of the color.
    """
    if not isinstance(rgbstr, str):
        raise TypeError(f"{rgbstr} is not of type str")

    rgbstr = rgbstr.replace(" ", "")

    if not rgbstr.startswith("rgb(") or not rgbstr.endswith(")"):
        raise ValueError(f"{rgbstr} does not follow the expected rgb(...) format")

    rgbstr = rgbstr[4:-1]
    colors = rgbstr.split(",")

    if len(colors) == 3:
        r, g, b = (int(c) for c in colors)
        return rgb8(r, g, b, a=None)

    if len(colors) == 4:
        return rgb8(*[int(c) for c in colors])

    raise ValueError(f"{rgbstr} could not be interpreted as a rgb(R, G, B[, A]) color")
```

---

## Tutorial¬∂

**URL:** https://py-pdf.github.io/fpdf2/Tutorial-bn.html

**Contents:**
- Tutorial¬∂
- ‡¶ü‡¶ø‡¶â‡¶ü‡ßã‡¶∞‡¶ø‡ßü‡¶æ‡¶≤ ‡ßß - ‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡¶ø‡¶™‡ßç‡¶§ ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£¬∂
- ‡¶ü‡¶ø‡¶â‡¶ü‡ßã‡¶∞‡¶ø‡ßü‡¶æ‡¶≤ ‡ß® - ‡¶π‡ßá‡¶°‡¶æ‡¶∞, ‡¶´‡ßÅ‡¶ü‡¶æ‡¶∞, ‡¶™‡ßá‡¶ú ‡¶¨‡ßç‡¶∞‡ßá‡¶ï ‡¶è‡¶¨‡¶Ç ‡¶á‡¶Æ‡ßá‡¶ú¬∂
- ‡¶ü‡¶ø‡¶â‡¶ü‡ßã‡¶∞‡¶ø‡ßü‡¶æ‡¶≤ ‡ß© - ‡¶≤‡¶æ‡¶á‡¶® ‡¶¨‡ßç‡¶∞‡ßá‡¶ï ‡¶è‡¶¨‡¶Ç ‡¶ï‡¶æ‡¶≤‡¶æ‡¶∞‡¶∏¬∂
- ‡¶ü‡¶ø‡¶â‡¶ü‡ßã‡¶∞‡¶ø‡ßü‡¶æ‡¶≤ ‡ß™ - ‡¶Æ‡¶æ‡¶≤‡ßç‡¶ü‡¶ø ‡¶ï‡¶≤‡¶æ‡¶Æ¬∂
- ‡¶ü‡¶ø‡¶â‡¶ü‡ßã‡¶∞‡¶ø‡ßü‡¶æ‡¶≤ ‡ß´ - ‡¶ü‡ßá‡¶¨‡¶ø‡¶≤ ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡¶æ¬∂
- ‡¶ü‡¶ø‡¶â‡¶ü‡ßã‡¶∞‡¶ø‡ßü‡¶æ‡¶≤ ‡ß¨ - ‡¶≤‡¶ø‡¶Ç‡¶ï ‡¶è‡¶¨‡¶Ç ‡¶Æ‡¶ø‡¶∂‡ßç‡¶∞ ‡¶ü‡ßá‡¶ï‡ßç‡¶∏‡¶ü ‡¶∏‡ßç‡¶ü‡¶æ‡¶á‡¶≤ ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡¶æ¬∂

Method ‡¶ó‡ßÅ‡¶≤‡ßã‡¶∞ ‡¶∏‡¶Æ‡ßç‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶°‡¶ï‡ßÅ‡¶Æ‡ßá‡¶®‡ßç‡¶ü‡ßá‡¶∂‡¶®: fpdf.FPDF API doc

‡¶è‡¶ï‡¶ü‡¶ø ‡¶ï‡ßç‡¶≤‡¶æ‡¶∏‡¶ø‡¶ï ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£ ‡¶¶‡¶ø‡ßü‡ßá ‡¶∂‡ßÅ‡¶∞‡ßÅ ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡¶ï:

‡¶™‡ßç‡¶∞‡ßü‡ßã‡¶ú‡¶®‡ßÄ‡ßü ‡¶≤‡¶æ‡¶á‡¶¨‡ßç‡¶∞‡ßá‡¶∞‡ßÄ‡¶ó‡ßÅ‡¶≤‡ßã ‡¶Ø‡ßÅ‡¶ï‡ßç‡¶§ ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶™‡¶∞, ‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶è‡¶ï‡¶ü‡¶æ FPDF ‡¶Ö‡¶¨‡ßç‡¶ú‡ßá‡¶ï‡ßç‡¶ü ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡¶¨‡ßã. FPDF ‡¶ï‡¶®‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡¶æ‡¶ï‡ßç‡¶ü‡¶∞‡¶ü‡¶ø ‡¶è‡¶ñ‡¶æ‡¶®‡ßá ‡¶°‡¶ø‡¶´‡¶≤‡ßç‡¶ü ‡¶≠‡ßç‡¶Ø‡¶æ‡¶≤‡ßÅ‡¶ó‡ßÅ‡¶≤‡ßã ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶õ‡ßá: ‡¶™‡ßÉ‡¶∑‡ßç‡¶†‡¶æ‡¶ó‡ßÅ‡¶≤‡ßã A4 ‡¶™‡ßã‡¶∞‡ßç‡¶ü‡ßç‡¶∞‡ßá‡¶ü ‡¶∏‡¶æ‡¶á‡¶ú‡ßá‡¶∞ ‡¶è‡¶¨‡¶Ç ‡¶™‡¶∞‡¶ø‡¶Æ‡¶æ‡¶™‡¶ï ‡¶è‡¶ï‡¶ï ‡¶π‡¶ö‡ßç‡¶õ‡ßá ‡¶Æ‡¶ø‡¶≤‡¶ø‡¶Æ‡¶ø‡¶ü‡¶æ‡¶∞. ‡¶è‡¶ü‡¶æ‡¶ï‡ßá ‡¶¨‡¶æ‡¶π‡ßç‡¶Ø‡¶ø‡¶ï‡¶≠‡¶æ‡¶¨‡ßá ‡¶â‡¶≤‡ßç‡¶≤‡ßá‡¶ñ ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡ßü ‡¶®‡¶ø‡¶ö‡ßá‡¶∞ ‡¶∏‡ßç‡¶®‡¶ø‡¶™‡ßá‡¶ü ‡¶è‡¶∞ ‡¶Æ‡¶§ ‡¶ï‡¶∞‡ßá -

‡¶™‡¶ø‡¶°‡¶ø‡¶è‡¶´ ‡¶ï‡ßá ‡¶≤‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶°‡¶∏‡ßç‡¶ï‡ßá‡¶™ ‡¶Æ‡ßã‡¶° (L) ‡¶Ö‡¶•‡¶¨‡¶æ ‡¶Ö‡¶®‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶Ø ‡¶´‡¶∞‡¶Æ‡ßç‡¶Ø‡¶æ‡¶ü ‡¶è‡¶ì ‡¶™‡ßÉ‡¶∑‡ßç‡¶†‡¶æ ‡¶¨‡¶ø‡¶®‡ßç‡¶Ø‡¶æ‡¶∏ ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡ßü (‡¶Ø‡ßá‡¶Æ‡¶® Letter ‡¶è‡¶¨‡¶Ç Legal) ‡¶è‡¶¨‡¶Ç ‡¶™‡¶∞‡¶ø‡¶Æ‡¶æ‡¶™‡¶ï ‡¶è‡¶ï‡¶ï (pt, cm, in)‡•§

‡¶è‡¶á ‡¶Æ‡ßÅ‡¶π‡ßÅ‡¶∞‡ßç‡¶§‡ßá ‡¶è‡¶ñ‡¶æ‡¶®‡ßá ‡¶ï‡ßã‡¶® ‡¶™‡ßÉ‡¶∑‡ßç‡¶†‡¶æ ‡¶®‡ßá‡¶á, ‡¶§‡¶æ‡¶á ‡¶Ü‡¶Æ‡¶æ‡¶¶‡ßá‡¶∞ ‡¶è‡¶ï‡¶ü‡¶æ ‡¶™‡ßÉ‡¶∑‡ßç‡¶†‡¶æ ‡¶Ø‡ßÅ‡¶ï‡ßç‡¶§ ‡¶ï‡¶∞‡¶§‡ßá ‡¶π‡¶¨‡ßá add_page‡•§ ‡¶∂‡ßÅ‡¶∞‡ßÅ‡¶ü‡¶æ ‡¶â‡¶™‡¶∞-‡¶®‡¶æ‡¶Æ ‡¶ï‡ßã‡¶£‡¶æ‡ßü ‡¶è‡¶¨‡¶Ç ‡¶¨‡¶∞‡ßç‡¶§‡¶Æ‡¶æ‡¶® ‡¶Ö‡¶¨‡¶∏‡ßç‡¶•‡¶æ‡¶®‡¶ü‡¶ø ‡¶∏‡ßÄ‡¶Æ‡¶æ‡¶®‡ßç‡¶§ ‡¶•‡ßá‡¶ï‡ßá ‡¶ó‡¶§‡¶æ‡¶®‡ßÅ‡¶ó‡¶§‡¶ø‡¶ï‡¶≠‡¶æ‡¶¨‡ßá ‡ßß ‡¶∏‡ßá‡¶®‡ßç‡¶ü‡¶ø‡¶Æ‡¶ø‡¶ü‡¶æ‡¶∞ ‡¶®‡¶ø‡¶ö‡ßá‡¶∞ ‡¶¶‡¶ø‡¶ï‡ßá ‡¶Ö‡¶¨‡¶∏‡ßç‡¶•‡¶æ‡¶® ‡¶ï‡¶∞‡ßá; ‡¶Æ‡¶æ‡¶∞‡ßç‡¶ú‡¶ø‡¶® ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡¶¨‡ßá set_margins‡•§

‡¶≤‡¶ø‡¶ñ‡¶æ ‡¶™‡ßç‡¶∞‡¶ø‡¶®‡ßç‡¶ü ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶™‡ßÇ‡¶∞‡ßç‡¶¨‡ßá‡¶á ‡¶´‡¶®‡ßç‡¶ü ‡¶∏‡¶ø‡¶≤‡ßá‡¶ï‡ßç‡¶ü ‡¶ï‡¶∞‡ßá ‡¶®‡¶ø‡¶§‡ßá ‡¶π‡ßü set_font, ‡¶®‡¶§‡ßÅ‡¶¨‡¶æ ‡¶°‡¶ï‡ßÅ‡¶Æ‡ßá‡¶®‡ßç‡¶ü ‡¶ü‡¶æ ‡¶Ö‡¶ï‡¶æ‡¶∞‡ßç‡¶Ø‡¶ï‡¶∞ ‡¶π‡ßü‡ßá ‡¶Ø‡¶æ‡¶¨‡ßá‡•§ ‡¶Ü‡¶Æ‡¶∞‡¶æ Helvetica bold 16 ‡¶™‡¶õ‡¶®‡ßç‡¶¶ ‡¶ï‡¶∞‡¶≤‡¶æ‡¶Æ‡¶É

‡¶á‡¶ü‡¶æ‡¶≤‡¶ø‡¶ï ‡¶∏‡ßá‡¶ü ‡¶ï‡¶∞‡¶§‡ßá ‡¶ö‡¶æ‡¶á‡¶≤‡ßá I, ‡¶Ü‡¶®‡ßç‡¶°‡¶æ‡¶∞‡¶≤‡¶æ‡¶á‡¶® ‡¶ï‡¶∞‡¶§‡ßá ‡¶ö‡¶æ‡¶á‡¶≤‡ßá U ‡¶Ö‡¶•‡¶¨‡¶æ ‡¶è‡¶ï‡¶ü‡¶ø ‡¶∏‡¶æ‡¶ß‡¶æ‡¶∞‡¶£ ‡¶´‡¶®‡ßç‡¶ü‡ßá ‡¶è‡¶ï‡¶ü‡¶ø ‡¶ñ‡¶æ‡¶≤‡¶ø ‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡¶ø‡¶Ç (‡¶Ö‡¶•‡¶¨‡¶æ ‡¶Ø‡ßá‡¶ï‡ßã‡¶® ‡¶ï‡¶Æ‡ßç‡¶¨‡¶ø‡¶®‡ßá‡¶∂‡¶®)‡•§ ‡¶â‡¶≤‡ßç‡¶≤‡ßá‡¶ñ‡ßç‡¶Ø ‡¶´‡¶®‡ßç‡¶ü ‡¶∏‡¶æ‡¶á‡¶ú ‡¶™‡ßü‡ßá‡¶®‡ßç‡¶ü‡ßá ‡¶¶‡ßá‡ßü‡¶æ ‡¶Ü‡¶õ‡ßá, ‡¶Æ‡¶ø‡¶≤‡¶ø‡¶Æ‡¶ø‡¶ü‡¶æ‡¶∞‡ßá ‡¶®‡ßü (‡¶Ö‡¶®‡ßç‡¶Ø ‡¶ï‡ßã‡¶® ‡¶è‡¶ï‡¶ï‡ßá‡¶ì ‡¶®‡ßü); ‡¶è‡¶ü‡¶æ‡¶á ‡¶è‡¶ï‡¶Æ‡¶æ‡¶§‡ßç‡¶∞ ‡¶¨‡ßç‡¶Ø‡¶æ‡¶§‡¶ø‡¶ï‡ßç‡¶∞‡¶Æ‡•§ ‡¶Ö‡¶®‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶Ø ‡¶Æ‡ßå‡¶≤‡¶ø‡¶ï ‡¶´‡¶®‡ßç‡¶ü‡¶ó‡ßÅ‡¶≤‡ßã ‡¶π‡¶≤‡ßã, Times, Courier, Symbol ‡¶è‡¶¨‡¶Ç ZapfDingbats

‡¶è‡¶ñ‡¶® ‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶è‡¶ï‡¶ü‡¶ø cell ‡¶™‡ßç‡¶∞‡¶ø‡¶®‡ßç‡¶ü ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡¶ø cell‡•§ cell ‡¶π‡¶≤‡ßã ‡¶è‡¶ï‡¶ü‡¶ø ‡¶Ü‡ßü‡¶§‡¶æ‡¶ï‡ßÉ‡¶§‡¶ø ‡¶ï‡ßç‡¶∑‡ßá‡¶§‡ßç‡¶∞, ‡¶π‡ßü‡¶§‡ßã ‡¶´‡ßç‡¶∞‡ßá‡¶Æ ‡¶ï‡¶∞‡¶æ, ‡¶Ø‡ßá‡¶ñ‡¶æ‡¶®‡ßá ‡¶ï‡¶ø‡¶õ‡ßÅ ‡¶ü‡ßá‡¶ï‡ßç‡¶∏‡¶ü ‡¶•‡¶æ‡¶ï‡¶¨‡ßá‡•§ ‡¶è‡¶ü‡¶æ ‡¶∞‡ßá‡¶®‡ßç‡¶°‡¶æ‡¶∞ ‡¶π‡ßü ‡¶¨‡¶∞‡ßç‡¶§‡¶Æ‡¶æ‡¶® ‡¶Ö‡¶¨‡¶∏‡ßç‡¶•‡¶æ‡¶®‡ßá‡•§ ‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶°‡¶æ‡¶á‡¶Æ‡ßá‡¶®‡¶∂‡¶®, ‡¶ü‡ßá‡¶ï‡ßç‡¶∏‡¶ü (‡¶Æ‡¶æ‡¶ù‡¶æ‡¶Æ‡¶æ‡¶ù‡¶ø ‡¶ï‡¶ø‡¶Ç‡¶¨‡¶æ ‡¶∏‡¶æ‡¶ú‡¶æ‡¶®‡ßã) ‡¶®‡¶ø‡¶∞‡ßç‡¶¶‡¶ø‡¶∑‡ßç‡¶ü ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡¶ø, ‡¶Ø‡¶¶‡¶ø ‡¶¨‡¶∞‡ßç‡¶°‡¶æ‡¶∞ ‡¶Ü‡¶ï‡¶æ‡¶®‡ßã ‡¶π‡ßü, ‡¶è‡¶¨‡¶Ç ‡¶¨‡¶∞‡ßç‡¶§‡¶Æ‡¶æ‡¶® ‡¶Ö‡¶¨‡¶∏‡ßç‡¶•‡¶æ‡¶® ‡¶¨‡¶∞‡ßç‡¶°‡¶æ‡¶∞‡ßá‡¶∞ ‡¶™‡¶∞‡ßá ‡¶è‡¶ó‡¶ø‡ßü‡ßá ‡¶Ø‡¶æ‡¶¨‡ßá (‡¶°‡¶æ‡¶®‡ßá, ‡¶®‡¶ø‡¶ö‡ßá ‡¶Ö‡¶•‡¶¨‡¶æ ‡¶™‡¶∞‡¶¨‡¶∞‡ßç‡¶§‡ßÄ ‡¶≤‡¶æ‡¶á‡¶®‡ßá‡¶∞ ‡¶∂‡ßÅ‡¶∞‡ßÅ‡¶§‡ßá)‡•§ ‡¶´‡ßç‡¶∞‡ßá‡¶Æ ‡¶Ø‡ßÅ‡¶ï‡ßç‡¶§ ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶®‡¶ø‡¶ö‡ßá‡¶∞ ‡¶Æ‡¶§ ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡¶ø‡¶É

‡¶è‡¶∞ ‡¶™‡¶∞ ‡¶ï‡ßá‡¶®‡ßç‡¶¶‡ßç‡¶∞ ‡¶¨‡¶∞‡¶æ‡¶¨‡¶∞ ‡¶è‡¶ï‡¶ü‡¶ø ‡¶®‡¶§‡ßÅ‡¶® cell ‡¶Ø‡ßÅ‡¶ï‡ßç‡¶§ ‡¶ï‡¶∞‡ßá ‡¶è‡¶¨‡¶Ç ‡¶™‡¶∞‡ßá‡¶∞ ‡¶≤‡¶æ‡¶á‡¶®‡ßá ‡¶è‡¶ó‡ßã‡¶®‡ßã‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶®‡¶ø‡¶ö‡ßá‡¶∞ ‡¶Æ‡¶§ ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡¶ø‡¶É

‡¶Æ‡¶®‡ßç‡¶§‡¶¨‡ßç‡¶Ø: ‡¶™‡¶∞‡¶¨‡¶∞‡ßç‡¶§‡ßÄ ‡¶≤‡¶æ‡¶á‡¶®‡ßá ‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶è‡¶≠‡¶æ‡¶¨‡ßá‡¶ì ‡¶Ø‡ßá‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡¶ø ln‡•§ ‡¶è‡¶á ‡¶Æ‡ßá‡¶•‡¶°‡ßá‡¶∞ ‡¶Æ‡¶æ‡¶ß‡ßç‡¶Ø‡¶Æ‡ßá ‡¶≤‡¶æ‡¶á‡¶® ‡¶¨‡ßç‡¶∞‡ßá‡¶ï ‡¶è‡¶∞ ‡¶â‡¶ö‡ßç‡¶ö‡¶§‡¶æ‡¶ì ‡¶Ø‡ßÅ‡¶ï‡ßç‡¶§ ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡ßü‡•§

‡¶∏‡¶¨‡¶∂‡ßá‡¶∑‡ßá, ‡¶°‡¶ï‡ßÅ‡¶Æ‡ßá‡¶®‡ßç‡¶ü‡¶ü‡¶ø ‡¶¨‡¶®‡ßç‡¶ß ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü ‡¶è‡¶¨‡¶Ç output ‡¶è‡¶á ‡¶´‡¶æ‡¶á‡¶≤ ‡¶™‡¶æ‡¶• ‡¶è ‡¶∏‡ßá‡¶≠ ‡¶ï‡¶∞‡¶æ ‡¶π‡¶≤‡ßã‡•§ ‡¶ï‡ßã‡¶® ‡¶™‡ßç‡¶Ø‡¶æ‡¶∞‡¶æ‡¶Æ‡¶ø‡¶ü‡¶æ‡¶∞ ‡¶õ‡¶æ‡ßú‡¶æ output() ‡¶™‡¶ø‡¶°‡¶ø‡¶è‡¶´ ‡¶è‡¶∞ ‡¶è‡¶ï‡¶ü‡¶ø bytearray ‡¶∞‡¶ø‡¶ü‡¶æ‡¶∞‡ßç‡¶® ‡¶ï‡¶∞‡ßá‡•§

‡¶π‡ßá‡¶°‡¶æ‡¶∞, ‡¶´‡ßÅ‡¶ü‡¶æ‡¶∞ ‡¶è‡¶¨‡¶Ç ‡¶≤‡ßã‡¶ó‡ßã ‡¶∏‡¶π ‡¶è‡¶ï‡¶ü‡¶æ ‡¶¶‡ßÅ‡¶á ‡¶™‡ßÉ‡¶∑‡ßç‡¶†‡¶æ‡¶∞ ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£ ‡¶¶‡ßá‡ßü‡¶æ ‡¶π‡¶≤‡ßã‡¶É

‡¶è‡¶á ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£‡¶ü‡¶ø headers ‡¶è‡¶¨‡¶Ç footers ‡¶™‡ßç‡¶∞‡¶∏‡ßá‡¶∏ ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø header ‡¶è‡¶¨‡¶Ç footer ‡¶Æ‡ßá‡¶•‡¶°‡¶ï‡ßá ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞‡¶ï‡ßá ‡¶¶‡ßá‡¶ñ‡¶æ‡ßü‡•§ ‡¶è‡¶∞‡¶æ ‡¶∏‡ßç‡¶¨‡ßü‡¶Ç‡¶ï‡ßç‡¶∞‡¶ø‡ßü‡¶≠‡¶æ‡¶¨‡ßá‡¶á ‡¶ö‡¶æ‡¶≤‡¶ø‡¶§ ‡¶π‡ßü‡•§ ‡¶è‡¶∞‡¶æ FPDF ‡¶ï‡ßç‡¶≤‡¶æ‡¶∏‡ßá‡¶á ‡¶•‡¶æ‡¶ï‡ßá ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ ‡¶ï‡ßã‡¶® ‡¶Ü‡¶≤‡¶æ‡¶¶‡¶æ ‡¶™‡ßç‡¶∞‡¶∏‡ßá‡¶∏ ‡¶ï‡¶∞‡ßá ‡¶®‡¶æ, ‡¶§‡¶æ‡¶á ‡¶è‡¶á ‡¶ï‡ßç‡¶≤‡¶æ‡¶∏‡¶ó‡ßÅ‡¶≤‡ßã‡¶ï‡ßá ‡¶è‡¶ï‡ßç‡¶∏‡¶ü‡ßá‡¶®‡ßç‡¶° ‡¶ï‡¶∞‡¶§‡ßá ‡¶π‡¶¨‡ßá ‡¶è‡¶¨‡¶Ç ‡¶ì‡¶≠‡¶æ‡¶∞‡¶∞‡¶æ‡¶á‡¶° ‡¶ï‡¶∞‡¶§‡ßá ‡¶π‡¶¨‡ßá‡•§

‡¶Ö‡¶¨‡¶∏‡ßç‡¶•‡¶æ‡¶® ‡¶â‡¶™‡¶∞‡ßá‡¶∞ ‡¶ï‡ßã‡¶£‡¶æ ‡¶è‡¶¨‡¶Ç ‡¶ö‡¶ì‡ßú‡¶æ‡¶∞ ‡¶™‡¶∞‡¶ø‡¶Æ‡¶æ‡¶® ‡¶®‡¶ø‡¶∞‡ßç‡¶¶‡ßç‡¶¶‡¶ø‡¶∑‡ßç‡¶ü ‡¶ï‡¶∞‡ßá ‡¶≤‡ßã‡¶ó‡ßã‡¶ü‡¶ø ‡¶™‡ßç‡¶∞‡¶ø‡¶®‡ßç‡¶ü ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü image ‡¶Æ‡ßá‡¶•‡¶°‡¶ï‡ßá ‡¶ï‡¶≤ ‡¶ï‡¶∞‡¶≤‡ßá‡•§ ‡¶õ‡¶¨‡¶ø‡¶∞ ‡¶Ö‡¶®‡ßÅ‡¶™‡¶æ‡¶§‡¶ï‡ßá ‡¶†‡¶ø‡¶ï ‡¶∞‡¶æ‡¶ñ‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶â‡¶ö‡ßç‡¶ö‡¶§‡¶æ‡¶ü‡¶æ ‡¶∏‡ßç‡¶¨‡ßü‡¶Ç‡¶ï‡ßç‡¶∞‡¶ø‡ßü‡¶≠‡¶æ‡¶¨‡ßá‡¶á ‡¶®‡¶ø‡¶∞‡ßÇ‡¶™‡¶ø‡¶§ ‡¶π‡ßü‡•§

‡¶™‡ßÉ‡¶∑‡ßç‡¶†‡¶æ ‡¶®‡¶Æ‡ßç‡¶¨‡¶∞ ‡¶™‡ßç‡¶∞‡¶ø‡¶®‡ßç‡¶ü ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø, ‡¶è‡¶ï‡¶ü‡¶ø ‡¶∂‡ßÇ‡¶£‡ßç‡¶Ø ‡¶Æ‡¶æ‡¶® cell width ‡¶π‡¶ø‡¶∏‡ßá‡¶¨‡ßá ‡¶™‡¶æ‡¶†‡¶æ‡¶®‡ßã ‡¶π‡ßü‡•§ ‡¶è‡¶∞ ‡¶Æ‡¶æ‡¶®‡ßá cell ‡¶ü‡¶ø ‡¶™‡ßÉ‡¶∑‡ßç‡¶†‡¶æ‡¶∞ ‡¶°‡¶æ‡¶® ‡¶Æ‡¶æ‡¶∞‡ßç‡¶ú‡¶ø‡¶® ‡¶™‡¶∞‡ßç‡¶Ø‡¶®‡ßç‡¶§ ‡¶™‡ßç‡¶∞‡¶∏‡¶æ‡¶∞‡¶ø‡¶§ ‡¶π‡¶ì‡¶Ø‡¶º‡¶æ ‡¶â‡¶ö‡¶ø‡¶§; ‡¶Ø‡ßá‡¶ü‡¶æ ‡¶≤‡¶ø‡¶ñ‡¶æ ‡¶ó‡ßÅ‡¶≤‡ßã‡¶ï‡ßá ‡¶ï‡ßá‡¶®‡ßç‡¶¶‡ßç‡¶∞ ‡¶¨‡¶∞‡¶æ‡¶¨‡¶∞ ‡¶∏‡¶æ‡¶∞‡¶ø‡¶¨‡¶¶‡ßç‡¶ß ‡¶ï‡¶∞‡¶æ ‡¶π‡¶≤‡ßã‡•§ page_no ‡¶Æ‡ßá‡¶•‡¶° ‡¶¨‡¶∞‡ßç‡¶§‡¶Æ‡¶æ‡¶® ‡¶™‡ßÉ‡¶∑‡ßç‡¶†‡¶æ ‡¶®‡¶æ‡¶Æ‡ßç‡¶¨‡¶æ‡¶∞‡¶ü‡¶ø ‡¶∞‡¶ø‡¶ü‡¶æ‡¶∞‡ßç‡¶® ‡¶ï‡¶∞‡ßá; ‡¶Æ‡ßã‡¶ü ‡¶™‡ßÉ‡¶∑‡ßç‡¶†‡¶æ ‡¶®‡¶æ‡¶Æ‡ßç‡¶¨‡¶æ‡¶∞‡¶ü‡¶æ ‡¶è‡¶ï‡¶ü‡¶ø ‡¶¨‡¶ø‡¶∂‡ßá‡¶∑ ‡¶≠‡ßç‡¶Ø‡¶æ‡¶≤‡ßÅ {nb} ‡¶è‡¶∞ ‡¶Æ‡¶æ‡¶ß‡ßç‡¶Ø‡¶Æ‡ßá ‡¶™‡¶æ‡¶ì‡ßü‡¶æ ‡¶Ø‡¶æ‡ßü ‡¶Ø‡ßá‡¶ü‡¶æ ‡¶°‡¶ï‡ßÅ‡¶Æ‡ßá‡¶®‡ßç‡¶ü ‡¶ï‡ßç‡¶≤‡ßã‡¶ú‡¶æ‡¶∞‡ßá‡¶∞ ‡¶è‡¶∞ ‡¶∏‡¶Æ‡ßü ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶∏‡ßç‡¶•‡¶æ‡¶™‡¶ø‡¶§ ‡¶π‡ßü‡•§ (‡¶è‡¶á ‡¶¨‡¶ø‡¶∂‡ßá‡¶∑ ‡¶≠‡ßç‡¶Ø‡¶æ‡¶≤‡ßÅ ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡ßü alias_nb_pages() ‡¶è‡¶∞ ‡¶Æ‡¶æ‡¶ß‡ßç‡¶Ø‡¶Æ‡ßá)‡•§ ‡¶â‡¶≤‡ßç‡¶≤‡ßá‡¶ñ‡ßç‡¶Ø, ‡¶â‡¶™‡¶∞ ‡¶ï‡¶ø‡¶Ç‡¶¨‡¶æ ‡¶®‡¶ø‡¶ö ‡¶•‡ßá‡¶ï‡ßá ‡¶∂‡ßÅ‡¶∞‡ßÅ ‡¶ï‡¶∞‡ßá ‡¶™‡ßÉ‡¶∑‡ßç‡¶†‡¶æ‡¶∞ ‡¶Ö‡¶¨‡¶∏‡ßç‡¶•‡¶æ‡¶® set_y ‡¶Æ‡ßá‡¶•‡¶°‡ßá‡¶∞ ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá ‡¶∏‡ßá‡¶ü ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡ßü‡•§

‡¶è‡¶ñ‡¶æ‡¶®‡ßá ‡¶Ü‡¶∞‡ßá‡¶ï‡¶ü‡¶ø ‡¶Æ‡¶ú‡¶æ‡¶∞ ‡¶¨‡ßà‡¶∂‡¶ø‡¶∑‡ßç‡¶ü‡ßç‡¶Ø ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá‡¶É ‡¶Ö‡¶ü‡ßã‡¶Æ‡ßá‡¶ü‡¶ø‡¶ï ‡¶™‡ßá‡¶ú ‡¶¨‡ßç‡¶∞‡ßá‡¶ï‡¶ø‡¶Ç‡•§ ‡¶Ø‡¶ñ‡¶®‡¶á ‡¶è‡¶ï‡¶ü‡¶æ cell ‡¶è‡¶ï‡¶ü‡¶æ ‡¶™‡ßá‡¶ú ‡¶≤‡¶ø‡¶Æ‡¶ø‡¶ü ‡¶ï‡ßç‡¶∞‡¶∏ ‡¶ï‡¶∞‡ßá ‡¶Ø‡¶æ‡ßü ( ‡¶®‡¶ø‡¶ö ‡¶•‡ßá‡¶ï‡ßá ‡ß® ‡¶∏‡ßá‡¶®‡ßç‡¶ü‡¶ø‡¶Æ‡¶ø‡¶ü‡¶æ‡¶∞ ), ‡¶™‡ßá‡¶ú ‡¶¨‡ßç‡¶∞‡ßá‡¶ï ‡¶è‡ßç‡¶Ø‡¶æ‡¶™‡ßç‡¶≤‡¶æ‡¶á ‡¶π‡ßü ‡¶è‡¶¨‡¶Ç ‡¶´‡¶®‡ßç‡¶ü ‡¶∞‡¶ø‡¶∏‡ßç‡¶ü‡ßã‡¶∞ ‡¶π‡ßü‡•§ ‡¶Ø‡¶¶‡¶ø‡¶ì ‡¶π‡ßá‡¶°‡¶æ‡¶∞ ‡¶è‡¶¨‡¶Ç ‡¶´‡ßÅ‡¶ü‡¶æ‡¶∞ ‡¶®‡¶ø‡¶ú ‡¶®‡¶ø‡¶ú ‡¶´‡¶®‡ßç‡¶ü (helvetica) ‡¶∏‡¶ø‡¶≤‡ßá‡¶ï‡ßç‡¶ü ‡¶ï‡¶∞‡ßá, ‡¶™‡ßá‡¶ú ‡¶¨‡¶°‡¶ø Times ‡¶π‡¶ø‡¶∏‡ßá‡¶¨‡ßá‡¶á ‡¶è‡¶ó‡ßã‡¶§‡ßá ‡¶•‡¶æ‡¶ï‡ßá‡•§ ‡¶Ö‡¶ü‡ßã‡¶Æ‡ßá‡¶ü‡¶ø‡¶ï ‡¶∞‡¶ø‡¶∏‡ßç‡¶ü‡ßã‡¶∞ ‡¶è‡¶∞ ‡¶¨‡ßç‡¶Ø‡¶æ‡¶™‡¶æ‡¶∞ ‡¶ü‡¶æ ‡¶ï‡¶æ‡¶≤‡¶æ‡¶∞ ‡¶è‡¶¨‡¶Ç ‡¶≤‡¶æ‡¶á‡¶® ‡¶â‡¶á‡¶°‡¶• ‡¶è‡¶∞ ‡¶¨‡ßç‡¶Ø‡¶æ‡¶™‡¶æ‡¶∞‡ßá‡¶ì ‡¶™‡ßç‡¶∞‡¶Ø‡ßã‡¶ú‡ßç‡¶Ø ‡¶π‡ßü‡•§ ‡¶™‡ßá‡¶ú ‡¶¨‡ßç‡¶∞‡ßá‡¶ï ‡¶è‡¶∞ ‡¶≤‡¶ø‡¶Æ‡¶ø‡¶ü ‡¶ü‡¶ø set_auto_page_break ‡¶Æ‡ßá‡¶•‡¶°‡ßá‡¶∞ ‡¶Æ‡¶æ‡¶ß‡ßç‡¶Ø‡¶Æ‡ßá‡¶ì ‡¶∏‡ßá‡¶ü ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡ßü‡•§

‡¶ú‡¶æ‡¶∏‡ßç‡¶ü‡¶ø‡¶´‡¶æ‡¶á‡¶° ‡¶™‡ßç‡¶Ø‡¶æ‡¶∞‡¶æ‡¶ó‡ßç‡¶∞‡¶æ‡¶´‡ßá ‡¶™‡ßç‡¶∞‡¶ø‡¶®‡ßç‡¶ü ‡¶ï‡¶∞‡¶æ ‡¶è‡¶ï‡¶ü‡¶ø ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£ ‡¶è‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá ‡¶è‡¶ó‡ßã‡¶®‡ßã ‡¶Ø‡¶æ‡¶ï‡•§ ‡¶Ø‡¶æ ‡¶è‡¶ï‡¶á‡¶∏‡¶æ‡¶•‡ßá colors ‡¶®‡¶ø‡ßü‡ßá‡¶ì ‡¶ß‡¶æ‡¶∞‡¶£‡¶æ ‡¶¶‡ßá‡¶¨‡ßá‡•§

get_string_width ‡¶Æ‡ßá‡¶•‡¶° ‡¶¨‡¶∞‡ßç‡¶§‡¶Æ‡¶æ‡¶® ‡¶´‡¶®‡ßç‡¶ü‡ßá ‡¶è‡¶ï‡¶ü‡¶ø ‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡¶ø‡¶Ç ‡¶è‡¶∞ ‡¶¶‡ßà‡¶∞‡ßç‡¶ò‡ßç‡¶Ø ‡¶®‡¶ø‡¶∞‡ßç‡¶£‡ßü ‡¶ï‡¶∞‡ßá ‡¶¶‡ßá‡ßü, ‡¶Ø‡¶æ ‡¶è‡¶ñ‡¶æ‡¶®‡ßá ‡¶Ö‡¶¨‡¶∏‡ßç‡¶•‡¶æ ‡¶è‡¶¨‡¶Ç ‡¶ü‡¶æ‡¶á‡¶ü‡ßá‡¶≤ ‡¶∏‡¶Æ‡ßá‡¶§ ‡¶´‡ßç‡¶∞‡ßá‡¶Æ ‡¶ì ‡¶è‡¶∞ ‡¶Ü‡¶∂‡¶™‡¶æ‡¶∂‡¶∏‡¶π ‡¶â‡¶á‡¶¶‡¶• ‡¶Æ‡¶æ‡¶™‡¶ú‡ßã‡¶ï‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡ßü‡•§ colors ‡¶∏‡ßá‡¶ü ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡ßü (set_draw_color, set_fill_color ‡¶è‡¶¨‡¶Ç set_text_color ‡¶Æ‡¶æ‡¶ß‡ßç‡¶Ø‡¶Æ‡ßá) ‡¶è‡¶¨‡¶Ç ‡¶≤‡¶æ‡¶á‡¶®‡ßá‡¶∞ ‡¶™‡ßÅ‡¶∞‡ßÅ‡¶§‡ßç‡¶¨ ‡¶¨‡¶æ ‡¶•‡¶ø‡¶ï‡¶®‡ßá‡¶∏ ‡¶∏‡ßá‡¶ü ‡¶ï‡¶∞‡¶æ ‡¶π‡¶≤‡ßã 1 mm ( 0.2 ‡¶è‡¶∞ ‡¶¨‡¶ø‡¶™‡¶∞‡ßÄ‡¶§‡ßá ‡¶¨‡¶æ‡¶á ‡¶°‡¶ø‡¶´‡¶≤‡ßç‡¶ü) set_line_width ‡¶è‡¶∞ ‡¶Æ‡¶æ‡¶ß‡ßç‡¶Ø‡¶Æ‡ßá‡•§ ‡¶Ö‡¶¨‡¶∂‡ßá‡¶∑‡ßá, ‡¶Ü‡¶Æ‡¶∞‡¶æ cell ‡¶ü‡¶æ ‡¶Ü‡¶â‡¶ü‡¶™‡ßÅ‡¶ü ‡¶¶‡¶ø‡¶≤‡¶æ‡¶Æ (‡¶∏‡¶∞‡ßç‡¶¨‡¶∂‡ßá‡¶∑ ‡¶™‡ßç‡¶Ø‡¶æ‡¶∞‡¶æ‡¶Æ‡¶ø‡¶ü‡¶æ‡¶∞ ‡¶ü‡¶æ true ‡¶Ø‡¶æ‡¶∞ ‡¶Æ‡¶æ‡¶®‡ßá ‡¶¨‡ßç‡¶Ø‡¶æ‡¶ï‡¶ó‡ßç‡¶∞‡¶æ‡¶â‡¶®‡ßç‡¶° ‡¶Ü‡¶¨‡¶∂‡ßç‡¶Ø‡¶ø‡¶ï‡¶≠‡¶æ‡¶¨‡ßá ‡¶™‡¶∞‡¶ø‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶•‡¶æ‡¶ï‡¶§‡ßá ‡¶π‡¶¨‡ßá)‡•§

‡¶™‡ßç‡¶Ø‡¶æ‡¶∞‡¶æ‡¶ó‡ßç‡¶∞‡¶æ‡¶´ ‡¶™‡ßç‡¶∞‡¶ø‡¶®‡ßç‡¶ü ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø multi_cell ‡¶Æ‡ßá‡¶•‡¶° ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá‡•§ ‡¶≤‡¶ø‡¶ñ‡¶æ‡¶ó‡ßÅ‡¶≤‡ßã ‡¶ú‡¶æ‡¶∏‡ßç‡¶ü‡¶ø‡¶´‡¶æ‡¶á‡¶° ‡¶è‡¶≤‡¶æ‡¶á‡¶®‡¶Æ‡ßá‡¶®‡ßç‡¶ü‡ßá ‡¶è ‡¶•‡¶æ‡¶ï‡ßá ‡¶ó‡¶§‡¶æ‡¶®‡ßÅ‡¶ó‡¶§‡¶ø‡¶ï‡¶≠‡¶æ‡¶¨‡ßá‡•§ ‡¶™‡ßç‡¶∞‡¶§‡ßç‡¶Ø‡ßá‡¶ï ‡¶≤‡¶æ‡¶á‡¶® ‡¶Ø‡¶ñ‡¶® cell ‡¶è‡¶∞ ‡¶∂‡ßá‡¶∑ ‡¶è ‡¶™‡ßå‡¶õ‡¶æ‡ßü ‡¶Ö‡¶•‡¶¨‡¶æ ‡¶è‡¶ï‡¶ü‡¶ø carriage return ‡¶ï‡ßç‡¶Ø‡¶æ‡¶∞‡ßá‡¶ï‡ßç‡¶ü‡¶æ‡¶∞ (\n) ‡¶™‡¶æ‡¶ì‡ßü‡¶æ ‡¶Ø‡¶æ‡ßü, ‡¶è‡¶ï‡¶ü‡¶ø ‡¶≤‡¶æ‡¶á‡¶® ‡¶¨‡ßç‡¶∞‡ßá‡¶ï ‡¶è‡ßç‡¶Ø‡¶æ‡¶™‡ßç‡¶≤‡¶æ‡¶á ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü ‡¶è‡¶¨‡¶Ç ‡¶è‡¶ï‡¶ü‡¶ø ‡¶®‡¶§‡ßÅ‡¶® cell ‡¶Ö‡¶ü‡ßã‡¶Æ‡ßá‡¶ü‡¶ø‡¶ï‡ßç‡¶Ø‡¶æ‡¶≤‡¶ø ‡¶¨‡¶∞‡ßç‡¶§‡¶Æ‡¶æ‡¶®‡¶ü‡¶ø‡¶∞ ‡¶®‡¶ø‡¶ö‡ßá ‡¶§‡ßà‡¶∞‡¶ø ‡¶π‡ßü‡•§ ‡¶∏‡¶†‡¶ø‡¶ï ‡¶≤‡¶ø‡¶Æ‡¶ø‡¶ü‡ßá‡¶∞ ‡¶™‡ßÇ‡¶∞‡ßç‡¶¨‡ßá‡¶á ‡¶ï‡¶æ‡¶õ‡¶æ‡¶ï‡¶æ‡¶õ‡¶ø ‡¶∏‡ßç‡¶™‡ßá‡¶∏ ‡¶ï‡¶ø‡¶Ç‡¶¨‡¶æ ‡¶∏‡¶´‡¶ü ‡¶π‡¶æ‡¶á‡¶´‡ßá‡¶® (\u00ad) ‡¶ï‡ßç‡¶Ø‡¶æ‡¶∞‡ßá‡¶ï‡ßç‡¶ü‡¶æ‡¶∞ ‡¶è‡¶∞ ‡¶ú‡¶æ‡ßü‡¶ó‡¶æ‡ßü ‡¶è‡¶ï‡¶ü‡¶æ ‡¶Ö‡¶ü‡ßã‡¶Æ‡ßá‡¶ü‡¶ø‡¶ï ‡¶¨‡ßç‡¶∞‡ßá‡¶ï ‡¶§‡ßà‡¶∞‡¶ø ‡¶π‡ßü‡•§ ‡¶Ø‡¶ñ‡¶® ‡¶è‡¶ï‡¶ü‡¶ø ‡¶≤‡¶æ‡¶á‡¶® ‡¶¨‡ßç‡¶∞‡ßá‡¶ï ‡¶è‡ßç‡¶Ø‡¶æ‡¶™‡ßç‡¶≤‡¶æ‡¶á ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü ‡¶§‡¶ñ‡¶® ‡¶è‡¶ï‡¶ü‡¶æ ‡¶∏‡¶´‡¶ü-‡¶π‡¶æ‡¶á‡¶´‡ßá‡¶® ‡¶è‡¶ï‡¶ü‡¶ø ‡¶®‡¶∞‡¶Æ‡¶æ‡¶≤ ‡¶π‡¶æ‡¶á‡¶´‡ßá‡¶® ‡¶è‡¶∞ ‡¶¶‡ßç‡¶¨‡¶æ‡¶∞‡¶æ ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶∏‡ßç‡¶•‡¶æ‡¶™‡¶ø‡¶§ ‡¶π‡ßü ‡¶®‡¶§‡ßÅ‡¶¨‡¶æ ‡¶á‡¶ó‡ßç‡¶®‡ßã‡¶∞ ‡¶π‡ßü‡•§

‡¶°‡¶ï‡ßÅ‡¶Æ‡ßá‡¶®‡ßç‡¶ü ‡¶¶‡ßÅ‡¶ü‡ßã ‡¶™‡ßç‡¶∞‡¶™‡¶æ‡¶∞‡ßç‡¶ü‡¶ø ‡¶∏‡¶Ç‡¶ô‡ßç‡¶ó‡¶æ‡ßü‡¶ø‡¶§ ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡¶É title (set_title) ‡¶Æ‡ßá‡¶•‡¶° ‡¶è‡¶¨‡¶Ç author (set_author) ‡¶Æ‡ßá‡¶•‡¶°‡•§ ‡¶™‡ßç‡¶∞‡¶™‡¶æ‡¶∞‡ßç‡¶ü‡¶ø ‡¶¶‡ßÅ‡¶á ‡¶â‡¶™‡¶æ‡ßü‡ßá ‡¶¶‡ßá‡¶ñ‡¶æ ‡¶Ø‡¶æ‡ßü‡•§ ‡¶™‡ßç‡¶∞‡¶•‡¶Æ‡¶ü‡¶ø ‡¶π‡¶≤‡ßã ‡¶°‡¶ï‡ßÅ‡¶Æ‡ßá‡¶®‡ßç‡¶ü‡¶ï‡ßá ‡¶°‡¶ø‡¶∞‡ßá‡¶ï‡ßç‡¶ü‡¶≤‡¶ø Acrobat Reader ‡¶¶‡¶ø‡ßü‡ßá ‡¶ì‡¶™‡ßá‡¶® ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü, File ‡¶Æ‡ßá‡¶®‡ßç‡¶Ø‡ßÇ ‡¶§‡ßá ‡¶ó‡¶ø‡ßü‡ßá Document Properties ‡¶Ö‡¶™‡¶∂‡¶®‡¶ü‡¶ø ‡¶ö‡ßÅ‡¶ú ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡•§ ‡¶™‡¶∞‡ßá‡¶∞‡¶ü‡¶ø ‡¶π‡¶≤‡ßã, ‡¶™‡ßç‡¶≤‡¶æ‡¶ó‡¶ø‡¶® ‡¶•‡ßá‡¶ï‡ßá ‡¶∞‡¶æ‡¶á‡¶ü ‡¶ï‡ßç‡¶≤‡¶ø‡¶ï ‡¶ï‡¶∞‡ßá ‡¶°‡¶ï‡ßÅ‡¶Æ‡ßá‡¶®‡ßç‡¶ü ‡¶™‡ßç‡¶∞‡¶™‡¶æ‡¶∞‡ßç‡¶ü‡¶ø ‡¶∏‡¶ø‡¶≤‡ßá‡¶ï‡ßç‡¶ü ‡¶ï‡¶∞‡ßá‡•§

‡¶è‡¶á ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£‡¶ü‡¶ø ‡¶™‡ßÇ‡¶∞‡ßç‡¶¨‡ßá‡¶∞ ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£ ‡¶è‡¶∞ ‡¶Ö‡¶®‡ßç‡¶Ø‡¶∞‡¶ï‡¶Æ ‡¶∏‡¶Ç‡¶∏‡ßç‡¶ï‡¶∞‡¶£, ‡¶Ø‡¶æ ‡¶Ü‡¶∏‡¶≤‡ßá ‡¶ï‡¶ø‡¶≠‡¶æ‡¶¨‡ßá ‡¶ï‡ßü‡ßá‡¶ï‡¶ü‡¶ø ‡¶ï‡¶≤‡¶æ‡¶Æ ‡¶è‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶ü‡ßá‡¶ï‡ßç‡¶∏‡¶ü ‡¶∞‡¶æ‡¶ñ‡¶§‡ßá ‡¶π‡ßü ‡¶∏‡ßá‡¶ü‡¶æ ‡¶¶‡ßá‡¶ñ‡¶æ‡¶®‡ßã ‡¶π‡ßü‡ßá‡¶õ‡ßá‡•§

‚ö†Ô∏è This section has changed a lot and requires a new translation: https://github.com/py-pdf/fpdf2/issues/267

‡¶è‡¶á ‡¶ü‡¶ø‡¶â‡¶ü‡ßã‡¶∞‡¶ø‡ßü‡¶æ‡¶≤‡¶ü‡¶ø ‡¶ï‡¶ø‡¶≠‡¶æ‡¶¨‡ßá ‡¶π‡¶æ‡¶≤‡¶ï‡¶æ ‡¶ï‡¶ø‡¶õ‡ßÅ ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® ‡¶ï‡¶∞‡ßá‡¶á ‡¶∏‡¶π‡¶ú‡ßá‡¶á ‡¶≠‡¶ø‡¶®‡ßç‡¶® ‡¶¶‡ßÅ‡¶á‡¶ü‡¶ø ‡¶ü‡ßá‡¶¨‡¶ø‡¶≤ ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡ßü ‡¶∏‡ßá‡¶ü‡¶æ ‡¶¨‡ßç‡¶Ø‡¶æ‡¶ñ‡ßç‡¶Ø‡¶æ ‡¶ï‡¶∞‡¶¨‡ßá‡•§ ‡¶®‡¶æ ‡¶®‡¶æ ‡¶ï‡¶æ‡¶†‡ßá‡¶∞ ‡¶®‡¶æ! ‡¶∏‡¶æ‡¶∞‡¶ø-‡¶ï‡¶≤‡¶æ‡¶Æ ‡¶è‡¶∞ ‡¶ü‡ßá‡¶¨‡¶ø‡¶≤‡•§

Resulting PDF - Countries CSV data

‡¶™‡ßç‡¶∞‡¶•‡¶Æ ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£‡¶ü‡¶ø FPDF.table() ‡¶è‡¶∞ ‡¶≠‡ßá‡¶§‡¶∞‡ßá ‡¶°‡ßá‡¶ü‡¶æ ‡¶∏‡¶∞‡¶¨‡¶∞‡¶æ‡¶π‡ßá‡¶∞ ‡¶Æ‡¶æ‡¶ß‡ßç‡¶Ø‡¶Æ‡ßá ‡¶ñ‡ßÅ‡¶¨‡¶á ‡¶∏‡¶æ‡¶ß‡¶æ‡¶∞‡¶£‡¶≠‡¶æ‡¶¨‡ßá‡¶á ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡ßü‡•§ ‡¶´‡¶≤‡¶æ‡¶´‡¶≤ ‡¶ñ‡ßÅ‡¶¨‡¶á ‡¶∏‡¶æ‡¶ß‡¶æ‡¶∞‡¶£ ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ ‡¶ñ‡ßÅ‡¶¨ ‡¶∏‡¶π‡¶ú‡ßá‡¶á ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡ßü ‡¶è‡¶Æ‡¶®‡•§

‡¶™‡¶∞‡¶¨‡¶∞‡ßç‡¶§‡ßÄ ‡¶ü‡ßá‡¶¨‡¶ø‡¶≤‡ßá ‡¶ï‡¶ø‡¶õ‡ßÅ ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® ‡¶Ü‡¶®‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá‡¶É ‡¶ï‡¶æ‡¶≤‡¶æ‡¶∞, ‡¶ü‡ßá‡¶¨‡¶ø‡¶≤‡ßá‡¶∞ ‡¶®‡¶ø‡ßü‡¶®‡ßç‡¶§‡ßç‡¶∞‡¶ø‡¶§ ‡¶¨‡¶ø‡¶∏‡ßç‡¶§‡¶æ‡¶∞, ‡¶π‡ßç‡¶∞‡¶æ‡¶∏‡¶ï‡ßÉ‡¶§ ‡¶≤‡¶æ‡¶á‡¶®‡ßá‡¶∞ ‡¶â‡¶ö‡ßç‡¶ö‡¶§‡¶æ, ‡¶Æ‡¶æ‡¶ù ‡¶¨‡¶∞‡¶æ‡¶¨‡¶∞ ‡¶è‡¶≤‡¶æ‡¶á‡¶® ‡¶ï‡¶∞‡¶æ ‡¶∂‡¶ø‡¶∞‡ßã‡¶®‡¶æ‡¶Æ, ‡¶°‡¶æ‡¶® ‡¶¶‡¶ø‡¶ï‡ßá ‡¶è‡¶≤‡¶æ‡¶á‡¶® ‡¶ï‡¶∞‡¶æ ‡¶õ‡¶¨‡¶ø ... ‡¶è‡¶∏‡¶¨‡ßá‡¶∞ ‡¶Æ‡¶æ‡¶ß‡ßç‡¶Ø‡¶Æ‡ßá‡•§ ‡¶§‡¶æ‡¶õ‡¶æ‡ßú‡¶æ, ‡¶Ü‡¶®‡ßÅ‡¶≠‡ßÇ‡¶Æ‡¶ø‡¶ï ‡¶≤‡¶æ‡¶á‡¶®‡¶ó‡ßÅ‡¶≤‡ßã‡¶ì ‡¶∏‡¶∞‡¶æ‡¶®‡ßã ‡¶π‡ßü‡ßá‡¶õ‡ßá‡•§ ‡¶è‡¶ü‡¶æ ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá ‡¶è‡¶≠‡ßá‡¶á‡¶≤‡ßá‡¶¨‡¶≤ ‡¶≠‡ßç‡¶Ø‡¶æ‡¶≤‡ßÅ ‡¶ó‡ßÅ‡¶≤‡ßã ‡¶•‡ßá‡¶ï‡ßá borders_layout ‡¶è‡¶∞ ‡¶è‡¶ï‡¶ü‡¶ø ‡¶≠‡ßç‡¶Ø‡¶æ‡¶≤‡ßÅ ‡¶®‡ßá‡¶¨‡¶æ‡¶∞ ‡¶Æ‡¶æ‡¶ß‡ßç‡¶Ø‡¶Æ‡ßá TableBordersLayout.

‡¶è‡¶á ‡¶ü‡¶ø‡¶â‡¶ü‡ßã‡¶∞‡¶ø‡ßü‡¶æ‡¶≤‡¶ü‡¶ø PDF ‡¶è‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶≤‡¶ø‡¶Ç‡¶ï ‡¶™‡ßç‡¶∞‡¶¨‡ßá‡¶∂ ‡¶ï‡¶∞‡¶æ‡¶®‡ßã ‡¶∏‡¶π ‡¶¨‡¶ø‡¶≠‡¶ø‡¶®‡ßç‡¶® ‡¶¨‡¶æ‡¶π‡ßç‡¶Ø‡¶ø‡¶ï ‡¶â‡ßé‡¶∏‡ßá‡¶∞ ‡¶≤‡¶ø‡¶Ç‡¶ï ‡¶Ø‡ßÅ‡¶ï‡ßç‡¶§ ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶¨‡¶ø‡¶∑‡ßü‡ßá ‡¶¨‡¶∞‡ßç‡¶£‡¶®‡¶æ ‡¶ï‡¶∞‡¶¨‡ßá‡•§ ‡¶è‡¶ï‡¶á‡¶∏‡¶æ‡¶•‡ßá ‡¶≤‡¶ø‡¶ñ‡¶æ‡¶∞ ‡¶¨‡¶ø‡¶≠‡¶ø‡¶®‡ßç‡¶® ‡¶∞‡¶ï‡¶Æ ‡¶∏‡ßç‡¶ü‡¶æ‡¶á‡¶≤ (bold, italic, underline) ‡¶è‡¶∞ ‡¶¨‡ßç‡¶Ø‡¶æ‡¶™‡¶æ‡¶∞‡ßá‡¶ì ‡¶Ü‡¶≤‡ßã‡¶ï‡¶™‡¶æ‡¶§ ‡¶ï‡¶∞‡¶¨‡ßá‡•§

Resulting PDF - fpdf2-logo

‡¶≤‡¶ø‡¶ñ‡¶æ‡¶∞ ‡¶™‡ßç‡¶∞‡¶ø‡¶®‡ßç‡¶ü ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶®‡¶§‡ßÅ‡¶® ‡¶Æ‡ßá‡¶•‡¶° ‡¶è‡¶ñ‡¶æ‡¶®‡ßá ‡¶¶‡ßá‡¶ñ‡¶æ‡¶®‡ßã ‡¶π‡¶≤‡ßã - write() ‡•§ ‡¶Ø‡¶æ multi_cell() ‡¶è‡¶∞ ‡¶ñ‡ßÅ‡¶¨ ‡¶ï‡¶æ‡¶õ‡¶æ‡¶ï‡¶æ‡¶õ‡¶ø, ‡¶Æ‡ßÇ‡¶≤ ‡¶™‡¶æ‡¶∞‡ßç‡¶•‡¶ï‡ßç‡¶Ø ‡¶π‡¶≤‡ßã:

‡¶è‡¶á ‡¶Æ‡ßá‡¶•‡¶°‡ßá‡¶∞ ‡¶Æ‡¶æ‡¶ß‡ßç‡¶Ø‡¶Æ‡ßá ‡¶ï‡¶ø‡¶õ‡ßÅ ‡¶ü‡ßá‡¶ï‡ßç‡¶∏‡¶ü ‡¶è‡¶ï‡¶∏‡¶æ‡¶•‡ßá ‡¶≤‡¶ø‡¶ñ‡¶æ ‡¶Ø‡¶æ‡ßü, ‡¶´‡¶®‡ßç‡¶ü ‡¶∏‡ßç‡¶ü‡¶æ‡¶á‡¶≤ ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡ßü, ‡¶è‡¶¨‡¶Ç ‡¶Ø‡ßá‡¶á ‡¶∏‡ßç‡¶•‡¶æ‡¶® ‡¶π‡¶§‡ßá ‡¶≤‡¶ø‡¶ñ‡¶æ ‡¶¨‡¶®‡ßç‡¶ß ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá ‡¶™‡ßÅ‡¶®‡¶∞‡¶æ‡ßü ‡¶∏‡ßá‡¶ñ‡¶æ‡¶® ‡¶•‡ßá‡¶ï‡ßá‡¶á ‡¶∂‡ßÅ‡¶∞‡ßÅ ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡ßü‡•§ ‡¶Ö‡¶®‡ßç‡¶Ø‡¶¶‡¶ø‡¶ï‡ßá ‡¶è‡¶á ‡¶Æ‡ßá‡¶•‡¶°‡ßá‡¶∞ ‡¶Æ‡ßÇ‡¶≤ ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶¨‡¶®‡ßç‡¶ß‡¶ï‡¶§‡¶æ ‡¶π‡¶ö‡ßç‡¶õ‡ßá, ‡¶ü‡ßá‡¶ï‡ßç‡¶∏‡¶ü‡¶ó‡ßÅ‡¶≤‡ßã‡¶ï‡ßá ‡¶ú‡¶æ‡¶∏‡ßç‡¶ü‡¶ø‡¶´‡¶æ‡¶á ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡ßü ‡¶®‡¶æ ‡¶Ø‡ßá‡¶Æ‡¶®‡¶ü‡¶æ ‡¶Ü‡¶Æ‡¶∞‡¶æ multi_cell() ‡¶Æ‡ßá‡¶•‡¶°‡ßá‡¶∞ ‡¶Æ‡¶æ‡¶ß‡ßç‡¶Ø‡¶Æ‡ßá ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡¶ø‡•§

‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£‡ßá‡¶∞ ‡¶™‡ßç‡¶∞‡¶•‡¶Æ ‡¶™‡ßÉ‡¶∑‡ßç‡¶†‡¶æ‡ßü, ‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶è‡¶á ‡¶â‡¶¶‡ßç‡¶¶‡ßá‡¶∂‡ßç‡¶Ø‡ßá write() ‡¶Æ‡ßá‡¶•‡¶° ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá‡¶õ‡¶ø‡¶≤‡¶æ‡¶Æ‡•§ ‡¶¨‡¶æ‡¶ï‡ßç‡¶Ø‡ßá‡¶∞ ‡¶∂‡ßÅ‡¶∞‡ßÅ‡¶ü‡¶æ ‡¶∏‡¶æ‡¶ß‡¶æ‡¶∞‡¶£ ‡¶ü‡ßá‡¶ï‡ßç‡¶∏‡¶ü ‡¶∏‡ßç‡¶ü‡¶æ‡¶á‡¶≤‡ßá‡¶á ‡¶≤‡¶ø‡¶ñ‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá, ‡¶è‡¶∞‡¶™‡¶∞‡ßá set_font() ‡¶Æ‡ßá‡¶•‡¶° ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá, ‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶Ü‡¶®‡ßç‡¶°‡¶æ‡¶∞‡¶≤‡¶æ‡¶á‡¶® ‡¶ï‡¶∞‡ßá ‡¶¨‡¶æ‡¶ï‡ßç‡¶Ø‡¶ü‡¶ø ‡¶∂‡ßá‡¶∑ ‡¶ï‡¶∞‡¶≤‡¶æ‡¶Æ‡•§

‡¶™‡¶∞‡¶¨‡¶∞‡ßç‡¶§‡ßÄ ‡¶™‡ßÉ‡¶∑‡ßç‡¶†‡¶æ‡¶∞ ‡¶è‡¶ï‡¶ü‡¶ø ‡¶Ü‡¶®‡ßç‡¶§‡¶∞‡ßç‡¶¨‡¶∞‡ßç‡¶§‡ßÄ ‡¶≤‡¶ø‡¶Ç‡¶ï ‡¶Ø‡ßÅ‡¶ï‡ßç‡¶§ ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø, ‡¶Ü‡¶Æ‡¶∞‡¶æ add_link() ‡¶Æ‡ßá‡¶•‡¶°‡¶ü‡¶ø ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá‡¶õ‡¶ø, ‡¶Ø‡¶æ ‡¶ï‡ßç‡¶≤‡¶ø‡¶ï ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶Æ‡¶§ ‡¶è‡¶ï‡¶ü‡¶ø ‡¶è‡¶≤‡¶æ‡¶ï‡¶æ ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡ßá ‡¶¶‡¶ø‡¶≤‡ßã ‡¶Ø‡ßá‡¶ü‡¶æ‡¶ï‡ßá ‡¶Ü‡¶Æ‡¶∞‡¶æ "‡¶≤‡¶ø‡¶Ç‡¶ï" ‡¶¨‡¶≤‡¶õ‡¶ø ‡¶Ø‡¶æ ‡¶°‡¶ï‡ßÅ‡¶Æ‡ßá‡¶®‡ßç‡¶ü ‡¶è‡¶∞ ‡¶≠‡ßá‡¶§‡¶∞‡ßá‡¶∞‡¶á ‡¶Ö‡¶®‡ßç‡¶Ø ‡¶è‡¶ï‡¶ü‡¶ø ‡¶™‡ßÉ‡¶∑‡ßç‡¶†‡¶æ‡ßü ‡¶®‡¶ø‡ßü‡ßá ‡¶Ø‡¶æ‡ßü‡•§

‡¶õ‡¶¨‡¶ø‡¶∞ ‡¶Æ‡¶æ‡¶ß‡ßç‡¶Ø‡¶Æ‡ßá ‡¶è‡¶ï‡¶ü‡¶ø ‡¶¨‡¶æ‡¶π‡ßç‡¶Ø‡¶ø‡¶ï ‡¶≤‡¶ø‡¶Ç‡¶ï ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø, ‡¶Ü‡¶Æ‡¶∞‡¶æ image() ‡¶Æ‡ßá‡¶•‡¶°‡¶ü‡¶ø ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá‡¶õ‡¶ø‡•§ ‡¶è‡¶á ‡¶Æ‡ßá‡¶•‡¶°‡ßá‡¶∞ ‡¶Æ‡¶æ‡¶ß‡ßç‡¶Ø‡¶Æ‡ßá ‡¶Ü‡¶∞‡ßç‡¶ó‡ßÅ‡¶Æ‡ßá‡¶®‡ßç‡¶ü ‡¶π‡¶ø‡¶∏‡ßá‡¶¨‡ßá ‡¶≤‡¶ø‡¶Ç‡¶ï ‡¶™‡¶æ‡¶∏ ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶Æ‡¶§ ‡¶∏‡ßÅ‡¶¨‡¶ø‡¶ß‡¶æ ‡¶Ü‡¶õ‡ßá‡•§ ‡¶è‡¶á ‡¶≤‡¶ø‡¶Ç‡¶ï ‡¶°‡¶ï‡ßÅ‡¶Æ‡ßá‡¶®‡ßç‡¶ü ‡¶è‡¶∞ ‡¶≠‡ßá‡¶§‡¶∞‡¶ï‡¶æ‡¶∞ ‡¶¨‡¶æ ‡¶¨‡¶æ‡¶á‡¶∞‡ßá‡¶∞ ‡¶Ø‡ßá‡¶ï‡ßã‡¶® ‡¶≤‡¶ø‡¶Ç‡¶ï‡¶á ‡¶π‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá‡•§

‡¶¨‡¶ø‡¶ï‡¶≤‡ßç‡¶™ ‡¶π‡¶ø‡¶∏‡ßá‡¶¨‡ßá ‡¶´‡¶®‡ßç‡¶ü ‡¶∏‡ßç‡¶ü‡¶æ‡¶á‡¶≤ ‡¶è‡¶¨‡¶Ç ‡¶≤‡¶ø‡¶Ç‡¶ï ‡¶Ø‡ßÅ‡¶ï‡ßç‡¶§ ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶Ö‡¶®‡ßç‡¶Ø ‡¶Ü‡¶∞‡ßá‡¶ï‡¶ü‡¶ø ‡¶Æ‡¶æ‡¶ß‡ßç‡¶Ø‡¶Æ ‡¶Ü‡¶õ‡ßá, ‡¶∏‡ßá‡¶ü‡¶ø ‡¶π‡¶≤‡ßã write_html() ‡¶Æ‡ßá‡¶•‡¶° ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶æ‡•§ ‡¶è‡¶ü‡¶æ ‡¶è‡¶ï‡¶ü‡¶æ html ‡¶™‡¶æ‡¶∞‡¶∏‡¶æ‡¶∞, ‡¶Ø‡¶æ‡¶∞ ‡¶Æ‡¶æ‡¶ß‡ßç‡¶Ø‡¶Æ‡ßá html ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá ‡¶ü‡ßá‡¶ï‡ßç‡¶∏‡¶ü ‡¶Ø‡ßÅ‡¶ï‡ßç‡¶§ ‡¶ï‡¶∞‡¶æ‡¶∞, ‡¶´‡¶®‡ßç‡¶ü ‡¶∏‡ßç‡¶ü‡¶æ‡¶á‡¶≤ ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® ‡¶ï‡¶∞‡¶æ ‡¶è‡¶¨‡¶Ç ‡¶≤‡¶ø‡¶Ç‡¶ï ‡¶Ø‡ßÅ‡¶ï‡ßç‡¶§ ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡ßü‡•§

**Examples:**

Example 1 (python):
```python
from fpdf import FPDF

pdf = FPDF()
pdf.add_page()
pdf.set_font("helvetica", style="B", size=16)
pdf.cell(40, 10, "Hello World!")
pdf.output("tuto1.pdf")
```

Example 2 (unknown):
```unknown
pdf = FPDF(orientation="P", unit="mm", format="A4")
```

Example 3 (unknown):
```unknown
pdf.set_font('Helvetica', style='B', size=16)
```

Example 4 (unknown):
```unknown
pdf.cell(40, 10, 'Hello World!', 1)
```

---

## Module fpdf.prefs

**URL:** https://py-pdf.github.io/fpdf2/fpdf/prefs.html

**Contents:**
- Module fpdf.prefs
- Classes
  - Instance variables
  - Methods

Usage documentation at: https://py-pdf.github.io/fpdf2/PageFormatAndOrientation.html#viewer-preferences

Specifies the way the document shall be displayed on the screen

(bool) A flag specifying whether to position the document‚Äôs window in the center of the screen

(TextDirection) The predominant reading order for text.

(bool) A flag specifying whether the window‚Äôs title bar should display the document title taken from the Title entry of the document information dictionary. If false, the title bar should instead display the name of the PDF file containing the document.

(Duplex) The paper handling option that shall be used when printing the file from the print dialog.

(bool) A flag specifying whether to resize the document‚Äôs window to fit the size of the first displayed page

(bool) A flag specifying whether to hide the conforming reader‚Äôs menu bar when the document is active

(bool) A flag specifying whether to hide the conforming reader‚Äôs tool bars when the document is active

(bool) A flag specifying whether to hide user interface elements in the document‚Äôs window (such as scroll bars and navigation controls), leaving only the document‚Äôs contents displayed

(PageMode) The document‚Äôs page mode, specifying how to display the document on exiting full-screen mode

(int) The number of copies that shall be printed when the print dialog is opened for this file. Values outside this range shall be ignored. Default value: as defined by the conforming reader, but typically 1

(PageBoundaries) The name of the page boundary representing the area of a page that shall be rendered when printing the document. Default value: CropBox.

(PageBoundaries) The name of the page boundary to which the contents of a page shall be clipped when printing the document. Default value: CropBox.

(list[int]) The page numbers used to initialize the print dialog box when the file is printed. The array shall contain an even number of integers to be interpreted in pairs, with each pair specifying the first and last pages in a sub-range of pages to be printed. The first page of the PDF file shall be denoted by 1.

The page scaling option that shall be selected when a print dialogue is displayed for this document. Valid values are:

If this entry is not specified or has an unrecognised value, AppDefault shall be used.

(PageBoundaries) The name of the page boundary representing the area of a page that shall be displayed when viewing the document on the screen. Default value: CropBox.

(PageBoundaries) The name of the page boundary to which the contents of a page shall be clipped when viewing the document on the screen. Default value: CropBox.

**Examples:**

Example 1 (python):
```python
class ViewerPreferences:
    "Specifies the way the document shall be displayed on the screen"

    def __init__(
        self,
        hide_toolbar: bool = False,
        hide_menubar: bool = False,
        hide_window_u_i: bool = False,
        fit_window: bool = False,
        center_window: bool = False,
        display_doc_title: bool = False,
        non_full_screen_page_mode: PageMode = PageMode.USE_NONE,
        num_copies: Optional[int] = None,
        print_page_range: Optional[list[int]] = None,
        direction: Optional[TextDirection | str] = None,
        duplex: Optional[Duplex | str] = None,
        view_area: Optional[PageBoundaries | str] = None,
        view_clip: Optional[PageBoundaries | str] = None,
        print_area: Optional[PageBoundaries | str] = None,
        print_clip: Optional[PageBoundaries | str] = None,
        print_scaling: Optional[str] = None,
    ) -> None:
        self._min_pdf_version = "1.3"

        self.hide_toolbar = hide_toolbar
        """
        (`bool`)
        A flag specifying whether to hide the conforming reader‚Äôs tool bars when the document is active
        """
        self.hide_menubar = hide_menubar
        """
        (`bool`)
        A flag specifying whether to hide the conforming reader‚Äôs menu bar when the document is active
        """
        self.hide_window_u_i = hide_window_u_i
        """
        (`bool`)
        A flag specifying whether to hide user interface elements in the document‚Äôs window
        (such as scroll bars and navigation controls), leaving only the document‚Äôs contents displayed
        """
        self.fit_window = fit_window
        """
        (`bool`)
        A flag specifying whether to resize the document‚Äôs window to fit the size of the first displayed page
        """
        self.center_window = center_window
        """
        (`bool`)
        A flag specifying whether to position the document‚Äôs window in the center of the screen
        """
        self.display_doc_title = display_doc_title
        """
        (`bool`)
        A flag specifying whether the window‚Äôs title bar should display the document title
        taken from the Title entry of the document information dictionary.
        If false, the title bar should instead display the name of the PDF file containing the document.
        """
        self.non_full_screen_page_mode = non_full_screen_page_mode
        """
        (`fpdf.enums.PageMode`)
        The document‚Äôs page mode, specifying how to display the document on exiting full-screen mode
        """
        self.num_copies = num_copies
        """
        (`int`)
        The number of copies that shall be printed when the print dialog is opened for this file.
        Values outside this range shall be ignored. Default value: as defined by the conforming reader, but typically 1
        """
        self.print_page_range = print_page_range
        """
        (`list[int]`)
        The page numbers used to initialize the print dialog box when the file is printed.
        The array shall contain an even number of integers to be interpreted in pairs,
        with each pair specifying the first and last pages in a sub-range of pages to be printed.
        The first page of the PDF file shall be denoted by 1.
        """
        self.direction = direction
        """
        (`fpdf.enums.TextDirection`)
        The predominant reading order for text.
        """
        self.duplex = duplex
        """
        (`fpdf.enums.Duplex`)
        The paper handling option that shall be used when printing the file from the print dialog.
        """
        self.view_area = view_area
        """
        (`fpdf.enums.PageBoundaries`)
        The name of the page boundary representing the area of a page that shall be displayed when viewing the document on the screen.
        Default value: CropBox.
        """
        self.view_clip = view_clip
        """
        (`fpdf.enums.PageBoundaries`)
        The name of the page boundary to which the contents of a page shall be clipped when viewing the document on the screen.
        Default value: CropBox.
        """
        self.print_area = print_area
        """
        (`fpdf.enums.PageBoundaries`)
        The name of the page boundary representing the area of a page that shall be rendered when printing the document.
        Default value: CropBox.
        """
        self.print_clip = print_clip
        """
        (`fpdf.enums.PageBoundaries`)
        The name of the page boundary to which the contents of a page shall be clipped when printing the document.
        Default value: CropBox.
        """
        self.print_scaling = print_scaling
        """
        The page scaling option that shall be selected when a print dialogue is displayed for this document.
        Valid values are:

        * `"None"`, which indicates no page scaling
        * `"AppDefault"`, which indicates the interactive PDF processor‚Äôs default print scaling

        If this entry is not specified or has an unrecognised value, `AppDefault` shall be used.
        """

    def _set_min_pdf_version(self, version: str) -> None:
        self._min_pdf_version = max(self._min_pdf_version, version)

    @property
    def non_full_screen_page_mode(self) -> Optional[PageMode]:
        return self._non_full_screen_page_mode

    @non_full_screen_page_mode.setter
    def non_full_screen_page_mode(self, page_mode: Optional[PageMode | str]) -> None:
        self._non_full_screen_page_mode = (
            None if page_mode is None else PageMode.coerce(page_mode)
        )
        if self._non_full_screen_page_mode in (
            PageMode.FULL_SCREEN,
            PageMode.USE_ATTACHMENTS,
        ):
            raise ValueError(
                f"{self.non_full_screen_page_mode} is not a supported value for NonFullScreenPageMode"
            )

    @property
    def num_copies(self) -> Optional[int]:
        return self._num_copies

    @num_copies.setter
    def num_copies(self, num_copies: Optional[int]) -> None:
        if num_copies is not None:
            self._set_min_pdf_version("1.7")
        self._num_copies = num_copies

    @property
    def print_page_range(self) -> Optional[list[int]]:
        return self._print_page_range

    @print_page_range.setter
    def print_page_range(self, print_page_range: Optional[list[int]]) -> None:
        if print_page_range is not None:
            self._set_min_pdf_version("1.7")
        self._print_page_range = print_page_range

    @property
    def direction(self) -> Optional[TextDirection]:
        return self._direction

    @direction.setter
    def direction(self, direction: Optional[TextDirection | str]) -> None:
        self._direction = None if direction is None else TextDirection.coerce(direction)

    @property
    def display_doc_title(self) -> bool:
        return self._display_doc_title

    @display_doc_title.setter
    def display_doc_title(self, display_doc_title: bool) -> None:
        if display_doc_title:
            self._set_min_pdf_version("1.4")
        self._display_doc_title = display_doc_title

    @property
    def duplex(self) -> Optional[Duplex]:
        return self._duplex

    @duplex.setter
    def duplex(self, duplex: Optional[Duplex | str]) -> None:
        if duplex is not None:
            self._set_min_pdf_version("1.7")
        self._duplex = None if duplex is None else Duplex.coerce(duplex)

    @property
    def view_area(self) -> Optional[PageBoundaries]:
        return self._view_area

    @view_area.setter
    def view_area(self, view_area: Optional[PageBoundaries | str]) -> None:
        if view_area is not None:
            self._set_min_pdf_version("1.4")
        self._view_area = (
            None if view_area is None else PageBoundaries.coerce(view_area)
        )

    @property
    def view_clip(self) -> Optional[PageBoundaries]:
        return self._view_clip

    @view_clip.setter
    def view_clip(self, view_clip: Optional[PageBoundaries | str]) -> None:
        if view_clip is not None:
            self._set_min_pdf_version("1.4")
        self._view_clip = (
            None if view_clip is None else PageBoundaries.coerce(view_clip)
        )

    @property
    def print_area(self) -> Optional[PageBoundaries]:
        return self._print_area

    @print_area.setter
    def print_area(self, print_area: Optional[PageBoundaries | str]) -> None:
        if print_area is not None:
            self._set_min_pdf_version("1.4")
        self._print_area = (
            None if print_area is None else PageBoundaries.coerce(print_area)
        )

    @property
    def print_clip(self) -> Optional[PageBoundaries]:
        return self._print_clip

    @print_clip.setter
    def print_clip(self, print_clip: Optional[PageBoundaries | str]) -> None:
        if print_clip is not None:
            self._set_min_pdf_version("1.4")
        self._print_clip = (
            None if print_clip is None else PageBoundaries.coerce(print_clip)
        )

    @property
    def print_scaling(self) -> Optional[Name]:
        return self._print_scaling

    @print_scaling.setter
    def print_scaling(self, print_scaling: Optional[str]) -> None:
        if print_scaling is None:
            self._print_scaling = None
            return
        self._set_min_pdf_version("1.6")
        if print_scaling not in ("None", "AppDefault"):
            raise ValueError(f"Invalid {print_scaling=} value provided")
        self._print_scaling = Name(print_scaling)

    def serialize(
        self,
        _security_handler: Optional["StandardSecurityHandler"] = None,
        _obj_id: Optional[int] = None,
    ) -> str:
        obj_dict = build_obj_dict(
            {key: getattr(self, key) for key in dir(self)},
            _security_handler=_security_handler,
            _obj_id=_obj_id,
        )
        return create_dictionary_string(obj_dict)
```

Example 2 (python):
```python
@property
def direction(self) -> Optional[TextDirection]:
    return self._direction
```

Example 3 (python):
```python
@property
def display_doc_title(self) -> bool:
    return self._display_doc_title
```

Example 4 (python):
```python
@property
def duplex(self) -> Optional[Duplex]:
    return self._duplex
```

---

## fpdf2 internals¬∂

**URL:** https://py-pdf.github.io/fpdf2/Internals.html

**Contents:**
- fpdf2 internals¬∂
- FPDF.pages¬∂
- syntax.py & objects serialization¬∂
- GraphicsStateMixin¬∂
- OutputProducer¬∂

FPDF is designed to add content progressively to the document generated, page by page.

Each page is an entry in the .pages attribute of FPDF instances. Indices start at 1 (the first page) and values are PDFPage instances.

PDFPage instances have a .contents attribute that is a bytearray and contains the Content Stream for this page (bytearray makes things a lot faster).

Going back to a previously generated page to add content is possible, using the .page attribute, but may result in unexpected behavior, because .add_page() takes special care to ensure the page's content stream matches FPDF's instance attributes.

The syntax.py package contains classes representing core elements of the PDF syntax.

Classes inherit from the PDFObject class, that has the following properties:

Other notable core classes are:

This mixin class, inherited by the FPDF class, allows to manage a stack of graphics state variables:

The main methods of this API are:

Each stack entry is a GraphicsState dataclass, and _get_current_graphics_state() returns a copy used by fragments or temporary contexts.

Thanks to this mixin, we can use the following semantics: from fpdf.graphics_state import GraphicsStateMixin f = GraphicsStateMixin() # Push initial state in stack: gs0 gs0 = f._push_local_stack() # Step 1 - set some graphic styles: gs1 f.font_size_pt = 16 f.underline = True gs1 = f._get_current_graphics_state() # Step 2 - restore gs0 f._pop_local_stack() print(f"{f.font_size_pt=} {f.underline=}") # -> f.font_size_pt=0 f.underline=False

The graphics states used in the code above can be depicted by this diagram:

In fpdf2, the FPDF class is used to store the document definition, its state as it is progressively built. Most attributes and internal data is mutable.

Once it's done, when the FPDF.output() method is called, the actual PDF file creation is delegated to the OutputProducer class.

It performs the serialization of the PDF document, including the generation of the cross-reference table & file trailer. This class uses the FPDF instance as immutable input: it does not perform any modification on it.

**Examples:**

Example 1 (swift):
```swift
from fpdf.graphics_state import GraphicsStateMixin

f = GraphicsStateMixin()
# Push initial state in stack: gs0
gs0 = f._push_local_stack()
# Step 1 - set some graphic styles: gs1
f.font_size_pt = 16
f.underline = True
gs1 = f._get_current_graphics_state()
# Step 2 - restore gs0
f._pop_local_stack()
print(f"{f.font_size_pt=} {f.underline=}")
# -> f.font_size_pt=0 f.underline=False
```

Example 2 (typescript):
```typescript
stateDiagram-v2
  direction LR
  state gs0 {
    initial1 : Base state
  }
  state gs1 {
    initial2 : Base state
    font_size_pt2 : font_size_pt=16
    underline2 : underline=True
    font_size_pt2 --> initial2
    underline2 --> font_size_pt2
  }
  gs0 --> gs1: Step 1
  state "gs0" as stack2 {
    initial3 : Base state
  }
  gs1 --> stack2: Step 2
```

---

## Module fpdf.enums

**URL:** https://py-pdf.github.io/fpdf2/fpdf/enums.html

**Contents:**
- Module fpdf.enums
- Classes
  - Ancestors
  - Class variables
  - Static methods
  - Ancestors
  - Class variables
  - Static methods
  - Ancestors
  - Class variables

Permission flags will translate as an integer on the encryption dictionary

Add or modify text annotations

Insert, rotate or delete pages and create bookmarks or thumbnail images

Copy or extract text and graphics from the document

Extract text and graphics in support of accessibility to users with disabilities

Fill in existing interactive form fields

Modify the contents of the document

Print document at the highest resolution

Defines how to render text in a cell

Center text horizontally

Center text horizontally around current x position

Inherited from: CoerciveEnum.coerce

Attempt to coerce value into a member of this enumeration ‚Ä¶

Direction values used for mirror transformations specifying the angle of mirror line

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

Inherited from: CoerciveIntEnum.coerce

Attempt to coerce value into a member of this enumeration ‚Ä¶

An enumeration that provides a helper to coerce strings and integers into enumeration members.

If set, do not display or print the annotation or allow it to interact with the user

If set, do not display the annotation if it does not belong to one of the standard annotation types and no annotation handler is available.

If set, do not allow the annotation to be deleted or its properties (including position and size) to be modified by the user.

If set, do not allow the contents of the annotation to be modified by the user.

If set, do not rotate the annotation‚Äôs appearance to match the rotation of the page.

If set, do not display the annotation on the screen or allow it to interact with the user

If set, do not scale the annotation‚Äôs appearance to match the magnification of the page.

If set, print the annotation when the page is printed.

If set, do not allow the annotation to interact with the user. The annotation may be displayed or printed but should not respond to mouse clicks.

If set, invert the interpretation of the NoView flag for certain events.

Inherited from: CoerciveIntEnum.coerce

Attempt to coerce value into a member of this enumeration ‚Ä¶

The name of an icon that shall be used in displaying the annotation

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

Inherited from: CoerciveEnum.coerce

Attempt to coerce value into a member of this enumeration ‚Ä¶

Represents the association between an embedded file and the content on the PDF

The file has an alternative representation of the content

The file has the information used to produce the associated object. e.g.: the data used to produce a table or a graph

The file is an encrypted payload document that should be displayed to the user if the PDF processor has the cryptographic filter needed to decrypt the document

The file has the data associated with the interactive form in this document

The file is a schema definition for the associated object

The file is the original source material of the content

The file has a supplemental representation of the original source or data that may be more easily consumable

Shall be used when the relationship is not known or cannot be described using one of the other values

Inherited from: CoerciveEnum.coerce

Attempt to coerce value into a member of this enumeration ‚Ä¶

An enumeration of the named standard named blend functions supported by PDF.

"Creates a color with the hue and saturation of the source color and the luminosity of the backdrop color. This preserves the gray levels of the backdrop and is useful for coloring monochrome images or tinting color images."

"Darkens the backdrop color to reflect the source color. Painting with white produces no change."

"Brightens the backdrop color to reflect the source color. Painting with black produces no changes."

"Selects the darker of the backdrop and source colors."

"Subtracts the darker of the two constituent colors from the lighter color."

"Produces an effect similar to that of the Difference mode but lower in contrast. Painting with white inverts the backdrop color; painting with black produces no change."

"Multiplies or screens the colors, depending on the source color value. The effect is similar to shining a harsh spotlight on the backdrop."

"Creates a color with the hue of the source color and the saturation and luminosity of the backdrop color."

"Selects the lighter of the backdrop and source colors."

"Creates a color with the luminosity of the source color and the hue and saturation of the backdrop color. This produces an inverse effect to that of the Color mode."

"Multiplies the backdrop and source color values."

"Selects the source color, ignoring the backdrop."

"Multiplies or screens the colors, depending on the backdrop color value. Source colors overlay the backdrop while preserving its highlights and shadows. The backdrop color is not replaced but is mixed with the source color to reflect the lightness or darkness of the backdrop."

"Creates a color with the saturation of the source color and the hue and luminosity of the backdrop color. Painting with this mode in an area of the backdrop that is a pure gray (no saturation) produces no change."

"Multiplies the complements of the backdrop and source color values, then complements the result."

"Darkens or lightens the colors, depending on the source color value. The effect is similar to shining a diffused spotlight on the backdrop."

Inherited from: CoerciveEnum.coerce

Attempt to coerce value into a member of this enumeration ‚Ä¶

Defines how to render cell borders in table

The integer value of border determines which borders are applied. Below are some common examples:

Using border=3 will combine LEFT and RIGHT borders, as it represents the bitwise OR of LEFT (1) and RIGHT (2).

Draw border on all side of the cell

Draw border on the bottom side of the cell

Inherits the border layout from the table borders layout

Draw border on the left side of the cell

Draw no border on any side of cell

Draw border on the right side of the cell

Draw border on the top side of the cell

Inherited from: CoerciveIntFlag.coerce

Attempt to coerce value into a member of this enumeration ‚Ä¶

Protocol for custom table cell fill mode classes

Defines the vertical position of text relative to the line.

Denominator of a fraction

Default line position

Nominator of a fraction

Inherited from: CoerciveEnum.coerce

Attempt to coerce value into a member of this enumeration ‚Ä¶

An enumeration of the PDF drawing directives that define a path as a clipping path.

"An alternative to the nonzero winding number rule is the even-odd rule. This rule determines whether a point is inside a path by drawing a ray from that point in any direction and simply counting the number of path segments that cross the ray, regardless of direction. If this number is odd, the point is inside; if even, the point is outside. This yields the same results as the nonzero winding number rule for paths with simple shapes, but produces different results for more complex shapes.

"The nonzero winding number rule determines whether a given point is inside a path by conceptually drawing a ray from that point to infinity in any direction and then examining the places where a segment of the path crosses the ray. Starting with a count of 0, the rule adds 1 each time a path segment crosses the ray from left to right and subtracts 1 each time a segment crosses from right to left. After counting all the crossings, if the result is 0, the point is outside the path; otherwise, it is inside."

Inherited from: CoerciveEnum.coerce

Attempt to coerce value into a member of this enumeration ‚Ä¶

An enumeration that provides a helper to coerce strings into enumeration members.

Attempt to coerce value into a member of this enumeration.

If value is already a member of this enumeration it is returned unchanged. Otherwise, if it is a string, attempt to convert it as an enumeration value. If that fails, attempt to convert it (case insensitively, by upcasing) as an enumeration name.

If all different conversion attempts fail, an exception is raised.

An enumeration that provides a helper to coerce strings and integers into enumeration members.

Attempt to coerce value into a member of this enumeration.

If value is already a member of this enumeration it is returned unchanged. Otherwise, if it is a string, attempt to convert it (case insensitively, by upcasing) as an enumeration name. Otherwise, if it is an int, attempt to convert it as an enumeration value.

Otherwise, an exception is raised.

Enumerated constants that can be combined using the bitwise operators, with a helper to coerce strings and integers into enumeration members.

Attempt to coerce value into a member of this enumeration.

If value is already a member of this enumeration it is returned unchanged. Otherwise, if it is a string, attempt to convert it (case insensitively, by upcasing) as an enumeration name. Otherwise, if it is an int, attempt to convert it as an enumeration value. Otherwise, an exception is raised.

An enumeration of Porter-Duff compositing operations.

Draw the destination only

The part of the destination that overlaps the source is drawn over the source. The rest of the destination is discarded.

Only the part of the destination that overlaps with the source is drawn. The rest is discarded.

Only the part of the destination that does not overlap the source is drawn.

The destination (backdrop) is drawn over the source.

The part of the source that overlaps the destination is drawn over the destination. The rest of the source is discarded.

Only the part of the source that overlaps with the destination is drawn. The rest is discarded.

Only the part of the source that does not overlap the destination is drawn.

The source is drawn over the destination (backdrop).

Only the parts of the source and destination that do not overlap are drawn.

Inherited from: CoerciveEnum.coerce

Attempt to coerce value into a member of this enumeration ‚Ä¶

An enumeration that provides a helper to coerce strings into enumeration members.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

Inherited from: CoerciveEnum.coerce

Attempt to coerce value into a member of this enumeration ‚Ä¶

Type of compliance enforcement that can be applied to a document. Limited to PDF/A at the moment, but extendable to other standards like: - PDF/E (Engineering PDFs) - PDF/UA (PDF Universal Accessibility) - PDF/X (Graphics Exchange PDFs)

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The paper handling option that shall be used when printing the file from the print dialog.

Duplex and flip on the long edge of the sheet

Duplex and flip on the short edge of the sheet

Inherited from: CoerciveEnum.coerce

Attempt to coerce value into a member of this enumeration ‚Ä¶

Algorithm to be used to encrypt the document

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The name of an icon that shall be used in displaying the annotation

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

Inherited from: CoerciveEnum.coerce

Attempt to coerce value into a member of this enumeration ‚Ä¶

An enumeration of the flags for the unsigned 32-bit integer entry in the font descriptor specifying various characteristics of the font. Bit positions are numbered from 1 (low-order) to 32 (high-order).

"All glyphs have the same width (as opposed to proportional or variable-pitch fonts, which have different widths."

"The flag shall determine whether bold glyphs shall be painted with extra pixels even at very small text sizes by a conforming reader. If set, features of bold glyphs may be thickened at small text sizes."

"Glyphs have dominant vertical strokes that are slanted."

"Font contains glyphs outside the Adobe standard Latin character set. This flag and the Nonsymbolic flag shall not both be set or both be clear."

Specifies how to fill the area outside the gradient's start and end points.

The color at the start or end of the gradient is extended to fill the area before or after the gradient.

The gradient pattern is repeated in reverse order (mirrored) to fill the area before or after the gradient.

The gradient pattern is repeated in the same order to fill the area before or after the gradient.

Inherited from: CoerciveEnum.coerce

Attempt to coerce value into a member of this enumeration ‚Ä¶

Specifies the coordinate system for gradients.

Coordinates are expressed as fractions of the painted object's bounding box (0..1 in each axis).

Coordinates are in the current page space.

Inherited from: CoerciveEnum.coerce

Attempt to coerce value into a member of this enumeration ‚Ä¶

An enumeration representing the two possible PDF intersection rules.

The intersection rule is used by the renderer to determine which points are considered to be inside the path and which points are outside the path. This primarily affects fill rendering and clipping paths.

"An alternative to the nonzero winding number rule is the even-odd rule. This rule determines whether a point is inside a path by drawing a ray from that point in any direction and simply counting the number of path segments that cross the ray, regardless of direction. If this number is odd, the point is inside; if even, the point is outside. This yields the same results as the nonzero winding number rule for paths with simple shapes, but produces different results for more complex shapes."

"The nonzero winding number rule determines whether a given point is inside a path by conceptually drawing a ray from that point to infinity in any direction and then examining the places where a segment of the path crosses the ray. Starting with a count of 0, the rule adds 1 each time a path segment crosses the ray from left to right and subtracts 1 each time a segment crosses from right to left. After counting all the crossings, if the result is 0, the point is outside the path; otherwise, it is inside."

Inherited from: CoerciveEnum.coerce

Attempt to coerce value into a member of this enumeration ‚Ä¶

Defines the return value(s) of a FPDF content-rendering method.

This enum values can be combined with & and | operators: PAGE_BREAK | LINES

The method will return how much vertical space was used

The method will return a multi-lines array of strings, after performing word-wrapping

The method will return a boolean indicating if a page break occurred

Inherited from: CoerciveIntFlag.coerce

Attempt to coerce value into a member of this enumeration ‚Ä¶

Definition for Output Intent Subtypes

ISO_PDFE1 PDF/E standards (ISO 24517, all parts)

PDF/A (ISO 19005) standard to produce RGB output

PDF/X-1a which is based upon CMYK processing

Inherited from: CoerciveEnum.coerce

Attempt to coerce value into a member of this enumeration ‚Ä¶

Create a collection of name/value pairs.

Enumerations can be iterated over, and know how many members they have:

Methods can be added to enumerations, and members can have their own attributes ‚Äì see the documentation for details.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

An enumeration of the graphics state parameter dictionary keys.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

An enumeration that provides a helper to coerce strings into enumeration members.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

Inherited from: CoerciveEnum.coerce

Attempt to coerce value into a member of this enumeration ‚Ä¶

Style of the page label

uppercase letters a to z, aa to zz, aaa to zzz and so on

lowercase roman numerals

decimal arabic numerals

uppercase letters A to Z, AA to ZZ, AAA to ZZZ and so on

uppercase roman numerals

Inherited from: CoerciveEnum.coerce

Attempt to coerce value into a member of this enumeration ‚Ä¶

Specify the page layout shall be used when the document is opened

Display the pages in one column

Display one page at a time

Display the pages in two columns, with odd-numbered pages on the left

Display the pages in two columns, with odd-numbered pages on the right

Display the pages two at a time, with odd-numbered pages on the left

Display the pages two at a time, with odd-numbered pages on the right

Inherited from: CoerciveEnum.coerce

Attempt to coerce value into a member of this enumeration ‚Ä¶

Specifying how to display the document on exiting full-screen mode

Full-screen mode, with no menu bar, window controls, or any other window visible

Attachments panel visible

Neither document outline nor thumbnail images visible

Optional content group panel visible

Document outline visible

Thumbnail images visible

Inherited from: CoerciveEnum.coerce

Attempt to coerce value into a member of this enumeration ‚Ä¶

An enumeration that provides a helper to coerce strings into enumeration members.

The type of the None singleton.

The type of the None singleton.

Inherited from: CoerciveEnum.coerce

Attempt to coerce value into a member of this enumeration ‚Ä¶

An enumeration of the PDF drawing directives that determine how the renderer should paint a given path.

Automatically determine which PathPaintRule should be used.

PaintedPath will select one of the above PathPaintRules based on the resolved set/inherited values of its style property.

"End the path object without filling or stroking it. This operator is a path-painting no-op, used primarily for the side effect of changing the current clipping path."

"Fill the path, using the even-odd rule to determine the region to fill. Any subpaths that are open are implicitly closed before being filled."

"Fill the path, using the nonzero winding number rule to determine the region to fill. Any subpaths that are open are implicitly closed before being filled."

"Fill and then stroke the path, using the even-odd rule to determine the region to fill. This operator produces the same result as STROKE_FILL_NONZERO, except that the path is filled as if with FILL_EVENODD instead of FILL_NONZERO."

"Fill and then stroke the path, using the nonzero winding number rule to determine the region to fill. This operator produces the same result as constructing two identical path objects, painting the first with FILL_NONZERO and the second with STROKE."

Inherited from: CoerciveEnum.coerce

Attempt to coerce value into a member of this enumeration ‚Ä¶

Defines how to render shapes

Draw lines. Line color can be controlled with FPDF.set_draw_color(). Line thickness can be controlled with FPDF.set_line_width().

Draw lines and fill areas

Fill areas. Filling color can be controlled with FPDF.set_fill_color().

Inherited from: CoerciveEnum.coerce

Attempt to coerce value into a member of this enumeration ‚Ä¶

Enum where members are also (and must be) ints

If set, the document contains signatures that may be invalidated if the file is saved (written) in a way that alters its previous contents, as opposed to an incremental update.

If set, the document contains at least one signature field.

An enumeration of values defining how the end of a stroke should be rendered.

This affects the ends of the segments of dashed strokes, as well.

"The stroke is squared off at the endpoint of the path. There is no projection beyond the end of the path."

"A semicircular arc with a diameter equal to the line width is drawn around the endpoint and filled in."

"The stroke continues beyond the endpoint of the path for a distance equal to half the line width and is squared off."

Inherited from: CoerciveIntEnum.coerce

Attempt to coerce value into a member of this enumeration ‚Ä¶

An enumeration of values defining how the corner joining two path components should be rendered.

"The two segments are finished with butt caps and the resulting notch beyond the ends of the segments is filled with a triangle."

"The outer edges of the strokes for the two segments are extended until they meet at an angle, as in a picture frame. If the segments meet at too sharp an angle (as defined by the miter limit parameter), a bevel join is used instead."

"An arc of a circle with a diameter equal to the line width is drawn around the point where the two segments meet, connecting the outer edges of the strokes for the two segments. This pieslice-shaped figure is filled in, pro- ducing a rounded corner."

Inherited from: CoerciveIntEnum.coerce

Attempt to coerce value into a member of this enumeration ‚Ä¶

A helper class for drawing one border of a table

From boolean or TableBorderStyle input, convert to definite TableBorderStyle class object

Return list with string for the command to draw a line at the specified endpoints

The type of the None singleton.

The type of the None singleton.

Return dict object specifying dash in the same format as the pdf object

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

Return True if this style changes the any aspect of the draw command, False otherwise

Return list of strings for the draw command to change stroke (empty if no change)

Get draw commands for this section of a cell border. x and y are presumed to be already shifted and scaled.

Return True if this style produces a visible stroke, False otherwise

Customizable class for setting the drawing style of cell borders for the whole table. cell_style_getter is an abstract method that derived classes must implement. All current classes do not use self, but it is available in case a very complicated derived class needs to refer to stored internal data.

Standard TableBordersLayouts are available as static members of this class

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

Attempt to coerce value into a member of this class.

If value is already a member of this enumeration it is returned unchanged. Otherwise, if it is a string, attempt to convert it as an enumeration value. If that fails, attempt to convert it (case insensitively, by upcasing) as an enumeration name.

If all different conversion attempts fail, an exception is raised.

Specify the desired TableCellStyle for the given position in the table

TableCellStyle for the given position in the table

Class for drawing all cell borders

Inherited from: TableBordersLayout.ALL

The type of the None singleton.

Inherited from: TableBordersLayout.HORIZONTAL_LINES

The type of the None singleton.

Inherited from: TableBordersLayout.INTERNAL

The type of the None singleton.

Inherited from: TableBordersLayout.MINIMAL

The type of the None singleton.

Inherited from: TableBordersLayout.NONE

The type of the None singleton.

Inherited from: TableBordersLayout.NO_HORIZONTAL_LINES

The type of the None singleton.

Inherited from: TableBordersLayout.SINGLE_TOP_LINE

The type of the None singleton.

Inherited from: TableBordersLayout.coerce

Attempt to coerce value into a member of this class ‚Ä¶

Inherited from: TableBordersLayout.cell_style_getter

Specify the desired TableCellStyle for the given position in the table ‚Ä¶

Class to draw only horizontal lines

Inherited from: TableBordersLayout.ALL

The type of the None singleton.

Inherited from: TableBordersLayout.HORIZONTAL_LINES

The type of the None singleton.

Inherited from: TableBordersLayout.INTERNAL

The type of the None singleton.

Inherited from: TableBordersLayout.MINIMAL

The type of the None singleton.

Inherited from: TableBordersLayout.NONE

The type of the None singleton.

Inherited from: TableBordersLayout.NO_HORIZONTAL_LINES

The type of the None singleton.

Inherited from: TableBordersLayout.SINGLE_TOP_LINE

The type of the None singleton.

Inherited from: TableBordersLayout.coerce

Attempt to coerce value into a member of this class ‚Ä¶

Inherited from: TableBordersLayout.cell_style_getter

Specify the desired TableCellStyle for the given position in the table ‚Ä¶

Class to draw only internal horizontal & vertical borders

Inherited from: TableBordersLayout.ALL

The type of the None singleton.

Inherited from: TableBordersLayout.HORIZONTAL_LINES

The type of the None singleton.

Inherited from: TableBordersLayout.INTERNAL

The type of the None singleton.

Inherited from: TableBordersLayout.MINIMAL

The type of the None singleton.

Inherited from: TableBordersLayout.NONE

The type of the None singleton.

Inherited from: TableBordersLayout.NO_HORIZONTAL_LINES

The type of the None singleton.

Inherited from: TableBordersLayout.SINGLE_TOP_LINE

The type of the None singleton.

Inherited from: TableBordersLayout.coerce

Attempt to coerce value into a member of this class ‚Ä¶

Inherited from: TableBordersLayout.cell_style_getter

Specify the desired TableCellStyle for the given position in the table ‚Ä¶

Class to draw only the top horizontal border, below the headings, and internal vertical borders

Inherited from: TableBordersLayout.ALL

The type of the None singleton.

Inherited from: TableBordersLayout.HORIZONTAL_LINES

The type of the None singleton.

Inherited from: TableBordersLayout.INTERNAL

The type of the None singleton.

Inherited from: TableBordersLayout.MINIMAL

The type of the None singleton.

Inherited from: TableBordersLayout.NONE

The type of the None singleton.

Inherited from: TableBordersLayout.NO_HORIZONTAL_LINES

The type of the None singleton.

Inherited from: TableBordersLayout.SINGLE_TOP_LINE

The type of the None singleton.

Inherited from: TableBordersLayout.coerce

Attempt to coerce value into a member of this class ‚Ä¶

Inherited from: TableBordersLayout.cell_style_getter

Specify the desired TableCellStyle for the given position in the table ‚Ä¶

Class to draw all cells border except interior horizontal lines after the headings

Inherited from: TableBordersLayout.ALL

The type of the None singleton.

Inherited from: TableBordersLayout.HORIZONTAL_LINES

The type of the None singleton.

Inherited from: TableBordersLayout.INTERNAL

The type of the None singleton.

Inherited from: TableBordersLayout.MINIMAL

The type of the None singleton.

Inherited from: TableBordersLayout.NONE

The type of the None singleton.

Inherited from: TableBordersLayout.NO_HORIZONTAL_LINES

The type of the None singleton.

Inherited from: TableBordersLayout.SINGLE_TOP_LINE

The type of the None singleton.

Inherited from: TableBordersLayout.coerce

Attempt to coerce value into a member of this class ‚Ä¶

Inherited from: TableBordersLayout.cell_style_getter

Specify the desired TableCellStyle for the given position in the table ‚Ä¶

Class for drawing zero cell borders

Inherited from: TableBordersLayout.ALL

The type of the None singleton.

Inherited from: TableBordersLayout.HORIZONTAL_LINES

The type of the None singleton.

Inherited from: TableBordersLayout.INTERNAL

The type of the None singleton.

Inherited from: TableBordersLayout.MINIMAL

The type of the None singleton.

Inherited from: TableBordersLayout.NONE

The type of the None singleton.

Inherited from: TableBordersLayout.NO_HORIZONTAL_LINES

The type of the None singleton.

Inherited from: TableBordersLayout.SINGLE_TOP_LINE

The type of the None singleton.

Inherited from: TableBordersLayout.coerce

Attempt to coerce value into a member of this class ‚Ä¶

Inherited from: TableBordersLayout.cell_style_getter

Specify the desired TableCellStyle for the given position in the table ‚Ä¶

Class to draw a single top line

Inherited from: TableBordersLayout.ALL

The type of the None singleton.

Inherited from: TableBordersLayout.HORIZONTAL_LINES

The type of the None singleton.

Inherited from: TableBordersLayout.INTERNAL

The type of the None singleton.

Inherited from: TableBordersLayout.MINIMAL

The type of the None singleton.

Inherited from: TableBordersLayout.NONE

The type of the None singleton.

Inherited from: TableBordersLayout.NO_HORIZONTAL_LINES

The type of the None singleton.

Inherited from: TableBordersLayout.SINGLE_TOP_LINE

The type of the None singleton.

Inherited from: TableBordersLayout.coerce

Attempt to coerce value into a member of this class ‚Ä¶

Inherited from: TableBordersLayout.cell_style_getter

Specify the desired TableCellStyle for the given position in the table ‚Ä¶

Defines which table cells to fill

Fill only table cells in odd columns

Fill only table cells in even columns

Fill only table cells in even rows

Fill only table cells in odd rows

Inherited from: CoerciveEnum.coerce

Attempt to coerce value into a member of this enumeration ‚Ä¶

A helper class for drawing all the borders of one cell in a table

Return list with string for command to change device color (empty list if no color)

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

Draw the cell border for this cell, and fill it with the given fill color.

Get list of primitive commands to draw the cell border for this cell, and fill it with the given fill color.

Allow override by CellBordersLayout mechanism

Defines how the table headings should be displayed

0: Only render the table headings at the beginning of the table

1: When a page break occurs, repeat the table headings at the top of every table fragment

Inherited from: CoerciveIntEnum.coerce

Attempt to coerce value into a member of this enumeration ‚Ä¶

An enumeration that provides a helper to coerce strings into enumeration members.

Mark this cell as a continuation of the previous column

Mark this cell as a continuation of the previous row

Inherited from: CoerciveEnum.coerce

Attempt to coerce value into a member of this enumeration ‚Ä¶

Text rendering direction for text shaping

Inherited from: CoerciveEnum.coerce

Attempt to coerce value into a member of this enumeration ‚Ä¶

Indicates use of bold / italics / underline.

This enum values can be combined with & and | operators: style = B | I

Inherited from: CoerciveIntFlag.coerce

Attempt to coerce value into a member of this enumeration ‚Ä¶

Subtype of a text markup annotation

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

Inherited from: CoerciveEnum.coerce

Attempt to coerce value into a member of this enumeration ‚Ä¶

Values described in PDF spec section 'Text Rendering Mode'

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

Inherited from: CoerciveIntEnum.coerce

Attempt to coerce value into a member of this enumeration ‚Ä¶

Defines how to vertically render text in a cell. Default value is MIDDLE

Place text at the bottom of the cell, but obey the cells padding

Center text vertically

Place text at the top of the cell, but obey the cells padding

Inherited from: CoerciveEnum.coerce

Attempt to coerce value into a member of this enumeration ‚Ä¶

Defines how to break and wrap lines in multi-line text.

Inherited from: CoerciveEnum.coerce

Attempt to coerce value into a member of this enumeration ‚Ä¶

Positional values in horizontal direction for use after printing text.

center of actual text

right end of actual text

left page margin (start of printable area)

right end of the cell (default)

right page margin (end of printable area)

left start of actual text

for write() to continue next (slightly left of END)

Inherited from: CoerciveEnum.coerce

Attempt to coerce value into a member of this enumeration ‚Ä¶

Positional values in vertical direction for use after printing text

bottom page margin (end of printable area)

top of the last line (same as TOP for single-line text)

top of next line (bottom of current text)

top page margin (start of printable area)

top of the first line (default)

Inherited from: CoerciveEnum.coerce

Attempt to coerce value into a member of this enumeration ‚Ä¶

**Examples:**

Example 1 (python):
```python
class AccessPermission(IntFlag):
    "Permission flags will translate as an integer on the encryption dictionary"

    PRINT_LOW_RES = 0b000000000100
    "Print the document"

    MODIFY = 0b000000001000
    "Modify the contents of the document"

    COPY = 0b000000010000
    "Copy or extract text and graphics from the document"

    ANNOTATION = 0b000000100000
    "Add or modify text annotations"

    FILL_FORMS = 0b000100000000
    "Fill in existing interactive form fields"

    COPY_FOR_ACCESSIBILITY = 0b001000000000
    "Extract text and graphics in support of accessibility to users with disabilities"

    ASSEMBLE = 0b010000000000
    "Insert, rotate or delete pages and create bookmarks or thumbnail images"

    PRINT_HIGH_RES = 0b100000000000
    "Print document at the highest resolution"

    @classmethod
    def all(cls) -> int:
        "All flags enabled"
        result = 0
        for permission in list(AccessPermission):
            access_permission = permission
            result = result | access_permission.value
        return result

    @classmethod
    def none(cls) -> int:
        "All flags disabled"
        return 0
```

Example 2 (python):
```python
class Align(CoerciveEnum):
    "Defines how to render text in a cell"

    C = intern("CENTER")
    "Center text horizontally"

    X = intern("X_CENTER")
    "Center text horizontally around current x position"

    L = intern("LEFT")
    "Left-align text"

    R = intern("RIGHT")
    "Right-align text"

    J = intern("JUSTIFY")
    "Justify text"

    @classmethod
    def coerce(  # pyright: ignore[reportIncompatibleMethodOverride]
        cls, value: Union["Align", str], case_sensitive: bool = False
    ) -> "Align":
        if value == "":
            return cls.L
        if isinstance(value, str):
            value = value.upper()
        return super(cls, cls).coerce(
            value, case_sensitive  # pyright: ignore[reportArgumentType]
        )
```

Example 3 (python):
```python
class Angle(CoerciveIntEnum):
    "Direction values used for mirror transformations specifying the angle of mirror line"

    NORTH = 90
    EAST = 0
    SOUTH = 270
    WEST = 180
    NORTHEAST = 45
    SOUTHEAST = 315
    SOUTHWEST = 225
    NORTHWEST = 135
```

Example 4 (python):
```python
class AnnotationFlag(CoerciveIntEnum):
    INVISIBLE = 1
    """
    If set, do not display the annotation if it does not belong to one of the
    standard annotation types and no annotation handler is available.
    """
    HIDDEN = 2
    "If set, do not display or print the annotation or allow it to interact with the user"
    PRINT = 4
    "If set, print the annotation when the page is printed."
    NO_ZOOM = 8
    "If set, do not scale the annotation‚Äôs appearance to match the magnification of the page."
    NO_ROTATE = 16
    "If set, do not rotate the annotation‚Äôs appearance to match the rotation of the page."
    NO_VIEW = 32
    "If set, do not display the annotation on the screen or allow it to interact with the user"
    READ_ONLY = 64
    """
    If set, do not allow the annotation to interact with the user.
    The annotation may be displayed or printed but should not respond to mouse clicks.
    """
    LOCKED = 128
    """
    If set, do not allow the annotation to be deleted or its properties
    (including position and size) to be modified by the user.
    """
    TOGGLE_NO_VIEW = 256
    "If set, invert the interpretation of the NoView flag for certain events."
    LOCKED_CONTENTS = 512
    "If set, do not allow the contents of the annotation to be modified by the user."
```

---

## Module fpdf.output

**URL:** https://py-pdf.github.io/fpdf2/fpdf/output.html

**Contents:**
- Module fpdf.output
- Functions
- Classes
  - Methods
  - Ancestors
  - Methods
  - Ancestors
  - Subclasses
  - Methods
- Args

This module contains the serialization logic that produces a PDF document from a FPDF instance. Most of the code in this module is used when FPDF.output() is called.

The contents of this module are internal to fpdf2, and not part of the public API. They may change at any time without prior warning or any deprecation period, in non-backward-compatible ways.

Convert a blend group into a Form XObject with an isolated transparency group.

Converts a PaintedSoftMask into a PDF XObject Form suitable for use as a soft mask.

Inherited from: PDFObject.content_stream

Subclasses can override this method to indicate the presence of a content stream

Inherited from: PDFObject.serialize

Serialize the PDF object as an obj<</>>endobj text block

Helper class that provides a standard way to create an ABC using inheritance.

The optional OutputIntents (PDF 1.4) entry in the document catalog dictionary holds an array of output intent dictionaries, each describing the colour reproduction characteristics of a possible output device.

dest_output_profile (PDFICCProfile, required/optional): PDFICCProfile | None # (required if output_condition_identifier does not specify a standard production condition; optional otherwise) info (str, required/optional see dest_output_profile): human readable description of profile

Generates the final bytearray representing the PDF document, based on a FPDF instance.

This method alters the target FPDF instance by assigning IDs to all PDF objects, plus a few other properties on PDFPage instances

Inherited from: PDFObject.content_stream

Subclasses can override this method to indicate the presence of a content stream

Inherited from: PDFObject.serialize

Serialize the PDF object as an obj<</>>endobj text block

Inherited from: PDFObject.content_stream

Subclasses can override this method to indicate the presence of a content stream

Inherited from: PDFObject.serialize

Serialize the PDF object as an obj<</>>endobj text block

Inherited from: PDFObject.content_stream

Subclasses can override this method to indicate the presence of a content stream

Inherited from: PDFObject.serialize

Serialize the PDF object as an obj<</>>endobj text block

Inherited from: PDFContentStream.content_stream

Subclasses can override this method to indicate the presence of a content stream

Inherited from: PDFContentStream.serialize

Serialize the PDF object as an obj<</>>endobj text block

Emit the PDF file header as required by ISO 32000-1, ¬ß7.5.2 ‚ÄúFile header‚Äù.

The header consists of: 1) A line starting with the literal "%PDF-" followed by the file version 2) If the file contains binary data an immediate second line that is a comment starting with "%" and containing at least four bytes with values ‚â• 128 (non-ASCII). This helps file-transfer tools treat the content as binary rather than text.

Holds values for ICC Profile Stream

Inherited from: PDFContentStream.content_stream

Subclasses can override this method to indicate the presence of a content stream

Inherited from: PDFContentStream.serialize

Serialize the PDF object as an obj<</>>endobj text block

Inherited from: PDFObject.content_stream

Subclasses can override this method to indicate the presence of a content stream

Inherited from: PDFObject.serialize

Serialize the PDF object as an obj<</>>endobj text block

Inherited from: PDFObject.content_stream

Subclasses can override this method to indicate the presence of a content stream

Return a pair (width, height) in the unit specified to FPDF constructor

Inherited from: PDFObject.serialize

Serialize the PDF object as an obj<</>>endobj text block

Accepts a pair (width, height) in the unit specified to FPDF constructor

This will be displayed by some PDF readers to identify pages.

Inherited from: PDFObject.content_stream

Subclasses can override this method to indicate the presence of a content stream

Inherited from: PDFObject.serialize

Serialize the PDF object as an obj<</>>endobj text block

Inherited from: PDFObject.content_stream

Subclasses can override this method to indicate the presence of a content stream

Inherited from: PDFObject.serialize

Serialize the PDF object as an obj<</>>endobj text block

Inherited from: PDFObject.content_stream

Subclasses can override this method to indicate the presence of a content stream

Inherited from: PDFObject.serialize

Serialize the PDF object as an obj<</>>endobj text block

Inherited from: PDFContentStream.content_stream

Subclasses can override this method to indicate the presence of a content stream

Inherited from: PDFContentStream.serialize

Serialize the PDF object as an obj<</>>endobj text block

Inherited from: PDFContentStream.content_stream

Subclasses can override this method to indicate the presence of a content stream

Inherited from: PDFContentStream.serialize

Serialize the PDF object as an obj<</>>endobj text block

Cross-reference table & file trailer

Manage the indexing of resources and association to the pages they are used

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

Resolve a family+style to a concrete font instance from the font registry.

Scan a rendered content stream and register resources used on the given page. Currently indexes: - ExtGState invocations: '/GSn gs' - Image XObjects: '/In Do'

Register a blend group Form XObject and return its resource index.

Graphics style can be added without associating to a page number right away, like when rendering a svg image. The method that adds image to the page will call the add method for the page association.

Register a soft mask xobject and return its object id

Parse a content stream and return discovered resources

**Examples:**

Example 1 (python):
```python
def blend_group_to_xobject(
    group: "BlendGroup", resource_catalog: ResourceCatalog
) -> PDFContentStream:
    """Convert a blend group into a Form XObject with an isolated transparency group."""
    stream = group.render(resource_catalog)
    xobject = PDFContentStream(contents=stream.encode("latin-1"))
    xobject._blend_group = group  # type: ignore[attr-defined]
    xobject._registered = False  # type: ignore[attr-defined]
    xobject.type = Name("XObject")  # type: ignore[attr-defined]
    xobject.subtype = Name("Form")  # type: ignore[attr-defined]
    bbox = group.get_bounding_box()
    xobject.b_box = PDFArray(bbox)  # type: ignore[attr-defined]
    xobject.group = "<</S /Transparency /CS /DeviceRGB /I true>>"  # type: ignore[attr-defined]
    return xobject
```

Example 2 (python):
```python
def soft_mask_path_to_xobject(
    path: PaintSoftMask, resource_catalog: ResourceCatalog
) -> PDFContentStream:
    """Converts a PaintedSoftMask into a PDF XObject Form suitable for use as a soft mask."""
    xobject = PDFContentStream(contents=path.render(resource_catalog).encode("latin-1"))
    xobject._path = path  # type: ignore[attr-defined]
    xobject.type = Name("XObject")  # type: ignore[attr-defined]
    xobject.subtype = Name("Form")  # type: ignore[attr-defined]
    xobject.b_box = PDFArray(path.get_bounding_box())  # type: ignore[attr-defined]
    xobject.group = "<</S /Transparency /CS /DeviceGray /I true /K false>>"  # type: ignore[attr-defined]
    return xobject
```

Example 3 (python):
```python
def stream_content_for_raster_image(
    info: RasterImageInfo,
    x: float,
    y: float,
    w: float,
    h: float,
    keep_aspect_ratio: bool = False,
    scale: float = 1,
    pdf_height_to_flip: Optional[float] = None,
) -> str:
    if keep_aspect_ratio:
        x, y, w, h = info.scale_inside_box(x, y, w, h)
    if pdf_height_to_flip:
        stream_h = h
        stream_y = pdf_height_to_flip - h - y
    else:
        stream_h = -h
        stream_y = y + h
    return (
        f"q {w * scale:.2f} 0 0 {stream_h * scale:.2f}"
        f" {x * scale:.2f} {stream_y * scale:.2f} cm"
        f" /I{info['i']} Do Q"
    )
```

Example 4 (python):
```python
class AcroForm:
    def __init__(self, fields: PDFArray, sig_flags: int):
        self.fields = fields
        self.sig_flags = sig_flags

    def serialize(
        self,
        _security_handler: Optional["StandardSecurityHandler"] = None,
        _obj_id: Optional[int] = None,
    ) -> str:
        obj_dict = build_obj_dict(
            {key: getattr(self, key) for key in dir(self)},
            _security_handler=_security_handler,
            _obj_id=_obj_id,
        )
        return pdf_dict(obj_dict, field_join=" ")
```

---

## Transformations¬∂

**URL:** https://py-pdf.github.io/fpdf2/Transformations.html

**Contents:**
- Transformations¬∂
- Rotation¬∂
- Skew¬∂
- Mirror¬∂

The rotation() context-manager will apply a rotation to all objects inserted in its indented block: from fpdf import FPDF pdf = FPDF(format=(40, 40)) pdf.add_page() x, y = 15, 15 with pdf.rotation(60, x=x, y=y): pdf.circle(x=x, y=y+15, radius=5) # Inserting a small base64-encoded image: pdf.image("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAMFBMVEU0OkArMjhobHEoPUPFEBIuO0L+AAC2FBZ2JyuNICOfGx7xAwTjCAlCNTvVDA1aLzQ3COjMAAAAVUlEQVQI12NgwAaCDSA0888GCItjn0szWGBJTVoGSCjWs8TleQCQYV95evdxkFT8Kpe0PLDi5WfKd4LUsN5zS1sKFolt8bwAZrCaGqNYJAgFDEpQAAAzmxafI4vZWwAAAABJRU5ErkJggg==", x=x, y=y) pdf.rect(x=x-10, y=y+10, w=25, h=15) pdf.output("rotations.pdf")

skew creates a skewing transformation of magnitude ax in the horizontal axis and ay in the vertical axis. The transformation originates from x, y and will use a default origin unless specified otherwise:

with pdf.skew(ax=0, ay=10): pdf.cell(text="text skewed on the y-axis")

with pdf.skew(ax=10, ay=0): pdf.cell(text="text skewed on the x-axis")

pdf.set_line_width(2) pdf.set_draw_color(240) pdf.set_fill_color(r=230, g=30, b=180) with pdf.skew(ax=-45, ay=0, x=100, y=170): pdf.circle(x=100, y=170, radius=10, style="FD")

The mirror context-manager applies a mirror transformation to all objects inserted in its indented block over a given mirror line by specifying starting co-ordinate and angle.

x, y = 100, 100 pdf.text(x, y, text="mirror this text") with pdf.mirror((x, y), "EAST"): pdf.set_text_color(r=255, g=128, b=0) pdf.text(x, y, text="mirror this text")

pdf.text(x, y, text="mirror this text") with pdf.mirror((x, y), "NORTH"): pdf.set_text_color(r=255, g=128, b=0) pdf.text(x, y, text="mirror this text")

prev_x, prev_y = pdf.x, pdf.y pdf.multi_cell(w=50, text=LOREM_IPSUM) with pdf.mirror((pdf.x, pdf.y), "NORTHEAST"): # Reset cursor to mirror original multi-cell pdf.x = prev_x pdf.y = prev_y pdf.multi_cell(w=50, text=LOREM_IPSUM, fill=True)

**Examples:**

Example 1 (python):
```python
from fpdf import FPDF

pdf = FPDF(format=(40, 40))
pdf.add_page()
x, y = 15, 15
with pdf.rotation(60, x=x, y=y):
    pdf.circle(x=x, y=y+15, radius=5)
    # Inserting a small base64-encoded image:
    pdf.image("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAMFBMVEU0OkArMjhobHEoPUPFEBIuO0L+AAC2FBZ2JyuNICOfGx7xAwTjCAlCNTvVDA1aLzQ3COjMAAAAVUlEQVQI12NgwAaCDSA0888GCItjn0szWGBJTVoGSCjWs8TleQCQYV95evdxkFT8Kpe0PLDi5WfKd4LUsN5zS1sKFolt8bwAZrCaGqNYJAgFDEpQAAAzmxafI4vZWwAAAABJRU5ErkJggg==", x=x, y=y)
    pdf.rect(x=x-10, y=y+10, w=25, h=15)
pdf.output("rotations.pdf")
```

Example 2 (unknown):
```unknown
with pdf.skew(ax=0, ay=10):
    pdf.cell(text="text skewed on the y-axis")
```

Example 3 (unknown):
```unknown
with pdf.skew(ax=10, ay=0):
    pdf.cell(text="text skewed on the x-axis")
```

Example 4 (unknown):
```unknown
pdf.set_line_width(2)
pdf.set_draw_color(240)
pdf.set_fill_color(r=230, g=30, b=180)
with pdf.skew(ax=-45, ay=0, x=100, y=170):
    pdf.circle(x=100, y=170, radius=10, style="FD")
```

---

## Tutorial¬∂

**URL:** https://py-pdf.github.io/fpdf2/Tutorial-pt.html

**Contents:**
- Tutorial¬∂
- Tuto 1 - Exemplo M√≠nimo¬∂
- Tuto 2 - Cabe√ßalho, rodap√©, quebra de p√°gina e imagem¬∂
- Tuto 3 - Quebras de linha e cores¬∂
- Tuto 4 - Multi Colunas¬∂
- Tuto 5 - Criar Tabelas¬∂
- Tuto 6 - Criar links e misturar estilos de texto¬∂

Methods full documentation: fpdf.FPDF API doc

Vamos come√ßar com um exemplo cl√°ssico:

Ap√≥s incluirmos o ficheiro da biblioteca, criamos um objeto FPDF. O FPDF construtor √© constru√≠do com os seguintes par√¢metros por omiss√£o: P√°ginas s√£o em formato A4 vertical e a unidade de medida √© o mil√≠metro. Pode ser especificado explicitamente atrav√©s de:

√â poss√≠vel colocar o PDF em modo horizontal (L) ou em outros formatos de p√°gina (como Letter e Legal) e em outras unidades de medida (pt, cm, in).

Neste momento, n√£o h√° nenhuma p√°gina, ent√£o temos que adicionar uma com add_page. A origem est√° no canto superior esquerdo e a posi√ß√£o atual √©, por padr√£o, colocada a 1 cm das bordas; as margens podem ser alteradas com set_margins.

Antes de imprimirmos o texto, √© obrigat√≥rio selecionar uma fonte com set_font, caso contr√°rio, o documento ser√° inv√°lido. N√≥s escolhemos Helvetica bold 16:

pdf.set_font('Helvetica', style='B', size=16) Podemos formatar em it√°lico com I, sublinhar comU ou uma fonte normal com uma string vazia (ou qualquer combina√ß√£o). Observe que o tamanho da fonte √© fornecido em pontos, n√£o mil√≠metros (ou outra unidade do utilizador); esta √© a √∫nica exce√ß√£o. As outras fontes integradas s√£o Times,Courier, Symbol eZapfDingbats.

Agora podemos imprimir uma c√©lula com cell. Uma c√©lula √© uma √°rea retangular, possivelmente emoldurada, que cont√©m algum texto. √â renderizado na posi√ß√£o atual. N√≥s especificamos as suas dimens√µes, o seu texto (centrado ou alinhado), se as bordas devem ser desenhadas, e para onde a posi√ß√£o atual se deve mover depois desta altera√ß√£o (para a direita, abaixo ou no in√≠cio da pr√≥xima linha). Para adicionar uma moldura, temos de fazer o seguinte:

Para adicionar uma nova c√©lula ao lado desta, com texto centralizado e ir para a pr√≥xima linha, ter√≠amos de fazer:

Nota: a quebra de linha tamb√©m pode ser feita com ln. Esse m√©todo permite especificar, adicionalmente, a altura da quebra.

Finalmente, o documento √© fechado e guardado no caminho do arquivo fornecido utilizando output. Sem termos qualquer par√¢metro fornecido, output () retorna o buffer PDF bytearray.

Aqui temos um exemplo de duas p√°ginas com cabe√ßalho, rodap√© e log√≥tipo:

Este exemplo usa os header e o footer para processar cabe√ßalhos e rodap√©s de p√°gina. Estes s√£o chamados automaticamente. Eles j√° existem na classe FPDF, mas n√£o fazem nada, portanto, temos que os estender a classe e substitu√≠-los.

O log√≥tipo √© impresso utilizando o m√©todo image, especificando o seu canto superior esquerdo e sua largura. A altura √© calculada automaticamente para respeitar as propor√ß√µes da imagem.

Para imprimir o n√∫mero da p√°gina, um valor nulo √© passado como a largura da c√©lula. Isso significa que a c√©lula deve se estender at√© a margem direita da p√°gina; √© √∫til para centralizar texto. O n√∫mero da p√°gina atual √© retornado pelo m√©todo page_no; quanto ao n√∫mero total de p√°ginas, √© obtido por meio do valor especial {nb} que ser√° substitu√≠do quando se fecha o documento. Observe que o uso do m√©todo set_y permite definir a posi√ß√£o em um local absoluto da p√°gina, come√ßando do in√≠cio ou do fim.

Outro recurso interessante que se usa aqui √© a quebra de p√°gina autom√°tica. Desde do momento em que uma c√©lula cruza o limite da p√°gina (a 2 cent√≠metros da parte inferior por padr√£o), uma pausa √© executada e a fonte restaurada. Embora o cabe√ßalho e rodap√©s selecionam a sua pr√≥pria fonte (helvetica), o corpo continua comTimes. Este mecanismo de restaura√ß√£o autom√°tica tamb√©m se aplica a cores e largura de linha. O limite que dispara quebras de p√°gina pode ser definido com set_auto_page_break.

Vamos continuar com um exemplo que imprime par√°grafos justificados e o uso de cores.

O m√©todo get_string_width permite determinar o comprimento de uma string na fonte atual, e que √© usada aqui para calcular a posi√ß√£o e a largura do quadro ao redor do t√≠tulo. Em seguida, as cores s√£o definidas (via set_draw_color, set_fill_color e set_text_color) e a espessura da linha √© definida como 1 mm (contra 0,2 por padr√£o) com set_line_width. Finalmente, produzimos a c√©lula (se o √∫ltimo par√¢metro for verdadeiro, indica que o plano de fundo deve ser preenchido).

O m√©todo usado para imprimir os par√°grafos √© multi_cell. Cada vez que uma linha atinge a extremidade direita da c√©lula ou um c√≥digo de fim de linha √© encontrado, uma quebra de linha √© emitida e uma nova c√©lula √© criada automaticamente sob a atual. O texto √© justificado por padr√£o.

Duas propriedades do documento s√£o definidas: o t√≠tulo (set_title) e o autor (set_author). As propriedades podem ser visualizadas de duas maneiras: A primeira √© abrir o documento diretamente com o Acrobat Reader, v√° para o menu Arquivo e escolha a op√ß√£o Propriedades do documento. O segundo, tamb√©m dispon√≠vel no plug-in, √© clicar com o bot√£o direito e selecionar Propriedades do documento.

Este exemplo √© uma variante do anterior, mostrando como colocar o texto em v√°rias colunas.

‚ö†Ô∏è This section has changed a lot and requires a new translation: https://github.com/py-pdf/fpdf2/issues/267

PDF resultante - Texto dos pa√≠ses

‚ö†Ô∏è This section has changed a lot and requires a new translation: https://github.com/py-pdf/fpdf2/issues/267

Este tutorial ir√° explicar v√°rias maneiras de inserir links dentro de um documento PDF, bem como adicionar links para fontes externas.

Tamb√©m mostrar√° v√°rias maneiras de usar diferentes estilos de texto, (negrito, it√°lico, sublinhado) no mesmo texto.

PDF resultante - fpdf2-logo

O novo m√©todo mostrado aqui para imprimir texto √© write(). √â muito parecido com multi_cell (), sendo as principais diferen√ßas:

O m√©todo, portanto, nos permite escrever um peda√ßo de texto, alterar o estilo da fonte, e continuar do ponto exato em que paramos. Por outro lado, a sua principal desvantagem √© que n√£o podemos justificar o texto como n√≥s fazemos com o m√©todo multi_cell() .

Na primeira p√°gina do exemplo, us√°mos write() para este prop√≥sito. O in√≠cio da frase est√° escrita no estilo de texto normal, depois usando o m√©todo set_font(), trocamos para sublinhado e acab√°mos a frase.

Para adicionar o link externo a apontar para a segunda p√°gina, n√≥s us√°mos o m√©todo add_link(), que cria uma √°rea clic√°vel √† qual demos o nome de ‚Äúlink‚Äù que direciona para outra parte do documento.

Para criar o link externo usando uma imagem, us√°mos image(). O m√©todo tem a op√ß√£o de passar um link como um dos seus argumentos. O link pode ser interno ou externo.

Como alternativa, outra op√ß√£o para mudar o estilo da fonte e adicionar links √© usar o m√©todo write_html(). √â um ‚Äúparser‚Äù que permite adicionar texto, mudar o estilo da fonte e adicionar links usando html.

**Examples:**

Example 1 (python):
```python
from fpdf import FPDF

pdf = FPDF()
pdf.add_page()
pdf.set_font("helvetica", style="B", size=16)
pdf.cell(40, 10, "Hello World!")
pdf.output("tuto1.pdf")
```

Example 2 (unknown):
```unknown
pdf = FPDF(orientation="P", unit="mm", format="A4")
```

Example 3 (unknown):
```unknown
pdf.set_font('Helvetica', style='B', size=16)
```

Example 4 (unknown):
```unknown
pdf.cell(40, 10, 'Hello World!', 1)
```

---

## Page format and orientation¬∂

**URL:** https://py-pdf.github.io/fpdf2/PageFormatAndOrientation.html

**Contents:**
- Page format and orientation¬∂
- Per-page format, orientation and background¬∂
- Page layout & zoom level¬∂
- Viewer preferences¬∂
- Full screen¬∂

By default, a FPDF document has a A4 format with portrait orientation.

Other formats & orientation can be specified to FPDF constructor:

Currently supported formats are a3, a4, a5, letter, legal or a tuple (width, height). Additional standard formats are welcome and can be suggested through pull requests.

.set_page_background() lets you set a background for all pages following this call until the background is removed. The value must be of type str, io.BytesIO, PIL.Image.Image, drawing.DeviceRGB, tuple or None

The following code snippet illustrates how to configure different page formats for specific pages as well as setting different backgrounds and then removing it:

Similarly, an orientation parameter can be provided to the add_page method.

set_display_mode() allows to set the zoom level: pages can be displayed entirely on screen, occupy the full width of the window, use the real size, be scaled by a specific zooming factor or use the viewer default (configured in its Preferences menu).

The page layout can also be specified: single page at a time, continuous display, two columns or viewer default.

Those settings are detailed in the official PDF format specification, but may not be honored by PDF viewers. If a setting seems ignored, this is probably not a bug with fpdf2, but a choice or a missing feature from your PDF renderer software.

**Examples:**

Example 1 (unknown):
```unknown
pdf = fpdf.FPDF(orientation="landscape", format="A5")
```

Example 2 (python):
```python
from fpdf import FPDF

pdf = FPDF()
pdf.set_font("Helvetica")
pdf.set_page_background((252,212,255))
for i in range(9):
    if i == 6:
        pdf.set_page_background('image_path.png')
    pdf.add_page(format=(210 * (1 - i/10), 297 * (1 - i/10)))
    pdf.cell(text=str(i))
pdf.set_page_background(None)
pdf.add_page(same=True)
pdf.cell(text="9")
pdf.output("varying_format.pdf")
```

Example 3 (python):
```python
from fpdf import FPDF

pdf = FPDF()
pdf.set_display_mode(zoom="default", layout="TWO_COLUMN_LEFT")
pdf.set_font("helvetica", size=30)
pdf.add_page()
pdf.cell(text="page 1")
pdf.add_page()
pdf.cell(text="page 2")
pdf.output("two-column.pdf")
```

Example 4 (python):
```python
from fpdf import FPDF, ViewerPreferences

pdf = FPDF()
pdf.viewer_preferences = ViewerPreferences(
    hide_toolbar=True,
    hide_menubar=True,
    hide_window_u_i=True,
    fit_window=True,
    center_window=True,
    display_doc_title=True,
    non_full_screen_page_mode="USE_OUTLINES",
)
pdf.set_font("helvetica", size=30)
pdf.add_page()
pdf.cell(text="page 1")
pdf.add_page()
pdf.cell(text="page 2")
pdf.output("viewer-prefs.pdf")
```

---

## Combine with pdfrw¬∂

**URL:** https://py-pdf.github.io/fpdf2/CombineWithPdfrw.html

**Contents:**
- Combine with pdfrw¬∂
- Adding content onto an existing PDF page¬∂
- Adding a page to an existing PDF¬∂
- Altering with pdfrw a document generated with fpdf2¬∂

fpdf2 cannot parse existing PDF files.

However, other Python libraries can be combined with fpdf2 in order to add new content to existing PDF files.

This page provides several examples of using fpdf2 with pdfrw, a great zero-dependency pure Python library dedicated to reading & writing PDFs, with numerous examples and a very clean set of classes modelling the PDF internal syntax.

Sadly, this library is not maintained anymore, cf. pmaupin/pdfrw issue #232 & sarnold/pdfrw issue #15.

This example relies on pdfrw Pull Request #216. Until it is merged, you can install a forked version of pdfrw including the required patch:

A document created with fpdf2 can the be edited with pdfrw by passing its .output() to a pdfrw.PdfReader: import io from fpdf import FPDF from pdfrw import PdfReader pdf = FPDF() pdf.add_page() pdf.set_font('times', style='B', size=19) pdf.text(50, 10, 'Hello World!') reader = PdfReader(io.BytesIO(pdf.output()))

**Examples:**

Example 1 (python):
```python
#!/usr/bin/env python3
# USAGE: ./add_on_page_with_pdfrw.py src_file.pdf dest_file.pdf
import sys
from fpdf import FPDF
from pdfrw import PageMerge, PdfReader, PdfWriter
from pdfrw.pagemerge import RectXObj

IN_FILEPATH = sys.argv[1]
OUT_FILEPATH = sys.argv[2]
ON_PAGE_INDEX = 1
# if True, new content will be placed underneath page (painted first):
UNDERNEATH = False

reader = PdfReader(IN_FILEPATH)
area = RectXObj(reader.pages[0])


def new_content():
    fpdf = FPDF(format=(area.w, area.h), unit="pt")
    fpdf.add_page()
    fpdf.set_font("helvetica", size=36)
    fpdf.text(50, 50, "Hello!")
    reader = PdfReader(fdata=bytes(fpdf.output()))
    return reader.pages[0]


writer = PdfWriter()
writer.pagearray = reader.Root.Pages.Kids
if writer.pagearray[0].Kids:
    writer.pagearray = writer.pagearray[0].Kids
PageMerge(writer.pagearray[ON_PAGE_INDEX]).add(
    new_content(), prepend=UNDERNEATH
).render()
writer.write(OUT_FILEPATH)
```

Example 2 (python):
```python
#!/usr/bin/env python3
# USAGE: ./add_new_page_with_pdfrw.py src_file.pdf dest_file.pdf
import sys

from fpdf import FPDF
from pdfrw import PdfReader, PdfWriter

IN_FILEPATH = sys.argv[1]
OUT_FILEPATH = sys.argv[2]
NEW_PAGE_INDEX = 1  # set to None to append at the end


def new_page():
    fpdf = FPDF()
    fpdf.add_page()
    fpdf.set_font("helvetica", size=36)
    fpdf.text(50, 50, "Hello!")
    reader = PdfReader(fdata=bytes(fpdf.output()))
    return reader.pages[0]


writer = PdfWriter(trailer=PdfReader(IN_FILEPATH))
writer.addpage(new_page(), at_index=NEW_PAGE_INDEX)
writer.write(OUT_FILEPATH)
```

Example 3 (python):
```python
pip install git+https://github.com/PyFPDF/pdfrw.git@addpage_at_index
```

Example 4 (swift):
```swift
import io
from fpdf import FPDF
from pdfrw import PdfReader

pdf = FPDF()
pdf.add_page()
pdf.set_font('times', style='B', size=19)
pdf.text(50, 10, 'Hello World!')

reader = PdfReader(io.BytesIO(pdf.output()))
```

---

## Logging¬∂

**URL:** https://py-pdf.github.io/fpdf2/Logging.html

**Contents:**
- Logging¬∂
- fonttools verbose logs¬∂
- Warning logs for unsupported SVG features¬∂

fpdf.FPDF generates useful DEBUG logs on generated sections sizes when calling the output() method., that can help to identify what part of a PDF takes most space (fonts, images, pages...).

Here is an example of setup code to display them:

Example output using the Tutorial first code snippet:

Since fpdf2 v2.5.7, verbose INFO logs are generated by fonttools, a library we use to parse font files:

You can easily suppress those logs with this single line of code: logging.getLogger('fontTools.subset').level = logging.WARN

Similarly, you can omit verbose logs from fontTools.ttLib.ttFont: logging.getLogger('fontTools.ttLib.ttFont').level = logging.WARN

The fpdf.svg module produces WARNING log messages for unsupported SVG tags & attributes. If need be, you can suppress those logs:

**Examples:**

Example 1 (python):
```python
import logging

logging.basicConfig(format="%(asctime)s %(name)s [%(levelname)s] %(message)s",
                    datefmt="%H:%M:%S", level=logging.DEBUG)
```

Example 2 (yaml):
```yaml
19:25:24 fpdf.output [DEBUG] Final size summary of the biggest document sections:
19:25:24 fpdf.output [DEBUG] - pages: 223.0B
19:25:24 fpdf.output [DEBUG] - fonts: 102.0B
```

Example 3 (swift):
```swift
fontTools.subset [INFO] maxp pruned
fontTools.subset [INFO] cmap pruned
fontTools.subset [INFO] post pruned
fontTools.subset [INFO] EBDT dropped
fontTools.subset [INFO] EBLC dropped
fontTools.subset [INFO] GDEF dropped
fontTools.subset [INFO] GPOS dropped
fontTools.subset [INFO] GSUB dropped
fontTools.subset [INFO] DSIG dropped
fontTools.subset [INFO] name pruned
fontTools.subset [INFO] glyf pruned
fontTools.subset [INFO] Added gid0 to subset
fontTools.subset [INFO] Added first four glyphs to subset
fontTools.subset [INFO] Closing glyph list over 'glyf': 25 glyphs before
fontTools.subset [INFO] Glyph names: ['.notdef', 'b', 'braceleft', 'braceright', 'd', 'e', 'eight', 'five', 'four', 'glyph1', 'glyph2', 'h', 'l', 'n', 'nine', 'o', 'one', 'r', 'seven', 'six', 'space', 'three', 'two', 'w', 'zero']
fontTools.subset [INFO] Glyph IDs:   [0, 1, 2, 3, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 69, 71, 72, 75, 79, 81, 82, 85, 90, 94, 96]
fontTools.subset [INFO] Closed glyph list over 'glyf': 25 glyphs after
fontTools.subset [INFO] Glyph names: ['.notdef', 'b', 'braceleft', 'braceright', 'd', 'e', 'eight', 'five', 'four', 'glyph1', 'glyph2', 'h', 'l', 'n', 'nine', 'o', 'one', 'r', 'seven', 'six', 'space', 'three', 'two', 'w', 'zero']
fontTools.subset [INFO] Glyph IDs:   [0, 1, 2, 3, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 69, 71, 72, 75, 79, 81, 82, 85, 90, 94, 96]
fontTools.subset [INFO] Retaining 25 glyphs
fontTools.subset [INFO] head subsetting not needed
fontTools.subset [INFO] hhea subsetting not needed
fontTools.subset [INFO] maxp subsetting not needed
fontTools.subset [INFO] OS/2 subsetting not needed
fontTools.subset [INFO] hmtx subsetted
fontTools.subset [INFO] cmap subsetted
fontTools.subset [INFO] fpgm subsetting not needed
fontTools.subset [INFO] prep subsetting not needed
fontTools.subset [INFO] cvt  subsetting not needed
fontTools.subset [INFO] loca subsetting not needed
fontTools.subset [INFO] post subsetted
fontTools.subset [INFO] name subsetting not needed
fontTools.subset [INFO] glyf subsetted
fontTools.subset [INFO] head pruned
fontTools.subset [INFO] OS/2 Unicode ranges pruned: [0]
fontTools.subset [INFO] glyf pruned
```

Example 4 (unknown):
```unknown
logging.getLogger('fontTools.subset').level = logging.WARN
```

---

## Module fpdf.html

**URL:** https://py-pdf.github.io/fpdf2/fpdf/html.html

**Contents:**
- Module fpdf.html
- Functions
- Classes
- Args
  - Ancestors
  - Class variables
  - Methods

The contents of this module are internal to fpdf2, and not part of the public API. They may change at any time without prior warning or any deprecation period, in non-backward-compatible ways.

Usage documentation at: https://py-pdf.github.io/fpdf2/HTML.html

Convert a web color name to a (R, G, B) color tuple. cf. https://en.wikipedia.org/wiki/Web_colors#HTML_color_names

Parse style="..." HTML attributes, and return a dict of key-value

Render basic HTML to FPDF

The type of the None singleton.

The type of the None singleton.

Feed data to the parser.

Call this as often as you want, with as little or as much text as you want (may include '\n').

This method can be overridden by subclasses to customize the Table of Contents style.

[DEPRECATED since v2.6.0] You can now directly use the FPDF.write_html() method

**Examples:**

Example 1 (python):
```python
def color_as_decimal(
    color: Optional[str] = "#000000",
) -> Optional[DeviceRGB | DeviceGray]:
    """
    Convert a web color name to a (R, G, B) color tuple.
    cf. https://en.wikipedia.org/wiki/Web_colors#HTML_color_names
    """
    if not color:
        return None
    # Checks if color is a name and gets the hex value
    hexcolor = COLOR_DICT.get(color.lower(), color)
    return color_from_hex_string(hexcolor)
```

Example 2 (python):
```python
def ol_prefix(ol_type: str, index: int) -> int | str:
    if ol_type == "1":
        return index
    if ol_type == "a":
        return ascii_lowercase[index - 1]
    if ol_type == "A":
        return ascii_uppercase[index - 1]
    if ol_type == "I":
        return int2roman(index)
    if ol_type == "i":
        return int2roman(index).lower()
    raise NotImplementedError(f"Unsupported type: {ol_type}")
```

Example 3 (python):
```python
def parse_css_style(style_attr: str) -> dict[str, str]:
    """Parse `style="..."` HTML attributes, and return a dict of key-value"""
    style: dict[str, str] = {}
    for element in style_attr.split(";"):
        if not element:
            continue
        pair = element.split(":")
        if len(pair) == 2 and pair[0] and pair[1]:
            attr, value = pair
            style[attr.strip()] = value.strip()
    return style
```

Example 4 (python):
```python
def ul_prefix(ul_type: str, is_ttf_font: bool) -> str:
    if ul_type == "disc":
        return BULLET_UNICODE if is_ttf_font else MESSAGE_WAITING_WIN1252
    if ul_type == "circle":
        return RING_OPERATOR_UNICODE if is_ttf_font else DEGREE_SIGN_WIN1252
    if len(ul_type) == 1:
        return ul_type
    raise NotImplementedError(f"Unsupported type: {ul_type}")
```

---

## Module fpdf.outline

**URL:** https://py-pdf.github.io/fpdf2/fpdf/outline.html

**Contents:**
- Module fpdf.outline
- Functions
- Classes
  - Ancestors
  - Instance variables
  - Methods
  - Ancestors
  - Instance variables
  - Methods
  - Instance variables

Quoting section 8.2.2 "Document Outline" of the 2006 PDF spec 1.7:

The document outline consists of a tree-structured hierarchy of outline items (sometimes called bookmarks), which serve as a visual table of contents to display the document‚Äôs structure to the user.

The contents of this module are internal to fpdf2, and not part of the public API. They may change at any time without prior warning or any deprecation period, in non-backward-compatible ways.

Usage documentation at: https://py-pdf.github.io/fpdf2/DocumentOutlineAndTableOfContents.html

Build PDF objects constitutive of the documents outline, and yield them one by one, starting with the outline dictionary

Inherited from: PDFObject.content_stream

Subclasses can override this method to indicate the presence of a content stream

Inherited from: PDFObject.serialize

Serialize the PDF object as an obj<</>>endobj text block

Inherited from: PDFObject.content_stream

Subclasses can override this method to indicate the presence of a content stream

Inherited from: PDFObject.serialize

Serialize the PDF object as an obj<</>>endobj text block

OutlineSection(name: str, level: int, page_number: int, dest: fpdf.syntax.DestinationXYZ, struct_elem: fpdf.structure_tree.StructElem | None = None)

A reference implementation of a Table of Contents (ToC) for use with fpdf2.

This class provides a customizable Table of Contents that can be used directly or subclassed for additional functionality. To use this class, create an instance of TableOfContents, configure it as needed, and pass its render_toc method as the render_toc_function argument to FPDF.insert_toc_placeholder().

This method can be overridden by subclasses to customize the Table of Contents style.

**Examples:**

Example 1 (python):
```python
def build_outline_objs(
    sections: Sequence[OutlineSection],
) -> Iterator[OutlineDictionary | OutlineItemDictionary]:
    """
    Build PDF objects constitutive of the documents outline,
    and yield them one by one, starting with the outline dictionary
    """
    outline = OutlineDictionary()
    yield outline

    outline_items: list[OutlineItemDictionary] = []
    last_outline_item_per_level: dict[int, OutlineItemDictionary] = {}
    parent_outline_item: OutlineDictionary | OutlineItemDictionary

    for section in sections:
        outline_item = OutlineItemDictionary(
            title=section.name,
            dest=section.dest,
            struct_elem=section.struct_elem,
        )
        yield outline_item

        if section.level in last_outline_item_per_level:
            last_outline_item_at_level = last_outline_item_per_level[section.level]
            last_outline_item_at_level.next = outline_item
            outline_item.prev = last_outline_item_at_level

        if section.level - 1 in last_outline_item_per_level:
            parent_outline_item = last_outline_item_per_level[section.level - 1]
        else:
            parent_outline_item = outline

        outline_item.parent = parent_outline_item
        if parent_outline_item.first is None:
            parent_outline_item.first = (  # pyright: ignore[reportAttributeAccessIssue]
                outline_item
            )
        parent_outline_item.last = (  # pyright: ignore[reportAttributeAccessIssue]
            outline_item
        )
        parent_outline_item.count += 1

        outline_items.append(outline_item)
        last_outline_item_per_level[section.level] = outline_item
        last_outline_item_per_level = {
            level: oitem
            for level, oitem in last_outline_item_per_level.items()
            if level <= section.level
        }
```

Example 2 (python):
```python
class OutlineDictionary(PDFObject):
    __slots__ = ("_id", "type", "first", "last", "count")  # RAM usage optimization

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self.type = "/Outlines"
        self.first = None
        self.last = None
        self.count = 0

    def __str__(self) -> str:
        return f"OutlineDictionary(count={self.count})"
```

Example 3 (python):
```python
class OutlineDictionary(PDFObject):
    __slots__ = ("_id", "type", "first", "last", "count")  # RAM usage optimization

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self.type = "/Outlines"
        self.first = None
        self.last = None
        self.count = 0

    def __str__(self) -> str:
        return f"OutlineDictionary(count={self.count})"
```

Example 4 (python):
```python
class OutlineDictionary(PDFObject):
    __slots__ = ("_id", "type", "first", "last", "count")  # RAM usage optimization

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self.type = "/Outlines"
        self.first = None
        self.last = None
        self.count = 0

    def __str__(self) -> str:
        return f"OutlineDictionary(count={self.count})"
```

---

## Module fpdf.bidi

**URL:** https://py-pdf.github.io/fpdf2/fpdf/bidi.html

**Contents:**
- Module fpdf.bidi
- Functions
- Classes
  - Instance variables
  - Methods
  - Instance variables
  - Methods
  - Instance variables
  - Instance variables
  - Methods

This function applies rules P2 and P3 to detect the direction of a paragraph, retuning the first strong direction and skipping over isolate sequences. P1 must be applied before calling this function (breaking into paragraphs) stop_at_pdi can be set to True to get the direction of a single isolate sequence

Used for conformance validation

DirectionalStatus(embedding_level: int, directional_override_status: str, directional_isolate_status: bool)

Calculate all the bracket pairs on an isolate run, to be used on rule N0 How to calculate bracket pairs: - Basic definitions 14, 15 and 16: http://www.unicode.org/reports/tr9/#BD14 - BIDI brackets for dummies: https://www.unicode.org/notes/tn39/

**Examples:**

Example 1 (python):
```python
def auto_detect_base_direction(
    string: str, stop_at_pdi: bool = False, debug: bool = False
) -> TextDirection:
    """
    This function applies rules P2 and P3 to detect the direction of a paragraph, retuning
    the first strong direction and skipping over isolate sequences.
    P1 must be applied before calling this function (breaking into paragraphs)
    stop_at_pdi can be set to True to get the direction of a single isolate sequence
    """
    # Auto-LTR (standard BIDI) uses the first L/R/AL character, and is LTR if none is found.
    isolate = 0
    for char in string:
        bidi_class = unicodedata.bidirectional(char)
        if debug and bidi_class.isupper():
            bidi_class = "R"
        if bidi_class == "PDI" and isolate == 0 and stop_at_pdi:
            return TextDirection.LTR
        if bidi_class in ("LRI", "RLI", "FSI"):
            isolate += 1
        if bidi_class == "PDI" and isolate > 0:
            isolate -= 1
        if bidi_class in ("R", "AL") and isolate == 0:
            return TextDirection.RTL
        if bidi_class == "L" and isolate == 0:
            return TextDirection.LTR
    return TextDirection.LTR
```

Example 2 (python):
```python
def calculate_isolate_runs(paragraph: list[BidiCharacter]) -> list[IsolatingRun]:
    # BD13 and X10
    class LevelRun(TypedDict):
        level: int
        text: list[BidiCharacter]
        complete: bool
        sos: str
        eos: str

    level_run: list[LevelRun] = []
    lr: list[BidiCharacter] = []
    lr_embedding_level: int = paragraph[0].embedding_level

    for bidi_char in paragraph:
        if bidi_char.embedding_level != lr_embedding_level:
            level_run.append(
                {
                    "level": lr_embedding_level,
                    "text": lr,
                    "complete": False,
                    "sos": "",
                    "eos": "",
                }
            )
            lr = []
            lr_embedding_level = bidi_char.embedding_level
        lr.append(bidi_char)
    level_run.append(
        {
            "level": lr_embedding_level,
            "text": lr,
            "complete": False,
            "sos": "",
            "eos": "",
        }
    )

    def level_to_direction(level: int) -> str:
        if level % 2 == 0:
            return "L"
        return "R"

    # compute sos, eos for each level run
    for index, lr1 in enumerate(level_run):
        if lr1["complete"]:
            continue
        if index == 0:
            sos = level_to_direction(lr1["level"])
        else:
            sos = level_to_direction(max(lr1["level"], level_run[index - 1]["level"]))
        if index == len(level_run) - 1:
            eos = level_to_direction(lr1["level"])
        else:
            if lr1["text"][-1].original_bidi_class in ("LRI", "RLI", "FSI"):
                # X10 - last char is an isolator without matching PDI - set EOS to embedding level
                eos = level_to_direction(lr1["level"])
            else:
                eos = level_to_direction(
                    max(lr1["level"], level_run[index + 1]["level"])
                )
        lr1["sos"] = sos
        lr1["eos"] = eos

    # combine levels runs to create isolate runs
    isolate_runs: list[IsolatingRun] = []
    for index, lr2 in enumerate(level_run):
        if lr2["complete"]:
            continue
        sos = lr2["sos"]
        eos = lr2["eos"]
        ir_chars = lr2["text"]
        lr2["complete"] = True
        if lr2["text"][-1].original_bidi_class in ("LRI", "RLI", "FSI"):
            for nlr in level_run[index + 1 :]:
                if (
                    nlr["level"] == lr2["level"]
                    and nlr["text"][0].original_bidi_class == "PDI"
                ):
                    lr2["text"] += nlr["text"]
                    nlr["complete"] = True
                    eos = nlr["eos"]
                    if nlr["text"][-1].original_bidi_class not in ("LRI", "RLI", "FSI"):
                        break
        isolate_runs.append(IsolatingRun(characters=ir_chars, sos=sos, eos=eos))

    return isolate_runs
```

Example 3 (python):
```python
class BidiCharacter:
    __slots__ = [
        "character_index",
        "character",
        "bidi_class",
        "original_bidi_class",
        "embedding_level",
        "direction",
    ]

    def __init__(
        self, character_index: int, character: str, embedding_level: int, debug: bool
    ) -> None:
        self.character_index = character_index
        self.character = character
        if debug and character.isupper():
            self.bidi_class = "R"
        else:
            self.bidi_class = unicodedata.bidirectional(character)
        self.original_bidi_class = self.bidi_class
        self.embedding_level = embedding_level
        self.direction = None

    def get_direction_from_level(self) -> str:
        return "R" if self.embedding_level % 2 else "L"

    def set_class(self, cls: str) -> None:
        self.bidi_class = cls

    def __repr__(self) -> str:
        return (
            f"character_index: {self.character_index} character: {self.character}"
            + f" bidi_class: {self.bidi_class} original_bidi_class: {self.original_bidi_class}"
            + f" embedding_level: {self.embedding_level} direction: {self.direction}"
        )
```

Example 4 (python):
```python
class BidiCharacter:
    __slots__ = [
        "character_index",
        "character",
        "bidi_class",
        "original_bidi_class",
        "embedding_level",
        "direction",
    ]

    def __init__(
        self, character_index: int, character: str, embedding_level: int, debug: bool
    ) -> None:
        self.character_index = character_index
        self.character = character
        if debug and character.isupper():
            self.bidi_class = "R"
        else:
            self.bidi_class = unicodedata.bidirectional(character)
        self.original_bidi_class = self.bidi_class
        self.embedding_level = embedding_level
        self.direction = None

    def get_direction_from_level(self) -> str:
        return "R" if self.embedding_level % 2 else "L"

    def set_class(self, cls: str) -> None:
        self.bidi_class = cls

    def __repr__(self) -> str:
        return (
            f"character_index: {self.character_index} character: {self.character}"
            + f" bidi_class: {self.bidi_class} original_bidi_class: {self.original_bidi_class}"
            + f" embedding_level: {self.embedding_level} direction: {self.direction}"
        )
```

---

## Tutorial¬∂

**URL:** https://py-pdf.github.io/fpdf2/Tutorial-fr.html

**Contents:**
- Tutorial¬∂
- Tuto 1 - Exemple minimal¬∂
- Tuto 2 - En-t√™te, bas de page, saut de page et image¬∂
- Tuto 3 - Saut de ligne et couleur¬∂
- Tuto 4 - Colonnes multiples¬∂
- Tuto 5 - Cr√©er des tables¬∂
- Tuto 6 - Cr√©er des liens et m√©langer diff√©rents styles de textes¬∂
- Tuto 7 - Cr√©ation de documents PDF/A¬∂
  - Normes PDF/A¬∂
  - Classes de conformit√©¬∂

Documentation compl√®te des m√©thodes : fpdf.FPDF API doc

Commen√ßons par un exemple classique :

Apr√®s avoir inclus la librairie, on cr√©e un objet FPDF. Le constructeur FPDF est utilis√© avec ses valeurs par d√©faut : les pages sont en format portrait A4 et l'unit√© de mesure est le millim√®tre. Cela peut √©galement √™tre sp√©fici√© de cette mani√®re :

Il est possible de cr√©er un PDF en format paysage (L) ou encore d'utiliser d'autres formats (par exemple Letter et Legal) et unit√©s de mesure (pt, cm, in).

Il n'y a pas encore de page, il faut donc en cr√©er une avec add_page. Le coin en haut √† gauche correspond √† l'origine, et le curseur (c'est-√†-dire la position actuelle o√π l'on va afficher un √©l√©ment) est plac√© par d√©faut √† 1 cm des bords. Les marges peuvent √™tre modifi√©es avec set_margins.

Avant de pouvoir afficher du texte, il faut obligatoirement choisir une police de caract√®res avec set_font. Choisissons Helvetica bold 16 :

On aurait pu sp√©cifier une police en italique avec I, soulign√©e avec U ou une police normale avec une chaine de caract√®res vide. Il est aussi possible de combiner les effets en combinant les caract√®res. Notez que la taille des caract√®res est √† sp√©cifier en points (pts), pas en millim√®tres (ou tout autre unit√©). C'est la seule exception. Les autres polices fournies par d√©faut sont Times, Courier, Symbol et ZapfDingbats.

On peut maintenant afficher une cellule avec cell. Une cellule est une zone rectangulaire, avec ou sans cadre, qui contient du texte. Elle est affich√©e √† la position actuelle du curseur. On sp√©cifie ses dimensions, le texte (centr√© ou align√©), s'il y a une bordure ou non, ainsi que la position du curseur apr√®s avoir affich√© la cellule (s'il se d√©place √† droite, vers le bas ou au d√©but de la ligne suivante). Pour ajouter un cadre, on utilise ceci :

Pour ajouter une nouvelle cellule avec un texte centr√© et d√©placer le curseur √† la ligne suivante, on utilise cela :

Remarque : le saut de ligne peut aussi √™tre fait avec ln. Cette m√©thode permet de sp√©cifier la hauteur du saut.

Enfin, le document est sauvegard√© √† l'endroit sp√©cifi√© en utilisant output. Sans aucun param√®tre, output() retourne le buffer bytearray du PDF.

Voici un exemple contenant deux pages avec un en-t√™te, un bas de page et un logo :

Cet exemple utilise les m√©thodes header et footer pour g√©n√©rer des en-t√™tes et des bas de page. Elles sont appel√©es automatiquement. Elles existent d√©j√† dans la classe FPDF mais elles ne font rien, il faut donc les red√©finir dans une classe fille.

Le logo est affich√© avec la m√©thode image en sp√©cifiant la position du coin sup√©rieur gauche et la largeur de l'image. La hauteur est calcul√©e automatiquement pour garder les proportions de l'image.

Pour centrer le num√©ro de page dans le bas de page, il faut passer la valeur nulle √† la place de la largeur de la cellule. Cela fait prendre toute la largeur de la page √† la cellule, ce qui permet de centrer le texte. Le num√©ro de page actuel est obtenu avec la m√©thode page_no. Le nombre total de pages est obtenu avec la variable {nb} qui prend sa valeur quand le document est ferm√© (la m√©thode alias_nb_pages permet de d√©finir un autre nom de variable pour cette valeur). La m√©thode set_y permet de sp√©cifier une position dans la page relative au haut ou bas de page.

Une autre fonctionnalit√© int√©ressante est utilis√©e ici : les sauts de page automatiques. Si une cellule d√©passe la limite du contenu de la page (par d√©faut √† 2 centim√®tres du bas), un saut de page est ins√©r√© √† la place et la police de caract√®res est restaur√©e. C'est-√†-dire, bien que l'en-t√™te et le bas de page utilisent la police helvetica, le corps du texte garde la police Times. Ce m√©canisme de restauration automatique s'applique √©galement √† la couleur et l'√©paisseur des lignes. La limite du contenu qui d√©clenche le saut de page peut √™tre sp√©cifi√©e avec set_auto_page_break.

Continuons avec un exemple qui affiche des paragraphes avec du texte justifi√©. Cet exemple montre √©galement l'utilisation de couleurs.

La m√©thode get_string_width permet de d√©terminer la largeur d'un texte utilisant la police actuelle, ce qui permet de calculer la position et la largeur du cadre autour du titre. Ensuite les couleurs sont sp√©cifi√©es (avec set_draw_color, set_fill_color et set_text_color) et on sp√©cifie l'√©paisseur de la bordure du cadre √† 1 mm (contre 0.2 par d√©faut) avec set_line_width. Enfin, on affiche la cellule (le dernier param√®tre "true" indique que le fond doit √™tre rempli).

La m√©thode multi_cell est utilis√©e pour afficher les paragraphes. Chaque fois qu'une ligne atteint le bord d'une cellule ou qu'un caract√®re de retour √† la ligne est pr√©sent, un saut de ligne est ins√©r√© et une nouvelle cellule est cr√©√©e automatiquement sous la cellule actuelle. Le texte est justifi√© par d√©faut.

Deux propri√©t√©s sont d√©finies pour le document : le titre (set_title) et l'auteur (set_author). Les propri√©t√©s peuvent √™tre trouv√©es en ouvrant le document PDF avec Acrobat Reader. Elles sont alors visibles dans le menu Fichier -> Propri√©t√©s du document.

Cet exemple est une variante du pr√©c√©dent qui montre comment r√©partir le texte sur plusieurs colonnes.

Extrait de Jules Verne

‚ö†Ô∏è This section has changed a lot and requires a new translation: https://github.com/py-pdf/fpdf2/issues/267

Ce tutoriel explique comment cr√©er facilement des tableaux. Deux tableaux diff√©rents sont g√©n√©r√©s, pour illustrer ce qui peut √™tre produit avec de tr√®s simples changements.

PDF g√©n√©r√© - Donn√©es CSV des pays

Le premier exemple est g√©n√©r√© de la fa√ßon la plus simple possible, en fournissant des donn√©es √† FPDF.table(). Le r√©sultat est rudimentaire, mais tr√®s rapide √† obtenir.

Le second tableau introduit quelques am√©liorations : couleurs, largeur r√©duite de la table, moindre hauteur des lignes de texte, titres centr√©s, colonnes avec des largeurs propres, nombres align√©s √† droite... De plus, les lignes horizontales ont √©t√© supprim√©es. Cela gr√¢ce √† la s√©lection d'un borders_layout parmi les valeurs disponibles : TableBordersLayout.

Ce tutoriel explique plusieurs fa√ßons d'ins√©rer des liens √† l'int√©rieur d'un document pdf, ainsi que l'ajout de liens vers des sources externes.

Il montrera √©galement plusieurs fa√ßons d'utiliser diff√©rents styles de texte (gras, italique, soulign√©) dans un m√™me texte.

PDF cr√©√© dans ce tutoriel - fpdf2-logo

La nouvelle m√©thode pr√©sent√©e ici pour imprimer du texte est write(). Elle est tr√®s similaire √† multi_cell(). Les principales diff√©rences sont les suivantes :

Cette m√©thode nous permet donc d'√©crire un morceau de texte, de modifier le style de police et de reprendre exactement l√† o√π nous nous sommes arr√™t√©s. En revanche, son principal inconv√©nient est que nous ne pouvons pas justifier le texte comme nous le faisons avec la m√©thode multi_cell().

Dans la premi√®re page de l'exemple, nous avons utilis√© write() √† cette fin. Le d√©but de la phrase est √©crit en style normal, puis en utilisant la m√©thode set_font(), nous sommes pass√©s au soulignement et avons termin√© la phrase.

Pour ajouter un lien interne pointant vers la deuxi√®me page, nous avons utilis√© la m√©thode add_link(), qui cr√©e une zone cliquable que nous avons nomm√©e link et qui dirige vers une autre page du document.

Pour cr√©er le lien externe √† l'aide d'une image, nous avons utilis√© image(). Cette m√©thode a la possibilit√© de transmettre un lien comme l'un de ses arguments. Le lien peut √™tre interne ou externe.

Comme alternative, une autre option pour changer le style de police et ajouter des liens est d'utiliser la m√©thode write_html(). Celle-ci permet de lire du HTML pour produire du texte, changer le style de police ou encore ajouter des liens.

PDF/A-1 est bas√© sur la sp√©cification PDF 1.4. Toutes les ressources (images, graphiques, polices) doivent √™tre incorpor√©es dans le document. La gestion des couleurs doit √™tre sp√©cifi√©e de mani√®re ind√©pendante de la plateforme avec des profils ICC, et les m√©tadonn√©es du document doivent √™tre fournies avec des m√©tadonn√©es XMP.

PDF/A-2 est bas√© sur la sp√©cification PDF 1.7. Il permet la compression avec JPEG2000, les √©l√©ments transparents, les polices OpenType et les signatures num√©riques.

La seule extension pour PDF/A-3 est la possibilit√© d'incorporer n'importe quel fichier possible.

Niveau A (accessible) englobe toutes les exigences de la norme, y compris la cartographie de la structure du contenu et l'ordre de lecture correct du contenu du document. Le contenu textuel doit √™tre extractible et la structure doit refl√©ter la s√©quence de lecture naturelle.

Niveau B (basique) garantit une reproductibilit√© visuelle claire du contenu. Le niveau B est g√©n√©ralement plus facile √† g√©n√©rer que le niveau A, mais il ne garantit pas une extraction de texte ou une capacit√© de recherche √† 100 %. La r√©utilisation sans probl√®me du contenu n'est pas n√©cessairement garantie.

Pour y parvenir, voici un petit exemple : from pathlib import Path from fpdf import FPDF from fpdf import FPDF_VERSION DIR = Path(__file__).parent FONT_DIR = DIR / ".." / "test" / "fonts" pdf = FPDF(enforce_compliance="PDF/A-3B") pdf.set_lang("en-US") pdf.set_title("Tutorial7") pdf.set_author(["John Dow", "Jane Dow"]) pdf.set_subject("Example for PDF/A") pdf.set_keywords(["example", "tutorial", "fpdf", "pdf/a"]) pdf.set_producer(f"py-pdf/fpdf2 {FPDF_VERSION}") pdf.add_font(fname=FONT_DIR / "DejaVuSans.ttf") pdf.add_font("DejaVuSans", style="B", fname=FONT_DIR / "DejaVuSans-Bold.ttf") pdf.add_font("DejaVuSans", style="I", fname=FONT_DIR / "DejaVuSans-Oblique.ttf") pdf.add_page() pdf.set_font("DejaVuSans", style="B", size=20) pdf.write(text="Header") pdf.ln(20) pdf.set_font(size=12) pdf.write(text="Example text") pdf.ln(20) pdf.set_font(style="I") pdf.write(text="Example text in italics") pdf.output("tuto7.pdf")

PDF r√©sultant : tuto7.pdf

Des outils comme VeraPDF peuvent v√©rifier la conformit√© des documents PDF produits : verapdf --format text -v tutorial/tuto7.pdf

Produit en sortie textuelle : PASS fpdf2/tutorial/tuto7.pdf 3b

**Examples:**

Example 1 (python):
```python
from fpdf import FPDF

pdf = FPDF()
pdf.add_page()
pdf.set_font("helvetica", style="B", size=16)
pdf.cell(40, 10, "Hello World!")
pdf.output("tuto1.pdf")
```

Example 2 (unknown):
```unknown
pdf = FPDF(orientation="P", unit="mm", format="A4")
```

Example 3 (unknown):
```unknown
pdf.set_font('Helvetica', style='B', size=16)
```

Example 4 (unknown):
```unknown
pdf.cell(40, 10, 'Hello World!', 1)
```

---

## Text Shaping¬∂

**URL:** https://py-pdf.github.io/fpdf2/TextShaping.html

**Contents:**
- Text Shaping¬∂
- What is text shaping?¬∂
  - Kerning¬∂
  - Ligatures¬∂
  - Glyph Substitution¬∂
- Usage¬∂
  - Basic usage¬∂
  - Features¬∂
  - Additional options¬∂
- Bidirectional Text¬∂

This is currently incompatible with the special {nb} string that inserts the number of pages.cf. GitHub issue #1090

Text shaping is a fundamental process in typography and computer typesetting that influences the aesthetics and readability of text in various languages and scripts. It involves the transformation of Unicode text into glyphs, which are then positioned for display or print.

For texts in latin script, text shaping can improve the aesthetics by replacing characters that would collide or overlap by a single glyph specially crafted to look harmonious.

This process is especially important for scripts that require complex layout, such as Arabic or Indic scripts, where characters change shape depending on their context.

There are three primary aspects of text shaping that contribute to the overall appearance of the text: kerning, ligatures, and glyph substitution.

Kerning refers to the adjustment of space between individual letter pairs in a font. This process is essential to avoid awkward gaps or overlaps that may occur due to the default spacing of the font. By manually or programmatically modifying the kerning, we can ensure an even and visually pleasing distribution of letters, which significantly improves the readability and aesthetic quality of the text.

Ligatures are special characters that are created by combining two or more glyphs. This is frequently used to avoid collision between characters or to adhere to the typographic traditions. For instance, in English typography, the most common ligatures are "fi" and "fl", which are often fused into single characters to provide a more seamless reading experience.

Glyph substitution is a mechanism that replaces one glyph or a set of glyphs with one or more alternative glyphs. This is a crucial aspect of text shaping, especially for complex scripts where the representation of a character can significantly vary based on its surrounding characters. For example, in Arabic script, a letter can have different forms depending on whether it's at the beginning, middle, or end of a word.

Another common use of glyph substitution is to replace a sequence of characters by a symbol that better represent the meaning of those characters on a specialized context (mathematical, programming, etc.).

Text shaping is disabled by default to keep backwards compatibility, reduce resource requirements and not make uharfbuzz a hard dependency.

If you want to use text shaping, the first step is installing the uharfbuzz package via pip.

‚ö†Ô∏è Text shaping is not available for type 1 fonts.

The method set_text_shaping() is used to control text shaping on a document. The only mandatory argument, use_shaping_engine can be set to True to enable the shaping mechanism or False to disable it.

On most languages, Harfbuzz enables all features by default. If you want to enable or disable a specific feature you can pass a dictionary containing the 4 digit OpenType feature code as key and a boolean value to indicate if it should be enabled or disable.

Example: pdf.set_text_shaping(use_shaping_engine=True, features={"kern": False, "liga": False})

The full list of OpenType feature codes can be found here

To perform the text shaping, harfbuzz needs to know some information like the language and the direction (right-to-left, left-to-right, etc) in order to apply the correct rules. Those information can be guessed based on the text being shaped, but you can also set the information to make sure the correct rules will be applied.

Examples: pdf.set_text_shaping(use_shaping_engine=True, direction="rtl", script="arab", language="ara") pdf.set_text_shaping(use_shaping_engine=True, direction="ltr", script="latn", language="eng")

Direction can be ltr (left to right) or rtl (right to left). The ttb (top to bottom) and btt (bottom to top) directions are not supported by fpdf2 for now.

Valid OpenType script tags

Valid OpenType language codes

Bidirectional text refers to text containing both left-to-right (LTR) and right-to-left (RTL) language scripts. Languages such as Arabic, Hebrew, and Persian are written from right to left, whereas languages like English, Spanish, and French are written from left to right. The Unicode Bidirectional Algorithm is a set of rules defined by the Unicode Consortium to properly display mixed-directional text. This algorithm ensures that characters are shown in their correct order, preserving the logical sequence of the text.

The Unicode Bidirectional Algorithm, often abbreviated as the Bidi Algorithm, is essential for displaying text containing both RTL and LTR scripts. It determines the directionality of characters and arranges them in a visually correct order. This algorithm takes into account the inherent directionality of characters (such as those in Arabic or Hebrew being inherently RTL) and the surrounding context to decide how text should be displayed.

fpdf2 will automatically apply the unicode bidirectional algorithm if text shaping is enabled.

If no direction parameter is provided - or direction is None - paragraph direction will be set according to the first directional character present on the text.

If there is a need to explicitly set the direction of a paragraph, regardless of the content, you can force the paragraph direction to either RTL or LTR.

**Examples:**

Example 1 (unknown):
```unknown
pip install uharfbuzz
```

Example 2 (python):
```python
from fpdf import FPDF

pdf = FPDF()
pdf.add_page()
pdf.add_font(family="ViaodaLibre", fname=HERE / "ViaodaLibre-Regular.ttf")
pdf.set_font("ViaodaLibre", size=40)
pdf.set_text_shaping(True)
pdf.cell(text="final soft stuff")
pdf.output("Example.pdf")
```

Example 3 (json):
```json
pdf.set_text_shaping(use_shaping_engine=True, features={"kern": False, "liga": False})
```

Example 4 (unknown):
```unknown
pdf.set_text_shaping(use_shaping_engine=True, direction="rtl", script="arab", language="ara")
```

---

## Rendering spreadsheets as PDF tables¬∂

**URL:** https://py-pdf.github.io/fpdf2/RenderingSpreadsheetsAsPDFTables.html

**Contents:**
- Rendering spreadsheets as PDF tables¬∂
- From a .csv spreadsheet¬∂
- From a .xlsx spreadsheet¬∂
- From an .ods spreadsheet¬∂
- From pandas DataFrame¬∂

All the details on tables and options to style them are detailed on the dedicated page: Tables.

Example input file: color_srgb.csv #!/usr/bin/env python3 # USAGE: ./csv2table.py color_srgb.csv import csv, sys from fpdf import FPDF, FontFace from fpdf.drawing_primitives import color_from_hex_string pdf = FPDF() pdf.add_page() pdf.set_font("Times", size=22) with pdf.table() as table: with open(sys.argv[1], encoding="utf-8") as csv_file: reader = csv.reader(csv_file, delimiter=",") for i, row in enumerate(reader): style = None if i > 0: # We color the row based on the hexadecimal code in the 2nd column: style = FontFace(fill_color=color_from_hex_string(row[1])) table.row(row, style=style) pdf.output("from-csv.pdf")

Example input file: color_srgb.xlsx #!/usr/bin/env python3 # Script Dependencies: # openxlsx # USAGE: ./xlsx2table.py color_srgb.xlsx import sys from fpdf import FPDF, FontFace from fpdf.drawing_primitives import color_from_hex_string from openpyxl import load_workbook pdf = FPDF() pdf.add_page() pdf.set_font("Times", size=22) wb = load_workbook(sys.argv[1]) ws = wb.active with pdf.table() as table: for i, row in enumerate(ws.rows): style = None if i > 0: # We color the row based on the hexadecimal code in the 2nd column: style = FontFace(fill_color=color_from_hex_string(row[1])) table.row([cell.value for cell in row], style=style) pdf.output("from-xlsx.pdf")

Example input file: color_srgb.ods #!/usr/bin/env python3 # Script Dependencies: # odfpy # USAGE: ./ods2table.py color_srgb.ods import sys from fpdf import FPDF, FontFace from fpdf.drawing_primitives import color_from_hex_string from odf.opendocument import load from odf.table import Table, TableCell, TableRow pdf = FPDF() pdf.add_page() pdf.set_font("Times", size=22) ods = load(sys.argv[1]) for sheet in ods.getElementsByType(Table): with pdf.table() as table: for i, row in enumerate(sheet.getElementsByType(TableRow)): row = [str(cell) for cell in row.getElementsByType(TableCell)] style = None if i > 0: # We color the row based on the hexadecimal code in the 2nd column: style = FontFace(fill_color=color_from_hex_string(row[1])) table.row(row, style=style) pdf.output("from-ods.pdf")

cf. Maths documentation page

**Examples:**

Example 1 (typescript):
```typescript
#!/usr/bin/env python3
# USAGE: ./csv2table.py color_srgb.csv
import csv, sys
from fpdf import FPDF, FontFace
from fpdf.drawing_primitives import color_from_hex_string

pdf = FPDF()
pdf.add_page()
pdf.set_font("Times", size=22)
with pdf.table() as table:
    with open(sys.argv[1], encoding="utf-8") as csv_file:
        reader = csv.reader(csv_file, delimiter=",")
        for i, row in enumerate(reader):
            style = None
            if i > 0:
                # We color the row based on the hexadecimal code in the 2nd column:
                style = FontFace(fill_color=color_from_hex_string(row[1]))
            table.row(row, style=style)
pdf.output("from-csv.pdf")
```

Example 2 (typescript):
```typescript
#!/usr/bin/env python3
# Script Dependencies:
#    openxlsx
# USAGE: ./xlsx2table.py color_srgb.xlsx
import sys
from fpdf import FPDF, FontFace
from fpdf.drawing_primitives import color_from_hex_string
from openpyxl import load_workbook

pdf = FPDF()
pdf.add_page()
pdf.set_font("Times", size=22)
wb = load_workbook(sys.argv[1])
ws = wb.active
with pdf.table() as table:
    for i, row in enumerate(ws.rows):
        style = None
        if i > 0:
            # We color the row based on the hexadecimal code in the 2nd column:
            style = FontFace(fill_color=color_from_hex_string(row[1]))
        table.row([cell.value for cell in row], style=style)
pdf.output("from-xlsx.pdf")
```

Example 3 (typescript):
```typescript
#!/usr/bin/env python3
# Script Dependencies:
#    odfpy
# USAGE: ./ods2table.py color_srgb.ods
import sys
from fpdf import FPDF, FontFace
from fpdf.drawing_primitives import color_from_hex_string
from odf.opendocument import load
from odf.table import Table, TableCell, TableRow

pdf = FPDF()
pdf.add_page()
pdf.set_font("Times", size=22)
ods = load(sys.argv[1])
for sheet in ods.getElementsByType(Table):
    with pdf.table() as table:
        for i, row in enumerate(sheet.getElementsByType(TableRow)):
            row = [str(cell) for cell in row.getElementsByType(TableCell)]
            style = None
            if i > 0:
                # We color the row based on the hexadecimal code in the 2nd column:
                style = FontFace(fill_color=color_from_hex_string(row[1]))
            table.row(row, style=style)
pdf.output("from-ods.pdf")
```

---

## „ÉÅ„É•„Éº„Éà„É™„Ç¢„É´¬∂

**URL:** https://py-pdf.github.io/fpdf2/Tutorial-ja.html

**Contents:**
- „ÉÅ„É•„Éº„Éà„É™„Ç¢„É´¬∂
- Tuto 1 - Á∞°Âçò„Å™‰ΩøÁî®‰æã¬∂
- Tuto 2 - „Éò„ÉÉ„ÉÄ„Éº„ÄÅ„Éï„ÉÉ„Çø„Éº„Å®Êîπ„Éö„Éº„Ç∏„ÄÅÁîªÂÉè¬∂
- Tuto 3 - ÊîπË°å„Å®Ëâ≤¬∂
- Tuto 4 - ÊÆµÁµÑ„Åø¬∂
- Tuto 5 - Ë°®„ÅÆ‰ΩúÊàê¬∂
- Tuto 6 - „É™„É≥„ÇØ„ÅÆ‰ΩúÊàê„Å®„ÄÅ„ÉÜ„Ç≠„Çπ„Éà„Çπ„Çø„Ç§„É´„ÅÆÁµÑ„ÅøÂêà„Çè„Åõ¬∂

Methods full documentation: fpdf.FPDF API doc

„É©„Ç§„Éñ„É©„É™„Çí„Ç§„É≥„Éù„Éº„Éà„Åó„ÅüÂæå„ÄÅFPDF „Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Çí‰ΩúÊàê„Åó„Åæ„Åô„ÄÇ ‰∏ä„ÅÆ‰æã„Åß„ÅØ„ÄÅFPDF „Ç≥„É≥„Çπ„Éà„É©„ÇØ„Çø„ÅØ„Éá„Éï„Ç©„É´„ÉàÂÄ§„ÇíÂà©Áî®„Åó„Åæ„Åô(A4„Çµ„Ç§„Ç∫Á∏¶Âêë„Åç„ÅÆ„Éö„Éº„Ç∏„Å®„Éü„É™„É°„Éº„Çø„ÉºÂçò‰Ωç)„ÄÇ Ê¨°„ÅÆ„Çà„ÅÜ„Å´„Åó„Å¶„ÄÅÊòéÁ§∫ÁöÑ„Å´ÊåáÂÆö„Åô„Çã„Åì„Å®„ÇÇÂèØËÉΩ„Åß„Åô„ÄÇ

PDF„ÇíÊ®™Âêë„Åç(L)„Å´Ë®≠ÂÆö„Åó„Åü„Çä„ÄÅ‰ªñ„ÅÆ„Éö„Éº„Ç∏„Çµ„Ç§„Ç∫(Letter, Legal „Å™„Å©)„ÇÑ Âçò‰Ωç(pt, cm, in)„ÇíË®≠ÂÆö„Åô„Çã„Åì„Å®„ÇÇÂèØËÉΩ„Åß„Åô„ÄÇ

ÔºàË®≥Ê≥®Ôºâ Á∏¶Âêë„ÅçÔºàportraitÔºâ„ÄÅÊ®™Âêë„ÅçÔºàlandscapeÔºâ„ÅÆÈ†≠ÊñáÂ≠ó„ÅßÂêë„Åç„ÇíÊåáÂÆö„Åó„Åæ„Åô„ÄÇ

„Åì„ÅÆÊôÇÁÇπ„Åß„ÅØPDF„Éï„Ç°„Ç§„É´„Å´„Éö„Éº„Ç∏„ÅåÂ≠òÂú®„Åó„Å™„ÅÑ„Åü„ÇÅ„ÄÅadd_page„Åß„Éö„Éº„Ç∏„ÇíËøΩÂä†„Åó„Åæ„Åô„ÄÇ ÂéüÁÇπ„ÅØÂ∑¶‰∏äÈöÖ„Åß„ÄÅÁèæÂú®„ÅÆ‰ΩçÁΩÆ„ÅØ„Éá„Éï„Ç©„É´„Éà„Åß„Éö„Éº„Ç∏Á´Ø„Åã„Çâ1cm„ÅÆÂ†¥ÊâÄ„Å´„Å™„Çä„Åæ„Åô„ÄÇ ‰ΩôÁôΩ„ÅØset_margins „ÅßÂ§âÊõ¥ÂèØËÉΩ„Åß„Åô„ÄÇ

„ÉÜ„Ç≠„Çπ„Éà„ÇíË°®Á§∫„Åô„ÇãÂâç„Å´„ÄÅset_font „Åß „Éï„Ç©„É≥„Éà„ÇíÈÅ∏Êäû„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ‰ªäÂõû„ÅØHelvetica bold 16 „ÇíÈÅ∏Êäû„Åó„Åæ„Åô„ÄÇ

I„ÅßÊñú‰Ωì„ÄÅU„Åß‰∏ãÁ∑ö„ÄÅÁ©∫ÊñáÂ≠óÂàó„ÅßÈÄöÂ∏∏„ÅÆ„Éï„Ç©„É≥„ÉàÔºà„Åæ„Åü„ÅØ‰ªªÊÑè„ÅÆÁµÑ„ÅøÂêà„Çè„ÅõÔºâ„ÇíÊåáÂÆö„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ „Éï„Ç©„É≥„Éà„Çµ„Ç§„Ç∫„ÅØ„Éü„É™„É°„Éº„Éà„É´Ôºà„Åæ„Åü„ÅØ‰ªñ„ÅÆ„É¶„Éº„Ç∂„ÉºÂçò‰ΩçÔºâ„Åß„ÅØ„Å™„Åè„Éù„Ç§„É≥„Éà„ÅßÊåáÂÆö„Åô„Çã„Åì„Å®„Å´Ê≥®ÊÑè„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ‰ªñ„ÅÆÂÜÖËîµ„Éï„Ç©„É≥„Éà„ÅØTimes„ÄÅCourier„ÄÅSymbol„ÄÅZapfDingbats„Åß„Åô„ÄÇ

„Åì„Çå„Åß„Çª„É´„Çí cell „ÅßË°®Á§∫„Åß„Åç„Çã„Çà„ÅÜ„Å´„Å™„Çä„Åæ„Åó„Åü„ÄÇ „Çª„É´„Å®„ÅØ„ÄÅ„ÉÜ„Ç≠„Çπ„Éà„ÇíÂê´„ÇÄÈï∑ÊñπÂΩ¢„ÅÆÈ†òÂüü„Åß„ÄÅÁèæÂú®„ÅÆ‰ΩçÁΩÆ„Å´ÊèèÁîª„Åï„Çå„Åæ„Åô„ÄÇ ÂØ∏Ê≥ï„ÄÅ„ÉÜ„Ç≠„Çπ„ÉàÔºàÈÖçÁΩÆÔºâ„ÄÅ„Éú„Éº„ÉÄ„Éº„ÅÆÊúâÁÑ°„ÄÅ„Åù„Åó„Å¶ÁèæÂú®„ÅÆ‰ΩçÁΩÆ„ÅåÊ¨°„Å´ÁßªÂãï„Åô„ÇãÂÖàÔºàÂè≥„ÄÅ‰∏ã„ÄÅÊ¨°„ÅÆË°åÈ†≠Ôºâ„ÇíÊåáÂÆö„Åó„Åæ„Åô„ÄÇ „Éú„Éº„ÉÄ„Éº‰ªò„Åç„ÅßÊèèÁîª„Åô„Çã„Å´„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å´„Åó„Åæ„Åô„ÄÇ

„Åù„ÅÆÈö£„Å´Êñ∞„Åó„ÅÑ„Çª„É´„Çí‰∏≠Â§ÆÊèÉ„Åà„ÅÆ„ÉÜ„Ç≠„Çπ„Éà„ÅßËøΩÂä†„Åó„ÄÅÊ¨°„ÅÆË°å„Å´ÈÄ≤„ÇÄ„Å´„ÅØ„ÄÅÊ¨°„ÅÆ„Çà„ÅÜ„Å´„Åó„Åæ„Åô„ÄÇ

ÂÇôËÄÉ: ÊîπË°å„ÅØ ln „Åß„ÇÇÂèØËÉΩ„Åß„Åô„ÄÇln „É°„ÇΩ„ÉÉ„Éâ„ÅØ„ÄÅÊîπË°åÊôÇ„ÅÆÈ´ò„Åï„ÇíÊåáÂÆö„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ

ÊúÄÂæå„Å´„ÄÅoutput „Åß„ÄÅÊåáÂÆö„Åó„ÅüÂ†¥ÊâÄ„Å´PDF„Çí‰øùÂ≠ò„Åó„Åæ„Åô„ÄÇÂºïÊï∞„Å™„Åó„ÅÆ output()„ÅØ PDF„ÅÆ bytearray„ÇíËøî„Åó„Åæ„Åô„ÄÇ

„Éò„ÉÉ„ÉÄ„Éº„ÄÅ„Éï„ÉÉ„Çø„Éº„ÄÅ„É≠„Ç¥„ÅÆ„ÅÇ„Çã2„Éö„Éº„Ç∏„ÅÆPDF„ÇíÁîüÊàê„Åô„Çã„Çµ„É≥„Éó„É´„Åß„Åô„ÄÇ

„Åì„ÅÆ‰æã„Åß„ÅØ„ÄÅheader „Å® footer„É°„ÇΩ„ÉÉ„Éâ„Çí‰ΩøÁî®„Åó„Å¶„ÄÅ„Éö„Éº„Ç∏„ÅÆ„Éò„ÉÉ„ÉÄ„Éº„Å®„Éï„ÉÉ„Çø„Éº„ÇíÂá¶ÁêÜ„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ „Åì„Çå„Çâ„ÅÆ„É°„ÇΩ„ÉÉ„Éâ„ÅØËá™ÂãïÁöÑ„Å´Âëº„Å≥Âá∫„Åï„Çå„Åæ„Åô„ÄÇ FPDF„ÇØ„É©„Çπ„ÅØ„Åì„Çå„Çâ„ÅÆ„É°„ÇΩ„ÉÉ„Éâ„ÇíÊåÅ„Å£„Å¶„ÅÑ„Åæ„Åô„Åå„ÄÅ‰Ωï„ÇÇ„Åó„Åæ„Åõ„Çì„ÄÇ „Åù„ÅÆ„Åü„ÇÅ„ÄÅ„ÇØ„É©„Çπ„ÇíÁ∂ôÊâø„Åó„Å¶„É°„ÇΩ„ÉÉ„Éâ„Çí„Ç™„Éº„Éê„Éº„É©„Ç§„Éâ„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ

„É≠„Ç¥„ÅØ„ÄÅÂ∑¶‰∏äÈöÖ„ÅÆ‰ΩçÁΩÆ„Å®ÂπÖ„ÇíÊåáÂÆö„Åó„Å¶„ÄÅimage„É°„ÇΩ„ÉÉ„Éâ„Å´„Çà„Å£„Å¶Ë°®Á§∫„Åï„Çå„Åæ„Åô„ÄÇ È´ò„Åï„ÅØÁîªÂÉè„ÅÆÁ∏¶Ê®™ÊØî„Åã„ÇâËá™ÂãïÁöÑ„Å´Ë®àÁÆó„Åï„Çå„Åæ„Åô„ÄÇ

„Éö„Éº„Ç∏Áï™Âè∑„ÇíË°®Á§∫„Åô„Çã„Å´„ÅØ„ÄÅ„Çª„É´„ÅÆÂπÖ„Å´null value„ÇíÊ∏°„Åó„Åæ„Åô„ÄÇ „Åì„Çå„Å´„Çà„Å£„Å¶„ÄÅ„Çª„É´„Åå„Éö„Éº„Ç∏„ÅÆÂè≥„ÅÆ‰ΩôÁôΩ„Åæ„ÅßÂ∫É„Åå„Çä„Åæ„Åô„ÄÇ„Åì„Çå„ÅØ„ÉÜ„Ç≠„Çπ„Éà„Çí‰∏≠Â§ÆÂØÑ„Åõ„Åô„ÇãÂ†¥Âêà„Å´‰æøÂà©„Åß„Åô„ÄÇ ÁèæÂú®„ÅÆ„Éö„Éº„Ç∏Áï™Âè∑„ÅØ page_no „É°„ÇΩ„ÉÉ„Éâ„ÅßÂèñÂæó„Åß„Åç„Åæ„Åô„ÄÇ Á∑è„Éö„Éº„Ç∏Êï∞„ÅØ„Éâ„Ç≠„É•„É°„É≥„ÉàÁµÇ‰∫ÜÊôÇ„Å´ÁΩÆÊèõ„Åï„Çå„ÇãÁâπÊÆä„Å™ÂÄ§ {nb} „Å´„Çà„Å£„Å¶ÂèñÂæó„Åß„Åç„Åæ„ÅôÔºà„Åì„ÅÆÁâπÊÆä„Å™ÂÄ§„ÅØalias_nb_pages() „Å´„Çà„Å£„Å¶Â§âÊõ¥„Åß„Åç„Åæ„ÅôÔºâ„ÄÇ set_y „É°„ÇΩ„ÉÉ„Éâ„Çí‰Ωø„ÅÜ„Åì„Å®„Åß„ÄÅ„Éö„Éº„Ç∏„ÅÆ‰∏äÈÉ®„ÇÇ„Åó„Åè„ÅØ‰∏ãÈÉ®„Åã„Çâ„ÅÆÁµ∂ÂØæ‰ΩçÁΩÆ„ÇíÊåáÂÆö„Åß„Åç„Åæ„Åô„ÄÇ

„Åì„Åì„Åß‰ΩøÁî®„Åï„Çå„Å¶„ÅÑ„Çã„ÇÇ„ÅÜ‰∏Ä„Å§„ÅÆËààÂë≥Ê∑±„ÅÑÊ©üËÉΩ„ÅØ„ÄÅËá™ÂãïÊîπ„Éö„Éº„Ç∏Ê©üËÉΩ„Åß„Åô„ÄÇ „Çª„É´„Åå„Éö„Éº„Ç∏„ÅÆÈôêÁïåÔºà„Éá„Éï„Ç©„É´„Éà„Åß„ÅØ‰∏ã„Åã„Çâ2cmÔºâ„ÇíË∂Ö„Åà„Çã„Å®ÊîπË°å„Åï„Çå„ÄÅ„Éï„Ç©„É≥„Éà„ÅåÂÖÉ„Å´Êàª„Çä„Åæ„Åô„ÄÇ „Éò„ÉÉ„ÉÄ„Éº„Å®„Éï„ÉÉ„Çø„Éº„ÅØÁã¨Ëá™„ÅÆ„Éï„Ç©„É≥„ÉàÔºàhelveticaÔºâ„Çí‰ΩøÁî®„Åó„Åæ„Åô„Åå„ÄÅÊú¨Êñá„ÅØTimes „Çí‰ΩøÁî®„ÅóÁ∂ö„Åë„Åæ„Åô„ÄÇ „Åì„ÅÆËá™ÂãïÂæ©Â∏∞„ÅÆ‰ªïÁµÑ„Åø„ÅØ„ÄÅËâ≤„Å®Ë°åÂπÖ„Å´„ÇÇÈÅ©Áî®„Åï„Çå„Åæ„Åô„ÄÇ „Åì„ÅÆÊîπ„Éö„Éº„Ç∏„ÅÆ„Éà„É™„Ç¨„Éº„Å®„Å™„Çã„Éö„Éº„Ç∏„ÅÆÈôêÁïå„ÅØ set_auto_page_break „ÅßË®≠ÂÆö„Åß„Åç„Åæ„Åô„ÄÇ

Á∂ö„ÅÑ„Å¶„ÄÅË§áÊï∞„ÅÆÊÆµËêΩ„ÇíÊñáÂ≠óÊèÉ„Åà„Åó„Å¶Ë°®Á§∫„Åô„Çã‰æã„ÇíË¶ã„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇÂêåÊôÇ„Å´„ÄÅËâ≤„ÅÆ‰Ωø„ÅÑÊñπ„Å´„Å§„ÅÑ„Å¶„ÇÇÂ≠¶„Å≥„Åæ„Åô„ÄÇ

PDF‰∏≠„ÅÆÊú¨ÊñáÔºàJules Verne textÔºâ

get_string_width „É°„ÇΩ„ÉÉ„Éâ„ÅØÁèæÂú®„ÅÆ„Éï„Ç©„É≥„Éà„Åß„ÅÆÊñáÂ≠óÂàó„ÅÆÂπÖ„ÇíÊ±Ç„ÇÅ„Çã„Åì„Å®„Åå„Åß„Åç„ÄÅ„Åì„Åì„Åß„ÅØ„Çø„Ç§„Éà„É´„ÇíÂõ≤„ÇÄÊû†„ÅÆ‰ΩçÁΩÆ„Å®ÂπÖ„ÇíË®àÁÆó„Åô„Çã„Åü„ÇÅ„Å´‰Ωø„Çè„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ Ê¨°„Å´„ÄÅËâ≤„ÇíÊåáÂÆö„ÅóÔºàset_draw_color„ÄÅ set_fill_color„ÄÅ set_text_color „ÇíÂà©Áî®Ôºâ„ÄÅ Á∑ö„ÅÆÂ§™„Åï„Çíset_line_width„Åß1mm„Å´Ë®≠ÂÆö„Åó„Åæ„ÅôÔºà„Éá„Éï„Ç©„É´„Éà„Åß„ÅØ0.2Ôºâ„ÄÇ ÊúÄÂæå„Å´„ÄÅ„Çª„É´„ÇíÂá∫Âäõ„Åó„Åæ„ÅôÔºàÊúÄÂæå„ÅÆ„Éë„É©„É°„Éº„Çø„Çítrue„Å´„Åó„Å¶„ÄÅËÉåÊôØ„ÅÆÂ°ó„Çä„Å§„Å∂„Åó„ÇíÊúâÂäπ„Å´„Åó„Åæ„Åô„ÄÇÔºâ„ÄÇ

ÊÆµËêΩ„ÇíË°®Á§∫„Åô„Çã„Åü„ÇÅ„Å´„ÅØ multi_cell „É°„ÇΩ„ÉÉ„Éâ„ÇíÂà©Áî®„Åó„Åæ„Åô„ÄÇ „ÉÜ„Ç≠„Çπ„Éà„ÅØ„Éá„Éï„Ç©„É´„Éà„Åß‰∏°Á´ØÊèÉ„Åà„Åï„Çå„Åæ„Åô„ÄÇ Ë°å„Åå„Çª„É´„ÅÆÂè≥Á´Ø„Å´Â±ä„Åè„Åã„ÄÅÊîπË°åÊñáÂ≠óÔºà\nÔºâ„ÅÆ„Åü„Å≥„Å´ÊîπË°å„Åï„Çå„ÄÅÁèæÂú®„ÅÆ„Çª„É´„ÅÆ‰∏ã„Å´Êñ∞„Åó„ÅÑ„Çª„É´„ÅåËá™ÂãïÁöÑ„Å´‰ΩúÊàê„Åï„Çå„Åæ„Åô„ÄÇ Ëá™ÂãïÊîπË°å„ÅØ„ÄÅÂè≥Á´Ø„Å´ÊúÄ„ÇÇËøë„ÅÑ„Çπ„Éö„Éº„Çπ„Åã„ÇΩ„Éï„Éà„Éè„Ç§„Éï„É≥Ôºà\u00adÔºâ„ÅÆ‰ΩçÁΩÆ„ÅßË°å„Çè„Çå„Åæ„Åô„ÄÇ „ÇΩ„Éï„Éà„Éè„Ç§„Éï„É≥„ÅØÊîπË°å„Çí„Éà„É™„Ç¨„Éº„Åô„ÇãÂ†¥Âêà„ÅØÈÄöÂ∏∏„ÅÆ„Éè„Ç§„Éï„É≥„Å´ÁΩÆ„ÅçÊèõ„Åà„Çâ„Çå„ÄÅ„Åù„ÅÜ„Åß„Å™„ÅÑÂ†¥Âêà„ÅØÁÑ°Ë¶ñ„Åï„Çå„Åæ„Åô„ÄÇ

„Åì„ÅÆÊñáÊõ∏„Å´„ÅØ„ÄÅ„Çø„Ç§„Éà„É´Ôºàset_titleÔºâ„Å®ËëóËÄÖÔºàset_authorÔºâ„ÅÆ2„Å§„ÅÆÊñáÊõ∏„Éó„É≠„Éë„ÉÜ„Ç£„Åå„Çª„ÉÉ„Éà„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ „Éó„É≠„Éë„ÉÜ„Ç£„ÅØ2„Å§„ÅÆÊñπÊ≥ï„ÅßË¶ã„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ 1„Å§ÁõÆ„ÅØ„ÄÅAcrobat Reader„ÅßÁõ¥Êé•ÊñáÊõ∏„ÇíÈñã„Åç„ÄÅ„Äå„Éï„Ç°„Ç§„É´„Äç„É°„Éã„É•„Éº„Åã„Çâ„Äå„Éó„É≠„Éë„ÉÜ„Ç£„Äç„Ç™„Éó„Ç∑„Éß„É≥„ÇíÈÅ∏Êäû„Åô„ÇãÊñπÊ≥ï„Åß„Åô„ÄÇ „ÇÇ„ÅÜ1„Å§„ÅØ„ÄÅ„Éó„É©„Ç∞„Ç§„É≥„Åã„Çâ„ÇÇÂà©Áî®„Åß„Åç„Åæ„Åô„Åå„ÄÅÂè≥„ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶„Äå„Éâ„Ç≠„É•„É°„É≥„Éà„ÅÆ„Éó„É≠„Éë„ÉÜ„Ç£„Äç„ÇíÈÅ∏Êäû„Åô„ÇãÊñπÊ≥ï„Åß„Åô„ÄÇ

„Åì„ÅÆ‰æã„Åß„ÅØ„ÄÅÂâç„ÅÆ‰æã„ÅÆÊ¥æÁîüÁâà„Å®„Åó„Å¶„ÄÅË§áÊï∞Âàó„Å´Ê∏°„Å£„Å¶„ÉÜ„Ç≠„Çπ„Éà„ÇíÈÖçÁΩÆ„Åô„ÇãÔºàÊÆµÁµÑ„ÅøÔºâÊñπÊ≥ï„ÇíÁ¥π‰ªã„Åó„Åæ„Åô„ÄÇ

PDF‰∏≠„ÅÆÊú¨ÊñáÔºàJules Verne textÔºâ

‚ö†Ô∏è This section has changed a lot and requires a new translation: https://github.com/py-pdf/fpdf2/issues/267

„Åì„ÅÆ„ÉÅ„É•„Éº„Éà„É™„Ç¢„É´„Åß„ÅØ„ÄÅÁ∞°Âçò„Å™Ë™øÊï¥„Åß‰Ωï„Åå„Åß„Åç„Çã„ÅÆ„Åã„ÇíÁ§∫„Åô„Åü„ÇÅ„Å´„ÄÅ 2Á®ÆÈ°û„ÅÆ„ÉÜ„Éº„Éñ„É´„ÅÆ‰ΩúÊàêÊñπÊ≥ï„Å´„Å§„ÅÑ„Å¶Ëß£Ë™¨„Åó„Åæ„Åô„ÄÇ

1„Å§ÁõÆ„ÅÆ‰æã„ÅØÊúÄ„ÇÇÂü∫Êú¨ÁöÑ„Å™ÊñπÊ≥ï„Åß„ÄÅFPDF.table() „Å´„Éá„Éº„Çø„Çí‰∏é„Åà„Å¶„ÅÑ„Åæ„Åô„ÄÇ ÁµêÊûú„ÅØÂçòÁ¥î„Å™„ÇÇ„ÅÆ„Åß„Åô„Åå„ÄÅÈùûÂ∏∏„Å´Áü≠ÊôÇÈñì„Åß‰ΩúÊàê„Åß„Åç„Åæ„Åô„ÄÇ

2„Å§ÁõÆ„ÅÆ‰æã„Åß„ÅØ„ÅÑ„Åè„Å§„Åã„ÅÆÊîπÂñÑ„ÇíÂä†„Åà„Å¶„ÅÑ„Åæ„Åô„ÄÇËâ≤„ÄÅ„ÉÜ„Éº„Éñ„É´„ÅÆÂπÖ„ÅÆÂà∂Èôê„ÄÅË°å„ÅÆÈ´ò„Åï„ÅÆÁ∏ÆÂ∞è„ÄÅ‰∏≠Â§ÆÂØÑ„Åõ„Åï„Çå„Åü„Çø„Ç§„Éà„É´„ÄÅÂàóÂπÖ„ÅÆÊåáÂÆö„ÄÅÂè≥ÂØÑ„Åõ„ÅÆÊï∞ÂÄ§„Å™„Å©„Å´Âä†„Åà„ÄÅË°å„ÇíÂå∫Âàá„ÇãÊ®™Á∑ö„ÇíÂâäÈô§„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ „Åì„Çå„ÅØ„ÄÅTableBordersLayout „ÅÆ borders_layout „ÇíÊåáÂÆö„Åô„Çã„Åì„Å®„ÅßË°å„ÅÜ„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ

„Åì„ÅÆ„ÉÅ„É•„Éº„Éà„É™„Ç¢„É´„Åß„ÅØ„ÄÅPDFÊñáÊõ∏ÂÜÖ„Å´„É™„É≥„ÇØ„ÇíÂüã„ÇÅËæº„ÇÄ„ÅÑ„Åè„Å§„Åã„ÅÆÊñπÊ≥ï„ÇíÁ¥π‰ªã„Åó„Åæ„Åô„ÄÇ ÂêåÊßò„ÅÆÊñπÊ≥ï„Åß„ÄÅÂ§ñÈÉ®„É™„É≥„ÇØ„ÇÇ‰ΩúÊàêÂèØËÉΩ„Åß„Åô„ÄÇ

„Åæ„Åü„ÄÅ1„Å§„ÅÆ„ÉÜ„Ç≠„Çπ„ÉàÂÜÖ„ÅßË§áÊï∞„ÅÆ„Çπ„Çø„Ç§„É™„É≥„Ç∞ÔºàÂ§™Â≠ó„ÄÅÊñú‰Ωì„ÄÅ‰∏ãÁ∑öÔºâ„Çí‰ΩøÁî®„Åô„ÇãÊñπÊ≥ï„Å´„Å§„ÅÑ„Å¶„ÇÇËß£Ë™¨„Åó„Åæ„Åô„ÄÇ

ÁîüÊàê„Åï„Çå„ÇãPDF - fpdf2-logo

„Åì„Åì„Åß„ÅØ„ÉÜ„Ç≠„Çπ„Éà„ÇíË°®Á§∫„Åô„Çã„Åü„ÇÅ„ÅÆÊñ∞„Åó„ÅÑÊñπÊ≥ï„Å®„Åó„Å¶„ÄÅ write() „Çí‰Ωø„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ „Åì„ÅÆ„É°„ÇΩ„ÉÉ„Éâ„ÅØ multi_cell() „Å®ÈùûÂ∏∏„Å´„Çà„Åè‰ºº„Å¶„Åä„Çä„ÄÅÈáçË¶Å„Å™ÈÅï„ÅÑ„Å®„Åó„Å¶„ÅØÊ¨°„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ

„Åó„Åü„Åå„Å£„Å¶„ÄÅ„Åì„ÅÆ„É°„ÇΩ„ÉÉ„Éâ„ÇíÁî®„ÅÑ„Å¶„ÉÜ„Ç≠„Çπ„Éà„ÅÆ„Åæ„Å®„Åæ„Çä„ÇíÊõ∏„ÅçËæº„Åø„ÄÅ„Éï„Ç©„É≥„Éà„Çπ„Çø„Ç§„É´„ÇíÂ§âÊõ¥„Åó„ÄÅ „Åï„Çâ„Å´„Åù„ÅÆÁ∂ö„Åç„Åã„Çâ„ÉÜ„Ç≠„Çπ„Éà„ÇíÊõ∏„ÅçËæº„ÇÄ„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ ‰∏ÄÊñπ„Åß„Åì„ÅÆÊñπÊ≥ï„ÅÆÊ¨†ÁÇπ„ÅØ„ÄÅ multi_cell() „É°„ÇΩ„ÉÉ„Éâ„ÅßË°å„Å£„Åü„Çà„ÅÜ„Å™„ÉÜ„Ç≠„Çπ„Éà„ÅÆÂ≠óÊèÉ„Åà„ÅåË°å„Åà„Å™„ÅÑ„Åì„Å®„Åß„Åô„ÄÇ

„Åì„ÅÆ‰æã„ÅÆ1„Éö„Éº„Ç∏ÁõÆ„Åß„ÅØ„ÄÅwrite() „Çí„Éï„Ç©„É≥„Éà„Çπ„Çø„Ç§„É´„ÅÆÂ§âÊõ¥„Å´‰ΩøÁî®„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇÊñáÁ´†„ÅÆÂßã„ÇÅ„Å´„ÅØÈÄöÂ∏∏„ÅÆ„Çπ„Çø„Ç§„É´„ÅÆ„ÉÜ„Ç≠„Çπ„Éà„Åß„Åô„Åå„ÄÅ set_font() „É°„ÇΩ„ÉÉ„Éâ„ÇíÁî®„ÅÑ„Å¶‰∏ãÁ∑ö„ÇíËøΩÂä†„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ

2„Éö„Éº„Ç∏ÁõÆ„Å∏„ÅÆÂÜÖÈÉ®„É™„É≥„ÇØ„Çí‰ΩúÊàê„Åô„Çã„Å´„ÅØ„ÄÅ add_link() „É°„ÇΩ„ÉÉ„Éâ„Çí‰ΩøÁî®„Åó„Åæ„Åô„ÄÇ „Åì„ÅÆ„É°„ÇΩ„ÉÉ„Éâ„ÅØ„Äålink„Äç„Å®Âêç‰ªò„Åë„Çâ„Çå„Åü„ÇØ„É™„ÉÉ„ÇØÂèØËÉΩ„Å™„Ç®„É™„Ç¢„Çí‰ΩúÊàê„Åó„ÄÅ ÊñáÊõ∏ÂÜÖ„ÅÆÂà•„ÅÆ„Éö„Éº„Ç∏„Å´ÁßªÂãï„Åï„Åõ„Åæ„Åô„ÄÇ

ÁîªÂÉè„ÇíÂà©Áî®„Åó„ÅüÂ§ñÈÉ®„É™„É≥„ÇØ„Çí‰ΩúÊàê„Åô„Çã„Åü„ÇÅ„Å´„ÄÅ„Åì„Åì„Åß„ÅØ image() „É°„ÇΩ„ÉÉ„Éâ„Çí‰Ωø„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ „Åì„ÅÆ„É°„ÇΩ„ÉÉ„Éâ„ÅØÂºïÊï∞„ÅÆ1„Å§„Å®„Åó„Å¶„É™„É≥„ÇØ„ÇíÂèó„ÅëÂèñ„Çä„Åæ„Åô„ÄÇ„Åì„ÅÆ„É™„É≥„ÇØ„ÅØÂÜÖÈÉ®„É™„É≥„ÇØ„Åß„ÇÇÂ§ñÈÉ®„É™„É≥„ÇØ„Åß„ÇÇÂïèÈ°å„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ

Âà•„ÅÆÊñπÊ≥ï„Å®„Åó„Å¶„ÄÅwrite_html() „É°„ÇΩ„ÉÉ„Éâ„Çí‰ΩøÁî®„Åó„Å¶„Éï„Ç©„É≥„Éà„Çπ„Çø„Ç§„É´„ÅÆÂ§âÊõ¥„ÇÑ„É™„É≥„ÇØ„ÅÆ‰ΩúÊàê„ÇíË°å„ÅÜ„Åì„Å®„ÇÇÂá∫Êù•„Åæ„Åô„ÄÇ „Åì„ÅÆ„É°„ÇΩ„ÉÉ„Éâ„ÅØHTML„Éë„Éº„Çµ„Éº„Åß„ÅÇ„Çä„ÄÅ„ÉÜ„Ç≠„Çπ„Éà„ÅÆËøΩÂä†„ÄÅ„Éï„Ç©„É≥„Éà„Çπ„Çø„Ç§„É´„ÅÆÂ§âÊõ¥„ÄÅ„É™„É≥„ÇØ„ÅÆ‰ΩúÊàê„ÇíHTML„ÇíÁî®„ÅÑ„Å¶Ë°å„Å™„Åà„Åæ„Åô„ÄÇ

**Examples:**

Example 1 (python):
```python
from fpdf import FPDF

pdf = FPDF()
pdf.add_page()
pdf.set_font("helvetica", style="B", size=16)
pdf.cell(40, 10, "Hello World!")
pdf.output("tuto1.pdf")
```

Example 2 (unknown):
```unknown
pdf = FPDF(orientation="P", unit="mm", format="A4")
```

Example 3 (unknown):
```unknown
pdf.set_font('Helvetica', style='B', size=16)
```

Example 4 (unknown):
```unknown
pdf.cell(40, 10, 'Hello World!', 1)
```

---

## Vodiƒç¬∂

**URL:** https://py-pdf.github.io/fpdf2/Tutorial-sl.html

**Contents:**
- Vodiƒç¬∂
- Vodiƒç 1 - Minimalni primer¬∂
- Vodiƒç 2 - Glava, noga, prelom strani in slika¬∂
- Vodiƒç 3 - Prelomi vrstic in barve¬∂
- Vodiƒç 4 - Veƒçstolpƒçno besedilo¬∂
- Vodiƒç 5 - Ustvarjanje tabel¬∂
- Vodiƒç 6 - Ustvarjanje povezav in me≈°anje slogov besedila¬∂

Metode ‚Äì popolna dokumentacija: fpdf.FPDF API doc

Zaƒçnimo s klasiƒçnim primerom:

Po vkljuƒçitvi datoteke knji≈ænice ustvarimo objekt FPDF. Konstruktor FPDF se tu uporablja z privzetimi vrednostmi: strani so v pokonƒçni postavitvi A4 in merska enota je milimeter. To bi lahko eksplicitno doloƒçili z:

Mo≈æno je nastaviti PDF v le≈æeƒçi naƒçin (L) ali uporabiti druge formate strani (npr. Letter in Legal) ter merske enote (pt, cm, in).

Zaenkrat ni strani, zato jo moramo dodati z add_page. Izvor je v zgornjem levem kotu, trenutni polo≈æaj pa je privzeto nastavljen na 1 cm od robov; robove lahko spremenimo z set_margins.

Pred tiskanjem besedila je obvezno izbrati pisavo z set_font, sicer dokument ne bi bil veljaven. Izberemo Helvetica krepko 16:

Doloƒçimo lahko tudi le≈æeƒço (I), podƒçrtano (U) ali obiƒçajno pisavo (prazno niz ali katerokoli kombinacijo). Velikost pisave je izra≈æena v pikah, ne v milimetrih (ali drugi merski enoti); to je edina izjema. Druge vgrajene pisave so Times, Courier, Symbol in ZapfDingbats.

Zdaj lahko natisnemo celico z cell. Celica je pravokotno podroƒçje, morda z okvirjem, ki vsebuje nekaj besedila. Izri≈°e se na trenutnem polo≈æaju. Doloƒçimo njene dimenzije, besedilo (poravnano ali centrirano), ali naj se nari≈°ejo obrobe in kam se trenutni polo≈æaj premakne po tem (na desno, spodaj ali na zaƒçetek naslednje vrstice). Da bi dodali okvir, naredimo to:

Za dodajanje nove celice poleg nje s centriranim besedilom in premik v novo vrstico:

Opomba: prelom vrstice lahko izvedemo tudi z ln. Ta metoda omogoƒça tudi doloƒçitev vi≈°ine preloma.

Nazadnje je dokument zaprt in shranjen pod navedeno potjo datoteke z uporabo output. Brez navedenega parametra output() vrne PDF bytearray medpomnilnik.

Tukaj je primer dvostranskega dokumenta z glavo, nogo in logotipom:

Ta primer uporablja header in footer za obdelavo glav in nog dokumenta. Kliƒçeta se samodejno. V osnovnem razredu FPDF ≈æe obstajata, a vendar ne izvajata niƒçesar, zato je razred potrebno raz≈°iriti in metodi prepisati.

Logotip je natisnjen z image, kjer doloƒçimo zgornji levi kot in ≈°irino. Vi≈°ina se izraƒçuna samodejno, da ostanejo razmerja slike nespremenjena.

Za izpis ≈°tevilke strani se kot ≈°irino celice poda None. To pomeni, da se celica raztegne do desnega roba strani; to je priroƒçno za centriranje besedila. Trenutno ≈°tevilko strani vrne page_no, medtem ko skupno ≈°tevilo strani dobimo z uporabo posebne vrednosti {nb}, ki se nadomesti ob zapiranju dokumenta (to vrednost lahko spremenimo z alias_nb_pages()). Omeniti velja tudi uporabo set_y, ki omogoƒça nastavitev navpiƒçnega polo≈æaja na absolutno lokacijo strani, priƒçen≈°i na vrhu ali dnu.

Zanimiva mo≈ænost, uporabljena tukaj, je samodejno prelamljanje strani. Takoj, ko bi celica presegla dno strani (privzeto 2 centimetra od roba), se ustvari nov prelom strani in pisava se povrne na prej≈°nje stanje. ƒåeprav glava in noga uporabljata svojo pisavo (helvetica), se v telesu uporabi Times. Ta mehanizem samodejnega obnavljanja velja tudi za barve in ≈°irino ƒçrte. Mejo, ki spro≈æi prelom strani, lahko nastavimo z set_auto_page_break.

Nadaljujmo s primerom, ki natisne poravnane odstavke in ilustrira rabo barv.

get_string_width omogoƒça doloƒçitev dol≈æine niza v trenutni pisavi, kar nam pomaga izraƒçunati polo≈æaj in ≈°irino okvira, ki obdaja naslov. Nato se nastavijo barve preko set_draw_color, set_fill_color in set_text_color, pa tudi debelina ƒçrte z set_line_width na 1 mm (privzeta je 0,2 mm). Na koncu izpi≈°emo celico (zadnji parameter True nakazuje, da se okno obarva).

Metoda, uporabljena za tiskanje odstavkov, je multi_cell. Besedilo je privzeto poravnano. Vsakiƒç, ko vrstica dose≈æe desni rob celice ali se pojavi znak za prelom vrstice (\n), se vrstice prelomi in nova celica se ustvari pod trenutnim polo≈æajem. Samodejni prelom se izvr≈°i na lokaciji najbli≈æjega presledka ali mehke ƒçrtice (\u00ad) pred desnim robom. Mehka ƒçrtica se ob prelomu vrstice spremeni v obiƒçajno ƒçrtico, sicer pa se ignorira.

Dve lastnosti dokumenta sta doloƒçeni: naslov set_title in avtor set_author. Do njih se lahko dostopa na dva naƒçina: dokument se odpre neposredno v Acrobat Readerju in v meniju File izbere Document Properties ali pa se z desno tipko mi≈°ke izbere Document Properties.

Ta primer je razliƒçica prej≈°njega, prikazuje, kako razdeliti besedilo v veƒç stolpcev.

Kljuƒçna razlika od prej≈°njega vodiƒça je uporaba metode text_columns. Zbira vse besedilo, po potrebi po delih, in ga razdeli ƒçez zahtevano ≈°tevilo stolpcev, pri ƒçemer samodejno vstavi prelome strani, kjer je to potrebno. Upo≈°tevajte, da dokler je TextColumns instanca aktivna kot upravljavec konteksta, lahko spreminjate slog besedila in druge lastnosti pisave, te spremembe pa bodo veljale samo znotraj tega konteksta. Ko je enkrat zaprt, se obnovijo prej≈°nje nastavitve.

Ta vodiƒç bo razlo≈æil, kako ustvariti dve razliƒçni tabeli, da prika≈æe, kaj je mogoƒçe doseƒçi z nekaj osnovnimi prilagoditvami.

Rezultatni PDF - Countries CSV data

Prvi primer je izveden na najbolj osnovni naƒçin, saj se podatki predajo metodi FPDF.table(). Rezultat je precej preprost, vendar hitro dosegljiv.

Druga tabela prina≈°a nekaj izbolj≈°av: barve, omejeno ≈°irino tabele, zmanj≈°ano vi≈°ino vrstic, centrirane naslove, stolpce s prilagojeno ≈°irino, desno poravnane ≈°tevilke ... Poleg tega so odstranjene vodoravne ƒçrte. Dosegli smo to z izbiro borders_layout med razpolo≈æljivimi vrednostmi: TableBordersLayout.

Ta vodiƒç bo razlo≈æil veƒç naƒçinov, kako vstaviti povezave v PDF dokument, pa tudi, kako dodati povezave na zunanje vire.

Poleg tega bo pokazal veƒç naƒçinov uporabe razliƒçnih slogov besedila (krepko, le≈æeƒçe, podƒçrtano) znotraj istega besedila.

Rezultatni PDF - fpdf2-logo

Nova metoda, prikazana tukaj za izpis besedila, je write(). Zelo je podobna metodi multi_cell(), vendar sta tu dve kljuƒçni razliki:

Ta metoda nam tako omogoƒça napisati kos besedila, spremeniti slog pisave in nadaljevati natanko tam, kjer smo ostali. Njena glavna slabost pa je, da ne omogoƒça poravnavanja besedila (justify) tako kot multi_cell().

Na prvi strani primera smo za ta namen uporabili write(). Zaƒçetek stavka je bil napisan z obiƒçajnim slogom pisave, nato smo z set_font() preklopili na podƒçrtano in dokonƒçali stavek.

Za dodajanje notranje povezave, ki ka≈æe na drugo stran, smo uporabili add_link(), ki ustvari klikabilno obmoƒçje z imenom "link", ki vodi na drugo stran v dokumentu.

Za izdelavo zunanje povezave z uporabo slike smo uporabili image(). Metoda ima parameter link, ki omogoƒça nastavitev povezave (lahko je interna ali eksterna).

Kot alternativa je na voljo ≈°e en naƒçin za spreminjanje sloga pisave in vstavljanje povezav: metoda write_html(), ki je HTML razƒçlenjevalnik in omogoƒça vstavljanje besedila, spreminjanje sloga pisave in povezav preko HTML kode.

**Examples:**

Example 1 (python):
```python
from fpdf import FPDF

pdf = FPDF()
pdf.add_page()
pdf.set_font("helvetica", style="B", size=16)
pdf.cell(40, 10, "Hello World!")
pdf.output("tuto1.pdf")
```

Example 2 (unknown):
```unknown
pdf = FPDF(orientation="P", unit="mm", format="A4")
```

Example 3 (unknown):
```unknown
pdf.set_font('Helvetica', style='B', size=16)
```

Example 4 (unknown):
```unknown
pdf.cell(40, 10, 'Hello World!', 1)
```

---

## Tutorial¬∂

**URL:** https://py-pdf.github.io/fpdf2/Tutorial-hi.html

**Contents:**
- Tutorial¬∂
- Tuto 1 - ‡§Æ‡•Ç‡§≤ ‡§â‡§¶‡§æ‡§π‡§∞‡§£¬∂
- Tuto 2 - ‡§∂‡•Ä‡§∞‡•ç‡§∑‡§≤‡•á‡§ñ (Header), ‡§™‡§æ‡§¶ ‡§≤‡•á‡§ñ (Footer), ‡§™‡•É‡§∑‡•ç‡§† ‡§µ‡§ø‡§∞‡§æ‡§Æ (Page Break) ‡§î‡§∞ ‡§õ‡§µ‡§ø (Image)¬∂
- Tuto 3 - ‡§≤‡§æ‡§á‡§® ‡§¨‡•ç‡§∞‡•á‡§ï ‡§î‡§∞ ‡§∞‡§Ç‡§ó¬∂
- Tuto 4 - ‡§Æ‡§≤‡•ç‡§ü‡•Ä ‡§ï‡•â‡§≤‡§Æ¬∂
- Tuto 5 - ‡§ü‡•á‡§¨‡§≤ ‡§¨‡§®‡§æ‡§®‡§æ¬∂
- Tuto 6 - ‡§≤‡§ø‡§Ç‡§ï ‡§¨‡§®‡§æ‡§®‡§æ ‡§î‡§∞ ‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü ‡§∂‡•à‡§≤‡§ø‡§Ø‡•ã‡§Ç ‡§ï‡•ã ‡§Æ‡§ø‡§≤‡§æ‡§®‡§æ¬∂

‡§µ‡§ø‡§≠‡§ø‡§®‡•ç‡§® ‡§â‡§¶‡§æ‡§π‡§∞‡§£ ‡§ú‡§≤‡•ç‡§¶‡•Ä ‡§∏‡•á ‡§¶‡§ø‡§ñ‡§æ‡§§‡•á ‡§π‡•à‡§Ç ‡§ï‡§ø fpdf2 ‡§ï‡§æ ‡§â‡§™‡§Ø‡•ã‡§ó ‡§ï‡•à‡§∏‡•á ‡§ï‡§∞‡•á‡§Ç‡•§ ‡§Ü‡§™‡§ï‡•ã ‡§∏‡§≠‡•Ä ‡§Æ‡•Å‡§ñ‡•ç‡§Ø ‡§µ‡§ø‡§∂‡•á‡§∑‡§§‡§æ‡§ì‡§Ç ‡§ï‡•Ä ‡§µ‡•ç‡§Ø‡§æ‡§ñ‡•ç‡§Ø‡§æ ‡§Æ‡§ø‡§≤ ‡§ú‡§æ‡§è‡§ó‡•Ä‡•§

Methods full documentation / ‡§§‡§∞‡•Ä‡§ï‡•á ‡§™‡•Ç‡§∞‡•ç‡§£ ‡§™‡•ç‡§∞‡§≤‡•á‡§ñ‡§®: fpdf.FPDF API doc

‡§Ü‡§á‡§è ‡§ï‡•ç‡§≤‡§æ‡§∏‡§ø‡§ï ‡§â‡§¶‡§æ‡§π‡§∞‡§£ ‡§∏‡•á ‡§∂‡•Å‡§∞‡•Ç ‡§ï‡§∞‡•á‡§Ç:

‡§≤‡§æ‡§á‡§¨‡•ç‡§∞‡•á‡§∞‡•Ä ‡§´‡§º‡§æ‡§á‡§≤ ‡§ï‡•ã ‡§∂‡§æ‡§Æ‡§ø‡§≤ ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§¨‡§æ‡§¶, ‡§π‡§Æ ‡§è‡§ï FPDF ‡§ë‡§¨‡•ç‡§ú‡•á‡§ï‡•ç‡§ü ‡§¨‡§®‡§æ‡§§‡•á ‡§π‡•à‡§Ç‡•§ FPDF ‡§ï‡§Ç‡§∏‡•ç‡§ü‡•ç‡§∞‡§ï‡•ç‡§ü‡§∞ ‡§ï‡§æ ‡§â‡§™‡§Ø‡•ã‡§ó ‡§Ø‡§π‡§æ‡§Ç ‡§°‡§ø‡§´‡§º‡•â‡§≤‡•ç‡§ü ‡§Æ‡§æ‡§®‡•ã‡§Ç ‡§ï‡•á ‡§∏‡§æ‡§• ‡§ï‡§ø‡§Ø‡§æ ‡§ú‡§æ‡§§‡§æ ‡§π‡•à:

‡§™‡•É‡§∑‡•ç‡§† A4 ‡§™‡•ã‡§∞‡•ç‡§ü‡•ç‡§∞‡•á‡§ü ‡§Æ‡•á‡§Ç ‡§π‡•à‡§Ç ‡§î‡§∞ ‡§Æ‡§æ‡§™ ‡§á‡§ï‡§æ‡§à ‡§Æ‡§ø‡§≤‡•Ä‡§Æ‡•Ä‡§ü‡§∞ ‡§π‡•à‡•§ ‡§á‡§∏‡§ï‡•á ‡§∏‡§æ‡§• ‡§∏‡•ç‡§™‡§∑‡•ç‡§ü ‡§∞‡•Ç‡§™ ‡§∏‡•á ‡§®‡§ø‡§Æ‡•ç‡§®‡§≤‡§ø‡§ñ‡§ø‡§§ ‡§®‡§ø‡§∞‡•ç‡§¶‡§ø‡§∑‡•ç‡§ü ‡§ï‡§ø‡§Ø‡•á ‡§ú‡§æ ‡§∏‡§ï‡§§‡•á ‡§π‡•à:

‡§™‡•Ä‡§°‡•Ä‡§è‡§´ ‡§ï‡•ã ‡§≤‡•à‡§Ç‡§°‡§∏‡•ç‡§ï‡•á‡§™ ‡§Æ‡•ã‡§° ‡§Æ‡•á‡§Ç ‡§∏‡•á‡§ü ‡§ï‡§∞‡§®‡§æ ‡§∏‡§Ç‡§≠‡§µ ‡§π‡•à (L) ‡§Ø‡§æ ‡§Ö‡§®‡•ç‡§Ø ‡§™‡•á‡§ú ‡§™‡•ç‡§∞‡§æ‡§∞‡•Ç‡§™‡•ã‡§Ç ‡§ï‡§æ ‡§â‡§™‡§Ø‡•ã‡§ó ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è (‡§ú‡•à‡§∏‡•á ‡§ï‡§ø Letter ‡§§‡§•‡§æ Legal) ‡§î‡§∞ ‡§á‡§ï‡§æ‡§á‡§Ø‡•ã‡§Ç ‡§ï‡•ã ‡§Æ‡§æ‡§™‡•á‡§Ç (pt, cm, in)‡•§

‡§´‡§ø‡§≤‡§π‡§æ‡§≤ ‡§ï‡•ã‡§à ‡§™‡•á‡§ú ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à, ‡§á‡§∏‡§≤‡§ø‡§è ‡§π‡§Æ‡•á‡§Ç ‡§á‡§∏‡§Æ‡•á‡§Ç ‡§è‡§ï add_page ‡§ú‡•ã‡§°‡§º‡§®‡§æ ‡§π‡•ã‡§ó‡§æ ‡•§

‡§Æ‡•Ç‡§≤ ‡§ä‡§™‡§∞‡•Ä-‡§¨‡§æ‡§è‡§Å ‡§ï‡•ã‡§®‡•á ‡§Æ‡•á‡§Ç ‡§π‡•à ‡§î‡§∞ ‡§µ‡§∞‡•ç‡§§‡§Æ‡§æ‡§® ‡§∏‡•ç‡§•‡§ø‡§§‡§ø ‡§°‡§ø‡§´‡§º‡•â‡§≤‡•ç‡§ü ‡§∞‡•Ç‡§™ ‡§∏‡•á ‡§∏‡•Ä‡§Æ‡§æ‡§ì‡§Ç ‡§∏‡•á 1 cm ‡§™‡§∞ ‡§∞‡§ñ‡•Ä ‡§ú‡§æ‡§§‡•Ä ‡§π‡•à; ‡§Æ‡§æ‡§∞‡•ç‡§ú‡§ø‡§® ‡§ï‡•ã set_margins ‡§ï‡•á ‡§∏‡§æ‡§• ‡§¨‡§¶‡§≤‡§æ ‡§ú‡§æ ‡§∏‡§ï‡§§‡§æ ‡§π‡•à ‡•§

‡§á‡§∏‡§∏‡•á ‡§™‡§π‡§≤‡•á ‡§ï‡§ø ‡§π‡§Æ ‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü ‡§™‡•ç‡§∞‡§ø‡§Ç‡§ü ‡§ï‡§∞ ‡§∏‡§ï‡•á‡§Ç, ‡§á‡§∏‡§ï‡•á ‡§∏‡§æ‡§• ‡§è‡§ï ‡§´‡•â‡§®‡•ç‡§ü ‡§ï‡§æ ‡§ö‡§Ø‡§® set_font ‡§∏‡•á ‡§ï‡§∞‡§®‡§æ ‡§Ö‡§®‡§ø‡§µ‡§æ‡§∞‡•ç‡§Ø ‡§π‡•à, ‡§Ö‡§®‡•ç‡§Ø‡§•‡§æ ‡§¶‡§∏‡•ç‡§§‡§æ‡§µ‡•á‡§ú‡§º (Document) ‡§Ö‡§Æ‡§æ‡§®‡•ç‡§Ø ‡§π‡•ã‡§ó‡§æ‡•§ ‡§π‡§Æ Helvetica bold 16 ‡§ö‡•Å‡§®‡§§‡•á ‡§π‡•à‡§Ç:

‡§π‡§Æ I ‡§ï‡•á ‡§∏‡§æ‡§• ‡§á‡§ü‡•à‡§≤‡§ø‡§ï (Italic) ‡§®‡§ø‡§∞‡•ç‡§¶‡§ø‡§∑‡•ç‡§ü ‡§ï‡§∞ ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç, U ‡§ï‡•á ‡§∏‡§æ‡§• ‡§∞‡•á‡§ñ‡§æ‡§Ç‡§ï‡§ø‡§§ (Underlined) ‡§®‡§ø‡§∞‡•ç‡§¶‡§ø‡§∑‡•ç‡§ü ‡§ï‡§∞ ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç ‡§Ø‡§æ ‡§è‡§ï ‡§®‡§ø‡§Ø‡§Æ‡§ø‡§§ ‡§´‡§º‡•â‡§®‡•ç‡§ü ‡§è‡§ï ‡§ñ‡§æ‡§≤‡•Ä ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó ‡§ï‡•á ‡§∏‡§æ‡§• (‡§Ø‡§æ ‡§ï‡•ã‡§à ‡§∏‡§Ç‡§Ø‡•ã‡§ú‡§®) ‡§®‡§ø‡§∞‡•ç‡§¶‡§ø‡§∑‡•ç‡§ü ‡§ï‡§∞ ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç‡•§ ‡§ß‡•ç‡§Ø‡§æ‡§® ‡§¶‡•á‡§Ç ‡§ï‡§ø ‡§´‡§º‡•â‡§®‡•ç‡§ü ‡§ï‡§æ ‡§Ü‡§ï‡§æ‡§∞ ‡§Ö‡§Ç‡§ï‡•ã‡§Ç ‡§Æ‡•á‡§Ç ‡§¶‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ ‡§π‡•à, ‡§Æ‡§ø‡§≤‡•Ä‡§Æ‡•Ä‡§ü‡§∞ ‡§Æ‡•á‡§Ç ‡§®‡§π‡•Ä‡§Ç (‡§Ø‡§æ ‡§Ö‡§®‡•ç‡§Ø ‡§â‡§™‡§Ø‡•ã‡§ó‡§ï‡§∞‡•ç‡§§‡§æ ‡§á‡§ï‡§æ‡§à); ‡§Ø‡§π ‡§è‡§ï‡§Æ‡§æ‡§§‡•ç‡§∞ ‡§Ö‡§™‡§µ‡§æ‡§¶ ‡§π‡•à‡•§ ‡§Ö‡§®‡•ç‡§Ø ‡§¨‡§ø‡§≤‡•ç‡§ü-‡§á‡§® ‡§´‡•â‡§®‡•ç‡§ü Times, Courier, Symbol ‡§î‡§∞ ZapfDingbats ‡§π‡•à‡§Ç‡•§

‡§Ö‡§¨ ‡§π‡§Æ cell ‡§ï‡•á ‡§∏‡§æ‡§• cell print ‡§ï‡§∞ ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç‡•§ ‡§è‡§ï ‡§∏‡•á‡§≤ (cell) ‡§è‡§ï ‡§Ü‡§Ø‡§§‡§æ‡§ï‡§æ‡§∞ ‡§ï‡•ç‡§∑‡•á‡§§‡•ç‡§∞ ‡§π‡•à, ‡§∏‡§Ç‡§≠‡§µ‡§§‡§É ‡§§‡•à‡§Ø‡§æ‡§∞ ‡§ï‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ ‡§π‡•à, ‡§ú‡§ø‡§∏‡§Æ‡•á‡§Ç ‡§ï‡•Å‡§õ ‡§™‡§æ‡§† ‡§π‡•à‡•§ ‡§Ø‡§π ‡§µ‡§∞‡•ç‡§§‡§Æ‡§æ‡§® ‡§∏‡•ç‡§•‡§ø‡§§‡§ø ‡§Æ‡•á‡§Ç ‡§™‡•ç‡§∞‡§¶‡§æ‡§® ‡§ï‡§ø‡§Ø‡§æ ‡§ú‡§æ‡§§‡§æ ‡§π‡•à‡•§ ‡§π‡§Æ ‡§á‡§∏‡§ï‡•á ‡§Ü‡§Ø‡§æ‡§Æ, ‡§á‡§∏‡§ï‡•á ‡§™‡§æ‡§† (‡§ï‡•á‡§Ç‡§¶‡•ç‡§∞‡§ø‡§§ ‡§Ø‡§æ ‡§∏‡§Ç‡§∞‡•á‡§ñ‡§ø‡§§) ‡§®‡§ø‡§∞‡•ç‡§¶‡§ø‡§∑‡•ç‡§ü ‡§ï‡§∞‡§§‡•á ‡§π‡•à‡§Ç, ‡§Ö‡§ó‡§∞ ‡§∏‡•Ä‡§Æ‡§æ‡§è‡§Ç ‡§ñ‡•Ä‡§Ç‡§ö‡§æ ‡§ú‡§æ‡§®‡§æ ‡§ö‡§æ‡§π‡§ø‡§è,‡§î‡§∞ ‡§ú‡§π‡§æ‡§Ç ‡§µ‡§∞‡•ç‡§§‡§Æ‡§æ‡§® ‡§∏‡•ç‡§•‡§ø‡§§‡§ø ‡§á‡§∏‡§ï‡•á ‡§¨‡§æ‡§¶ ‡§ö‡§≤‡§§‡•Ä ‡§π‡•à (‡§¶‡§æ‡§à‡§Ç ‡§ì‡§∞, ‡§®‡•Ä‡§ö‡•á ‡§Ø‡§æ ‡§Ö‡§ó‡§≤‡•Ä ‡§™‡§Ç‡§ï‡•ç‡§§‡§ø ‡§ï‡•Ä ‡§∂‡•Å‡§∞‡•Å‡§Ü‡§§ ‡§Æ‡•á‡§Ç)‡•§

‡§è‡§ï ‡§´‡•ç‡§∞‡•á‡§Æ ‡§ú‡•ã‡§°‡§º‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è, ‡§π‡§Æ ‡§Ø‡§π ‡§ï‡§∞‡•á‡§Ç‡§ó‡•á:

‡§ï‡•á‡§®‡•ç‡§¶‡•ç‡§∞‡§ø‡§§ ‡§™‡§æ‡§† (centered text) ‡§ï‡•á ‡§∏‡§æ‡§• ‡§á‡§∏‡§ï‡•á ‡§Ü‡§ó‡•á ‡§è‡§ï ‡§®‡§Ø‡§æ ‡§∏‡•á‡§≤ (cell) ‡§ú‡•ã‡§°‡§º‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§î‡§∞ ‡§Ö‡§ó‡§≤‡•Ä ‡§™‡§Ç‡§ï‡•ç‡§§‡§ø ‡§™‡§∞ ‡§ú‡§æ‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è, ‡§π‡§Æ ‡§ï‡§∞‡•á‡§Ç‡§ó‡•á:

‡§ü‡§ø‡§™‡•ç‡§™‡§£‡•Ä: ‡§≤‡§æ‡§á‡§® ‡§¨‡•ç‡§∞‡•á‡§ï ln ‡§ï‡•á ‡§∏‡§æ‡§• ‡§≠‡•Ä ‡§ï‡§ø‡§Ø‡§æ ‡§ú‡§æ ‡§∏‡§ï‡§§‡§æ ‡§π‡•à‡§Ç‡•§ ‡§á‡§∏ ‡§µ‡§ø‡§ß‡§ø ‡§¨‡•ç‡§∞‡•á‡§ï ‡§ï‡•Ä ‡§ä‡§Ç‡§ö‡§æ‡§à ‡§ï‡•á ‡§Ö‡§§‡§ø‡§∞‡§ø‡§ï‡•ç‡§§ ‡§®‡§ø‡§∞‡•ç‡§¶‡§ø‡§∑‡•ç‡§ü ‡§ï‡§∞‡§®‡•á ‡§ï‡•Ä ‡§Ö‡§®‡•Å‡§Æ‡§§‡§ø ‡§¶‡•á‡§§‡•Ä ‡§π‡•à‡•§

‡§Ö‡§Ç‡§§ ‡§Æ‡•á‡§Ç, ‡§¶‡§∏‡•ç‡§§‡§æ‡§µ‡•á‡§ú‡§º ‡§ï‡•ã ‡§¨‡§Ç‡§¶ ‡§ï‡§∞ ‡§¶‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ ‡§π‡•à ‡§î‡§∞ ‡§™‡•ç‡§∞‡§¶‡§æ‡§® ‡§ï‡§ø‡§è ‡§ó‡§è ‡§´‡§º‡§æ‡§á‡§≤ ‡§™‡§• ‡§ï‡•á ‡§§‡§π‡§§ ‡§∏‡§π‡•á‡§ú‡§æ ‡§ó‡§Ø‡§æ ‡§π‡•à output.‡§¨‡§ø‡§®‡§æ ‡§ï‡§ø‡§∏‡•Ä ‡§™‡•à‡§∞‡§æ‡§Æ‡•Ä‡§ü‡§∞ ‡§ï‡•á, output() PDF bytearray ‡§¨‡§´‡§º‡§∞ ‡§≤‡•å‡§ü‡§æ‡§§‡§æ ‡§π‡•à‡•§

‡§Ø‡§π‡§æ‡§Å ‡§∂‡•Ä‡§∞‡•ç‡§∑ ‡§≤‡•á‡§ñ (Header), ‡§™‡§æ‡§¶‡§≤‡•á‡§ñ (Footer) ‡§î‡§∞ ‡§≤‡•ã‡§ó‡•ã (Logo) ‡§ï‡•á ‡§∏‡§æ‡§• ‡§¶‡•ã ‡§™‡•É‡§∑‡•ç‡§† ‡§ï‡§æ ‡§â‡§¶‡§æ‡§π‡§∞‡§£ ‡§¶‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ ‡§π‡•à:

‡§Ø‡§π ‡§â‡§¶‡§æ‡§π‡§∞‡§£ header ‡§î‡§∞ footer ‡§ï‡•ã ‡§∏‡§Ç‡§∏‡§æ‡§ß‡§ø‡§§ ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è header ‡§î‡§∞ footer ‡§≤‡•á‡§ñ ‡§µ‡§ø‡§ß‡§ø‡§Ø‡•ã‡§Ç ‡§ï‡§æ ‡§â‡§™‡§Ø‡•ã‡§ó ‡§ï‡§∞‡§§‡§æ ‡§π‡•à‡•§ ‡§â‡§®‡•ç‡§π‡•á‡§Ç ‡§∏‡•ç‡§µ‡§ö‡§æ‡§≤‡§ø‡§§ ‡§∞‡•Ç‡§™ ‡§∏‡•á (automatically) ‡§¨‡•Å‡§≤‡§æ‡§Ø‡§æ ‡§ú‡§æ‡§§‡§æ ‡§π‡•à‡•§ ‡§µ‡•á ‡§™‡§π‡§≤‡•á ‡§∏‡•á ‡§π‡•Ä FPDF ‡§µ‡§∞‡•ç‡§ó ‡§Æ‡•á‡§Ç ‡§Æ‡•å‡§ú‡•Ç‡§¶ ‡§π‡•à‡§Ç ‡§≤‡•á‡§ï‡§ø‡§® ‡§ï‡•Å‡§õ ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§∞‡§§‡•á ‡§π‡•à‡§Ç, ‡§á‡§∏‡§≤‡§ø‡§è ‡§π‡§Æ‡•á‡§Ç class ‡§ï‡§æ ‡§µ‡§ø‡§∏‡•ç‡§§‡§æ‡§∞ ‡§ï‡§∞‡§®‡§æ ‡§π‡•ã‡§ó‡§æ ‡§î‡§∞ ‡§â‡§®‡•ç‡§π‡•á‡§Ç override ‡§ï‡§∞‡§®‡§æ ‡§π‡•ã‡§ó‡§æ‡•§

Logo ‡§ï‡•ã ‡§®‡§ø‡§∞‡•ç‡§¶‡§ø‡§∑‡•ç‡§ü ‡§ï‡§∞‡§ï‡•á image ‡§µ‡§ø‡§ß‡§ø ‡§∏‡•á ‡§á‡§∏‡§ï‡§æ ‡§ä‡§™‡§∞‡•Ä-‡§¨‡§æ‡§è‡§Å ‡§ï‡•ã‡§®‡§æ ‡§î‡§∞ ‡§á‡§∏‡§ï‡•Ä ‡§ö‡•å‡§°‡§º‡§æ‡§à ‡§®‡§ø‡§∞‡•ç‡§¶‡§ø‡§∑‡•ç‡§ü ‡§ï‡§∞‡§ï‡•á ‡§Æ‡•Å‡§¶‡•ç‡§∞‡§ø‡§§ ‡§ï‡§ø‡§Ø‡§æ ‡§ú‡§æ‡§§‡§æ ‡§π‡•à‡•§ ‡§õ‡§µ‡§ø ‡§Ö‡§®‡•Å‡§™‡§æ‡§§ ‡§ï‡§æ ‡§∏‡§Æ‡•ç‡§Æ‡§æ‡§® ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§ä‡§Ç‡§ö‡§æ‡§à ‡§ï‡•Ä ‡§ó‡§£‡§®‡§æ ‡§∏‡•ç‡§µ‡§ö‡§æ‡§≤‡§ø‡§§ ‡§∞‡•Ç‡§™ ‡§∏‡•á ‡§ï‡•Ä ‡§ú‡§æ‡§§‡•Ä ‡§π‡•à‡•§

‡§™‡•É‡§∑‡•ç‡§† ‡§∏‡§Ç‡§ñ‡•ç‡§Ø‡§æ (Page number) ‡§Æ‡•Å‡§¶‡•ç‡§∞‡§ø‡§§ (print) ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è, ‡§∏‡•á‡§≤ ‡§ö‡•å‡§°‡§º‡§æ‡§à (cell width) ‡§ï‡•á ‡§∞‡•Ç‡§™ ‡§Æ‡•á‡§Ç ‡§è‡§ï ‡§∂‡•Ç‡§®‡•ç‡§Ø ‡§Æ‡§æ‡§®(null value) ‡§™‡§æ‡§∏ ‡§ï‡§ø‡§Ø‡§æ ‡§ú‡§æ‡§§‡§æ ‡§π‡•à‡•§

‡§á‡§∏‡§ï‡§æ ‡§Æ‡§§‡§≤‡§¨ ‡§π‡•à ‡§ï‡§ø ‡§∏‡•á‡§≤ ‡§ï‡•ã ‡§™‡•á‡§ú ‡§ï‡•á ‡§¶‡§æ‡§π‡§ø‡§®‡•á ‡§π‡§æ‡§∂‡§ø‡§Ø‡•á (right margin) ‡§§‡§ï ‡§¨‡§¢‡§º‡§æ‡§Ø‡§æ ‡§ú‡§æ‡§®‡§æ ‡§ö‡§æ‡§π‡§ø‡§è; ‡§Ø‡§π ‡§™‡§æ‡§† ‡§ï‡•ã ‡§ï‡•á‡§Ç‡§¶‡•ç‡§∞(center) ‡§Æ‡•á‡§Ç ‡§∞‡§ñ‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§Ü‡§∏‡§æ‡§® ‡§π‡•à‡•§

‡§µ‡§∞‡•ç‡§§‡§Æ‡§æ‡§® ‡§™‡•É‡§∑‡•ç‡§† ‡§∏‡§Ç‡§ñ‡•ç‡§Ø‡§æ page_no ‡§µ‡§ø‡§ß‡§ø ‡§¶‡•ç‡§µ‡§æ‡§∞‡§æ ‡§µ‡§æ‡§™‡§∏ ‡§ï‡•Ä ‡§ú‡§æ‡§§‡•Ä ‡§π‡•à; ‡§™‡•É‡§∑‡•ç‡§†‡•ã‡§Ç ‡§ï‡•Ä ‡§ï‡•Å‡§≤ ‡§∏‡§Ç‡§ñ‡•ç‡§Ø‡§æ ‡§ï‡•á ‡§≤‡§ø‡§è, ‡§Ø‡§π ‡§µ‡§ø‡§∂‡•á‡§∑ ‡§Æ‡•Ç‡§≤‡•ç‡§Ø {nb} ‡§ï‡•á ‡§Æ‡§æ‡§ß‡•ç‡§Ø‡§Æ ‡§∏‡•á ‡§™‡•ç‡§∞‡§æ‡§™‡•ç‡§§ ‡§ï‡§ø‡§Ø‡§æ ‡§ú‡§æ‡§§‡§æ ‡§π‡•à ‡§ú‡§ø‡§∏‡•á ‡§¶‡§∏‡•ç‡§§‡§æ‡§µ‡•á‡§ú‡§º ‡§¨‡§Ç‡§¶ ‡§π‡•ã‡§®‡•á ‡§™‡§∞ ‡§™‡•ç‡§∞‡§§‡§ø‡§∏‡•ç‡§•‡§æ‡§™‡§ø‡§§ ‡§ï‡§ø‡§Ø‡§æ ‡§ú‡§æ‡§è‡§ó‡§æ ‡§ï‡§π‡§æ ‡§ú‡§æ‡§§‡§æ ‡§π‡•à)‡•§

set_y ‡§™‡§¶‡•ç‡§ß‡§§‡§ø ‡§ï‡•á ‡§â‡§™‡§Ø‡•ã‡§ó ‡§™‡§∞ ‡§ß‡•ç‡§Ø‡§æ‡§® ‡§¶‡•á‡§Ç ‡§ú‡•ã ‡§™‡•É‡§∑‡•ç‡§† ‡§Æ‡•á‡§Ç ‡§è‡§ï ‡§™‡•Ç‡§∞‡•ç‡§£ ‡§∏‡•ç‡§•‡§æ‡§® ‡§™‡§∞ ‡§∏‡•ç‡§•‡§ø‡§§‡§ø ‡§∏‡•á‡§ü ‡§ï‡§∞‡§®‡•á ‡§ï‡•Ä ‡§Ö‡§®‡•Å‡§Æ‡§§‡§ø ‡§¶‡•á‡§§‡§æ ‡§π‡•à, ‡§ä‡§™‡§∞ ‡§Ø‡§æ ‡§®‡•Ä‡§ö‡•á ‡§∏‡•á ‡§∂‡•Å‡§∞‡•Ç ‡§π‡•ã‡§§‡§æ ‡§π‡•à‡•§

‡§Ø‡§π‡§æ‡§Å ‡§è‡§ï ‡§î‡§∞ ‡§¶‡§ø‡§≤‡§ö‡§∏‡•ç‡§™ ‡§µ‡§ø‡§∂‡•á‡§∑‡§§‡§æ ‡§ï‡§æ ‡§â‡§™‡§Ø‡•ã‡§ó ‡§ï‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ ‡§π‡•à: the automatic page breaking. ‡§ú‡•à‡§∏‡•á ‡§π‡•Ä ‡§ï‡•ã‡§à ‡§∏‡•á‡§≤ ‡§™‡•É‡§∑‡•ç‡§† ‡§Æ‡•á‡§Ç ‡§è‡§ï ‡§∏‡•Ä‡§Æ‡§æ ‡§ï‡•ã ‡§™‡§æ‡§∞ ‡§ï‡§∞‡•á‡§ó‡§æ (‡§°‡§ø‡§´‡§º‡•â‡§≤‡•ç‡§ü ‡§∞‡•Ç‡§™ ‡§∏‡•á ‡§®‡•Ä‡§ö‡•á ‡§∏‡•á 2 ‡§∏‡•á‡§Ç‡§ü‡•Ä‡§Æ‡•Ä‡§ü‡§∞ ‡§™‡§∞), ‡§è‡§ï ‡§¨‡•ç‡§∞‡•á‡§ï ‡§ï‡§ø‡§Ø‡§æ ‡§ú‡§æ‡§§‡§æ ‡§π‡•à ‡§î‡§∞ ‡§´‡§º‡•â‡§®‡•ç‡§ü ‡§ï‡•ã ‡§™‡•Å‡§®‡§∞‡•ç‡§∏‡•ç‡§•‡§æ‡§™‡§ø‡§§ ‡§ï‡§ø‡§Ø‡§æ ‡§ú‡§æ‡§§‡§æ ‡§π‡•à‡•§

‡§π‡§æ‡§≤‡§æ‡§Ç‡§ï‡§ø ‡§∂‡•Ä‡§∞‡•ç‡§∑ ‡§≤‡•á‡§ñ (Header) ‡§î‡§∞ ‡§™‡§æ‡§¶ ‡§≤‡•á‡§ñ (Footer) ‡§Ö‡§™‡§®‡•á ‡§∏‡•ç‡§µ‡§Ø‡§Ç ‡§ï‡•á ‡§´‡§º‡•â‡§®‡•ç‡§ü (Helvetica) ‡§ï‡§æ ‡§ö‡§Ø‡§® ‡§ï‡§∞‡§§‡•á ‡§π‡•à‡§Ç, body Times ‡§ï‡•á ‡§∏‡§æ‡§• ‡§ú‡§æ‡§∞‡•Ä ‡§∞‡§π‡§§‡§æ ‡§π‡•à‡•§ ‡§∏‡•ç‡§µ‡§ö‡§æ‡§≤‡§ø‡§§ ‡§¨‡§π‡§æ‡§≤‡•Ä ‡§ï‡§æ ‡§Ø‡§π ‡§§‡§Ç‡§§‡•ç‡§∞ ‡§∞‡§Ç‡§ó‡•ã‡§Ç ‡§î‡§∞ ‡§∞‡•á‡§ñ‡§æ ‡§ï‡•Ä ‡§ö‡•å‡§°‡§º‡§æ‡§à ‡§™‡§∞ ‡§≠‡•Ä ‡§≤‡§æ‡§ó‡•Ç ‡§π‡•ã‡§§‡§æ ‡§π‡•à‡•§ ‡§™‡•É‡§∑‡•ç‡§† ‡§µ‡§ø‡§∞‡§æ‡§Æ ‡§ï‡•ã ‡§ü‡•ç‡§∞‡§ø‡§ó‡§∞ ‡§ï‡§∞‡§®‡•á ‡§µ‡§æ‡§≤‡•Ä ‡§∏‡•Ä‡§Æ‡§æ ‡§ï‡•ã set_auto_page_break ‡§ï‡•á ‡§∏‡§æ‡§• ‡§∏‡•á‡§ü ‡§ï‡§ø‡§Ø‡§æ ‡§ú‡§æ ‡§∏‡§ï‡§§‡§æ ‡§π‡•à‡•§

‡§Ü‡§á‡§è ‡§è‡§ï ‡§â‡§¶‡§æ‡§π‡§∞‡§£ ‡§ï‡•á ‡§∏‡§æ‡§• ‡§ú‡§æ‡§∞‡•Ä ‡§∞‡§ñ‡•á‡§Ç ‡§ú‡•ã Justified ‡§Ö‡§®‡•Å‡§ö‡•ç‡§õ‡•á‡§¶‡•ã‡§Ç ‡§ï‡•ã ‡§™‡•ç‡§∞‡§ø‡§Ç‡§ü ‡§ï‡§∞‡§§‡§æ ‡§π‡•à‡•§ ‡§Ø‡§π ‡§∞‡§Ç‡§ó‡•ã‡§Ç ‡§ï‡•á ‡§â‡§™‡§Ø‡•ã‡§ó ‡§ï‡•ã ‡§≠‡•Ä ‡§¶‡§∞‡•ç‡§∂‡§æ‡§§‡§æ ‡§π‡•à‡•§

get_string_width ‡§µ‡§ø‡§ß‡§ø ‡§µ‡§∞‡•ç‡§§‡§Æ‡§æ‡§® ‡§´‡§º‡•â‡§®‡•ç‡§ü ‡§Æ‡•á‡§Ç ‡§è‡§ï ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó ‡§ï‡•Ä ‡§≤‡§Ç‡§¨‡§æ‡§à ‡§®‡§ø‡§∞‡•ç‡§ß‡§æ‡§∞‡§ø‡§§ ‡§ï‡§∞‡§®‡•á ‡§ï‡•Ä ‡§Ö‡§®‡•Å‡§Æ‡§§‡§ø ‡§¶‡•á‡§§‡•Ä ‡§π‡•à, ‡§ú‡§ø‡§∏‡§ï‡§æ ‡§â‡§™‡§Ø‡•ã‡§ó ‡§∂‡•Ä‡§∞‡•ç‡§∑‡§ï ‡§ï‡•á ‡§Ü‡§∏‡§™‡§æ‡§∏ ‡§ï‡•á ‡§´‡•ç‡§∞‡•á‡§Æ ‡§ï‡•Ä ‡§∏‡•ç‡§•‡§ø‡§§‡§ø ‡§î‡§∞ ‡§ö‡•å‡§°‡§º‡§æ‡§à ‡§ï‡•Ä ‡§ó‡§£‡§®‡§æ ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§Ø‡§π‡§æ‡§Ç ‡§ï‡§ø‡§Ø‡§æ ‡§ú‡§æ‡§§‡§æ ‡§π‡•à‡•§

‡§´‡§ø‡§∞ ‡§∞‡§Ç‡§ó ‡§∏‡•á‡§ü ‡§ï‡§ø‡§è ‡§ú‡§æ‡§§‡•á ‡§π‡•à‡§Ç (set_draw_color, ‡§∏‡•á‡§ü ‡§´‡§ø‡§≤ ‡§ï‡§≤‡§∞ ‡§î‡§∞ ‡§∏‡•á‡§ü ‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü ‡§ï‡§≤‡§∞ ‡§ï‡•á ‡§Æ‡§æ‡§ß‡•ç‡§Ø‡§Æ ‡§∏‡•á) ‡§î‡§∞ ‡§≤‡§æ‡§á‡§® ‡§ï‡•Ä ‡§Æ‡•ã‡§ü‡§æ‡§à ‡§∏‡•á‡§ü‡§≤‡§æ‡§á‡§® ‡§ö‡•å‡§°‡§º‡§æ‡§à ‡§ï‡•á ‡§∏‡§æ‡§• 1 ‡§Æ‡§ø‡§Æ‡•Ä (‡§°‡§ø‡§´‡§º‡•â‡§≤‡•ç‡§ü ‡§∞‡•Ç‡§™ ‡§∏‡•á 0.2 ‡§ï‡•á ‡§ñ‡§ø‡§≤‡§æ‡§´) ‡§™‡§∞ ‡§∏‡•á‡§ü ‡§ï‡•Ä ‡§ú‡§æ‡§§‡•Ä ‡§π‡•à‡•§

‡§´‡§ø‡§∞ ‡§∞‡§Ç‡§ó ‡§∏‡•á‡§ü ‡§ï‡§ø‡§è ‡§ú‡§æ‡§§‡•á ‡§π‡•à‡§Ç (set_draw_color, set_fill_color ‡§î‡§∞ set_text_color ‡§ï‡•á ‡§Æ‡§æ‡§ß‡•ç‡§Ø‡§Æ ‡§∏‡•á) ‡§î‡§∞ ‡§≤‡§æ‡§á‡§® ‡§ï‡•Ä ‡§Æ‡•ã‡§ü‡§æ‡§à set_line_width ‡§ï‡•á ‡§∏‡§æ‡§• 1 ‡§Æ‡§ø‡§Æ‡•Ä (‡§°‡§ø‡§´‡§º‡•â‡§≤‡•ç‡§ü ‡§∞‡•Ç‡§™ ‡§∏‡•á 0.2 ‡§ï‡•á ‡§µ‡§ø‡§∞‡•Å‡§¶‡•ç‡§ß) ‡§™‡§∞ ‡§∏‡•á‡§ü ‡§ï‡•Ä ‡§ú‡§æ‡§§‡•Ä ‡§π‡•à‡•§ ‡§Ö‡§Ç‡§§ ‡§Æ‡•á‡§Ç, ‡§π‡§Æ ‡§∏‡•á‡§≤ ‡§ï‡•ã ‡§Ü‡§â‡§ü‡§™‡•Å‡§ü ‡§ï‡§∞‡§§‡•á ‡§π‡•à‡§Ç (‡§Ö‡§Ç‡§§‡§ø‡§Æ ‡§™‡•à‡§∞‡§æ‡§Æ‡•Ä‡§ü‡§∞ ‡§ï‡•á true ‡§π‡•ã‡§®‡•á ‡§∏‡•á ‡§π‡§Æ‡•á ‡§™‡§§‡§æ ‡§ö‡§≤‡§§‡§æ ‡§π‡•à ‡§ï‡§ø ‡§™‡•É‡§∑‡•ç‡§†‡§≠‡•Ç‡§Æ‡§ø ‡§ï‡•ã ‡§≠‡§∞‡§æ ‡§ú‡§æ‡§®‡§æ ‡§ö‡§æ‡§π‡§ø‡§è)‡•§

‡§™‡•à‡§∞‡§æ‡§ó‡•ç‡§∞‡§æ‡§´ ‡§ï‡•ã ‡§™‡•ç‡§∞‡§ø‡§Ç‡§ü ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§á‡§∏‡•ç‡§§‡•á‡§Æ‡§æ‡§≤ ‡§ï‡•Ä ‡§ú‡§æ‡§®‡•á ‡§µ‡§æ‡§≤‡•Ä ‡§µ‡§ø‡§ß‡§ø multi_cell ‡§π‡•à‡•§ ‡§π‡§∞ ‡§¨‡§æ‡§∞ ‡§ú‡§¨ ‡§ï‡•ã‡§à ‡§≤‡§æ‡§á‡§® cell ‡§ï‡•á ‡§¶‡§æ‡§π‡§ø‡§®‡•á ‡§õ‡•ã‡§∞ ‡§§‡§ï ‡§™‡§π‡•Å‡§Å‡§ö‡§§‡•Ä ‡§π‡•à ‡§Ø‡§æ carriage return ‡§ï‡•à‡§∞‡•á‡§ï‡•ç‡§ü‡§∞ ‡§Æ‡§ø‡§≤‡§§‡§æ ‡§π‡•à, ‡§§‡•ã ‡§è‡§ï ‡§≤‡§æ‡§á‡§® ‡§¨‡•ç‡§∞‡•á‡§ï ‡§ú‡§æ‡§∞‡•Ä ‡§ï‡§ø‡§Ø‡§æ ‡§ú‡§æ‡§§‡§æ ‡§π‡•à ‡§î‡§∞ current cell ‡§ï‡•á ‡§§‡§π‡§§ ‡§è‡§ï ‡§®‡§Ø‡§æ ‡§∏‡•á‡§≤ ‡§∏‡•ç‡§µ‡§ö‡§æ‡§≤‡§ø‡§§ ‡§∞‡•Ç‡§™ ‡§∏‡•á ‡§¨‡§®‡§æ‡§Ø‡§æ ‡§ú‡§æ‡§§‡§æ ‡§π‡•à‡•§ Text ‡§°‡§ø‡§´‡§º‡•â‡§≤‡•ç‡§ü ‡§∞‡•Ç‡§™ ‡§∏‡•á Justified ‡§π‡•à‡•§

‡§¶‡•ã ‡§¶‡§∏‡•ç‡§§‡§æ‡§µ‡•á‡§ú‡§º ‡§ó‡•Å‡§£ ‡§™‡§∞‡§ø‡§≠‡§æ‡§∑‡§ø‡§§ ‡§π‡•à‡§Ç: ‡§∂‡•Ä‡§∞‡•ç‡§∑‡§ï (set_title) ‡§î‡§∞ ‡§≤‡•á‡§ñ‡§ï (set_author). ‡§ó‡•Å‡§£‡•ã‡§Ç ‡§ï‡•ã ‡§¶‡•ã ‡§§‡§∞‡•Ä‡§ï‡•ã‡§Ç ‡§∏‡•á ‡§¶‡•á‡§ñ‡§æ ‡§ú‡§æ ‡§∏‡§ï‡§§‡§æ ‡§π‡•à‡•§ ‡§∏‡§¨‡§∏‡•á ‡§™‡§π‡§≤‡•á ‡§¶‡§∏‡•ç‡§§‡§æ‡§µ‡•á‡§ú‡§º ‡§ï‡•ã ‡§∏‡•Ä‡§ß‡•á ‡§è‡§ï‡•ç‡§∞‡•ã‡§¨‡•á‡§ü ‡§∞‡•Ä‡§°‡§∞ ‡§ï‡•á ‡§∏‡§æ‡§• ‡§ñ‡•ã‡§≤‡§®‡§æ ‡§π‡•à, ‡§´‡§º‡§æ‡§á‡§≤ ‡§Æ‡•á‡§®‡•Ç ‡§™‡§∞ ‡§ú‡§æ‡§è‡§Å ‡§î‡§∞ ‡§¶‡§∏‡•ç‡§§‡§æ‡§µ‡•á‡§ú‡§º ‡§ó‡•Å‡§£ ‡§µ‡§ø‡§ï‡§≤‡•ç‡§™ ‡§ö‡•Å‡§®‡•á‡§Ç‡•§ ‡§¶‡•Ç‡§∏‡§∞‡§æ, ‡§™‡•ç‡§≤‡§ó-‡§á‡§® ‡§∏‡•á ‡§≠‡•Ä ‡§â‡§™‡§≤‡§¨‡•ç‡§ß ‡§π‡•à, ‡§∞‡§æ‡§á‡§ü-‡§ï‡•ç‡§≤‡§ø‡§ï ‡§ï‡§∞‡§®‡§æ ‡§î‡§∞ ‡§¶‡§∏‡•ç‡§§‡§æ‡§µ‡•á‡§ú‡§º ‡§ó‡•Å‡§£ ‡§ö‡•Å‡§®‡§®‡§æ ‡§π‡•à‡•§

‡§Ø‡§π ‡§â‡§¶‡§æ‡§π‡§∞‡§£ ‡§™‡§ø‡§õ‡§≤‡•á ‡§è‡§ï ‡§ï‡§æ ‡§è‡§ï ‡§™‡•ç‡§∞‡§ï‡§æ‡§∞ ‡§π‡•à, ‡§ú‡§ø‡§∏‡§Æ‡•á‡§Ç ‡§¶‡§ø‡§ñ‡§æ‡§Ø‡§æ ‡§ó‡§Ø‡§æ ‡§π‡•à ‡§ï‡§ø ‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü ‡§ï‡•ã ‡§ï‡§à ‡§ï‡•â‡§≤‡§Æ ‡§Æ‡•á‡§Ç ‡§ï‡•à‡§∏‡•á ‡§∞‡§ñ‡§æ ‡§ú‡§æ‡§è‡•§

‚ö†Ô∏è This section has changed a lot and requires a new translation: https://github.com/py-pdf/fpdf2/issues/267

Resulting PDF - Countries text

‚ö†Ô∏è This section has changed a lot and requires a new translation: https://github.com/py-pdf/fpdf2/issues/267

‡§Ø‡§π ‡§ü‡•ç‡§Ø‡•Ç‡§ü‡•ã‡§∞‡§ø‡§Ø‡§≤ ‡§™‡•Ä‡§°‡•Ä‡§è‡§´ ‡§¶‡§∏‡•ç‡§§‡§æ‡§µ‡•á‡§ú‡§º ‡§ï‡•á ‡§Ö‡§Ç‡§¶‡§∞ ‡§≤‡§ø‡§Ç‡§ï ‡§°‡§æ‡§≤‡§®‡•á ‡§ï‡•á ‡§∏‡§æ‡§•-‡§∏‡§æ‡§• ‡§¨‡§æ‡§π‡§∞‡•Ä ‡§∏‡•ç‡§∞‡•ã‡§§‡•ã‡§Ç ‡§ï‡•á ‡§≤‡§ø‡§Ç‡§ï ‡§ú‡•ã‡§°‡§º‡§®‡•á ‡§ï‡•á ‡§ï‡§à ‡§§‡§∞‡•Ä‡§ï‡•ã‡§Ç ‡§ï‡•Ä ‡§µ‡•ç‡§Ø‡§æ‡§ñ‡•ç‡§Ø‡§æ ‡§ï‡§∞‡•á‡§ó‡§æ‡•§ ‡§Ø‡§π ‡§ï‡§à ‡§§‡§∞‡•Ä‡§ï‡•á ‡§≠‡•Ä ‡§¶‡§ø‡§ñ‡§æ‡§è‡§ó‡§æ ‡§ú‡§ø‡§∏‡§∏‡•á ‡§π‡§Æ ‡§è‡§ï ‡§π‡•Ä ‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü ‡§ï‡•á ‡§≠‡•Ä‡§§‡§∞ ‡§µ‡§ø‡§≠‡§ø‡§®‡•ç‡§® ‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü ‡§∂‡•à‡§≤‡§ø‡§Ø‡•ã‡§Ç, (‡§¨‡•ã‡§≤‡•ç‡§°, ‡§á‡§ü‡•à‡§≤‡§ø‡§ï, ‡§Ö‡§Ç‡§°‡§∞‡§≤‡§æ‡§á‡§®) ‡§ï‡§æ ‡§â‡§™‡§Ø‡•ã‡§ó ‡§ï‡§∞ ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç‡•§

Resulting PDF - fpdf2-logo

‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü ‡§™‡•ç‡§∞‡§ø‡§Ç‡§ü ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§Ø‡§π‡§æ‡§Ç ‡§¶‡§ø‡§ñ‡§æ‡§Ø‡§æ ‡§ó‡§Ø‡§æ ‡§®‡§Ø‡§æ ‡§§‡§∞‡•Ä‡§ï‡§æ write() ‡§π‡•à‡•§ ‡§Ø‡§π ‡§¨‡§π‡•Å‡§§ ‡§π‡§¶ ‡§§‡§ï multi_cell() ‡§ï‡•á ‡§∏‡§Æ‡§æ‡§® ‡§π‡•à, ‡§Æ‡•Å‡§ñ‡•ç‡§Ø ‡§Ö‡§Ç‡§§‡§∞ ‡§Ø‡§π ‡§π‡•à: - ‡§™‡§Ç‡§ï‡•ç‡§§‡§ø ‡§ï‡§æ ‡§Ö‡§Ç‡§§ ‡§¶‡§æ‡§è‡§Ç ‡§π‡§æ‡§∂‡§ø‡§Ø‡•á ‡§™‡§∞ ‡§π‡•à ‡§î‡§∞ ‡§Ö‡§ó‡§≤‡•Ä ‡§™‡§Ç‡§ï‡•ç‡§§‡§ø ‡§¨‡§æ‡§è‡§Ç ‡§π‡§æ‡§∂‡§ø‡§Ø‡•á ‡§™‡§∞ ‡§∂‡•Å‡§∞‡•Ç ‡§π‡•ã‡§§‡•Ä ‡§π‡•à‡•§ - ‡§µ‡§∞‡•ç‡§§‡§Æ‡§æ‡§® ‡§∏‡•ç‡§•‡§ø‡§§‡§ø ‡§™‡§æ‡§† ‡§ï‡•á ‡§Ö‡§Ç‡§§ ‡§Æ‡•á‡§Ç ‡§ö‡§≤‡•Ä ‡§ú‡§æ‡§§‡•Ä ‡§π‡•à‡•§

‡§á‡§∏‡§≤‡§ø‡§è ‡§µ‡§ø‡§ß‡§ø ‡§π‡§Æ‡•á‡§Ç ‡§™‡§æ‡§† ‡§ï‡§æ ‡§è‡§ï ‡§π‡§ø‡§∏‡•ç‡§∏‡§æ ‡§≤‡§ø‡§ñ‡§®‡•á, ‡§´‡§º‡•â‡§®‡•ç‡§ü ‡§∂‡•à‡§≤‡•Ä ‡§ï‡•ã ‡§¨‡§¶‡§≤‡§®‡•á ‡§î‡§∞ ‡§†‡•Ä‡§ï ‡§â‡§∏‡•Ä ‡§∏‡•ç‡§•‡§æ‡§® ‡§∏‡•á ‡§ú‡§æ‡§∞‡•Ä ‡§∞‡§ñ‡§®‡•á ‡§ï‡•Ä ‡§Ö‡§®‡•Å‡§Æ‡§§‡§ø ‡§¶‡•á‡§§‡•Ä ‡§π‡•à ‡§ú‡§π‡§æ‡§Ç ‡§∏‡•á ‡§π‡§Æ‡§®‡•á ‡§õ‡•ã‡§°‡§º‡§æ ‡§•‡§æ‡•§ ‡§¶‡•Ç‡§∏‡§∞‡•Ä ‡§ì‡§∞, ‡§á‡§∏‡§ï‡§æ ‡§Æ‡•Å‡§ñ‡•ç‡§Ø ‡§¶‡•ã‡§∑ ‡§Ø‡§π ‡§π‡•à ‡§ï‡§ø ‡§π‡§Æ ‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü ‡§ï‡•ã ‡§ú‡§∏‡•ç‡§ü‡§ø‡§´‡§æ‡§à ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§∞ ‡§∏‡§ï‡§§‡•á ‡§ú‡•à‡§∏‡•á ‡§π‡§Æ multi_cell() ‡§Æ‡•á‡§•‡§° ‡§ï‡•á ‡§∏‡§æ‡§• ‡§ï‡§∞‡§§‡•á ‡§π‡•à‡§Ç‡•§

‡§â‡§¶‡§æ‡§π‡§∞‡§£ ‡§ï‡•á ‡§™‡§π‡§≤‡•á ‡§™‡•É‡§∑‡•ç‡§† ‡§Æ‡•á‡§Ç, ‡§π‡§Æ‡§®‡•á ‡§á‡§∏ ‡§â‡§¶‡•ç‡§¶‡•á‡§∂‡•ç‡§Ø ‡§ï‡•á ‡§≤‡§ø‡§è write() ‡§ï‡§æ ‡§â‡§™‡§Ø‡•ã‡§ó ‡§ï‡§ø‡§Ø‡§æ‡•§ ‡§µ‡§æ‡§ï‡•ç‡§Ø ‡§ï‡•Ä ‡§∂‡•Å‡§∞‡•Å‡§Ü‡§§ ‡§®‡§ø‡§Ø‡§Æ‡§ø‡§§ ‡§∂‡•à‡§≤‡•Ä ‡§ï‡•á ‡§™‡§æ‡§† ‡§Æ‡•á‡§Ç ‡§≤‡§ø‡§ñ‡•Ä ‡§ú‡§æ‡§§‡•Ä ‡§π‡•à, ‡§´‡§ø‡§∞ set_font() ‡§µ‡§ø‡§ß‡§ø ‡§ï‡§æ ‡§â‡§™‡§Ø‡•ã‡§ó ‡§ï‡§∞‡§ï‡•á, ‡§π‡§Æ‡§®‡•á ‡§∞‡•á‡§ñ‡§æ‡§Ç‡§ï‡§ø‡§§ ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§∏‡•ç‡§µ‡§ø‡§ö ‡§ï‡§ø‡§Ø‡§æ ‡§î‡§∞ ‡§µ‡§æ‡§ï‡•ç‡§Ø ‡§ï‡•ã ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§ ‡§ï‡§ø‡§Ø‡§æ‡•§

‡§¶‡•Ç‡§∏‡§∞‡•á ‡§™‡•É‡§∑‡•ç‡§† ‡§ï‡•Ä ‡§ì‡§∞ ‡§á‡§∂‡§æ‡§∞‡§æ ‡§ï‡§∞‡§§‡•á ‡§π‡•Å‡§è ‡§è‡§ï ‡§Ü‡§Ç‡§§‡§∞‡§ø‡§ï ‡§≤‡§ø‡§Ç‡§ï ‡§ú‡•ã‡§°‡§º‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è, ‡§π‡§Æ‡§®‡•á add_link() ‡§µ‡§ø‡§ß‡§ø ‡§ï‡§æ ‡§â‡§™‡§Ø‡•ã‡§ó ‡§ï‡§ø‡§Ø‡§æ, ‡§ú‡•ã ‡§è‡§ï ‡§ï‡•ç‡§≤‡§ø‡§ï ‡§ï‡§∞‡§®‡•á ‡§Ø‡•ã‡§ó‡•ç‡§Ø ‡§ï‡•ç‡§∑‡•á‡§§‡•ç‡§∞ ‡§¨‡§®‡§æ‡§§‡§æ ‡§π‡•à ‡§ú‡§ø‡§∏‡•á ‡§π‡§Æ‡§®‡•á "Link" ‡§®‡§æ‡§Æ ‡§¶‡§ø‡§Ø‡§æ ‡§π‡•à ‡§ú‡•ã ‡§¶‡§∏‡•ç‡§§‡§æ‡§µ‡•á‡§ú‡§º ‡§ï‡•á ‡§≠‡•Ä‡§§‡§∞ ‡§ï‡§ø‡§∏‡•Ä ‡§Ö‡§®‡•ç‡§Ø ‡§∏‡•ç‡§•‡§æ‡§® ‡§™‡§∞ ‡§®‡§ø‡§∞‡•ç‡§¶‡•á‡§∂‡§ø‡§§ ‡§ï‡§∞‡§§‡§æ ‡§π‡•à‡•§

Image ‡§ï‡§æ ‡§â‡§™‡§Ø‡•ã‡§ó ‡§ï‡§∞‡§ï‡•á ‡§¨‡§æ‡§π‡§∞‡•Ä ‡§≤‡§ø‡§Ç‡§ï ‡§¨‡§®‡§æ‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è, ‡§π‡§Æ‡§®‡•á image() ‡§ï‡§æ ‡§â‡§™‡§Ø‡•ã‡§ó ‡§ï‡§ø‡§Ø‡§æ‡•§ ‡§µ‡§ø‡§ß‡§ø ‡§Æ‡•á‡§Ç ‡§è‡§ï ‡§≤‡§ø‡§Ç‡§ï ‡§ï‡•ã ‡§á‡§∏‡§ï‡•á ‡§§‡§∞‡•ç‡§ï‡•ã‡§Ç ‡§Æ‡•á‡§Ç ‡§∏‡•á ‡§è‡§ï ‡§ï‡•á ‡§∞‡•Ç‡§™ ‡§Æ‡•á‡§Ç ‡§™‡§æ‡§∞‡§ø‡§§ ‡§ï‡§∞‡§®‡•á ‡§ï‡§æ ‡§µ‡§ø‡§ï‡§≤‡•ç‡§™ ‡§π‡•ã‡§§‡§æ ‡§π‡•à‡•§ ‡§≤‡§ø‡§Ç‡§ï ‡§Ü‡§Ç‡§§‡§∞‡§ø‡§ï ‡§Ø‡§æ ‡§¨‡§æ‡§π‡§∞‡•Ä ‡§¶‡•ã‡§®‡•ã‡§Ç ‡§π‡•ã ‡§∏‡§ï‡§§‡§æ ‡§π‡•à‡•§

‡§è‡§ï ‡§µ‡§ø‡§ï‡§≤‡•ç‡§™ ‡§ï‡•á ‡§∞‡•Ç‡§™ ‡§Æ‡•á‡§Ç, ‡§´‡§º‡•â‡§®‡•ç‡§ü ‡§∂‡•à‡§≤‡•Ä ‡§¨‡§¶‡§≤‡§®‡•á ‡§î‡§∞ ‡§≤‡§ø‡§Ç‡§ï ‡§ú‡•ã‡§°‡§º‡§®‡•á ‡§ï‡§æ ‡§¶‡•Ç‡§∏‡§∞‡§æ ‡§µ‡§ø‡§ï‡§≤‡•ç‡§™ write_html() ‡§™‡§¶‡•ç‡§ß‡§§‡§ø ‡§ï‡§æ ‡§â‡§™‡§Ø‡•ã‡§ó ‡§ï‡§∞‡§®‡§æ ‡§π‡•à‡•§ ‡§Ø‡§π ‡§è‡§ï HTML ‡§™‡§æ‡§∞‡•ç‡§∏‡§∞ ‡§π‡•à, ‡§ú‡•ã ‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü ‡§ú‡•ã‡§°‡§º‡§®‡•á, ‡§´‡§º‡•â‡§®‡•ç‡§ü ‡§∂‡•à‡§≤‡•Ä ‡§¨‡§¶‡§≤‡§®‡•á ‡§î‡§∞ html ‡§ï‡§æ ‡§â‡§™‡§Ø‡•ã‡§ó ‡§ï‡§∞‡§ï‡•á ‡§≤‡§ø‡§Ç‡§ï ‡§ú‡•ã‡§°‡§º‡§®‡•á ‡§ï‡•Ä ‡§Ö‡§®‡•Å‡§Æ‡§§‡§ø ‡§¶‡•á‡§§‡§æ ‡§π‡•à‡•§

**Examples:**

Example 1 (python):
```python
from fpdf import FPDF

pdf = FPDF()
pdf.add_page()
pdf.set_font("helvetica", style="B", size=16)
pdf.cell(40, 10, "Hello World!")
pdf.output("tuto1.pdf")
```

Example 2 (unknown):
```unknown
pdf = FPDF(orientation="P", unit="mm", format="A4")
```

Example 3 (unknown):
```unknown
pdf.set_font('Helvetica', style='B', size=16)
```

Example 4 (unknown):
```unknown
pdf.cell(40, 10, 'Hello World!', 1)
```

---

## Panduan¬∂

**URL:** https://py-pdf.github.io/fpdf2/Tutorial-id.html

**Contents:**
- Panduan¬∂
- Panduan 1 - Contoh Sederhana¬∂
- Panduan 2 - Header, footer, page break dan gambar¬∂
- Panduan 3 - Line breaks dan warna¬∂
- Panduan 4 - Multi Kolom¬∂
- Panduan 5 - Membuat tabel¬∂
- Panduan 6 - Membuat tautan dan mencampur gaya teks¬∂

Dokumentasi secara lengkap: fpdf.FPDF API doc

Mari kita mulai dengan contoh sederhana:

Setelah menyertakan file library tersebut, kita buat objek FPDF. Konstruktor FPDF yang digunakan ini mempunyai nilai bawaan: halaman dalam format kertas A4 portrait dan satuan pengukuran dalam milimeter. Ini juga dapat ditentukan secara eksplisit dengan:

Kita juga dapat mengatur PDF dalam mode landscape (L) atau menggunakan format halaman lainnya (seperti Letter dan Legal) dan satuan ukuran (pt, cm, in).

Karena saat ini tidak ada halaman, kita harus menambahkannya dengan add_page. Titik awal kursor berada di pojok kiri atas dan posisi yang sekarang ditempatkan 1 cm dari margin secara default; margin dapat diubah dengan set_margins.

Sebelum kita dapat mencetak teks, penting untuk memilih font dengan set_font, jika tidak, dokumen akan menjadi tidak valid. Kita pilih font Helvetica dengan ketebalan 16:

Kita dapat menentukan font italic dengan I, bergaris bawah dengan U, atau jenis font reguler dengan string kosong (atau kombinasi lain). Perlu dicatat bahwa ukuran font diberikan dalam satuan poin, bukan milimeter (atau satuan lainnya); ini adalah satu-satunya pengecualian. Font bawaan lainnya adalah Times, Courier, Symbol, dan ZapfDingbats.

Sekarang kita dapat mencetak cell dengan cell. Sebuah cell adalah area berbentuk persegi panjang yang berisi beberapa teks. Cell tersebut dirender pada posisi kursor saat ini. Kita tentukan dimensinya, teksnya (di tengah atau rata kiri/kanan), apakah garis batas akan digambar, dan di mana posisi kursor bergerak setelahnya (ke kanan, ke bawah, atau ke awal baris berikutnya). Untuk menambahkan frame, kita dapat melakukannya seperti ini:

Untuk menambahkan cell baru tepat disampingnya dengan teks rata tengah dan langsung ke baris selanjutnya, kita bisa:

Komentar: line break atau menambah baris baru sekarang bisa dilakukan dengan ln. Method ini dapat menentukan tinggi dari baris baru tersebut.

Terakhir, dokumen di atas ditutup dan disimpan dalam file path yang ditentukan menggunakan output. Tanpa adanya parameter, output() akan menghasilkan PDF bytearray buffer.

Berikut adalah contoh dua halaman dengan header, footer dan logo:

Contoh di atas menggunakan method header dan footer untuk memproses header dan footer halaman. Keduanya dipanggil secara otomatis. Keduanya sebenarnya sudah ada dalam class FPDF namun tidak melakukan apapun, sehingga kita harus meng-extend class tersebut dan menimpanya dengan preferensi kita.

Logo halaman dicetak dengan method image dan dengan menentukan sudut kiri atas dan lebarnya. Tinggi gambar akan dihitung secara otomatis untuk menjaga proporsi gambarnya.

Untuk mencetak nomor halaman, nilai kosong atau null akan di-passing sebagai lebar cell. Yang artinya, cell harus memanjang hingga margin kanan halaman; hal ini berguna agar teks rata tengah. Nomor halaman yang ada sekarang, dihasilkan oleh method page_no; sedangkan untuk jumlah total halaman, dapat diperoleh dengan nilai khusus yaitu {nb} yang akan diganti saat dokumen ditutup (nilai khusus tersebut dapat diubah dengan alias_nb_pages()). Perhatikan penggunaan method set_y yang dapat mengatur posisi dengan lokasi yang absolut dalam halaman, mulai dari atas atau bawah.

Fitur menarik lain yang digunakan disini adalah page break otomatis. Begitu cell sudah melewati batas di halaman (jarak 2cm dari bawah secara default), page break dilakukan dan font dikembalikan. Meskipun header dan footer memilih font mereka sendiri (helvetica), body halaman tetap menggunakan Times. Mekanisme pemulihan otomatis ini juga berlaku untuk warna dan lebar garis. Batas yang memicu page break dapat diatur dengan set_auto_page_break.

Mari kita lanjutkan dengan mencetak paragraf yang rata kiri dan kanan. Contoh ini juga akan mengilustrasikan penggunaan warna.

Contoh teks Jules Verne

Method get_string_width dapat menentukan panjang string dalam sebuah font, yang digunakan untuk menghitung posisi dan lebar frame yang mengelilingi judul. Kemudian, warna dapat ditetapkan (melalui set_draw_color, set_fill_color dan set_text_color) dan ketebalan garis dapat ditetapkan ke 1 mm (dibandingkan 0,2 secara default) dengan set_line_width. Terakhir, kita output cell (parameter terakhir bernilai True menunjukkan bahwa background harus diisi).

Method yang digunakan untuk mencetak paragraf adalah multi_cell. Teks akan rata kiri dan kanan secara default. Setiap kali baris mencapai ujung kanan cell atau terdapat karakter carriage return (\n), akan dimunculkan line break dan cell baru akan otomatis dibuat di bawah cell tersebut. Pembatasan otomatis dilakukan di lokasi spasi terdekat atau karakter soft-hyphen (\u00ad) sebelum batas kanan halaman. Soft-hyphen akan diganti dengan tanda hubung biasa saat ada line break, dan diabaikan jika tidak.

Dua properti dokumen ditetapkan: judul (set_title) dan penulis (set_author). Properti tersebut dapat dilihat dengan dua cara. Pertama adalah dengan membuka dokumen secara langsung dengan Acrobat Reader, masuk ke menu File dan pilih opsi Document Properties. Yang kedua, juga tersedia dari plug-in, adalah klik kanan dan pilih Document Properties.

Contoh berikut adalah varian dari contoh sebelumnya, yang menunjukkan cara meletakkan teks di beberapa kolom.

Contoh teks Jules Verne

Perbedaan utama dari tutorial sebelumnya adalah penggunaan method text_columns. Method tersebut mengumpulkan semua teks secara bertahap dan mendistribusikan ke sejumlah kolom yang diminta, secara otomatis memasukkan page break jika diperlukan. Perlu diperhatikan bahwa saat instance TextColumns aktif sebagai context manager, gaya teks dan properti font lainnya dapat diubah. Perubahan tersebut akan dibatasi sesuai pada context dalam context manager. Setelah ditutup, pengaturan sebelumnya akan dikembalikan.

Panduan ini akan menjelaskan tentang cara membuat dua tabel berbeda dengan beberapa penyesuaian sederhana.

Hasil PDF - Data CSV Negara-negara

Contoh pertama dapat dicapai dengan cara yang mudah, yaitu memasukkan data ke FPDF.table(). Hasil yang didapatkan memang sangat simpel, tetapi sangat cepat untuk dibuat.

Tabel kedua menghadirkan beberapa perbaikan: warna, lebar tabel yang dibatasi, tinggi baris yang berkurang, judul dengan rata tengah, kolom dengan lebar custom, gambar yang rata kanan... Selain itu, garis horizontal telah dihapus. Hal ini dilakukan dengan memilih border_layout di antara nilai yang tersedia: TableBordersLayout.

Dalam panduan ini akan dijelaskan beberapa cara untuk menyisipkan tautan di dalam dokumen PDF, serta menambahkan tautan ke sumber eksternal.

Panduan ini juga akan menunjukkan beberapa cara untuk menggunakan gaya teks yang berbeda, (tebal, miring, garis bawah) dalam teks yang sama.

Hasil PDF - Logo fpdf2

Method baru yang ditunjukkan disini untuk mencetak teks adalah write() . Ini sangat mirip dengan multi_cell() , perbedaan utamanya adalah:

Oleh karena itu, method ini dapat digunakan untuk menulis sepotong teks, mengubah gaya font, dan melanjutkan dari tempat yang sama persis dengan tempat terakhir kursor berhenti. Di sisi lain, kelemahan utamanya adalah kita tidak bisa membuat teks rata kiri dan kanan seperti saat menggunakan method multi_cell().

Pada halaman pertama contoh, kita menggunakan write(). Awal kalimat ditulis dalam gaya teks biasa, kemudian menggunakan method set_font(), kita ganti menggunakan garis bawah dan mengakhiri kalimatnya.

Untuk menambahkan tautan internal yang mengarah ke halaman kedua, kita dapat menggunakan method add_link(), yang membuat area yang dapat diklik yang biasa disebut "link" yang mengarah ke halaman lain dalam dokumen.

Untuk membuat tautan eksternal menggunakan gambar, kita dapat menggunakan image(). Method ini mempunyai opsi untuk passing tautan sebagai salah satu argumennya. Tautan tersebut dapat berupa tautan internal atau eksternal.

Sebagai alternatif, opsi lain untuk mengubah gaya font dan menambahkan tautan adalah dengan menggunakan method write_html(). Method tersebut merupakan parser HTML yang dapat menambahkan teks, mengubah gaya font, dan menambahkan tautan menggunakan HTML.

**Examples:**

Example 1 (python):
```python
from fpdf import FPDF

pdf = FPDF()
pdf.add_page()
pdf.set_font("helvetica", style="B", size=16)
pdf.cell(40, 10, "Hello World!")
pdf.output("tuto1.pdf")
```

Example 2 (unknown):
```unknown
pdf = FPDF(orientation="P", unit="mm", format="A4")
```

Example 3 (unknown):
```unknown
pdf.set_font('Helvetica', style='B', size=16)
```

Example 4 (unknown):
```unknown
pdf.cell(40, 10, 'Hello World!', 1)
```

---

## Hello World with fpdf2¬∂

**URL:** https://py-pdf.github.io/fpdf2/notebook.html

**Contents:**
- Hello World with fpdf2¬∂

This Jupyter notebook demontrates some basic usage of the Python fpdf2 library

To continue learning about fpdf2, check our tutorial: - English - Deutsch - espa√±ol - ‡§π‡§ø‡§Ç‡§¶‡•Ä - portugu√™s - –†—É—Å—Å–∫–∏–π - Italian - fran√ßais - ŒïŒªŒªŒ∑ŒΩŒπŒ∫Œ¨ - ◊¢◊ë◊®◊ô◊™ - Dutch - Polski - T√ºrk√ße - Indonesian

**Examples:**

Example 1 (markdown):
```markdown
# Installation of fpdf2 with PIP:
!pip install fpdf2
```

Example 2 (python):
```python
# Enable deprecation warnings:
import warnings
warnings.simplefilter('default', DeprecationWarning)
```

Example 3 (python):
```python
# Generate a PDF:
from fpdf import FPDF
pdf = FPDF()
pdf.add_page()
pdf.set_font('helvetica', size=48)
pdf.cell(text="hello world")
pdf_bytes = pdf.output()
```

Example 4 (python):
```python
# Display the PDF in the notebook by embedding it as HTML content:
WIDTH, HEIGHT = 800, 400 
from base64 import b64encode
from IPython.display import display, HTML
base64_pdf = b64encode(pdf_bytes).decode("utf-8")
display(HTML(f'<embed height="{HEIGHT}" src="data:application/pdf;base64,{base64_pdf}" type="application/pdf" width="{WIDTH}"/>'))
```

---

## Tutorial¬∂

**URL:** https://py-pdf.github.io/fpdf2/Tutorial-es.html

**Contents:**
- Tutorial¬∂
- Tutorial 1 - Ejemplo b√°sico¬∂
- Tutorial 2 - Encabezado, pie de p√°gina, salto de p√°gina e imagen¬∂
- Tutorial 3 - Saltos de l√≠nea y colores¬∂
- Tutorial 4 - M√∫ltiples columnas¬∂
- Tutorial 5 - Creando tablas¬∂
- Tutorial 6 - Creando enlaces y combinando estilos de texto¬∂
- Tutorial 7 - Creando documentos PDF/A¬∂
  - Est√°ndares PDF/A¬∂
  - Clases de Conformidad¬∂

Documentaci√≥n completa de los m√©todos: Documentaci√≥n de la API de fpdf.FPDF

Empecemos con el ejemplo cl√°sico:

Luego de incluir la biblioteca, creamos un objeto FPDF. El constructor FPDF es usado aqu√≠ con los valores predeterminados: Las p√°ginas est√°n en A4 vertical y la unidad de medida es mil√≠metros. Podr√≠a haberse especificado expl√≠citamente con:

Es posible configurar el PDF en modo horizontal (L) o usar otros formatos de p√°gina como carta (Letter) y oficio (Legal) y unidades de medida (pt, cm, in).

Por el momento no hay una p√°gina, entonces tenemos que agregar una con add_page. El origen es la esquina superior izquierda y la posici√≥n actual est√° ubicada por defecto a 1 cm de los bordes; los m√°rgenes pueden ser cambiados con set_margins.

Antes de que podamos imprimir texto, es obligatorio seleccionar una fuente con set_font, de lo contrario, el documento ser√≠a inv√°lido. Elegimos helvetica en negrita 16:

Podr√≠amos haber especificado cursiva con I, subrayado con U o fuente regular con una cadena de texto vac√≠a (o cualquier combinaci√≥n). Nota que el tama√±o de la fuente es dado en puntos, no en mil√≠metros (u otra unidad de medida del usuario); √©sta es la √∫nica excepci√≥n. Las otras fuentes est√°ndar son Times, Courier, Symbol y ZapfDingbats.

Podemos ahora imprimir una celda con cell. Una celda es un √°rea rectangular, posiblemente enmarcada, que contiene alg√∫n texto. Se imprime en la posici√≥n actual. Especificamos sus dimensiones, su texto (centrado o alineado), si los bordes deber√≠an ser dibujados, y a donde la posici√≥n actual se mueve despu√©s (a la derecha, abajo o al principio de la pr√≥xima linea). Para agregar un marco, haremos esto:

Para agregar una nueva celda pr√≥xima a √©l, con texto centrado y luego ir a la siguiente l√≠nea, har√≠amos:

Nota: el salto de l√≠nea puede hacerse tambi√©n con ln. Este m√©todo permite especificar adicionalmente la altura del salto.

Finalmente, el documento es cerrado y guardado en la ruta provista usando output. Sin ning√∫n par√°metro provisto, output() devuelve el b√∫fer bytearray del PDF.

Aqu√≠ hay un ejemplo de dos p√°ginas con encabezado, pie de p√°gina y logo:

Este ejemplo hace uso de los m√©todos header y footer para procesar encabezados y pies de p√°gina. Estos son invocados autom√°ticamente. Ellos ya existen en la clase FPDF pero no hacen nada, por lo tanto tenemos que extender la clase y sobreescribirlos.

El logo es impreso con el m√©todo image especificando su esquina superior izquierda y su ancho. La altura es calculada autom√°ticamente para respetar las proporciones de la imagen.

Para imprimir el n√∫mero de p√°gina, un valor nulo es pasado como ancho de celda. Esto significa que la celda deber√° ser extendida hasta el margen derecho de la p√°gina; es √∫til para centrar texto. El n√∫mero de p√°gina actual es devuelto por el m√©todo page_no; respecto al n√∫mero total de p√°ginas, √©ste es obtenido mediante el valor especial {nb} que ser√° sustituido al cerrar el documento (este valor especial puede ser cambiado con alias_nb_pages()). Nota el uso del m√©todo set_y que permite establecer la posici√≥n en una ubicaci√≥n absoluta en la p√°gina, empezando desde arriba o desde abajo.

Otra caracter√≠stica interesante es usada aqu√≠: el salto de p√°gina autom√°tico. Tan pronto como una celda cruzar√≠a el l√≠mite de la p√°gina (por defecto a 2 cent√≠metros del borde inferior), un salto es realizado y la fuente es restaurada. Aunque el encabezado y pie de p√°gina tienen su propia fuente (helvetica), el cuerpo contin√∫a en Times. Este mecanismo de restauraci√≥n autom√°tica tambi√©n se aplica a los colores y al ancho de la l√≠nea. El l√≠mite que dispara los saltos de p√°gina puede establecerse con set_auto_page_break.

Continuemos con un ejemplo que imprime p√°rrafos justificados. Tambi√©n ilustra el uso de colores.

El m√©todo get_string_width permite determinar la longitud de una cadena de texto en la fuente actual, usada aqu√≠ para calcular la posici√≥n y el ancho del marco que rodea al t√≠tulo. Los colores son establecidos (v√≠a set_draw_color, set_fill_color y set_text_color) y el grosor de la l√≠nea es establecido a 1 mm (contra 0.2 por defecto) con set_line_width. Finalmente, emitimos la celda (el √∫ltimo par√°metro en True para indicar que el fondo debe ser rellenado).

El m√©todo usado para imprimir p√°rrafos es multi_cell. El texto es justificado por defecto. Cada vez que una l√≠nea alcanza el extremo derecho de la celda o un caracter de retorno de l√≠nea (\n) es encontrado, un salto de l√≠nea es emitido y una nueva celda es autom√°ticamente creada bajo la actual. Un salto autom√°tico es realizado en la ubicaci√≥n del espacio o gui√≥n suave (\u00ad) m√°s cercano antes del l√≠mite derecho. Un gui√≥n suave ser√° reemplazado por un gui√≥n normal cuando un salto de l√≠nea se dispara, e ignorado en cualquier otro caso.

Dos propiedades del documento son definidas: el t√≠tulo (set_title) y el autor (set_author). Las propiedades pueden ser vistas de dos formas. La primera es abrir el documento directamente con Acrobat Reader, ir al men√∫ Archivo y elegir la opci√≥n Propiedades del Documento. La segunda, tambi√©n disponible desde el complemento, es hacer clic derecho y seleccionar Propiedades del documento.

Este ejemplo es una variante del anterior, mostrando c√≥mo poner el texto en m√∫ltiples columnas.

La diferencia clave respecto al tutorial anterior es el uso del m√©todo text_columns. Este recoge todo el texto, posiblemente en incrementos, y lo distribuye entre el n√∫mero de columnas solicitadas, insertando autom√°ticamente saltos de p√°gina seg√∫n sea necesario. Nota que mientras la instancia de TextColumns est√° activa como gestor de contexto, los estilos de texto y otras propiedades de la fuente pueden cambiarse. Estos cambios estar√°n contenidos en el contexto. Una vez se cierre, la configuraci√≥n previa ser√° reestablecida.

Este tutorial explicar√° c√≥mo crear dos tablas diferentes, para demostrar lo que se puede lograr con algunos ajustes simples.

PDF resultante - Archivo de texto con pa√≠ses

El primer ejemplo es alcanzado de la forma m√°s b√°sica posible, alimentando datos a FPDF.table(). El resultado es rudimentario pero muy r√°pido de obtener.

La segunda tabla trae algunas mejoras: colores, ancho de tabla limitado, altura de l√≠nea reducida, t√≠tulos centrados, columnas con anchos personalizados, figuras alineadas a la derecha... A√∫n m√°s, las l√≠neas horizontales han sido removidas. Esto se hizo escogiendo un borders_layout entre los valores disponibles: TableBordersLayout.

Este tutorial explicar√° varias formas de insertar enlaces dentro de un documento pdf, al igual que c√≥mo agregar enlaces a recursos externos.

Tambi√©n mostrar√° muchas formas en que podemos usar los diferentes estilos de texto (negrita, cursiva, subrayado) dentro del mismo texto.

PDF resultante - Logo de fpdf2

El nuevo m√©todo mostrado aqu√≠ para imprimir texto es write() . Es muy similar a multi_cell() , siendo las diferencias clave:

El m√©todo por tanto nos permite escribir un trozo de texto, alterar el estilo de la fuente, y continuar desde el lugar exacto donde quedamos. Por otro lado, su principal desventaja es que no podemos justificar el texto como hacemos con el m√©todo multi_cell().

En la primera p√°gina del ejemplo usamos write() para este prop√≥sito. El comienzo de la oraci√≥n est√° escrito usando texto en estilo regular, luego usando el m√©todo set_font() cambiamos a subrayado y terminamos la oraci√≥n.

Para agregar un enlace interno apuntando a la segunda p√°gina, usamos el m√©todo add_link() , el cual crea un √°rea clicable a la que nombramos "link" que redirige a otro lugar dentro del documento.

Para crear un enlace externo usando una imagen, usamos image() . El m√©todo tiene la opci√≥n de recibir un enlace como uno de sus argumentos. El enlace puede ser tanto interno como externo.

Como alternativa, otra opci√≥n para cambiar el estilo de fuente y agregar enlaces es usar el m√©todo write_html(). Este es un analizador de html que permite agregar texto, cambiar el estilo de fuente y agregar enlaces usando html.

PDF/A-1 usa PDF versi√≥n 1.4. Todos los recursos (im√°genes, gr√°ficos, fuentes) deben ser incrustados en el documento. El manejo del color debe ser preciso y especificado de forma independiente de la plataforma con perfiles ICC y los metadatos del documento deben darse con metadatos XMP.

PDF/A-2 usa PDF versi√≥n 1.7. Permite compresi√≥n con JPEG2000, elementos transparentes, fuentes open type y firmas digitales.

La √∫nica adici√≥n en PDF/A-3 es la posibilidad de incrustar cualquier archivo posible.

El nivel A (accesible) incluye todos los requerimientos del est√°ndar, incluidos el mapeo de la estructura de contenido y el orden correcto de lectura del contenido del documento. El contenido de texto debe ser extra√≠ble, y la estructura debe reflejar la secuencia de lectura natural.

El nivel B (b√°sico) garantiza una reproducibilidad visual clara del contenido. El nivel B es generalmente m√°s f√°cil de generar que el nivel A, pero no asegura en un ciento por ciento la extracci√≥n del texto o la buscabilidad. El re√∫so sin complicaciones del contenido no est√° necesariamente garantizado.

Para lograr esto, aqu√≠ hay un peque√±o ejemplo:

PDF resultante: tuto7.pdf

Herramientas como VeraPDF pueden verificar la conformidad de los documentos PDF producidos:

**Examples:**

Example 1 (python):
```python
from fpdf import FPDF

pdf = FPDF()
pdf.add_page()
pdf.set_font("helvetica", style="B", size=16)
pdf.cell(40, 10, "Hello World!")
pdf.output("tuto1.pdf")
```

Example 2 (unknown):
```unknown
pdf = FPDF(orientation="P", unit="mm", format="A4")
```

Example 3 (unknown):
```unknown
pdf.set_font('Helvetica', style='B', size=16)
```

Example 4 (unknown):
```unknown
pdf.cell(40, 10, '¬°Hola mundo!', 1)
```

---

## Module fpdf.pattern

**URL:** https://py-pdf.github.io/fpdf2/fpdf/pattern.html

**Contents:**
- Module fpdf.pattern
- Functions
- Classes
  - Ancestors
  - Subclasses
  - Methods
- Args
  - Ancestors
  - Methods
  - Ancestors

Handles the creation of patterns and gradients

Usage documentation at: https://py-pdf.github.io/fpdf2/Patterns.html

Return [(u, a)] with a‚àà[0,1]; missing alpha => 1.0.

Clamp/sort/merge, ensure endpoints at 0 and 1, coerce to single Device* colorspace.

When return_raw is true, also returns a list of the original stop positions (prior to clamping to [0,1]) converted to the same device colorspace. The raw offsets are sorted and merged (last stop wins for near-duplicates) but no implicit 0/1 endpoints are synthesized.

Piecewise-linear sampling in [0,1]. Assumes normalized/sorted stops incl. endpoints.

Create a linear gradient for a shape with SVG-like stops (offset in [0,1]). REPEAT/REFLECT are implemented by expanding stops to cover the bbox projection.

Create a radial gradient for a shape with SVG-like stops (offset in [0,1]). - (cx, cy, r): outer circle - (fx, fy, fr): focal/inner circle (defaults to center with radius 0) REPEAT/REFLECT are implemented by expanding stops to cover the bbox projection.

Approximate a sweep (conic) gradient as a Type 4 mesh (triangles). We build a full 0..2œÄ fan so PAD/REPEAT/REFLECT outside [0,1] are respected. Angles are expected in radians.

Map u‚ààR -> [0,1] via PAD/REPEAT/REFLECT.

Helper class that provides a standard way to create an ABC using inheritance.

Grayscale Shading object representing the alpha ramp (for a soft mask).

True if any stop carries alpha != 1.0.

Helper class that provides a standard way to create an ABC using inheritance.

A shading pattern that creates a linear (axial) gradient in a PDF.

The gradient is defined by two points: (from_x, from_y) and (to_x, to_y), along which the specified colors are interpolated. Optionally, you can set a background color, extend the gradient beyond its start or end, and specify custom color stop positions via bounds.

Inherited from: Gradient.get_alpha_shading_object

Grayscale Shading object representing the alpha ramp (for a soft mask).

Inherited from: Gradient.has_alpha

True if any stop carries alpha != 1.0.

PDF Shading type 4 (free-form Gouraud triangle mesh) with per-vertex colors.

Type-4 mesh shadings don't use Function objects; return empty list for output.

Inherited from: PDFContentStream.content_stream

Subclasses can override this method to indicate the presence of a content stream

Inherited from: PDFContentStream.serialize

Serialize the PDF object as an obj<</>>endobj text block

Represents a PDF Pattern object.

Currently, this class supports only "shading patterns" (pattern_type 2), using either a linear or radial gradient. Tiling patterns (pattern_type 1) are not yet implemented.

Inherited from: PDFObject.content_stream

Subclasses can override this method to indicate the presence of a content stream

Inherited from: PDFObject.serialize

Serialize the PDF object as an obj<</>>endobj text block

Helper class that provides a standard way to create an ABC using inheritance.

A shading pattern that creates a radial (or circular/elliptical) gradient in a PDF.

The gradient is defined by two circles (start and end). Colors are blended from the start circle to the end circle, forming a radial gradient. You can optionally set a background color, extend the gradient beyond its circles, and provide custom color stop positions via bounds.

Inherited from: Gradient.get_alpha_shading_object

Grayscale Shading object representing the alpha ramp (for a soft mask).

Inherited from: Gradient.has_alpha

True if any stop carries alpha != 1.0.

Reference to the top-level function object for the shading dictionary.

Inherited from: PDFObject.content_stream

Subclasses can override this method to indicate the presence of a content stream

All function objects used by this shading (Type2 segments + final Type3).

Return self, as this is already a shading object.

Inherited from: PDFObject.serialize

Serialize the PDF object as an obj<</>>endobj text block

Conic/sweep gradient that materializes as a type-4 (mesh) Shading. Build is bbox-dependent, so we create the shading lazily at emit time.

Inherited from: PDFObject.content_stream

Subclasses can override this method to indicate the presence of a content stream

Inherited from: PDFObject.serialize

Serialize the PDF object as an obj<</>>endobj text block

Transition between 2 colors

Inherited from: PDFObject.content_stream

Subclasses can override this method to indicate the presence of a content stream

Inherited from: PDFObject.serialize

Serialize the PDF object as an obj<</>>endobj text block

1‚Äëchannel exponential interpolation for alpha/luminance ramps.

Inherited from: PDFObject.content_stream

Subclasses can override this method to indicate the presence of a content stream

Inherited from: PDFObject.serialize

Serialize the PDF object as an obj<</>>endobj text block

When multiple colors are used, a type 3 function is necessary to stitch type 2 functions together and define the bounds between each color transition

Inherited from: PDFObject.content_stream

Subclasses can override this method to indicate the presence of a content stream

Inherited from: PDFObject.serialize

Serialize the PDF object as an obj<</>>endobj text block

**Examples:**

Example 1 (python):
```python
def extract_alpha_stops(
    stops01: list[tuple[float, Color]],
) -> list[tuple[float, float]]:
    """Return [(u, a)] with a‚àà[0,1]; missing alpha => 1.0."""
    out: list[tuple[float, float]] = []
    for u, c in stops01:
        a = getattr(c, "a", None)
        out.append((u, 1.0 if a is None else float(a)))
    return out
```

Example 2 (python):
```python
def lerp(a: float, b: float, t: float) -> float:
    return a + (b - a) * t
```

Example 3 (python):
```python
def lerp_tuple(
    a: tuple[float, ...], b: tuple[float, ...], t: float
) -> tuple[float, ...]:
    if len(a) != len(b):
        raise ValueError("Mismatched color component counts")
    return tuple(lerp(a[i], b[i], t) for i in range(len(a)))
```

Example 4 (python):
```python
def merge_near_duplicates(
    pairs: Sequence[tuple[float, Union[Color, str]]],
) -> Sequence[tuple[float, Union[Color, str]]]:
    out: list[tuple[float, Union[Color, str]]] = []
    for u, col in pairs:
        if out and abs(out[-1][0] - u) <= TOLERANCE:
            prev_u, prev_col = out[-1]
            if prev_col == col:
                # identical color: keep the newest sample
                out[-1] = (u, col)
                continue

            step = max(TOLERANCE * 10, 1e-6)
            nudged_prev = prev_u - step
            if nudged_prev >= -TOLERANCE:
                out[-1] = (nudged_prev, prev_col)
                out.append((u, col))
            else:
                nudged = u + step
                if nudged > 1.0:
                    nudged = 1.0
                    out[-1] = (max(0.0, min(prev_u, nudged - step)), prev_col)
                else:
                    out[-1] = (prev_u, prev_col)
                out.append((nudged, col))
        else:
            out.append((u, col))
    return out
```

---

## Development¬∂

**URL:** https://py-pdf.github.io/fpdf2/Development.html

**Contents:**
- Development¬∂
- Repository structure¬∂
  - Deprecation policy¬∂
- Installing fpdf2 from a local git repository¬∂
- Code auto-formatting¬∂
- Linting¬∂
- Static typing¬∂
- Pre-commit hook¬∂
- Testing¬∂
  - Running tests¬∂

This page has summary information about developing the fpdf2 library.

We aim to keep public behaviour stable for as long as possible, so removals go through a staged process.

Method deprecation - Document the deprecation directly in the docstring using a .. deprecated:: directive. - Emit a DeprecationWarning, while still executing a compatible code path when feasible. - Example (from fpdf/fpdf.py):

Parameter deprecation - Step 1: Mark the parameter as deprecated in the documentation and emit a warning when it is supplied. - Step 2: After a few releases, add the @deprecated_parameter() decorator so that the argument disappears from the public signature and linters/IDEs flag its usage. - Step 3: Remove support for the parameter entirely, once it is safe with respect to backwards compatibility.

We try to leave generous time between these steps and only delete behaviour when absolutely necessary.

This will link the installed Python package to the repository location, basically meaning any changes to the code package will get reflected directly in your environment.

We use black as a code prettifier. This "uncomprimising Python code formatter" must be installed in your development environment in order to auto-format source code before any commit: pip install black black . # inside fpdf2 root directory

We use pylint as a static code analyzer to detect potential issues in the code. You can install & execute it by running those commands: pip install pylint pylint fpdf/ test/

In case of special "false positive" cases, checks can be disabled locally with #pylint disable=XXX code comments, or globally through the .pylintrc file.

Strict typing is enforced in CI with mypy and pyright (see pyproject.toml). Run them locally before pushing, or enable the pre-commit hook so they run automatically: pip install fpdf2[dev] mypy pyright

General guidelines: - Use # type: ignore[...] sparingly - Prefer real types over Any - Keep casts to unavoidable spots

This project uses git pre-commit hooks: https://pre-commit.com

Those hooks are configured in .pre-commit-config.yaml.

They are intended to abort your commit if pylint found issues or black detected non-properly formatted code. In the later case though, it will auto-format your code and you will just have to run git commit -a again.

To install pre-commit hooks on your computer, run: pip install pre-commit pre-commit install

To run tests, cd into fpdf2 repository, install the dependencies using pip install .[dev,test], and run pytest.

You may also need to install SWIG and Ghostscript, because they are dependencies for camelot, a library for table extraction in PDF that we test in test/table/test_table_extraction.py. Those tests will always be executed by the GitHub Actions pipeline, so you can also not bother installing those tools and skip those tests by running pytest -k "not camelot".

You can run a single test by executing: pytest -k function_name.

Alternatively, you can use Tox. It is self-documented in the tox.ini file in the repository. To run tests for all versions of Python, simply run tox. If you do not want to run tests for all versions of python, run tox -e py313 (or your version of Python).

If there are some failing tests after you made a code change, it is usually because there are difference between an expected PDF generated and the actual one produced.

Calling pytest -vv will display the difference of PDF source code between the expected & actual files, but that may be difficult to understand,

You can also have a look at the PDF files involved by navigating to the temporary test directory that is printed out during the test failure: =================================== FAILURES =================================== ____________________________ test_html_simple_table ____________________________ tmp_path = PosixPath('/tmp/pytest-of-runner/pytest-0/test_html_simple_table0')

This directory contains the actual & expected files, that you can vsualize to spot differences: $ ls /tmp/pytest-of-runner/pytest-0/test_html_simple_table0 actual.pdf actual_qpdf.pdf expected_qpdf.pdf

When a unit test generates a PDF, it is recommended to use the assert_pdf_equal utility function in order to validate the output. It relies on the very handy qpdf CLI program to generate a PDF that is easy to compare: annotated, strictly formatted, with uncompressed internal streams. You will need to have its binary in your $PATH, otherwise assert_pdf_equal will fall back to hash-based comparison.

All generated PDF files (including those processed by qpdf) will be stored in /tmp/pytest-of-USERNAME/pytest-current/NAME_OF_TEST/. By default, three last test runs will be saved and then automatically deleted, so you can check the output in case of a failed test.

In order to generate a "reference" PDF file, simply call assert_pdf_equal once with generate=True.

Next you can invoke pytest path/to/test.py to generate the file some_feature.pdf.

This script will build an serve a single HTML page containing all PDF references file modified on your current git branch, and render them side by side with the PDF file from the master branch, so that you can quickly scroll and check for visible differences:

First, try to write a really MINIMAL Python script that focus strictly on the performance point you are investigating. Try to choose the input dataset so that the script execution time is between 1 and 15 seconds.

Then, you can use cProfile to profile your code and produce a .pstats file: python -m cProfile -o profile.pstats script.py

Finally, you can quickly convert this .pstats file into a SVG flamegraph using flameprof: pip install flameprof flameprof profile.pstats > script-flamegraph.svg You will get something like this:

Source GitHub thread where this was produced: issue #907

A good way to track memory usage is to insert calls to fpdf.util.print_mem_usage() in the code you are investigating. This function will display the current process resident set size (RSS) which is currently, to the maintainer knowledge, one of the best way to get an accurate measure of Python scripts memory usage.

There is an example of using this function to track fpdf2 memory usage in this issue comment: issue #641. This thread also includes some tests of other libs & tools to track memory usage.

We try to have a small number of unit tests that ensure that the library performances do not degrade over time, when refactoring are made and new features added.

We have 2 test decorators to help with this:

As of fpdf2 v2.7.6, we only keep 3 non-regression performance tests:

A GitHub Actions pipeline is executed on every commit on the master branch, and for every Pull Request.

It performs all validation steps detailed above: code checking with black, static code analysis with pylint, unit tests... Pull Requests submitted must pass all those checks in order to be approved. Ask maintainers through comments if some errors in the pipeline seem obscure to you.

We use Renovate to detect dependency updates & create PRs for the Python dependencies / GitHub Actions / NPM dependencies that we use.

Its configuration file is renovate.json, and the full tool documentation is there: docs.renovatebot.com.

To debug issues with Renovate, it can be useful to invoke it locally using Docker, like this:

We also use zizmor as a GitHub Action to perform static analysis on our pipeline definition files.

In order to use zizmor locally:

typos is a handy CLI tool to detect & auto-fix typos in source files. Installation is relatively straightforward (read the docs).

This tool is invoked in the pre-commit hooks and in our CI pipeline.

If it fails, you should either:

The standalone documentation is in the docs/ subfolder, written in Markdown.

After being committed to the master branch, documentation is automatically uploaded to GitHub Pages.

Building instructions are contained in .github/workflows/continuous-integration-workflow.yml.

Configuration file: mkdocs.yml

To preview the documentation, launch a local rendering server with:

Configuration file: docs/pdoc/config.mako

It is generated from inline comments, and is available on the API page.

There is a useful one-page example Python module with docstrings illustrating how to document code: pdoc3 example_pkg.

To preview the API documentation, launch a local rendering server with:

The PDF 1.7 spec is available on Adobe website: PDF32000_2008.pdf.

The PDF 2.0 spec is available on the Adobe website or on the PDF Association website.

It may be intimidating at first, but while technical, it is usually quite clear and understandable.

It is also a great place to look for new features for fpdf2: there are still many PDF features that this library does not support.

qpdf is a very powerful tool to analyze PDF documents.

One of it most useful features is the QDF mode that can convert any PDF file to a human-readable, decompressed & annotated new PDF document:

This is extremely useful to peek into the PDF document structure.

pdfly is a very handy CLI tool to manipulate PDF files: py-pdf/pdfly.

Those are some very useful commands:

A xref table is basically an index of the document internal sections. When manually modifying a PDF file (for example one produced by qpdf --qdf), if the characters count in any of its sections changes, the xref table must be rebuilt.

**Examples:**

Example 1 (swift):
```swift
def set_doc_option(self, opt, value):
    """
    Defines a document option.

    Args:
        opt (str): name of the option to set
        value (str): option value

    .. deprecated:: 2.4.0
        Simply set the `FPDF.core_fonts_encoding` property as a replacement.
    """
    warnings.warn(
        (
            "set_doc_option() is deprecated since v2.4.0 "
            "and will be removed in a future release. "
            "Simply set the `.core_fonts_encoding` property as a replacement."
        ),
        DeprecationWarning,
        stacklevel=get_stack_level(),
    )
    if opt != "core_fonts_encoding":
        raise FPDFException(f'Unknown document option "{opt}"')
    self.core_fonts_encoding = value
```

Example 2 (bash):
```bash
pip install --editable $path/to/fpdf/repo
```

Example 3 (unknown):
```unknown
pip install black
black .  # inside fpdf2 root directory
```

Example 4 (unknown):
```unknown
pip install pylint
pylint fpdf/ test/
```

---

## History¬∂

**URL:** https://py-pdf.github.io/fpdf2/History.html

**Contents:**
- History¬∂
- How fpdf2 came to be¬∂
- Compatibility between PyFPDF & fpdf2¬∂

This project, fpdf2 is a fork of the PyFPDF project, which can still be found on GitHub at reingart/pyfpdf, but has been totally inactive since January 2018, and has not seen any new release since 2015.

About the original PyFPDF lib:

This project started as a Python fork of the FPDF PHP library, ported to Python by Max Pat in 2006: http://www.fpdf.org/dl.php?id=94. The original FPDF library was developed in PHP several years ago, and has been ported to many programming languages: http://www.fpdf.org. Later, in the Python FPDF library, code for native reading TTF fonts was added. In 2008 it was moved from a SVN repository to git on Google Code by Mariano Reingart, who became the maintainer of FPDF. In 2013, it was migrated to GitHub: https://github.com/reingart/pyfpdf. You can still access the old issues, and old wiki, that were moved to a dedicated repository. The original roadmap can also still be found there: https://github.com/reingart/pyfpdf/wiki/Roadmap

During the spring of 2016, David Ankin (@alexanderankin) started a fork of PyFPDF, and added the first commit of what became fpdf2: bd608e4. On May of 2017, the first release of fpdf2 was published on Pypi: v2.0.0.

On 2020, the first PRs were merged from external contributors. At the end of the year, Lucas Cimon (@Lucas-C) started contributing several improvements, in order to use fpdf2 for his Undying Dusk project. Version 2.1.0 was released and on 2021/01/10 fpdf2 was moved to a dedicated PyFPDF GitHub organization, and @Lucas-C became another maintainer of the project.

On 2023/08/04, fpdf2 moved to the py-pdf organization: https://github.com/py-pdf/fpdf2. The context for this move can be found there: discussion #752. On this date, the PyFPDF GitHub organization has been archived. The same month, Georg Mischler (@gmischler) and Anderson Herzogenrath da Costa (@andersonhc) joined the project as new maintainers.

fpdf2 aims to be fully compatible with PyFPDF original code (fpdf==1.7.2).

The notable exceptions are:

Additionally, HTML rendering is not guaranteed to be identical regarding whitespace, especially since version 2.7.6 and the new set of classes introduced to manage text flow: Text Flow Regions

Some features are also deprecated. As of version 2.8.4 they still work but generate a warning when used:

Note that DeprecationWarning messages are not displayed by Python by default. To get warned about deprecated features used in your code, you must execute your scripts with the -Wd option (cf. documentation), or enable them programmatically with warnings.simplefilter('default', DeprecationWarning).

---

## Signing¬∂

**URL:** https://py-pdf.github.io/fpdf2/Signing.html

**Contents:**
- Signing¬∂

A digital signature may be used to authenticate the identity of a user and the document‚Äôs contents. It stores information about the signer and the state of the document when it was signed.

fpdf2 allows to sign documents using PKCS#12 certificates (RFC 7292).

The endesive package is required to do so.

The lower-level sign() method allows to add a signature based on arbitrary key & certificates, not necessarily from a PKCS#12 file.

endesive also provides basic code to check PDFs signatures. examples/pdf-verify.py or the check_signature() function used in fpdf2 unit tests can be good starting points for you, if you want to perform PDF signature control.

If you want to sign existing PDF documents, you should consider using PyHanko: https://pyhanko.readthedocs.io.

**Examples:**

Example 1 (unknown):
```unknown
pdf = FPDF()
pdf.add_page()
pdf.sign_pkcs12("certs.p12", password=b"1234")
pdf.output("signed_doc.pdf")
```

---

## Combine with Rough.js¬∂

**URL:** https://py-pdf.github.io/fpdf2/CombineWithRoughJS.html

**Contents:**
- Combine with Rough.js¬∂
- Producing SVG with Rough.js¬∂
- Embedding Rough.js SVG files¬∂

Rough.js is a small graphics library that lets you draw in a sketchy, hand-drawn-like, style. The library defines primitives to draw lines, curves, arcs, polygons, circles, and ellipses. It also supports drawing SVG paths.

Rough.js is able to produce SVG files that can then be embedded by fpdf2 (with some limitations regarding SVG support).

This documentation page will guide you on how to do so.

Because there is no Python port of Rough.js, this tutorial requires that you install Node.js & npm to be able to execute Javascript code.

First, install the required dependencies: npm install roughjs xmldom

Create some graphics using Rough.js API in Javascript. As a starting point, you can copy the following code in a gen-svg.mjs file: import { DOMImplementation, XMLSerializer } from "xmldom"; import roughjs from "roughjs/bundled/rough.cjs.js"; const { svg: roughSvg } = roughjs; // Creating <svg> element: const document = new DOMImplementation().createDocument("http://www.w3.org/1999/xhtml", "html", null); const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg"); svg.setAttribute("viewBox", "0 0 200 200"); // max-X = max-Y = 200 // Drawing rosace using Rough.js: const rc = roughSvg(svg); const center = {x: 100, y: 100} const bigRadius = 66, smallRadius = 50; const count = 12; const letters = "0123456789abcdef"; for (let i = 0; i < count; i++) { const randColor = '#' + [...Array(6)].map(_ => letters[Math.floor(Math.random() * 16)]).join(''); svg.appendChild(rc.circle(center.x + bigRadius*Math.cos(i * 2*Math.PI/count), center.y + bigRadius*Math.sin(i * 2*Math.PI/count), smallRadius, { fill: randColor })); } // Writing SVG to file: const xmlSerializer = new XMLSerializer(); await writeFile("graphics.svg", xmlSerializer.serializeToString(svg));

Then execute this code: node gen-svg.mjs

A graphics.svg file should be produced, similar to this one:

Alternatively, you can convert an existing SVG file to a Rough.js-sketchy version using for example svg2roughjs.

Nothing fancy there, just embedding a SVG image file as described on the SVG page: from fpdf import FPDF pdf = FPDF() pdf.add_page() pdf.image("docs/graphics.svg") pdf.output("graphics_svg.pdf") Result: graphics_svg.pdf

**Examples:**

Example 1 (unknown):
```unknown
npm install roughjs xmldom
```

Example 2 (javascript):
```javascript
import { DOMImplementation, XMLSerializer } from "xmldom";
import roughjs from "roughjs/bundled/rough.cjs.js";
const { svg: roughSvg } = roughjs;

// Creating <svg> element:
const document = new DOMImplementation().createDocument("http://www.w3.org/1999/xhtml", "html", null);
const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
svg.setAttribute("viewBox", "0 0 200 200");  // max-X = max-Y = 200

// Drawing rosace using Rough.js:
const rc = roughSvg(svg);
const center = {x: 100, y: 100}
const bigRadius = 66, smallRadius = 50;
const count = 12;
const letters = "0123456789abcdef";
for (let i = 0; i < count; i++) {
  const randColor = '#' + [...Array(6)].map(_ => letters[Math.floor(Math.random() * 16)]).join('');
  svg.appendChild(rc.circle(center.x + bigRadius*Math.cos(i * 2*Math.PI/count),
                            center.y + bigRadius*Math.sin(i * 2*Math.PI/count),
                            smallRadius, { fill: randColor }));
}

// Writing SVG to file:
const xmlSerializer = new XMLSerializer();
await writeFile("graphics.svg", xmlSerializer.serializeToString(svg));
```

Example 3 (unknown):
```unknown
node gen-svg.mjs
```

Example 4 (swift):
```swift
from fpdf import FPDF

pdf = FPDF()
pdf.add_page()
pdf.image("docs/graphics.svg")
pdf.output("graphics_svg.pdf")
```

---

## Text Flow Regions¬∂

**URL:** https://py-pdf.github.io/fpdf2/TextRegion.html

**Contents:**
- Text Flow Regions¬∂
- General Operation¬∂
  - Text Start Position¬∂
  - Interaction Between Regions¬∂
  - Common Parameters¬∂
  - Common Methods¬∂
- Paragraphs¬∂
  - Possible Future Extensions¬∂
- Images¬∂

Text regions are a hierarchy of classes that enable to flow text within a given outline. In the simplest case, it is just the running text column of a page. But it can also be a sequence of outlines, such as several parallel columns or the cells of a table. Other outlines may be combined by addition or subtraction to create more complex shapes.

There are two general categories of regions. One defines boundaries for running text that will just continue in the same manner one the next page. Those include columns and tables. The second category are distinct shapes. Examples would be a circle, a rectangle, a polygon of individual shape or even an image. They may be used individually, in combination, or to modify the outline of a multipage column. Shape regions will typically not cause a page break when they are full. In the future, a possibility to chain them may be implemented, so that a new shape will continue with the text that didn't fit into the previous one.

The currently implemented text regions are:

Other types like Table cells, shaped regions and combinations are still in the design phase, see Quo vadis, .write()?.

Using the different region types and combination always follows the same pattern. The main difference to the normal FPDF.write() method is that all added text will first be buffered, and only gets rendered on the page when the context of the region is closed. This is necessary so that text can be aligned within the given boundaries even if its font, style, or size are arbitrarily varied along the way.

The graphic shows the relationship of page, text areas and paragraphs (with varying alignment) for the example of a two-column layout.

When rendering, the vertical start position of the text will be at the lowest one out of:

The horizontal start position will be either at the current x position, if that lies within the boundaries of the region/column, or at the left edge of the region. In both horizontal and vertical positioning, regions with multiple columns may follow additional rules and restrictions.

Several region instances can exist at the same time. But only one of them can act as context manager at any given time. It is not currently possible to activate them recursively. But it is possible to use them intermittingly. This will probably most often make sense between a columnar region and a table or a graphic. You may have some running text ending at a given height, then insert a table/graphic, and finally continue the running text at the new height below the table within the existing column(s).

All types of text regions have the following constructor parameters in common:

All of those values can be overridden for each individual paragraph.

The primary purpose of paragraphs is to enable variations in horizontal text alignment, while the horizontal extents of the text are managed by the text region. To set the alignment, you can use the align argument when creating the paragraph. Valid values are defined in the Align enum.

For more typographical control, you can use the following arguments. Most of those override the settings of the current region when set, and default to the value set there.

Other than text regions, paragraphs should always be used as context managers and never be reused. Violating those rules may result in the entered text turning up on the page out of sequence.

Those features are currently not supported, but Pull Requests are welcome to implement them:

Most arguments for inserting images into text regions are the same as for the FPDF.image() method, and have the same or equivalent meaning.

Since the image will be placed automatically, the x and y parameters are not available. The positioning can be controlled with align, where the default is LEFT, with the alternatives RIGHT and CENTER.

If neither width nor height are specified, the image will be inserted with the size resulting from the PDF default resolution of 72 dpi. If the fill_width parameter is set to True, it increases the size to fill the full column width if necessary. If the image is wider than the column width, it will always be reduced in size proportionally.

The top_margin and bottom_margin parameters have the same effect as with text paragraphs.

---

## Module fpdf.sign

**URL:** https://py-pdf.github.io/fpdf2/fpdf/sign.html

**Contents:**
- Module fpdf.sign
- Functions
- Classes
  - Instance variables
  - Methods

Module dedicated to document signature generation.

The contents of this module are internal to fpdf2, and not part of the public API. They may change at any time without prior warning or any deprecation period, in non-backward-compatible ways.

Usage documentation at: https://py-pdf.github.io/fpdf2/Signing.html

Perform PDF signing based on the content of the buffer, performing substitutions on it. The signing operation does not alter the buffer size

Information provided by the signer to enable a recipient to contact the signer to verify the signature

The CPU host name or physical location of the signing

The reason for the signing

**Examples:**

Example 1 (python):
```python
def sign_content(
    signer: "signer",  # pyright: ignore[reportGeneralTypeIssues]
    buffer: bytearray,
    key: Optional["PrivateKeyTypes"],
    cert: "Certificate",
    extra_certs: list["Certificate"],
    hashalgo: str,
    sign_time: "datetime",
) -> bytearray:
    """
    Perform PDF signing based on the content of the buffer, performing substitutions on it.
    The signing operation does not alter the buffer size
    """
    # We start by substituting the ByteRange,
    # that defines which part of the document content the signature is based on.
    # This is basically ALL the content EXCEPT the signature content itself.
    sig_placeholder = _SIGNATURE_CONTENTS_PLACEHOLDER.encode("latin1")
    start_index = buffer.find(sig_placeholder)
    end_index = start_index + len(sig_placeholder)
    content_range = (0, start_index - 1, end_index + 1, len(buffer) - end_index - 1)
    # pylint: disable=consider-using-f-string
    buffer = buffer_subst(
        buffer,
        _SIGNATURE_BYTERANGE_PLACEHOLDER,
        "[%010d %010d %010d %010d]" % content_range,
    )

    # We compute the ByteRange hash, of everything before & after the placeholder:
    content_hash = hashlib.new(hashalgo)
    content_hash.update(buffer[: content_range[1]])  # before
    content_hash.update(buffer[content_range[2] :])  # after

    # This monkey-patching is needed, at the time of endesive v2.0.9,
    # to get control over signed_time, initialized by endesive.signer.sign() to be datetime.now():
    class mock_datetime:
        @staticmethod
        def now(tz: Any) -> "datetime":  # pylint: disable=unused-argument
            return sign_time.astimezone(timezone.utc)

    sign = patch("endesive.signer.datetime", mock_datetime)(signer.sign)

    contents = sign(
        datau=None,
        key=key,
        cert=cert,
        othercerts=extra_certs,
        hashalgo=hashalgo,
        attrs=True,
        signed_value=content_hash.digest(),
    )
    contents = _pkcs11_aligned(contents).encode("latin1")
    # Sanity check, otherwise we will break the xref table:
    assert len(sig_placeholder) == len(contents)
    return buffer.replace(sig_placeholder, contents, 1)
```

Example 2 (python):
```python
class Signature:
    def __init__(
        self,
        contact_info: Optional[str] = None,
        location: Optional[str] = None,
        m: Optional[PDFDate] = None,
        reason: Optional[str] = None,
    ) -> None:
        self.type = Name("Sig")
        self.filter = Name("Adobe.PPKLite")
        self.sub_filter = Name("adbe.pkcs7.detached")
        self.contact_info = contact_info
        "Information provided by the signer to enable a recipient to contact the signer to verify the signature"
        self.location = location
        "The CPU host name or physical location of the signing"
        self.m = m
        "The time of signing"
        self.reason = reason
        "The reason for the signing"
        self.byte_range = _SIGNATURE_BYTERANGE_PLACEHOLDER
        self.contents = "<" + _SIGNATURE_CONTENTS_PLACEHOLDER + ">"

    def serialize(
        self,
        _security_handler: Optional["StandardSecurityHandler"] = None,
        _obj_id: Optional[int] = None,
    ) -> str:
        obj_dict = build_obj_dict(
            {key: getattr(self, key) for key in dir(self)},
            _security_handler=_security_handler,
            _obj_id=_obj_id,
        )
        return pdf_dict(obj_dict)
```

Example 3 (python):
```python
def serialize(
    self,
    _security_handler: Optional["StandardSecurityHandler"] = None,
    _obj_id: Optional[int] = None,
) -> str:
    obj_dict = build_obj_dict(
        {key: getattr(self, key) for key in dir(self)},
        _security_handler=_security_handler,
        _obj_id=_obj_id,
    )
    return pdf_dict(obj_dict)
```

---

## –†—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ¬∂

**URL:** https://py-pdf.github.io/fpdf2/Tutorial-ru.html

**Contents:**
- –†—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ¬∂
- –†—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ 1 - –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –ø—Ä–∏–º–µ—Ä¬∂
- –†—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ 2 - –í–µ—Ä—Ö–Ω–∏–π –∫–æ–ª–æ–Ω—Ç–∏—Ç—É–ª, –Ω–∏–∂–Ω–∏–π –∫–æ–ª–æ–Ω—Ç–∏—Ç—É–ª, —Ä–∞–∑—Ä—ã–≤ —Å—Ç—Ä–∞–Ω–∏—Ü—ã –∏ –∫–∞—Ä—Ç–∏–Ω–∫–∞¬∂
- –†—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ 3 - –ü–µ—Ä–µ–Ω–æ—Å—ã —Å—Ç—Ä–æ–∫ –∏ —Ü–≤–µ—Ç–∞¬∂
- –†—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ 4 - –ù–µ—Å–∫–æ–ª—å–∫–æ –∫–æ–ª–æ–Ω–æ–∫¬∂
- –†—É–∫–æ–≤–¥—Å—Ç–≤–æ 5 - –°–æ–∑–¥–∞–Ω–∏–µ —Ç–∞–±–ª–∏—Ü¬∂
- –†—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ 6 - –°–æ–∑–¥–∞–Ω–∏–µ —Å—Å—ã–ª–æ–∫ –∏ —Å–º–µ—à–∏–≤–∞–Ω–∏–µ —Å—Ç–∏–ª–µ–π —Ç–µ–∫—Å—Ç–∞¬∂

–ü–æ–ª–Ω–∞—è –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è –ø–æ –º–µ—Ç–æ–¥–∞–º –∫–ª–∞—Å—Å–∞ FPDF: fpdf.FPDF API doc

–ù–∞—á–Ω—ë–º —Å –∫–ª–∞—Å—Å–∏—á–µ—Å–∫–æ–≥–æ –ø—Ä–∏–º–µ—Ä–∞:

–ü–æ—Å–ª–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ –º—ã —Å–æ–∑–¥–∞–µ–º –æ–±—ä–µ–∫—Ç FPDF. –ó–¥–µ—Å—å –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä FPDF —Å–æ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é: —Å—Ç—Ä–∞–Ω–∏—Ü—ã —Ñ–æ—Ä–º–∞—Ç–∞ A4 –ø–æ—Ä—Ç—Ä–µ—Ç–Ω—ã–µ, –µ–¥–∏–Ω–∏—Ü–∞ –∏–∑–º–µ—Ä–µ–Ω–∏—è - –º–∏–ª–ª–∏–º–µ—Ç—Ä.

–ú–æ–∂–Ω–æ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å PDF –≤ –∞–ª—å–±–æ–º–Ω–æ–º —Ä–µ–∂–∏–º–µ (L) –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –¥—Ä—É–≥–æ–π —Ñ–æ—Ä–º–∞—Ç —Å—Ç—Ä–∞–Ω–∏—Ü (–Ω–∞–ø—Ä–∏–º–µ—Ä, Letter –∏–ª–∏ Legal) –∏ –µ–¥–∏–Ω–∏—Ü—ã –∏–∑–º–µ—Ä–µ–Ω–∏—è (pt, cm, in).

–ù–∞ –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç —Å—Ç—Ä–∞–Ω–∏—Ü—ã –Ω–µ—Ç, –ø–æ—ç—Ç–æ–º—É –º—ã –¥–æ–ª–∂–Ω—ã –¥–æ–±–∞–≤–∏—Ç—å –µ–µ —Å –ø–æ–º–æ—â—å—é –∫–æ–º–∞–Ω–¥—ã add_page. –ù–∞—á–∞–ª–æ —Å—Ç—Ä–∞–Ω–∏—Ü—ã –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ –ª–µ–≤–æ–º –≤–µ—Ä—Ö–Ω–µ–º —É–≥–ª—É, –∞ —Ç–µ–∫—É—â–∞—è –ø–æ–∑–∏—Ü–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é —Ä–∞—Å–ø–æ–ª–∞–≥–∞–µ—Ç—Å—è –Ω–∞ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–∏ 1 —Å–º –æ—Ç –≥—Ä–∞–Ω–∏—Ü; –ø–æ–ª—è –º–æ–∂–Ω–æ –∏–∑–º–µ–Ω–∏—Ç—å —Å –ø–æ–º–æ—â—å—é –∫–æ–º–∞–Ω–¥—ã set_margins.

–ü—Ä–µ–∂–¥–µ —á–µ–º –º—ã —Å–º–æ–∂–µ–º –Ω–∞–ø–µ—á–∞—Ç–∞—Ç—å —Ç–µ–∫—Å—Ç, –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –Ω—É–∂–Ω–æ –≤—ã–±—Ä–∞—Ç—å —à—Ä–∏—Ñ—Ç —Å –ø–æ–º–æ—â—å—é set_font, –∏–Ω–∞—á–µ –¥–æ–∫—É–º–µ–Ω—Ç –±—É–¥–µ—Ç –Ω–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–º. –ú—ã –≤—ã–±–∏—Ä–∞–µ–º Helvetica bold 16:

–ú—ã –º–æ–∂–µ–º —É–∫–∞–∑–∞—Ç—å –∫—É—Ä—Å–∏–≤ —Å –ø–æ–º–æ—â—å—é I, –ø–æ–¥—á–µ—Ä–∫–Ω—É—Ç—ã–π —à—Ä–∏—Ñ—Ç —Å –ø–æ–º–æ—â—å—é U –∏–ª–∏ –æ–±—ã—á–Ω—ã–π —à—Ä–∏—Ñ—Ç —Å –ø–æ–º–æ—â—å—é –ø—É—Å—Ç–æ–π —Å—Ç—Ä–æ–∫–∏ (–∏–ª–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ª—é–±—É—é –∫–æ–º–±–∏–Ω–∞—Ü–∏—é). –û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ, —á—Ç–æ —Ä–∞–∑–º–µ—Ä —à—Ä–∏—Ñ—Ç–∞ –∑–∞–¥–∞–µ—Ç—Å—è –≤ –ø—É–Ω–∫—Ç–∞—Ö, –∞ –Ω–µ –≤ –º–∏–ª–ª–∏–º–µ—Ç—Ä–∞—Ö (–∏–ª–∏ –¥—Ä—É–≥–æ–π –µ–¥–∏–Ω–∏—Ü–µ –∏–∑–º–µ—Ä–µ–Ω–∏–π); —ç—Ç–æ –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω–æ–µ –∏—Å–∫–ª—é—á–µ–Ω–∏–µ. –î—Ä—É–≥–∏–µ –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–µ —à—Ä–∏—Ñ—Ç—ã: Times, Courier, Symbol –∏ ZapfDingbats.

–¢–µ–ø–µ—Ä—å –º—ã –º–æ–∂–µ–º —Ä–∞—Å–ø–µ—á–∞—Ç–∞—Ç—å —è—á–µ–π–∫—É —Å –ø–æ–º–æ—â—å—é cell. –Ø—á–µ–π–∫–∞ - —ç—Ç–æ –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∞—è –æ–±–ª–∞—Å—Ç—å, –≤–æ–∑–º–æ–∂–Ω–æ, –æ–±—Ä–∞–º–ª–µ–Ω–Ω–∞—è —Ä–∞–º–∫–æ–π, –∫–æ—Ç–æ—Ä–∞—è —Å–æ–¥–µ—Ä–∂–∏—Ç –Ω–µ–∫–æ—Ç–æ—Ä—ã–π —Ç–µ–∫—Å—Ç. –û–Ω–∞ –æ—Ç–æ–±—Ä–∞–∂–∞–µ—Ç—Å—è –≤ —Ç–µ–∫—É—â–µ–π –ø–æ–∑–∏—Ü–∏–∏. –ú—ã —É–∫–∞–∑—ã–≤–∞–µ–º –µ–µ —Ä–∞–∑–º–µ—Ä—ã, —Ç–µ–∫—Å—Ç (—Ü–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∏–ª–∏ –≤—ã—Ä–æ–≤–Ω–µ–Ω–Ω—ã–π), –¥–æ–ª–∂–Ω—ã –ª–∏ –±—ã—Ç—å –Ω–∞—Ä–∏—Å–æ–≤–∞–Ω—ã —Ä–∞–º–∫–∏, –∏ –∫—É–¥–∞ —Ç–µ–∫—É—â–∞—è –ø–æ–∑–∏—Ü–∏—è –ø–µ—Ä–µ–º–µ—â–∞–µ—Ç—Å—è –ø–æ—Å–ª–µ –Ω–µ–µ (–≤–ø—Ä–∞–≤–æ, –≤–Ω–∏–∑ –∏–ª–∏ –≤ –Ω–∞—á–∞–ª–æ —Å–ª–µ–¥—É—é—â–µ–π —Å—Ç—Ä–æ–∫–∏). –ß—Ç–æ–±—ã –¥–æ–±–∞–≤–∏—Ç—å —Ä–∞–º–∫—É, –º—ã —Å–¥–µ–ª–∞–µ–º —Å–ª–µ–¥—É—é—â–µ–µ:

–ß—Ç–æ–±—ã –¥–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤—É—é —è—á–µ–π–∫—É —Å —Ü–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–º —Ç–µ–∫—Å—Ç–æ–º –∏ –ø–µ—Ä–µ–π—Ç–∏ –∫ —Å–ª–µ–¥—É—é—â–µ–π —Å—Ç—Ä–æ–∫–µ, –º—ã —Å–¥–µ–ª–∞–µ–º —Å–ª–µ–¥—É—é—â–µ–µ:

–ü—Ä–∏–º–µ—á–∞–Ω–∏–µ: —Ä–∞–∑—Ä—ã–≤ —Å—Ç—Ä–æ–∫–∏ —Ç–∞–∫–∂–µ –º–æ–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å —Å –ø–æ–º–æ—â—å—é ln. –≠—Ç–æ—Ç –º–µ—Ç–æ–¥ –ø–æ–∑–≤–æ–ª—è–µ—Ç –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ —É–∫–∞–∑–∞—Ç—å –≤—ã—Å–æ—Ç—É —Ä–∞–∑—Ä—ã–≤–∞.

–ù–∞–∫–æ–Ω–µ—Ü, –¥–æ–∫—É–º–µ–Ω—Ç –∑–∞–∫—Ä—ã–≤–∞–µ—Ç—Å—è –∏ —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è –ø–æ —É–∫–∞–∑–∞–Ω–Ω–æ–º—É –ø—É—Ç–∏ –∫ —Ñ–∞–π–ª—É —Å –ø–æ–º–æ—â—å—é —Ñ—É–Ω–∫—Ü–∏–∏ output. –ë–µ–∑ —É–∫–∞–∑–∞–Ω–∏—è –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ output() –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –±—É—Ñ–µ—Ä PDF bytearray.

–ü—Ä–∏–º–µ—Ä –¥–≤—É—Ö —Å—Ç—Ä–∞–Ω–∏—Ü —Å –≤–µ—Ä—Ö–Ω–∏–º –∏ –Ω–∏–∂–Ω–∏–º –∫–æ–ª–æ–Ω—Ç–∏—Ç—É–ª–∞–º–∏ –∏ –ª–æ–≥–æ—Ç–∏–ø–æ–º:

–í —ç—Ç–æ–º –ø—Ä–∏–º–µ—Ä–µ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –º–µ—Ç–æ–¥—ã header –∏ footer –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤ –∏ –∫–æ–ª–æ–Ω—Ç–∏—Ç—É–ª–æ–≤ —Å—Ç—Ä–∞–Ω–∏—Ü—ã. –û–Ω–∏ –≤—ã–∑—ã–≤–∞—é—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏. –û–Ω–∏ —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É—é—Ç –≤ –∫–ª–∞—Å—Å–µ FPDF, –Ω–æ –Ω–∏—á–µ–≥–æ –Ω–µ –¥–µ–ª–∞—é—Ç, –ø–æ—ç—Ç–æ–º—É –º—ã –¥–æ–ª–∂–Ω—ã —Ä–∞—Å—à–∏—Ä–∏—Ç—å –∫–ª–∞—Å—Å –∏ –ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –∏—Ö.

–õ–æ–≥–æ—Ç–∏–ø –ø–µ—á–∞—Ç–∞–µ—Ç—Å—è –º–µ—Ç–æ–¥–æ–º image —Å —É–∫–∞–∑–∞–Ω–∏–µ–º –µ–≥–æ –ª–µ–≤–æ–≥–æ –≤–µ—Ä—Ö–Ω–µ–≥–æ —É–≥–ª–∞ –∏ —à–∏—Ä–∏–Ω—ã. –í—ã—Å–æ—Ç–∞ –≤—ã—á–∏—Å–ª—è–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏, —á—Ç–æ–±—ã —Å–æ–±–ª—é—Å—Ç–∏ –ø—Ä–æ–ø–æ—Ä—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è.

–î–ª—è –ø–µ—á–∞—Ç–∏ –Ω–æ–º–µ—Ä–∞ —Å—Ç—Ä–∞–Ω–∏—Ü—ã –≤ –∫–∞—á–µ—Å—Ç–≤–µ —à–∏—Ä–∏–Ω—ã —è—á–µ–π–∫–∏ –ø–µ—Ä–µ–¥–∞–µ—Ç—Å—è –Ω—É–ª–µ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ. –≠—Ç–æ –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ —è—á–µ–π–∫–∞ –¥–æ–ª–∂–Ω–∞ –ø—Ä–æ—Å—Ç–∏—Ä–∞—Ç—å—Å—è –¥–æ –ø—Ä–∞–≤–æ–≥–æ –ø–æ–ª—è —Å—Ç—Ä–∞–Ω–∏—Ü—ã; —ç—Ç–æ —É–¥–æ–±–Ω–æ –¥–ª—è —Ü–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∏—è —Ç–µ–∫—Å—Ç–∞. –ù–æ–º–µ—Ä —Ç–µ–∫—É—â–µ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è –º–µ—Ç–æ–¥–æ–º page_no; —á—Ç–æ –∫–∞—Å–∞–µ—Ç—Å—è –æ–±—â–µ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —Å—Ç—Ä–∞–Ω–∏—Ü, —Ç–æ –æ–Ω–æ –ø–æ–ª—É—á–∞–µ—Ç—Å—è —Å –ø–æ–º–æ—â—å—é —Å–ø–µ—Ü–∏–∞–ª—å–Ω–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è {nb}, –∫–æ—Ç–æ—Ä–æ–µ –±—É–¥–µ—Ç –ø–æ–¥—Å—Ç–∞–≤–ª–µ–Ω–æ –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏ –¥–æ–∫—É–º–µ–Ω—Ç–∞. –û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ –Ω–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –º–µ—Ç–æ–¥–∞ set_y, –∫–æ—Ç–æ—Ä—ã–π –ø–æ–∑–≤–æ–ª—è–µ—Ç —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø–æ–∑–∏—Ü–∏—é –≤ –∞–±—Å–æ–ª—é—Ç–Ω–æ–º –º–µ—Å—Ç–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã, –Ω–∞—á–∏–Ω–∞—è —Å–≤–µ—Ä—Ö—É –∏–ª–∏ —Å–Ω–∏–∑—É.

–ó–¥–µ—Å—å –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –µ—â–µ –æ–¥–Ω–∞ –∏–Ω—Ç–µ—Ä–µ—Å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è: –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π —Ä–∞–∑—Ä—ã–≤ —Å—Ç—Ä–∞–Ω–∏—Ü—ã. –ö–∞–∫ —Ç–æ–ª—å–∫–æ —è—á–µ–π–∫–∞ –ø–µ—Ä–µ—Å–µ–∫–∞–µ—Ç –≥—Ä–∞–Ω–∏—Ü—É —Å—Ç—Ä–∞–Ω–∏—Ü—ã (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 2 —Å–∞–Ω—Ç–∏–º–µ—Ç—Ä–∞ –æ—Ç –Ω–∏–∑–∞), –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç —Ä–∞–∑—Ä—ã–≤ –∏ —à—Ä–∏—Ñ—Ç –≤–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç—Å—è. –•–æ—Ç—è –≤–µ—Ä—Ö–Ω–∏–π –∏ –Ω–∏–∂–Ω–∏–π –∫–æ–ª–æ–Ω—Ç–∏—Ç—É–ª—ã –≤—ã–±–∏—Ä–∞—é—Ç —Å–≤–æ–π —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–π —à—Ä–∏—Ñ—Ç (helvetica), –æ—Å–Ω–æ–≤–Ω–∞—è —á–∞—Å—Ç—å –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å Times. –≠—Ç–æ—Ç –º–µ—Ö–∞–Ω–∏–∑–º –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è —Ç–∞–∫–∂–µ –ø—Ä–∏–º–µ–Ω—è–µ—Ç—Å—è –∫ —Ü–≤–µ—Ç–∞–º –∏ —à–∏—Ä–∏–Ω–µ –ª–∏–Ω–∏–π. –ü—Ä–µ–¥–µ–ª, –∫–æ—Ç–æ—Ä—ã–π –≤—ã–∑—ã–≤–∞–µ—Ç —Ä–∞–∑—Ä—ã–≤ —Å—Ç—Ä–∞–Ω–∏—Ü—ã, –º–æ–∂–Ω–æ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Å –ø–æ–º–æ—â—å—é set_auto_page_break.

–ü—Ä–æ–¥–æ–ª–∂–∏–º —Å –ø—Ä–∏–º–µ—Ä–∞, –∫–æ—Ç–æ—Ä—ã–π –ø–µ—á–∞—Ç–∞–µ—Ç –≤—ã—Ä–æ–≤–Ω–µ–Ω–Ω—ã–µ –∞–±–∑–∞—Ü—ã. –û–Ω —Ç–∞–∫–∂–µ –∏–ª–ª—é—Å—Ç—Ä–∏—Ä—É–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —Ü–≤–µ—Ç–æ–≤.

–ú–µ—Ç–æ–¥ get_string_width –ø–æ–∑–≤–æ–ª—è–µ—Ç –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –¥–ª–∏–Ω—É —Å—Ç—Ä–æ–∫–∏ –≤ —Ç–µ–∫—É—â–µ–º —à—Ä–∏—Ñ—Ç–µ, –∫–æ—Ç–æ—Ä–∞—è –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –∑–¥–µ—Å—å –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞ –ø–æ–ª–æ–∂–µ–Ω–∏—è –∏ —à–∏—Ä–∏–Ω—ã —Ä–∞–º–∫–∏, –æ–∫—Ä—É–∂–∞—é—â–µ–π –∑–∞–≥–æ–ª–æ–≤–æ–∫. –ó–∞—Ç–µ–º —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—é—Ç—Å—è —Ü–≤–µ—Ç–∞ (—á–µ—Ä–µ–∑ set_draw_color, set_fill_color –∏ set_text_color), –∞ —Ç–æ–ª—â–∏–Ω–∞ –ª–∏–Ω–∏–∏ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç—Å—è –≤ 1 –º–º (–ø—Ä–æ—Ç–∏–≤ 0,2 –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é) —Å –ø–æ–º–æ—â—å—é set_line_width. –ù–∞–∫–æ–Ω–µ—Ü, –º—ã –≤—ã–≤–æ–¥–∏–º —è—á–µ–π–∫—É (–ø–æ—Å–ª–µ–¥–Ω–∏–π –ø–∞—Ä–∞–º–µ—Ç—Ä True —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ —Ç–æ, —á—Ç–æ —Ñ–æ–Ω –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –∑–∞–ø–æ–ª–Ω–µ–Ω).

–î–ª—è –ø–µ—á–∞—Ç–∏ –∞–±–∑–∞—Ü–µ–≤ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –º–µ—Ç–æ–¥ multi_cell. –ö–∞–∂–¥—ã–π —Ä–∞–∑, –∫–æ–≥–¥–∞ —Å—Ç—Ä–æ–∫–∞ –¥–æ—Å—Ç–∏–≥–∞–µ—Ç –ø—Ä–∞–≤–æ–≥–æ –∫—Ä–∞—è —è—á–µ–π–∫–∏ –∏–ª–∏ –≤—Å—Ç—Ä–µ—á–∞–µ—Ç—Å—è —Å–∏–º–≤–æ–ª –≤–æ–∑–≤—Ä–∞—Ç–∞ –∫–∞—Ä–µ—Ç–∫–∏, –≤—ã–¥–∞–µ—Ç—Å—è —Ä–∞–∑—Ä—ã–≤ —Å—Ç—Ä–æ–∫–∏ –∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–æ–∑–¥–∞–µ—Ç—Å—è –Ω–æ–≤–∞—è —è—á–µ–π–∫–∞ –ø–æ–¥ —Ç–µ–∫—É—â–µ–π. –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é —Ç–µ–∫—Å—Ç –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–µ—Ç—Å—è –ø–æ —à–∏—Ä–∏–Ω–µ.

–û–ø—Ä–µ–¥–µ–ª–µ–Ω—ã –¥–≤–∞ —Å–≤–æ–π—Å—Ç–≤–∞ –¥–æ–∫—É–º–µ–Ω—Ç–∞: –∑–∞–≥–æ–ª–æ–≤–æ–∫ (set_title) –∏ –∞–≤—Ç–æ—Ä (set_author). –°–≤–æ–π—Å—Ç–≤–∞ –º–æ–∂–Ω–æ –ø—Ä–æ—Å–º–∞—Ç—Ä–∏–≤–∞—Ç—å –¥–≤—É–º—è —Å–ø–æ—Å–æ–±–∞–º–∏. –ü–µ—Ä–≤—ã–π - –æ—Ç–∫—Ä—ã—Ç—å –¥–æ–∫—É–º–µ–Ω—Ç –Ω–µ–ø–æ—Å—Ä–µ–¥—Å—Ç–≤–µ–Ω–Ω–æ —Å –ø–æ–º–æ—â—å—é Acrobat Reader, –ø–µ—Ä–µ–π—Ç–∏ –≤ –º–µ–Ω—é –§–∞–π–ª –∏ –≤—ã–±—Ä–∞—Ç—å –ø—É–Ω–∫—Ç –°–≤–æ–π—Å—Ç–≤–∞ –¥–æ–∫—É–º–µ–Ω—Ç–∞. –í—Ç–æ—Ä–æ–π, —Ç–∞–∫–∂–µ –¥–æ—Å—Ç—É–ø–Ω—ã–π –∏–∑ –ø–ª–∞–≥–∏–Ω–∞, - —â–µ–ª–∫–Ω—É—Ç—å –ø—Ä–∞–≤–æ–π –∫–Ω–æ–ø–∫–æ–π –º—ã—à–∏ –∏ –≤—ã–±—Ä–∞—Ç—å –ø—É–Ω–∫—Ç –°–≤–æ–π—Å—Ç–≤–∞ –¥–æ–∫—É–º–µ–Ω—Ç–∞.

–≠—Ç–æ—Ç –ø—Ä–∏–º–µ—Ä —è–≤–ª—è–µ—Ç—Å—è –≤–∞—Ä–∏–∞–Ω—Ç–æ–º –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ –∏ –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç, –∫–∞–∫ —Ä–∞—Å–ø–æ–ª–æ–∂–∏—Ç—å —Ç–µ–∫—Å—Ç –≤ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –∫–æ–ª–æ–Ω–∫–∞—Ö.

‚ö†Ô∏è This section has changed a lot and requires a new translation: https://github.com/py-pdf/fpdf2/issues/267

–ò—Ç–æ–≥–æ–≤—ã–π PDF - –°–ø–∏—Å–æ–∫ —Å—Ç—Ä–∞–Ω

‚ö†Ô∏è This section has changed a lot and requires a new translation: https://github.com/py-pdf/fpdf2/issues/267

–í —ç—Ç–æ–º —É—Ä–æ–∫–µ –±—É–¥–µ—Ç —Ä–∞—Å—Å–∫–∞–∑–∞–Ω–æ –æ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —Å–ø–æ—Å–æ–±–∞—Ö –≤—Å—Ç–∞–≤–∫–∏ —Å—Å—ã–ª–æ–∫ –≤–Ω—É—Ç—Ä–∏ pdf –¥–æ–∫—É–º–µ–Ω—Ç–∞, –∞ —Ç–∞–∫–∂–µ –æ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ —Å—Å—ã–ª–æ–∫ –Ω–∞ –≤–Ω–µ—à–Ω–∏–µ –∏—Å—Ç–æ—á–Ω–∏–∫–∏.

–¢–∞–∫–∂–µ –±—É–¥–µ—Ç –ø–æ–∫–∞–∑–∞–Ω–æ –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å–ø–æ—Å–æ–±–æ–≤ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —Ä–∞–∑–ª–∏—á–Ω—ã—Ö —Å—Ç–∏–ª–µ–π —Ç–µ–∫—Å—Ç–∞ (–∂–∏—Ä–Ω—ã–π, –∫—É—Ä—Å–∏–≤, –ø–æ–¥—á–µ—Ä–∫–∏–≤–∞–Ω–∏–µ) –≤ –æ–¥–Ω–æ–º –∏ —Ç–æ–º –∂–µ —Ç–µ–∫—Å—Ç–µ.

–ò—Ç–æ–≥–æ–≤—ã–π PDF - fpdf2-logo

–ù–æ–≤—ã–π –º–µ—Ç–æ–¥, –ø–æ–∫–∞–∑–∞–Ω–Ω—ã–π –∑–¥–µ—Å—å –¥–ª—è –ø–µ—á–∞—Ç–∏ —Ç–µ–∫—Å—Ç–∞ - —ç—Ç–æ write(). –û–Ω –æ—á–µ–Ω—å –ø–æ—Ö–æ–∂ –Ω–∞ multi_cell(), –æ—Å–Ω–æ–≤–Ω—ã–µ –æ—Ç–ª–∏—á–∏—è –∑–∞–∫–ª—é—á–∞—é—Ç—Å—è –≤ —Å–ª–µ–¥—É—é—â–µ–º:

–¢–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º, —ç—Ç–æ—Ç –º–µ—Ç–æ–¥ –ø–æ–∑–≤–æ–ª—è–µ—Ç –Ω–∞–º –Ω–∞–ø–∏—Å–∞—Ç—å —Ñ—Ä–∞–≥–º–µ–Ω—Ç —Ç–µ–∫—Å—Ç–∞, –∏–∑–º–µ–Ω–∏—Ç—å —Å—Ç–∏–ª—å —à—Ä–∏—Ñ—Ç–∞ –∏ –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å —Å —Ç–æ–≥–æ —Å–∞–º–æ–≥–æ –º–µ—Å—Ç–∞, –Ω–∞ –∫–æ—Ç–æ—Ä–æ–º –º—ã –æ—Å—Ç–∞–Ω–æ–≤–∏–ª–∏—Å—å. –° –¥—Ä—É–≥–æ–π —Å—Ç–æ—Ä–æ–Ω—ã, –µ–≥–æ –≥–ª–∞–≤–Ω—ã–π –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ–∫ –∑–∞–∫–ª—é—á–∞–µ—Ç—Å—è –≤ —Ç–æ–º, —á—Ç–æ –º—ã –Ω–µ –º–æ–∂–µ–º –≤—ã—Ä–æ–≤–Ω—è—Ç—å —Ç–µ–∫—Å—Ç, –∫–∞–∫ —ç—Ç–æ –¥–µ–ª–∞–µ—Ç—Å—è –ø—Ä–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–∏ –º–µ—Ç–æ–¥–∞ multi_cell().

–ù–∞ –ø–µ—Ä–≤–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü–µ –ø—Ä–∏–º–µ—Ä–∞ –º—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ –¥–ª—è —ç—Ç–æ–π —Ü–µ–ª–∏ write(). –ù–∞—á–∞–ª–æ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è –Ω–∞–ø–∏—Å–∞–Ω–æ —Ç–µ–∫—Å—Ç–æ–º –æ–±—ã—á–Ω–æ–≥–æ —Å—Ç–∏–ª—è, –∑–∞—Ç–µ–º, –∏—Å–ø–æ–ª—å–∑—É—è –º–µ—Ç–æ–¥ set_font(), –º—ã –ø–µ—Ä–µ–∫–ª—é—á–∏–ª–∏—Å—å –Ω–∞ –ø–æ–¥—á–µ—Ä–∫–∏–≤–∞–Ω–∏–µ –∏ –∑–∞–∫–æ–Ω—á–∏–ª–∏ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ.

–î–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–π —Å—Å—ã–ª–∫–∏, —É–∫–∞–∑—ã–≤–∞—é—â–µ–π –Ω–∞ –≤—Ç–æ—Ä—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É, –º—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ –º–µ—Ç–æ–¥ add_link(), –∫–æ—Ç–æ—Ä—ã–π —Å–æ–∑–¥–∞–µ—Ç –∫–ª–∏–∫–∞–±–µ–ª—å–Ω—É—é –æ–±–ª–∞—Å—Ç—å, –Ω–∞–∑–≤–∞–Ω–Ω—É—é –Ω–∞–º–∏ "link", –∫–æ—Ç–æ—Ä–∞—è –≤–µ–¥–µ—Ç –≤ –¥—Ä—É–≥–æ–µ –º–µ—Å—Ç–æ –≤–Ω—É—Ç—Ä–∏ –¥–æ–∫—É–º–µ–Ω—Ç–∞.

–ß—Ç–æ–±—ã —Å–æ–∑–¥–∞—Ç—å –≤–Ω–µ—à–Ω—é—é —Å—Å—ã–ª–∫—É —Å –ø–æ–º–æ—â—å—é –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è, –º—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ –º–µ—Ç–æ–¥ image(). –≠—Ç–æ—Ç –º–µ—Ç–æ–¥ –∏–º–µ–µ—Ç –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –ø–µ—Ä–µ–¥–∞—Ç—å —Å—Å—ã–ª–∫—É –≤ –∫–∞—á–µ—Å—Ç–≤–µ –æ–¥–Ω–æ–≥–æ –∏–∑ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤. –°—Å—ã–ª–∫–∞ –º–æ–∂–µ—Ç –±—ã—Ç—å –∫–∞–∫ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–π, —Ç–∞–∫ –∏ –≤–Ω–µ—à–Ω–µ–π.

–í –∫–∞—á–µ—Å—Ç–≤–µ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤—ã –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è —Å—Ç–∏–ª—è —à—Ä–∏—Ñ—Ç–∞ –∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —Å—Å—ã–ª–æ–∫ –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –º–µ—Ç–æ–¥ write_html(). –≠—Ç–æ –ø–∞—Ä—Å–µ—Ä html, –∫–æ—Ç–æ—Ä—ã–π –ø–æ–∑–≤–æ–ª—è–µ—Ç –¥–æ–±–∞–≤–ª—è—Ç—å —Ç–µ–∫—Å—Ç, –∏–∑–º–µ–Ω—è—Ç—å —Å—Ç–∏–ª—å —à—Ä–∏—Ñ—Ç–∞ –∏ –¥–æ–±–∞–≤–ª—è—Ç—å —Å—Å—ã–ª–∫–∏ —Å –ø–æ–º–æ—â—å—é html.

**Examples:**

Example 1 (python):
```python
from fpdf import FPDF

pdf = FPDF()
pdf.add_page()
pdf.set_font("helvetica", style="B", size=16)
pdf.cell(40, 10, "Hello World!")
pdf.output("tuto1.pdf")
```

Example 2 (unknown):
```unknown
pdf = FPDF(orientation="P", unit="mm", format="A4")
```

Example 3 (unknown):
```unknown
pdf.set_font('Helvetica', style='B', size=16)
```

Example 4 (unknown):
```unknown
pdf.cell(40, 10, 'Hello World!', 1)
```

---

## Module fpdf.table

**URL:** https://py-pdf.github.io/fpdf2/fpdf/table.html

**Contents:**
- Module fpdf.table
- Functions
- Classes
  - Instance variables
  - Methods
  - Instance variables
  - Methods
- Args
  - Instance variables
  - Instance variables

Usage documentation at: https://py-pdf.github.io/fpdf2/Tables.html

Draws a box using the provided style - private helper used by table for drawing the cell and table borders. Difference between this and rect() is that border can be defined as "L,R,T,B" to draw only some of the four borders; compatible with get_border(i,k)

Internal representation of a table cell

Object that Table.row() yields, used to build a row in a table

Adds a cell to the row.

RowLayoutInfo(height: float, pagebreak_height: float, rendered_heights: Dict[int, float], merged_heights: List[float])

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

RowSpanLayoutInfo(column: int, start: int, length: int, contents_height: float)

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

Object that FPDF.table() yields, used to build a table in the document. Detailed usage documentation: https://py-pdf.github.io/fpdf2/Tables.html

This is an internal method called by fpdf.FPDF.table() once the table is finished

Adds a row to the table. Returns a Row object.

**Examples:**

Example 1 (python):
```python
def draw_box_borders(
    pdf: "FPDF",
    x1: float,
    y1: float,
    x2: float,
    y2: float,
    border: str | Literal[0, 1],
    fill_color: Optional[DeviceCMYK | DeviceGray | DeviceRGB] = None,
) -> None:
    """Draws a box using the provided style - private helper used by table for drawing the cell and table borders.
    Difference between this and rect() is that border can be defined as "L,R,T,B" to draw only some of the four borders;
    compatible with get_border(i,k)

    See Also: rect()"""
    if fill_color:
        prev_fill_color = pdf.fill_color
        pdf.set_fill_color(fill_color)

    sl: list[str] = []

    k = pdf.k

    # y top to bottom instead of bottom to top
    y1 = pdf.h - y1
    y2 = pdf.h - y2

    # scale
    x1 *= k
    x2 *= k
    y2 *= k
    y1 *= k

    if isinstance(border, str) and set(border).issuperset("LTRB"):
        border = 1

    if fill_color:
        op = "B" if border == 1 else "f"
        sl.append(f"{x1:.2f} {y2:.2f} " f"{x2 - x1:.2f} {y1 - y2:.2f} re {op}")
    elif border == 1:
        sl.append(f"{x1:.2f} {y2:.2f} " f"{x2 - x1:.2f} {y1 - y2:.2f} re S")

    if isinstance(border, str):
        if "L" in border:
            sl.append(f"{x1:.2f} {y2:.2f} m " f"{x1:.2f} {y1:.2f} l S")
        if "B" in border:
            sl.append(f"{x1:.2f} {y2:.2f} m " f"{x2:.2f} {y2:.2f} l S")
        if "R" in border:
            sl.append(f"{x2:.2f} {y2:.2f} m " f"{x2:.2f} {y1:.2f} l S")
        if "T" in border:
            sl.append(f"{x1:.2f} {y1:.2f} m " f"{x2:.2f} {y1:.2f} l S")

    s = " ".join(sl)
    pdf._out(  # pyright: ignore[reportPrivateUsage] # pylint: disable=protected-access
        s
    )

    if fill_color:
        pdf.set_fill_color(prev_fill_color)  # type: ignore[arg-type]
```

Example 2 (python):
```python
@dataclass(frozen=True)
class Cell:
    "Internal representation of a table cell"

    __slots__ = (  # RAM usage optimization
        "text",
        "align",
        "v_align",
        "style",
        "img",
        "img_fill_width",
        "colspan",
        "rowspan",
        "padding",
        "link",
        "border",
    )
    text: str
    align: Optional[Union[str, Align]]
    v_align: Optional[Union[str, VAlign]]
    style: Optional[FontFace]
    img: Optional[ImageType]
    img_fill_width: bool
    colspan: int
    rowspan: int
    padding: Optional[float | Sequence[float] | Padding]
    link: Optional[Union[str, int]]
    border: CellBordersLayout

    def write(self, text: str, align: Optional[Align | str] = None) -> None:
        raise NotImplementedError("Not implemented yet")
```

Example 3 (python):
```python
@dataclass(frozen=True)
class Cell:
    "Internal representation of a table cell"

    __slots__ = (  # RAM usage optimization
        "text",
        "align",
        "v_align",
        "style",
        "img",
        "img_fill_width",
        "colspan",
        "rowspan",
        "padding",
        "link",
        "border",
    )
    text: str
    align: Optional[Union[str, Align]]
    v_align: Optional[Union[str, VAlign]]
    style: Optional[FontFace]
    img: Optional[ImageType]
    img_fill_width: bool
    colspan: int
    rowspan: int
    padding: Optional[float | Sequence[float] | Padding]
    link: Optional[Union[str, int]]
    border: CellBordersLayout

    def write(self, text: str, align: Optional[Align | str] = None) -> None:
        raise NotImplementedError("Not implemented yet")
```

Example 4 (python):
```python
@dataclass(frozen=True)
class Cell:
    "Internal representation of a table cell"

    __slots__ = (  # RAM usage optimization
        "text",
        "align",
        "v_align",
        "style",
        "img",
        "img_fill_width",
        "colspan",
        "rowspan",
        "padding",
        "link",
        "border",
    )
    text: str
    align: Optional[Union[str, Align]]
    v_align: Optional[Union[str, VAlign]]
    style: Optional[FontFace]
    img: Optional[ImageType]
    img_fill_width: bool
    colspan: int
    rowspan: int
    padding: Optional[float | Sequence[float] | Padding]
    link: Optional[Union[str, int]]
    border: CellBordersLayout

    def write(self, text: str, align: Optional[Align | str] = None) -> None:
        raise NotImplementedError("Not implemented yet")
```

---

## Module fpdf.fonts

**URL:** https://py-pdf.github.io/fpdf2/fpdf/fonts.html

**Contents:**
- Module fpdf.fonts
- Classes
  - Instance variables
  - Methods
  - Subclasses
  - Static methods
  - Instance variables
  - Methods
  - Instance variables
  - Ancestors

Font-related classes & constants. Includes the definition of the character widths of all PDF standard fonts.

The contents of this module are internal to fpdf2, and not part of the public API. They may change at any time without prior warning or any deprecation period, in non-backward-compatible ways.

Usage documentation at: https://py-pdf.github.io/fpdf2/Unicode.html

Represent basic font styling properties. This is a subset of GraphicsStateMixin properties.

Create a combined FontFace with all the supplied features of the two styles. When both the default and override styles provide a feature, prefer the override style. Override specified FontFace style features Override this FontFace's values with the values of other. Values of other that are None in this FontFace will be kept unchanged.

Return a new object replacing specified fields with new values.

This is especially useful for frozen classes. Example usage::

@dataclass(frozen=True) class C: x: int y: int

c = C(1, 2) c1 = replace(c, x=3) assert c1.x == 3 and c1.y == 2

This represents one glyph on the font Unicode is a tuple because ligatures or character substitution can map a sequence of unicode characters to a single glyph

Inherited from: PDFObject.content_stream

Subclasses can override this method to indicate the presence of a content stream

Inherited from: PDFObject.serialize

Serialize the PDF object as an obj<</>>endobj text block

Holds a mapping of used characters and their position in the font's subset

Characters that must be mapped on their actual unicode must be part of the identities list during object instantiation. These non-negative values should only appear once in the list. pick() can be used to get the characters corresponding position in the subset. If it's not yet part of the object, a new position is acquired automatically. This implementation always tries to return the lowest possible representation.

This method invokes Harfbuzz to perform text shaping of the input string

This method will invoke harfbuzz for text shaping, include the mapping code of the glyphs on the subset and map input characters to the cluster codes

When texts are shaped, the length of a string is not always the sum of all individual character widths This method will invoke harfbuzz to perform the text shaping and return the sum of "x_advance" and "x_offset" for each glyph. This method works for "left to right" or "right to left" texts.

Subclass of FontFace that allows to specify vertical & horizontal spacing

Inherited from: FontFace.combine

Create a combined FontFace with all the supplied features of the two styles. When both the default and override styles provide a feature, prefer the ‚Ä¶

Create a new TextStyle instance, with new values for some attributes. Same as dataclasses.replace()

**Examples:**

Example 1 (python):
```python
class CoreFont:
    # RAM usage optimization:
    __slots__ = (
        "i",
        "type",
        "name",
        "sp",
        "ss",
        "up",
        "ut",
        "cw",
        "fontkey",
        "emphasis",
    )

    def __init__(self, i: int, fontkey: str, style: str) -> None:
        self.i = i
        self.type = "core"
        self.name = CORE_FONTS[fontkey]
        self.sp = 250  # strikethrough horizontal position
        self.ss = 50  # strikethrough size (height)
        self.up = -100  # underline horizontal position
        self.ut = 50  # underline height
        self.cw = CORE_FONTS_CHARWIDTHS[fontkey]
        self.fontkey = fontkey
        self.emphasis = TextEmphasis.coerce(style)

    def get_text_width(
        self, text: str, font_size_pt: float, _: Optional[dict[str, Any]]
    ) -> tuple[int, float]:
        return (len(text), sum(self.cw[c] for c in text) * font_size_pt * 0.001)

    # Disabling this check - method kept as is to have same method/signature on CoreConf and TTFFont:
    # pylint: disable=no-self-use
    def encode_text(self, text: str) -> str:
        return f"({escape_parens(text)}) Tj"

    def __repr__(self) -> str:
        return f"CoreFont(i={self.i}, fontkey={self.fontkey})"
```

Example 2 (python):
```python
class CoreFont:
    # RAM usage optimization:
    __slots__ = (
        "i",
        "type",
        "name",
        "sp",
        "ss",
        "up",
        "ut",
        "cw",
        "fontkey",
        "emphasis",
    )

    def __init__(self, i: int, fontkey: str, style: str) -> None:
        self.i = i
        self.type = "core"
        self.name = CORE_FONTS[fontkey]
        self.sp = 250  # strikethrough horizontal position
        self.ss = 50  # strikethrough size (height)
        self.up = -100  # underline horizontal position
        self.ut = 50  # underline height
        self.cw = CORE_FONTS_CHARWIDTHS[fontkey]
        self.fontkey = fontkey
        self.emphasis = TextEmphasis.coerce(style)

    def get_text_width(
        self, text: str, font_size_pt: float, _: Optional[dict[str, Any]]
    ) -> tuple[int, float]:
        return (len(text), sum(self.cw[c] for c in text) * font_size_pt * 0.001)

    # Disabling this check - method kept as is to have same method/signature on CoreConf and TTFFont:
    # pylint: disable=no-self-use
    def encode_text(self, text: str) -> str:
        return f"({escape_parens(text)}) Tj"

    def __repr__(self) -> str:
        return f"CoreFont(i={self.i}, fontkey={self.fontkey})"
```

Example 3 (python):
```python
class CoreFont:
    # RAM usage optimization:
    __slots__ = (
        "i",
        "type",
        "name",
        "sp",
        "ss",
        "up",
        "ut",
        "cw",
        "fontkey",
        "emphasis",
    )

    def __init__(self, i: int, fontkey: str, style: str) -> None:
        self.i = i
        self.type = "core"
        self.name = CORE_FONTS[fontkey]
        self.sp = 250  # strikethrough horizontal position
        self.ss = 50  # strikethrough size (height)
        self.up = -100  # underline horizontal position
        self.ut = 50  # underline height
        self.cw = CORE_FONTS_CHARWIDTHS[fontkey]
        self.fontkey = fontkey
        self.emphasis = TextEmphasis.coerce(style)

    def get_text_width(
        self, text: str, font_size_pt: float, _: Optional[dict[str, Any]]
    ) -> tuple[int, float]:
        return (len(text), sum(self.cw[c] for c in text) * font_size_pt * 0.001)

    # Disabling this check - method kept as is to have same method/signature on CoreConf and TTFFont:
    # pylint: disable=no-self-use
    def encode_text(self, text: str) -> str:
        return f"({escape_parens(text)}) Tj"

    def __repr__(self) -> str:
        return f"CoreFont(i={self.i}, fontkey={self.fontkey})"
```

Example 4 (python):
```python
class CoreFont:
    # RAM usage optimization:
    __slots__ = (
        "i",
        "type",
        "name",
        "sp",
        "ss",
        "up",
        "ut",
        "cw",
        "fontkey",
        "emphasis",
    )

    def __init__(self, i: int, fontkey: str, style: str) -> None:
        self.i = i
        self.type = "core"
        self.name = CORE_FONTS[fontkey]
        self.sp = 250  # strikethrough horizontal position
        self.ss = 50  # strikethrough size (height)
        self.up = -100  # underline horizontal position
        self.ut = 50  # underline height
        self.cw = CORE_FONTS_CHARWIDTHS[fontkey]
        self.fontkey = fontkey
        self.emphasis = TextEmphasis.coerce(style)

    def get_text_width(
        self, text: str, font_size_pt: float, _: Optional[dict[str, Any]]
    ) -> tuple[int, float]:
        return (len(text), sum(self.cw[c] for c in text) * font_size_pt * 0.001)

    # Disabling this check - method kept as is to have same method/signature on CoreConf and TTFFont:
    # pylint: disable=no-self-use
    def encode_text(self, text: str) -> str:
        return f"({escape_parens(text)}) Tj"

    def __repr__(self) -> str:
        return f"CoreFont(i={self.i}, fontkey={self.fontkey})"
```

---

## Text Columns

**URL:** https://py-pdf.github.io/fpdf2/TextColumns.html

**Contents:**
- Text Columns
- Text Columns¬∂
  - Single-Column Example¬∂
  - Multi-Column Example¬∂
  - Balanced Columns¬∂
  - Possible future extensions¬∂

The FPDF.text_columns() method allows to create columnar layouts, with one or several columns. Columns will always be of equal width.

Text columns support all the standard text region methods, and some extra ones:

A form feed character (\u000c) in the text will have the same effect as an explicit call to .new_column(),

Note that when used within balanced columns, switching to a new column manually will result in incorrect balancing.

In this example an inserted paragraph is used in order to format its content with justified alignment, while the rest of the text uses the default left alignment.

from fpdf import FPDF pdf = FPDF() pdf.add_page() pdf.set_font("Times", size=12) with pdf.text_columns() as cols: cols.write(text=LOREM_IPSUM[:400]) with cols.paragraph( text_align="J", top_margin=pdf.font_size, bottom_margin=pdf.font_size ) as paragraph: paragraph.write(text=LOREM_IPSUM[:400]) cols.write(text=LOREM_IPSUM[:400]) pdf.output("text_columns.pdf")

Indentation can be set on the first line of paragraphs by passing a first_line_indent value to .paragraph().

Here we have a layout with three columns. Note that font type and text size can be varied within a text region, while still maintaining the justified (in this case) horizontal alignment.

from fpdf import FPDF pdf = FPDF() pdf.add_page() pdf.set_font("Helvetica", size=16) with pdf.text_columns(text_align="J", ncols=3, gutter=5) as cols: cols.write(text=LOREM_IPSUM[:600]) pdf.set_font("Times", size=18) cols.write(text=LOREM_IPSUM[:500]) pdf.set_font("Courier", size=20) cols.write(text=LOREM_IPSUM[:500]) pdf.output("multi_columns.pdf")

Normally the columns will be filled left to right, and if the text ends before the page is full, the rightmost column will be shorter than the others. If you prefer that all columns on a page end on the same height, you can use the balance=True argument. In that case a simple algorithm will be applied that attempts to approximately balance their bottoms.

from fpdf import FPDF pdf = FPDF() pdf.add_page() pdf.set_font("Times", size=12) cols = pdf.text_columns(text_align="J", ncols=3, gutter=5, balance=True) # fill columns with balanced text with cols: pdf.set_font("Times", size=14) cols.write(text=LOREM_IPSUM[:300]) # add an image below img_info = pdf.image(".../fpdf2/docs/regular_polygon.png", x=pdf.l_margin, w=pdf.epw) # continue multi-column text with cols: cols.write(text=LOREM_IPSUM[300:600]) pdf.output("balanced_columns.pdf")

Note that column balancing only works reliably when the font size (specifically the line height) doesn't change, and if there are no images included. If parts of the text use a larger or smaller font than the rest, then the balancing will usually be out of whack. Contributions for a more refined balancing algorithm are welcome.

Those features are currently not supported, but Pull Requests are welcome to implement them:

**Examples:**

Example 1 (python):
```python
from fpdf import FPDF

pdf = FPDF()
pdf.add_page()
pdf.set_font("Times", size=12)
with pdf.text_columns() as cols:
    cols.write(text=LOREM_IPSUM[:400])
    with cols.paragraph(
        text_align="J",
        top_margin=pdf.font_size,
        bottom_margin=pdf.font_size
    ) as paragraph:
        paragraph.write(text=LOREM_IPSUM[:400])
    cols.write(text=LOREM_IPSUM[:400])
pdf.output("text_columns.pdf")
```

Example 2 (python):
```python
from fpdf import FPDF

pdf = FPDF()
pdf.add_page()
pdf.set_font("Helvetica", size=16)
with pdf.text_columns(text_align="J", ncols=3, gutter=5) as cols:
    cols.write(text=LOREM_IPSUM[:600])
    pdf.set_font("Times", size=18)
    cols.write(text=LOREM_IPSUM[:500])
    pdf.set_font("Courier", size=20)
    cols.write(text=LOREM_IPSUM[:500])
pdf.output("multi_columns.pdf")
```

Example 3 (python):
```python
from fpdf import FPDF

pdf = FPDF()
pdf.add_page()
pdf.set_font("Times", size=12)

cols = pdf.text_columns(text_align="J", ncols=3, gutter=5, balance=True)
# fill columns with balanced text
with cols:
    pdf.set_font("Times", size=14)
    cols.write(text=LOREM_IPSUM[:300])
# add an image below
img_info = pdf.image(".../fpdf2/docs/regular_polygon.png",
                     x=pdf.l_margin, w=pdf.epw)
# continue multi-column text
with cols:
    cols.write(text=LOREM_IPSUM[300:600])
pdf.output("balanced_columns.pdf")
```

---

## ·ûö·ûî·üÄ·ûî·ûî·üí·ûö·ûæ·ûî·üí·ûö·û∂·ûü¬∂

**URL:** https://py-pdf.github.io/fpdf2/Tutorial-km.html

**Contents:**
- ·ûö·ûî·üÄ·ûî·ûî·üí·ûö·ûæ·ûî·üí·ûö·û∂·ûü¬∂
- ·ûò·üÅ·ûö·üÄ·ûì·ûë·û∏ 1 - ·ûÇ·üÜ·ûö·ûº·ûÅ·üí·ûõ·û∏¬∂
- ·ûò·üÅ·ûö·üÄ·ûì·ûë·û∏ 2 - ·ûÄ·üí·ûî·û∂·ûõ·ûë·üÜ·ûñ·üê·ûö ·ûî·û∂·ûè·ûÄ·ûê·û∂ ·ûî·üÜ·ûì·üÇ·ûÄ·ûë·üÜ·ûñ·ûö ·ûì·û∑·ûÑ ·ûö·ûº·ûî·ûó·û∂·ûñ¬∂
- ·ûò·üÅ·ûö·üÄ·ûì·ûë·û∏ 3 - ·ûÖ·ûª·üá·ûî·ûì·üí·ûë·û∂·ûè·üã ·ûì·û∑·ûÑ ·ûä·û∂·ûÄ·üã·ûñ·ûé·üå¬∂
- ·ûò·üÅ·ûö·üÄ·ûì·ûë·û∏ 4 - ·ûñ·û†·ûª·ûá·ûΩ·ûö·ûà·ûö¬∂
- ·ûò·üÅ·ûö·üÄ·ûì·ûë·û∏ 5 - ·ûî·ûÑ·üí·ûÄ·ûæ·ûè·ûè·û∂·ûö·û∂·ûÑ¬∂
- ·ûò·üÅ·ûö·üÄ·ûì·ûë·û∏ 6 - ·ûî·ûÑ·üí·ûÄ·ûæ·ûè·ûè·üÜ·ûé·ûö·ûá·û∂·ûò·ûΩ·ûô·û¢·ûè·üí·ûê·ûî·ûë¬∂

·ûØ·ûÄ·ûü·û∂·ûö·ûë·û∂·üÜ·ûÑ·ûü·üí·ûö·ûª·ûÑ·ûì·üÉ·ûú·û∑·ûí·û∏·ûî·üí·ûö·ûæ: fpdf.FPDF API doc

·ûè·üÑ·üá·ûÖ·û∂·ûî·üã·ûï·üí·ûè·ûæ·ûò·ûá·û∂·ûò·ûΩ·ûô·ûß·ûë·û∂·û†·ûö·ûé·üç·ûÑ·û∂·ûô·üó:

·ûî·ûì·üí·ûë·û∂·ûî·üã·ûñ·û∏·ûî·ûâ·üí·ûÖ·ûº·ûõ·ûØ·ûÄ·ûü·û∂·ûö·ûä·ûæ·ûò·üí·ûî·û∏·ûî·üí·ûö·ûæ·ûÄ·üí·ûì·ûª·ûÑ·ûî·ûé·üí·ûé·û∂·ûõ·üê·ûô, ·ûô·ûæ·ûÑ·ûî·ûÑ·üí·ûÄ·ûæ·ûè·ûë·üÜ·ûö·ûÑ·üã FPDF ·ûò·ûΩ·ûô·üî FPDF ·ûë·üÜ·ûö·ûÑ·üã·ûì·üÉ·ûè·ûò·üí·ûõ·üÉ·ûä·ûæ·ûò·ûä·üÇ·ûõ·ûè·üí·ûö·ûº·ûú·ûî·û∂·ûì·ûî·üí·ûö·ûæ·ûë·û∏·ûì·üÅ·üá·ûÇ·û∫: ·ûÅ·üí·ûì·û∂·ûè·ûì·üÉ·ûë·üÜ·ûñ·üê·ûö·ûë·û∂·üÜ·ûÑ·û¢·ûü·üã·ûá·û∂ A4 ·ûö·û∂·ûÑ·ûî·ûâ·üí·ûÉ·ûö ·û†·ûæ·ûô·ûò·û∂·ûì·ûö·ûÑ·üí·ûú·û∂·ûü·üã·ûÅ·üí·ûì·û∂·ûè·ûÇ·û∑·ûè·ûá·û∂·ûò·û∏·ûõ·û∏·ûò·üâ·üÇ·ûè·üí·ûö·üî ·ûú·û∂·ûè·üí·ûö·ûº·ûú·ûî·û∂·ûì·ûü·üÜ·ûÇ·û∂·ûõ·üã·ûô·üâ·û∂·ûÑ·ûÖ·üí·ûî·û∂·ûü·üã·ûä·ûº·ûÖ·ûÄ·ûº·ûä·ûò·ûΩ·ûô·ûî·ûì·üí·ûë·û∂·ûè·üã·ûÅ·û∂·ûÑ·ûÄ·üí·ûö·üÑ·ûò·ûì·üÅ·üá:

·ûô·ûæ·ûÑ·ûÄ·üè·û¢·û∂·ûÖ·ûÄ·üÜ·ûé·ûè·üã PDF ·ûî·û∂·ûì·ûï·ûÑ·ûä·üÇ·ûö·ûá·û∂·ûë·üÜ·ûö·ûÑ·üã·ûö·üÄ·ûÑ·ûÄ·üí·ûö·ûä·û∂·ûü·ûï·üí·ûè·üÅ·ûÄ (L) ·û¨ ·û¢·û∂·ûÖ·ûî·üí·ûö·ûæ·ûÄ·üí·ûì·ûª·ûÑ·ûë·üÜ·ûö·ûÑ·üã·ûÄ·üí·ûö·ûä·û∂·ûü·ûï·üí·ûü·üÅ·ûÑ·üó·ûë·üÄ·ûè·ûä·ûº·ûÖ·ûá·û∂ (·ûë·üÜ·ûö·ûÑ·üã·ûõ·û∑·ûè·ûü·üí·ûì·û∂·ûò Letter ·ûì·û∑·ûÑ ·ûë·üÜ·ûö·ûÑ·üã·ûï·üí·ûõ·ûº·ûú·ûÖ·üí·ûî·û∂·ûî·üã Legal) ·û†·ûæ·ûô·ûÅ·üí·ûì·û∂·ûè·ûö·ûÑ·üí·ûú·û∂·ûü·üã·û¢·û∂·ûÖ·ûÇ·û∑·ûè·ûá·û∂ (pt, cm, in)·üî

·ûò·ûª·ûì·ûì·üÅ·üá·ûô·ûæ·ûÑ·ûò·û∑·ûì·ûî·û∂·ûì·ûì·û∑·ûô·û∂·ûô·û¢·üÜ·ûñ·û∏·ûë·üÜ·ûñ·üê·ûö·ûë·üÅ ·ûä·ûº·ûÖ·üí·ûì·üÅ·üá·ûô·ûæ·ûÑ·û¢·û∂·ûÖ·û¢·û∂·ûÖ·ûî·ûÑ·üí·ûÄ·ûæ·ûè·ûú·û∂·ûä·üÑ·ûô·ûî·üí·ûö·ûæ add_page·üî ·ûë·û∏·ûè·û∂·üÜ·ûÑ·ûá·üí·ûö·ûª·ûÑ·ûÅ·û∂·ûÑ·ûõ·ûæ·ûÅ·û∂·ûÑ·ûÜ·üí·ûú·üÅ·ûÑ ·ûì·û∑·ûÑ·ûë·û∏·ûè·û∂·üÜ·ûÑ·ûä·üÇ·ûõ·ûÄ·üÜ·ûñ·ûª·ûÑ·ûü·üí·ûê·û∑·ûè·ûì·üÖ·ûÇ·û∫·ûÄ·üÜ·ûé·ûè·üã·ûä·üÑ·ûô·ûè·ûò·üí·ûõ·üÉ·ûä·ûæ·ûò 1 ·ûü·ûÑ·üã·ûë·û∏·ûò·üâ·üÇ·ûè·üí·ûö·ûñ·û∏·ûü·üä·ûª·ûî·ûì·üÉ·ûî·ûì·üí·ûë·û∂·ûè·üã ·ûÄ·û∂·ûö·ûè·ûò·üí·ûö·ûπ·ûò·û¢·û∂·ûÖ·ûï·üí·ûõ·û∂·ûü·üã·ûî·üí·ûè·ûº·ûö·ûî·û∂·ûì·ûä·üÑ·ûô·ûî·üí·ûö·ûæ set_margins.

·ûò·ûª·ûì·ûô·ûæ·ûÑ·û¢·û∂·ûÖ·ûî·üÑ·üá·ûñ·ûª·ûò·üí·ûó·û¢·ûè·üí·ûê·ûî·ûë·ûî·û∂·ûì ·ûÄ·û∂·ûè·ûñ·üí·ûú·ûÄ·û∑·ûÖ·üí·ûÖ·ûö·ûî·ûü·üã·ûô·ûæ·ûÑ·ûÇ·û∫·ûö·ûæ·ûü·ûñ·ûª·ûò·üí·ûó·û¢·ûÄ·üí·ûü·ûö·ûá·û∂·ûò·ûª·ûì·ûü·û∑·ûì·ûä·üÑ·ûô·ûî·üí·ûö·ûæ set_font ·ûò·û∑·ûì·ûä·ûº·ûÖ·ûì·üÑ·üá·ûë·üÅ·û¢·ûè·üí·ûê·ûî·ûë·ûö·ûî·ûü·üã·ûô·ûæ·ûÑ·ûì·ûπ·ûÑ·ûò·û∂·ûì·ûî·ûâ·üí·û†·û∂·üî ·ûô·ûæ·ûÑ·û¢·û∂·ûÖ·ûö·ûæ·ûü·ûô·ûÄ·ûñ·ûª·ûò·üí·ûó·û¢·ûÄ·üí·ûü·ûö Helvetica ·ûä·û∂·ûÄ·üã bold ·ûë·üÜ·û†·üÜ 16 ·ûè·û∂·ûò·ûú·û∑·ûí·û∏·ûä·ûº·ûÖ·ûÅ·û∂·ûÑ·ûÄ·üí·ûö·üÑ·ûò·ûá·û∂·ûÇ·üÜ·ûö·ûº:

·ûô·ûæ·ûÑ·û¢·û∂·ûÖ·ûÄ·üÜ·ûé·ûè·üã·ûá·û∂·ûë·üÜ·ûö·ûÑ·üã·û¢·ûÄ·üí·ûü·ûö·ûë·üí·ûö·üÅ·ûè·ûä·üÑ·ûô·ûî·üí·ûö·ûæ I ·ûì·û∑·ûÑ ·ûë·üÜ·ûö·ûÑ·üã·ûò·û∂·ûì·ûî·ûì·üí·ûë·û∂·ûè·üã·ûö·ûè·üã·ûñ·û∏·ûÄ·üí·ûö·üÑ·ûô·ûä·üÑ·ûô·ûî·üí·ûö·ûæ U ·û¨ ·ûò·û∑·ûì·ûÖ·û∂·üÜ·ûî·û∂·ûÖ·üã·ûî·üí·ûö·ûæ·ûñ·ûΩ·ûÄ·ûú·û∂ ·ûú·û∂·ûì·ûπ·ûÑ·ûî·ûÑ·üí·û†·û∂·ûâ·ûë·üÜ·ûö·ûÑ·üã·ûí·ûò·üí·ûò·ûè·û∂·ûá·û∂·ûò·ûΩ·ûô·ûì·û∑·ûÑ·ûÄ·û∂·ûö·ûî·üí·ûö·ûæ·û¢·ûÄ·üí·ûü·ûö·ûë·ûë·üÅ (empty string) ·ûò·û∂·ûì·ûì·üê·ûô (·û¨ ·ûÄ·û∂·ûö·ûö·ûΩ·ûò·ûî·ûâ·üí·ûÖ·ûº·ûõ·ûÇ·üí·ûì·û∂·ûï·üí·ûü·üÅ·ûÑ·ûë·üÄ·ûè)·üî ·ûè·üí·ûö·ûº·ûú·ûÖ·û∂·üÜ·ûê·û∂·ûë·üÜ·û†·üÜ·û¢·ûÄ·üí·ûü·ûö·ûè·üí·ûö·ûº·ûú·ûè·üÇ·û¢·üÑ·ûô·ûè·ûò·üí·ûõ·üÉ·ûÅ·üí·ûì·û∂·ûè·ûÇ·û∑·ûè·ûá·û∂·ûÖ·ûª·ûÖ(points) ·ûò·û∑·ûì·ûò·üÇ·ûì·ûÇ·û∑·ûè·ûá·û∂·ûò·û∏·ûõ·û∏·ûò·üâ·üÇ·ûè·üí·ûö (·û¨·ûá·û∂·ûÅ·üí·ûì·û∂·ûè·ûé·û∂·ûò·ûΩ·ûô·ûï·üí·ûü·üÅ·ûÑ·ûë·üÅ) ·ûì·üÅ·üá·ûá·û∂·ûÄ·ûö·ûé·û∏·ûõ·ûæ·ûÄ·ûõ·üÅ·ûÑ·ûÄ·üí·ûì·ûª·ûÑ·ûÄ·û∂·ûö·ûî·üí·ûö·ûæ·ûî·üí·ûö·û∂·ûü·üî ·ûñ·ûª·ûò·üí·ûó·û¢·ûÄ·üí·ûü·ûö·ûä·üÇ·ûõ·ûî·û∂·ûì·ûî·ûâ·üí·ûÖ·ûº·ûõ·ûö·ûΩ·ûÖ·ûü·üí·ûö·üÅ·ûÖ·ûö·ûΩ·ûò·ûò·û∂·ûì Times, Courier, Symbol ·ûì·û∑·ûÑ ZapfDingbats ·üî

·û•·ûõ·ûº·ûú·ûô·ûæ·ûÑ·û¢·û∂·ûÖ·ûî·üÑ·üá·ûñ·ûª·ûò·üí·ûó·ûü·û∂·ûÄ·ûõ·üí·ûî·ûÑ·ûá·û∂·ûò·ûΩ·ûô·ûÄ·û∂·ûö·ûî·üí·ûö·ûæ cell·üî ·ûò·ûΩ·ûô·ûÄ·üí·ûö·û°·û∂ (cell) ·ûÇ·ûπ·ûò·ûΩ·ûô·ûÖ·ûè·ûª·ûÄ·üÑ·ûé·ûï·üí·ûë·üÉ·ûÇ·û∑·ûè·ûÖ·û∂·ûî·üã·ûñ·û∏·ûï·üí·ûè·ûæ·ûò·ûî·ûì·üí·ûë·û∂·ûè·üã ·ûö·û†·ûº·ûè·ûÖ·ûî·üã·ûì·üÉ·ûî·ûì·üí·ûë·û∂·ûè·üã·ûï·üí·ûè·üÅ·ûÄ ·ûá·û∂·ûò·ûΩ·ûô·ûü·üä·ûª·ûî·ûä·üÇ·ûõ·ûä·üÇ·ûõ·û¢·û∂·ûÖ·ûü·ûö·ûü·üÅ·ûö·û¢·ûè·üí·ûê·ûî·ûë·ûî·û∂·ûì·üî ·ûú·û∂·ûî·ûâ·üí·ûÖ·üÅ·ûâ·ûë·üÖ·ûõ·ûæ·ûë·û∏·ûè·û∂·üÜ·ûÑ·ûä·üÇ·ûõ·ûÄ·üÜ·ûñ·ûª·ûÑ·ûü·üí·ûê·û∑·ûì·üÖ·üî ·ûô·ûæ·ûÑ·û¢·û∂·ûÖ·ûÄ·üÜ·ûé·ûè·üã·ûú·û∑·ûò·û∂·ûè·üí·ûö ·ûì·û∑·ûÑ ·û¢·ûè·üí·ûê·ûî·ûë (·ûÖ·üÜ·ûÄ·ûé·üí·ûè·û∂·ûõ ·û¨ ·ûä·üÑ·ûô·ûÄ·û∂·ûö·ûè·ûò·üí·ûö·ûπ·ûò·ûü·üí·ûö·üÅ·ûÖ·ûî·û∂·ûì) ·ûî·üí·ûö·ûü·û∑·ûì·ûî·ûæ·ûò·û∂·ûì·ûÄ·û∂·ûö·ûÄ·üÜ·ûé·ûè·üã·ûñ·üí·ûö·üÜ·ûä·üÇ·ûì·ûú·û∂·û¢·û∂·ûÖ·ûî·ûÑ·üí·û†·û∂·ûâ·ûï·ûÑ·ûä·üÇ·ûö ·û†·ûæ·ûô·ûì·û∑·ûÑ·ûî·ûÑ·üí·û†·û∂·ûâ·ûÖ·üÅ·ûâ·ûî·ûì·üí·ûë·û∂·ûî·üã·ûñ·û∏·ûë·û∏·ûè·û∂·üÜ·ûÑ·ûä·üÇ·ûõ·ûÄ·üÜ·ûñ·ûª·ûÑ·ûì·üÖ (·ûä·û∂·ûÄ·üã·ûë·üÖ·ûÅ·û∂·ûÑ·ûü·üí·ûè·û∂·üÜ ·û¨ ·ûä·û∂·ûÄ·üã·ûñ·û∏·ûÄ·üí·ûö·üÑ·ûò ·û¨ ·ûä·û∂·ûÄ·üã·ûî·ûì·üí·ûë·û∂·ûî·üã·ûñ·û∏·ûÖ·ûª·üá·ûî·ûì·üí·ûë·û∂·ûè·üã)·üî ·ûä·ûæ·ûò·üí·ûî·û∏·ûä·û∂·ûÄ·üã·ûü·üä·ûª·ûò·ûá·û∂·ûî·ûì·üí·ûë·û∂·ûè·üã·ûá·ûª·üÜ·ûú·û∑·ûâ·ûô·ûæ·ûÑ·ûî·üí·ûö·ûæ:

·ûä·ûæ·ûò·üí·ûî·û∏·ûä·û∂·ûÄ·üã Cell ·ûê·üí·ûò·û∏·ûò·ûΩ·ûô·ûë·üÄ·ûè·ûá·û∂·ûî·üã·ûú·û∂ ·ûä·üÑ·ûô·ûè·ûò·üí·ûö·ûπ·ûò·û¢·ûè·üí·ûê·ûî·ûë·ûÖ·üÅ·ûâ·ûñ·û∏·ûÄ·ûé·üí·ûè·û∂·ûõ·ûü·ûò·üí·ûö·û∂·ûî·üã·ûî·ûì·üí·ûë·û∂·ûè·üã·ûî·ûì·üí·ûë·û∂·ûî·üã·ûô·ûæ·ûÑ·û¢·û∂·ûÖ·ûî·üí·ûö·ûæ:

·ûÖ·üÜ·ûé·û∂·üÜ: ·ûÄ·û∂·ûö·ûÖ·ûª·üá·ûî·ûì·üí·ûë·û∂·ûè·üã·û¢·û∂·ûÖ·ûí·üí·ûú·ûæ·ûî·û∂·ûì·ûä·üÑ·ûô·ûî·üí·ûö·ûæ ln. ·ûú·û∑·ûí·û∏·ûü·û∂·ûü·üí·ûö·üí·ûè·ûì·üÅ·üá·ûá·û∂·ûÄ·û∂·ûö·ûî·ûâ·üí·ûá·û∂·ûÄ·üã·ûî·ûì·üí·ûê·üÇ·ûò·ûõ·ûæ·ûÄ·û∂·ûö·ûî·ûâ·üí·ûÖ·ûî·üã·ûÄ·ûê·û∂·ûÅ·üê·ûé·üí·ûå·ûè·û∂·ûò·ûö·ûô·üà·ûÇ·ûò·üí·ûõ·û∂·ûè·ûÄ·ûò·üí·ûñ·ûü·üã·ûì·üÉ·ûî·ûì·üí·ûë·û∂·ûè·üã·üî

·ûá·û∂·ûÖ·ûª·ûÑ·ûÄ·üí·ûö·üÑ·ûô ·ûÄ·üí·ûì·ûª·ûÑ·ûÄ·û∂·ûö·ûî·ûâ·üí·ûÖ·ûî·üã·ûì·üÉ·ûÄ·û∂·ûö·ûî·ûÑ·üí·ûÄ·ûæ·ûè ·ûô·ûæ·ûÑ·ûè·üí·ûö·ûº·ûú·ûï·üí·ûè·ûõ·üã·ûì·ûº·ûú·ûï·üí·ûõ·ûº·ûú·ûö·ûî·ûü·üã·ûë·û∏·ûè·û∂·üÜ·ûÑ·ûä·üÇ·ûõ·ûô·ûæ·ûÑ·ûè·üí·ûö·ûº·ûú·ûö·ûÄ·üí·ûü·û∂·ûö·ûØ·ûÄ·ûü·û∂·ûö·ûë·ûª·ûÄ·ûä·üÑ·ûô·ûî·üí·ûö·ûæ output ·ûä·üÑ·ûô·ûò·û∑·ûì·ûÖ·û∂·üÜ·ûî·û∂·ûÖ·üã·ûï·üí·ûè·ûõ·üã·ûî·üâ·û∂·ûö·üâ·û∂·ûò·üâ·üÇ·ûè output() ·ûî·ûâ·üí·ûÖ·ûº·ûì·ûè·üí·ûö·ûõ·ûî·üã·ûú·û∑·ûâ·ûá·û∂·ûü·üí·ûö·ûë·û∂·ûî·üã PDF bytearray·üî

·ûì·üÅ·üá·ûá·û∂·ûß·ûë·û∂·ûö·û†·üç·ûò·ûΩ·ûô·ûä·üÇ·ûõ·ûò·û∂·ûì·ûñ·û∏·ûö·ûë·üÜ·ûñ·üê·ûö ·ûÄ·üí·ûî·û∂·ûõ·ûë·üÜ·ûñ·üê·ûö, ·ûî·û∂·ûè·ûÄ·ûê·û∂·ûë·üÜ·ûñ·üê·ûö ·û¨ ·ûá·ûæ·ûÑ·ûë·üÜ·ûñ·üê·ûö ·ûì·û∑·ûÑ ·ûô·û∏·û†·üÑ:

·ûØ·ûÄ·ûü·û∂·ûö·ûì·üÅ·üá·ûî·ûÑ·üí·ûÄ·ûæ·ûè·ûä·üÑ·ûô·ûî·üí·ûö·ûæ header ·ûì·û∑·ûÑ footer ·ûá·û∂·ûö·ûî·üÄ·ûî·ûì·üÉ·ûä·üÜ·ûé·ûæ·ûö·ûî·ûÑ·üí·ûÄ·ûæ·ûè·ûì·üÉ·ûÄ·üí·ûî·û∂·ûõ·ûë·üÜ·ûñ·üê·ûö ·ûì·û∑·ûÑ ·ûî·û∂·ûè·ûÄ·ûê·û∂·ûë·üÜ·ûñ·üê·ûö·üî ·ûñ·ûΩ·ûÄ·ûú·û∂·ûì·ûπ·ûÑ·ûÖ·üÅ·ûâ·ûò·ûÄ·ûä·üÑ·ûô·ûü·üí·ûú·üê·ûô·ûî·üí·ûö·ûú·ûè·üí·ûè·û∑·üî ·ûú·û∂·ûò·û∂·ûì·ûü·üí·ûö·û∂·ûî·üã·ûò·ûÄ·ûá·û∂·ûò·ûΩ·ûô FPDF ·ûè·üí·ûö·û∂·ûì·üã·ûè·üÇ·ûú·û∂·ûî·ûÑ·üí·û†·û∂·ûâ·ûÖ·üÅ·ûâ·ûá·û∂·ûÖ·ûì·üí·ûõ·üÑ·üá·ûë·üÜ·ûì·üÅ·ûö·ûä·üÇ·ûõ·ûí·üí·ûú·ûæ·û¢·üÑ·ûô·ûô·ûæ·ûÑ·ûò·ûæ·ûõ·ûò·û∑·ûì·ûä·ûπ·ûÑ·üî ·ûä·ûº·ûÖ·üí·ûì·üÅ·üá·ûô·ûæ·ûÑ·ûÇ·üí·ûö·û∂·ûì·üã·ûè·üÇ·ûè·üÇ·ûî·ûì·üí·ûê·üÇ·ûò·ûî·ûì·üí·ûê·ûô·ûú·û∂·ûá·û∂·ûÄ·û∂·ûö·ûü·üí·ûö·üÅ·ûÖ·üî

·ûö·ûº·ûî·ûó·û∂·ûñ·ûì·üÉ·ûô·û∏·û†·üÑ·ûî·û∂·ûì·ûî·ûÑ·üí·û†·û∂·ûâ image ·ûè·û∂·ûò·ûö·ûô·üà·ûÄ·û∂·ûö·ûÄ·üÜ·ûé·ûè·üã·ûî·üí·ûö·ûú·üÇ·ûÑ·ûë·ûë·ûπ·ûÑ·ûä·û∂·ûÄ·üã·ûú·û∂·ûõ·ûæ·ûá·üí·ûö·ûª·ûÑ·ûÅ·û∂·ûÑ·ûõ·ûæ·ûì·üÉ·ûï·üí·ûì·üÇ·ûÄ·ûÅ·û∂·ûÑ·ûÜ·üí·ûú·üÅ·ûÑ·üî ·ûÄ·ûò·üí·ûñ·ûü·üã·ûÇ·û∫·ûÇ·ûé·ûì·û∂·ûä·üÑ·ûô·ûü·üí·ûú·üê·ûô·ûî·üí·ûö·ûú·ûè·üí·ûè·û∑·ûï·üí·û¢·üÇ·ûÄ·ûè·û∂·ûò·ûÖ·üí·ûî·û∂·ûî·üã·ûü·ûò·û∂·ûò·û∂·ûè·üí·ûö·üî

·ûÖ·üÜ·ûñ·üÑ·üá·ûÄ·û∂·ûö·ûî·ûÑ·üí·û†·û∂·ûâ·ûõ·üÅ·ûÅ·ûë·üÜ·ûñ·üê·ûö·ûú·û∂·ûî·ûÑ·üí·û†·û∂·ûâ·ûè·ûò·üí·ûõ·üÉ·ûë·ûë·üÅ·ûö·ûì·üÉ·ûî·üí·ûö·ûú·üÇ·ûÑ·ûë·ûë·ûπ·ûÑ·ûö·ûî·ûü·üã·ûÄ·üí·ûö·û°·û∂·ûï·üí·ûë·üÉ·ûî·ûì·üí·ûë·û∂·ûè·üã (cell)·üî ·ûú·û∂·ûò·û∂·ûì·ûì·üê·ûô·ûê·û∂·ûÄ·üí·ûö·û°·û∂·ûï·üí·ûë·üÉ·ûè·üí·ûö·ûº·ûú·ûñ·ûÑ·üí·ûö·û∏·ûÄ·ûë·üÖ·ûï·üí·ûì·üÇ·ûÄ·ûì·üÉ·ûÄ·û∂·ûö·ûÄ·üÜ·ûé·ûè·üã·ûÖ·ûì·üí·ûõ·üÑ·üá·ûë·üÜ·ûì·üÅ·ûö(margin) ·ûï·üí·ûì·üÇ·ûÄ·ûÅ·û∂·ûÑ·ûü·üí·ûè·û∂·üÜ·ûú·û∂·ûè·ûò·üí·ûö·ûπ·ûò·ûÖ·üÅ·ûâ·ûñ·û∏·ûÄ·ûé·üí·ûè·û∂·ûõ·ûì·üÉ·û¢·ûè·üí·ûê·ûî·ûë·ûò·ûÄ·üî ·ûõ·üÅ·ûÅ·ûë·üÜ·ûñ·üê·ûö·ûä·üÇ·ûõ·ûô·ûæ·ûÑ·ûÄ·üÜ·ûñ·ûª·ûÑ·ûü·üí·ûê·û∑·ûè·ûì·üÖ·ûì·ûπ·ûÑ·ûî·ûÑ·üí·û†·û∂·ûâ·ûè·ûò·üí·ûõ·üÉ·ûä·üÑ·ûô·ûî·üí·ûö·ûæ page_no ·ûë·üÖ·ûè·û∂·ûò·ûÖ·üÜ·ûì·ûΩ·ûì·ûü·ûö·ûª·ûî·ûì·üÉ·ûë·üÜ·ûñ·üê·ûö·ûá·û∂·ûâ·ûπ·ûÄ·ûâ·üâ·û∂·ûî·üã·ûÇ·û∫·ûî·üí·ûö·ûæ·ûè·ûò·üí·ûõ·üÉ·ûñ·û∑·ûü·üÅ·ûü·ûî·üÇ·ûî·ûì·üÅ·üá {nb} ·ûä·üÇ·ûõ·ûá·üÜ·ûì·ûΩ·ûü·ûä·üÑ·ûô·ûÖ·üÜ·ûì·ûΩ·ûì·ûü·ûö·ûª·ûî·ûì·üÉ·ûë·üÜ·ûñ·üê·ûö (·ûè·ûò·üí·ûõ·üÉ·ûñ·û∑·ûü·üÅ·ûü·ûì·üÅ·üá·û¢·û∂·ûÖ·ûî·üí·ûè·ûº·ûö·ûî·û∂·ûì·ûä·üÑ·ûô alias_nb_pages())·üî ·ûÖ·üÜ·ûé·û∂·üÜ·ûì·üÉ·ûö·ûî·üÄ·ûî·ûî·üí·ûö·ûæ·ûî·üí·ûö·û∂·ûü set_y ·ûä·üÇ·ûõ·û¢·üÑ·ûô·ûô·ûæ·ûÑ·ûÄ·üÜ·ûé·ûè·üã·ûë·û∏·ûè·û∂·üÜ·ûÑ·û¢·ûÄ·üí·ûü·ûà·ûö ·ûñ·û∏·ûõ·ûæ·ûò·ûÄ·ûÄ·üí·ûö·üÑ·ûò·üî

·ûò·û∂·ûì·ûò·ûª·ûÅ·ûÑ·û∂·ûö·ûñ·û∑·ûü·üÅ·ûü·ûò·ûΩ·ûô·ûï·üí·ûü·üÅ·ûÑ·ûë·üÄ·ûè·ûä·üÇ·ûõ·û¢·û∂·ûÖ·ûî·üí·ûö·ûæ·ûî·û∂·ûì: ·ûÇ·û∫·ûÄ·û∂·ûö·ûÖ·ûª·üá·ûî·ûì·üí·ûë·û∂·ûè·üã·ûë·üÖ·ûë·üÜ·ûñ·üê·ûö·ûê·üí·ûò·û∏·ûä·üÑ·ûô·ûü·üí·ûú·üê·ûô·ûî·üí·ûö·ûú·ûè·üí·ûè·û∑·ûÅ·ûé·üà·ûñ·üÅ·ûõ·ûú·û∂·ûë·üÖ·ûä·ûõ·üã·ûÖ·üÜ·ûì·ûª·ûÖ·ûë·û∂·ûõ·üã·ûì·üÉ·ûë·üÜ·ûñ·üê·ûö (·ûì·üÖ·ûÖ·üÜ·ûì·ûª·ûÖ 2 ·ûü·ûÑ·üã·ûë·û∏·ûò·üâ·üÇ·ûè·ûÇ·ûò·üí·ûõ·û∂·ûè·ûñ·û∏·ûÄ·üí·ûö·üÑ·ûò·ûò·ûÄ) ·ûñ·üÅ·ûõ·ûÖ·ûª·üá·ûî·ûì·üí·ûë·û∂·ûè·üã·ûú·û∂·ûö·ûÄ·üí·ûü·û∂·ûñ·ûª·ûò·üí·ûó·û¢·ûÄ·üí·ûü·ûö·ûä·ûä·üÇ·ûõ·üî ·ûê·üí·ûú·û∏·ûî·ûæ·ûÄ·üí·ûî·û∂·ûõ·ûë·üÜ·ûñ·üê·ûö ·ûì·û∑·ûÑ ·ûî·û∂·ûè·ûÄ·ûê·û∂·ûë·üÜ·ûñ·üê·ûö·ûò·û∂·ûì·ûñ·ûª·ûò·üí·ûó·û¢·ûÄ·üí·ûü·ûö·ûï·üí·ûë·û∂·ûõ·üã·ûÇ·û∫ (helvetica)·ûè·üÇ·ûè·ûΩ·ûö·û¢·ûè·üí·ûê·ûî·ûë·ûì·üÖ·ûè·üÇ·ûá·û∂·ûñ·ûª·ûò·üí·ûó Times·üî ·ûô·ûì·üí·ûè·ûÄ·û∂·ûö·ûì·üÉ·ûÄ·û∂·ûö·ûü·üí·ûè·û∂·ûö·ûä·üÑ·ûô·ûü·üí·ûú·üê·ûô·ûî·üí·ûö·ûú·ûè·üí·ûè·û∑·ûì·üÅ·üá·ûÄ·üè·û¢·ûì·ûª·ûú·ûè·üí·ûè·ûÖ·üÜ·ûñ·üÑ·üá·ûñ·ûé·üå ·ûì·û∑·ûÑ·ûë·ûë·ûπ·ûÑ·ûî·ûì·üí·ûë·û∂·ûè·üã·ûï·ûÑ·ûä·üÇ·ûö·üî ·ûä·üÇ·ûì·ûÄ·üÜ·ûé·ûè·üã·ûä·üÇ·ûõ·ûò·û∂·ûì·ûÄ·û∂·ûö·ûâ·üÇ·ûÄ·ûë·üÜ·ûñ·üê·ûö·û¢·û∂·ûÖ·ûè·üí·ûö·ûº·ûú·ûî·û∂·ûì·ûÄ·üÜ·ûé·ûè·üã·ûá·û∂·ûò·ûΩ·ûô·ûñ·û∂·ûÄ·üí·ûô·ûê·û∂ set_auto_page_break·üî

·ûü·ûº·ûò·ûî·ûì·üí·ûè·ûá·û∂·ûò·ûΩ·ûô·ûß·ûë·û∂·û†·ûö·ûé·üç·ûò·ûΩ·ûô·ûä·üÇ·ûõ·ûî·üÑ·üá·ûñ·ûª·ûò·üí·ûñ·ûÄ·ûë·üÜ·ûö·ûÑ·üã·ûê·û∂·ûÅ·ûé·üí·ûå·ûô·üâ·û∂·ûÑ·ûè·üí·ûö·ûπ·ûò·ûè·üí·ûö·ûº·ûú·üî ·ûä·üÇ·ûõ·ûî·ûÑ·üí·û†·û∂·ûâ·ûñ·û∏·ûÄ·û∂·ûö·ûî·üí·ûö·ûæ·ûî·üí·ûö·û∂·ûü·üã·ûñ·ûé·üå·üî

·ûî·üí·ûö·ûæ get_string_width ·ûî·üí·ûö·ûú·üÇ·ûÑ·ûì·üÉ·ûÅ·üí·ûü·üÇ·ûñ·ûª·ûò·üí·ûó·û¢·ûÄ·üí·ûü·ûö·ûõ·ûæ·ûñ·ûª·ûò·üí·ûó·û¢·ûÄ·üí·ûü·ûö·ûÄ·üÜ·ûñ·ûª·ûÑ·ûî·üí·ûö·ûæ ·ûä·üÇ·ûõ·ûî·üí·ûö·ûæ·ûä·ûæ·ûò·üí·ûî·û∏·ûÇ·ûé·ûì·û∂·ûë·û∏·ûè·û∂·üÜ·ûÑ·ûá·ûª·üÜ·ûú·û∑·ûâ·ûÖ·üÜ·ûé·ûÑ·ûá·ûæ·ûÑ·üî ·û†·ûæ·ûô·ûä·û∂·ûÄ·üã·ûñ·ûé·üå·ûä·üÑ·ûô·ûî·üí·ûö·ûæ (via set_draw_color set_fill_color ·ûì·û∑·ûÑ set_text_color) ·û†·ûæ·ûô·ûÄ·üÜ·ûé·ûè·üã·ûÄ·üÜ·ûö·üâ·û∂·ûü·üã·ûî·ûì·üí·ûë·û∂·ûè·üã 1 ·ûò·û∏·ûõ·û∏·ûò·üâ·üÇ·ûè (·ûä·üÑ·ûô·ûè·ûò·üí·ûõ·üÉ·ûä·ûæ·ûò 0.2) ·ûì·û∑·ûÑ·ûî·üí·ûö·ûæ set_line_width·üî ·ûÖ·ûª·ûÑ·ûÄ·üí·ûö·üÑ·ûô ·ûô·ûæ·ûÑ·ûë·ûë·ûΩ·ûõ·ûî·û∂·ûì (·ûä·û∂·ûÄ·üã·ûî·üâ·û∂·ûö·üâ·û∂·ûò·üâ·üÇ·ûè·ûÖ·ûª·ûÑ·ûÄ·üí·ûö·üÑ·ûô·ûä·üÑ·ûô·ûñ·û∂·ûÄ·üí·ûô·ûê·û∂ ‚ÄúTrue‚Äù ·ûì·üÑ·üá·ûî·û∂·ûì·ûì·üê·ûô·ûê·û∂·ûñ·ûé·üå·ûï·üí·ûë·üÉ·ûÄ·üí·ûö·üÑ·ûô·ûî·û∂·ûì·ûä·û∂·ûÄ·üã)·üî

·ûú·û∑·ûí·û∏·ûü·û∂·ûü·üí·ûö·üí·ûè·ûÄ·üí·ûì·ûª·ûÑ·ûÄ·û∂·ûö·ûî·üÑ·üá·ûñ·ûª·ûò·üí·ûó·ûÄ·ûê·û∂·ûÅ·üê·ûé·üí·ûå·ûñ·û†·ûª·ûî·ûì·üí·ûë·û∂·ûè·üã·ûÇ·û∫ multi_cell. ·û¢·ûè·üí·ûê·ûî·ûë·ûö·ûÄ·üí·ûü·û∂·ûë·üÜ·ûö·ûÑ·üã·ûä·ûæ·ûò·ûô·üâ·û∂·ûÑ·ûî·üí·ûö·ûÄ·üí·ûö·ûè·û∏·üî ·ûö·û∂·ûõ·üã·ûî·ûì·üí·ûë·û∂·ûè·üã·ûä·üÇ·ûõ·ûä·ûõ·üã·ûÖ·ûª·ûÑ·ûÅ·û∂·ûÑ·ûü·üí·ûè·û∂·üÜ ·û¨ ·ûÖ·ûÑ·üã·ûÖ·ûª·üá·ûî·ûì·üí·ûë·û∂·ûè·üã·ûè·üí·ûö·ûº·ûú·ûî·üí·ûö·ûæ (\n) ·ûñ·üÅ·ûõ·ûô·ûæ·ûÑ·ûÖ·ûª·üá·ûî·ûì·üí·ûë·û∂·ûè·üã·ûï·üí·ûë·üÉ·ûê·üí·ûò·û∏·ûè·üí·ûö·ûº·ûú·ûî·û∂·ûì·ûî·ûÑ·üí·ûÄ·ûæ·ûè·ûä·üÑ·ûô·ûü·üí·ûú·üê·ûô·ûî·üí·ûö·ûú·ûè·üí·ûè·û∑·ûñ·û∏·ûÄ·üí·ûö·üÑ·ûò·ûî·ûì·üí·ûë·û∂·ûè·üã·ûÄ·üÜ·ûñ·ûª·ûÑ·ûî·üí·ûö·ûæ·üî ·ûÄ·û∂·ûö·ûÖ·ûª·üá·ûî·ûì·üí·ûë·û∂·ûè·üã·ûä·üÑ·ûô·ûü·üí·ûú·üê·ûô·ûî·üí·ûö·ûú·ûè·üí·ûè·û∑·ûì·û∑·ûÑ·ûî·üí·ûö·ûñ·üí·ûö·ûπ·ûè·üí·ûè·ûë·üÖ·ûì·üÖ·ûÅ·û∂·ûÑ·ûÖ·ûª·ûÑ·ûî·üÜ·ûï·ûª·ûè·ûì·üÉ·ûÖ·ûì·üí·ûõ·üÑ·üá ·û¨ soft-hyphen (\u00ad) ·ûì·üÖ·ûò·ûª·ûÅ·û¢·ûÄ·üí·ûü·ûö·ûä·üÇ·ûõ·ûè·üí·ûö·ûº·ûú·ûÖ·ûª·üá·üî ·ûü·ûâ·üí·ûâ·û∂·ûè·üí·ûö·üÅ·ûá·û∂·û¢·ûÄ·üí·ûü·ûö ·ûì·û∑·ûÑ·ûè·üí·ûö·ûº·ûú·ûá·üÜ·ûì·ûΩ·ûü·ûä·üÑ·ûô·ûü·ûâ·üí·ûâ·û∂·ûè·üí·ûö·üÅ·ûí·ûò·üí·ûò·ûè·û∂·ûì·üÖ·ûñ·üÅ·ûõ·ûä·üÇ·ûõ·ûú·û∂·ûó·üí·ûá·û∂·ûî·üã·ûá·û∂·ûò·ûΩ·ûô·ûî·ûì·üí·ûë·û∂·ûè·üã·ûè·üí·ûö·ûº·ûú·ûÖ·ûª·üá ·ûò·û∑·ûì·ûÖ·ûπ·ûÑ·ûë·üÅ·ûô·ûæ·ûÑ·ûö·üÜ·ûõ·ûÑ·ûú·û∂·ûÖ·üÑ·ûõ·ûî·û∂·ûì·üî

·ûò·û∂·ûì·ûÄ·ûì·üí·ûõ·üÇ·ûÑ·ûñ·û∏·ûö·ûä·üÇ·ûõ·û¢·û∂·ûÖ·ûÄ·üÜ·ûé·ûè·üã·ûõ·ûæ·ûØ·ûÄ·ûü·û∂·ûö·ûî·û∂·ûì·ûê·û∂·ûá·û∂·ûü·ûò·üí·ûî·ûè·üí·ûè·û∑·ûö·ûî·ûü·üã·ûô·ûæ·ûÑ·ûî·û∂·ûì·ûÇ·û∫: ·ûÖ·üÜ·ûé·ûÑ·ûá·ûæ·ûÑ (set_title) ·ûì·û∑·ûÑ ·û¢·üí·ûì·ûÄ·ûü·ûö·ûü·üÅ·ûö (set_author). ·ûë·û∂·üÜ·ûÑ·û¢·ûü·üã·ûì·üÅ·üá·û¢·û∂·ûÖ·ûî·ûÑ·üí·û†·û∂·ûâ·ûá·û∂·ûñ·û∏·ûö·û¢·ûè·üí·ûê·ûì·üê·ûô·üî ·ûë·û∏·ûò·ûΩ·ûô·ûñ·üÅ·ûõ·ûî·ûæ·ûÄ·ûØ·ûÄ·ûü·û∂·ûö·ûá·û∂·ûò·ûΩ·ûô·ûÄ·ûò·üí·ûò·ûú·û∑·ûí·û∏ Acrobat Reader ·ûÖ·ûª·ûÖ·ûõ·ûæ File ·ûñ·û∏·ûò·û∏·ûì·ûª·ûô ·û†·ûæ·ûô·ûö·ûæ·ûü·ûô·ûÄ Document Properties·üî ·ûë·û∏·ûñ·û∏·ûö·û¢·û∂·ûÖ·ûö·ûÄ·ûú·û∂·ûÉ·ûæ·ûâ·ûñ·û∏ plug-in ·ûä·üÑ·ûô·ûî·üí·ûö·ûæ Right-Click ·û†·ûæ·ûô·ûö·ûæ·ûü·ûô·ûÄ·ûñ·û∂·ûÄ·üí·ûô Document Properties·üî

·ûì·üÅ·üá·ûá·û∂·ûß·ûë·û∂·ûö·û†·üç·ûô·üÑ·ûÑ·ûñ·û∏·ûõ·ûæ·ûÄ·ûò·ûª·ûì ·ûè·üÇ·ûè·üí·ûö·ûÑ·üã·ûì·üÅ·üá·ûô·ûæ·ûÑ·ûì·ûπ·ûÑ·ûî·ûÑ·üí·û†·û∂·ûâ·ûñ·û∏·ûö·ûî·üÄ·ûî·ûî·üí·ûö·ûæ·ûî·üí·ûö·û∂·ûü·ûñ·û†·ûª·ûá·ûΩ·ûö·ûà·ûö·üî

·ûÖ·üÜ·ûì·ûª·ûÖ·ûÖ·üÜ·ûî·ûÑ·ûä·üÇ·ûõ·ûÅ·ûª·ûü·ûñ·û∏·ûò·üÅ·ûö·üÄ·ûì·ûò·ûª·ûì·ûÇ·û∫ ·ûÄ·û∂·ûö·ûî·üí·ûö·ûæ·ûî·üí·ûö·û∂·ûü·üã·ûò·ûª·ûÅ·ûÑ·û∂·ûö text_columns‚Äã ·üî ·ûö·û∂·ûõ·üã·û¢·ûÄ·üí·ûü·ûö·ûë·û∂·üÜ·ûÑ·û¢·ûü·üã‚Äã ·û¢·û∂·ûÖ·ûá·û∂·ûî·ûì·üí·ûê·üÇ·ûò·ûî·ûì·üí·ûè ·û†·ûæ·ûô·ûñ·ûÑ·üí·ûö·û∂·ûô·ûú·û∂·ûë·üÖ·ûè·û∂·ûò·ûá·ûΩ·ûö·ûà·ûö‚Äã ·ûú·û∂·ûî·ûÑ·üí·ûÄ·ûæ·ûè·ûî·üÜ·ûì·üÇ·ûÄ·ûë·üÜ·ûñ·üê·ûö·ûä·üÑ·ûô·ûü·üí·ûú·üê·ûô·ûî·üí·ûö·ûú·ûè·üí·ûè·û∑·ûñ·üÅ·ûõ·ûÖ·û∂·üÜ·ûî·û∂·ûÖ·üã·üî ·ûÖ·üÜ·ûé·û∂·üÜ ·ûñ·üÅ·ûõ·ûä·üÇ·ûõ TextColumns ·ûä·û∂·ûÄ·üã·û¢·üÑ·ûô·ûä·ûæ·ûö·ûè·ûΩ·ûá·û∂·ûî·üí·ûö·ûí·û∂·ûì·ûî·ûö·û∑·ûî·ûë (context manager) ·ûö·ûÖ·ûì·û∂·ûî·ûë·ûö·ûî·ûü·üã·û¢·ûè·üí·ûê·ûî·ûë ·ûì·û∑·ûÑ ·ûë·ûò·üí·ûö·ûÑ·üã·ûñ·ûª·üÜ·û¢·ûÄ·üí·ûü·ûö·ûï·üí·ûü·üÅ·ûÑ·üó·ûÄ·üè·ûè·üí·ûö·ûº·ûú·ûî·û∂·ûì·ûî·üí·ûè·ûº·ûö·ûï·ûÑ·ûä·üÇ·ûö·üî ·ûÄ·û∂·ûö·ûï·üí·ûõ·û∂·ûü·üã·ûî·üí·ûè·ûº·ûö·ûë·û∂·üÜ·ûÑ·ûì·üÅ·üá·ûÇ·û∫·ûï·üí·û¢·üÇ·ûÄ·ûõ·ûæ·ûî·ûì·üí·ûë·ûª·ûÄ·ûö·ûî·ûü·üã·ûî·ûö·û∑·ûî·ûë·üî ·ûì·üÖ·ûñ·üÅ·ûõ·ûä·üÇ·ûõ·ûú·û∂·ûî·û∂·ûì·ûî·û∑·ûë ·ûÄ·û∂·ûö·ûÄ·üÜ·ûé·ûè·üã·ûñ·û∏·ûò·ûª·ûì·ûì·ûπ·ûÑ·ûè·üí·ûö·ûº·ûú·ûî·û∂·ûì·ûü·üí·ûè·û∂·ûö·û°·ûæ·ûÑ·ûú·û∑·ûâ·üî

·ûÄ·üí·ûì·ûª·ûÑ·ûò·üÅ·ûö·üÄ·ûì·ûì·üÅ·üá·ûì·ûπ·ûÑ·ûñ·ûì·üí·ûô·ûõ·üã·û¢·üÜ·ûñ·û∏·ûÄ·û∂·ûö·ûî·ûÑ·üí·ûÄ·ûæ·ûè·ûè·û∂·ûö·û∂·ûÑ·ûñ·û∏·ûö·ûï·üí·ûü·üÅ·ûÑ·ûÇ·üí·ûì·û∂ ·ûä·ûæ·ûò·üí·ûî·û∏·ûò·û∂·ûì·ûó·û∂·ûñ·ûÑ·û∂·ûô·ûü·üí·ûö·ûΩ·ûõ·ûô·ûæ·ûÑ·ûò·û∂·ûì·ûß·ûë·û∂·ûö·û†·üç·ûÅ·üí·ûõ·üá·üó·û¢·üÜ·ûñ·û∏·ûÄ·û∂·ûö·ûî·ûÑ·üí·ûÄ·ûæ·ûè·ûì·üÅ·üá·üî

·ûõ·ûë·üí·ûí·ûï·ûõ·ûü·ûò·üí·ûö·üÅ·ûÖ PDF - Countries CSV data

·ûò·û∂·ûì·ûò·ûº·ûõ·ûä·üí·ûã·û∂·ûì·ûÄ·üí·ûì·ûª·ûÑ·ûÄ·û∂·ûö·ûí·üí·ûú·ûæ·ûä·üÑ·ûô·ûá·üÑ·ûÇ·ûá·üê·ûô·ûá·û∂·ûò·ûΩ·ûô·ûß·ûë·û∂·ûö·û†·üç·ûì·üÅ·üá·ûä·üÑ·ûô·ûä·û∂·ûÄ·üã·ûë·û∑·ûì·üí·ûì·ûì·üê·ûô·ûä·üÑ·ûô·ûî·üí·ûö·ûæ FPDF.table(). ·ûú·û∂·ûò·û∂·ûì·ûó·û∂·ûñ·ûü·ûò·üí·ûò·û∂·ûâ·üã·ûì·û∑·ûÑ·ûí·üí·ûú·ûæ·ûî·û∂·ûì·ûõ·ûø·ûì·üî

·ûè·û∂·ûö·û∂·ûÑ·ûë·û∏·ûñ·û∏·ûö·ûô·ûæ·ûÑ·ûì·ûπ·ûÑ·ûí·üí·ûú·ûæ·û¢·üÑ·ûô·ûî·üí·ûö·ûü·ûæ·ûö·ûá·û∂·ûÑ·ûò·ûª·ûì·ûö·ûΩ·ûò·ûò·û∂·ûì·ûä·ûº·ûÖ·ûá·û∂: ·ûä·û∂·ûÄ·üã·ûñ·ûé·üå ·ûä·üÑ·ûô·ûÄ·üÜ·ûé·ûè·üã·ûî·üí·ûö·ûú·üÇ·ûÑ·ûë·ûë·ûπ·ûÑ ·ûî·ûì·üí·ûê·ûô·ûî·ûì·üí·ûë·û∂·ûè·üã·ûÄ·üÜ·ûñ·ûü·üã·üî ·ûè·ûò·üí·ûö·ûπ·ûò·ûÖ·üÜ·ûé·ûÑ·ûá·ûæ·ûÑ·ûÖ·üÅ·ûâ·ûñ·û∏·ûÄ·ûé·üí·ûè·û∂·ûõ ·ûö·üÄ·ûî·ûá·ûΩ·ûö·ûà·ûö·ûä·üÑ·ûô·ûÄ·û∂·ûö·ûî·üí·ûè·ûº·ûö·ûè·ûò·üí·ûõ·üÉ·ûî·üí·ûö·ûú·üÇ·ûÑ·ûë·ûë·ûπ·ûÑ·ûú·û∂ ·ûì·û∑·ûÑ ·ûÄ·û∂·ûö·ûÄ·üÜ·ûé·ûè·üã·ûè·ûò·üí·ûö·ûπ·ûò·ûÅ·û∂·ûÑ·ûü·üí·ûè·û∂·üÜ·üî ·ûá·û∂·ûÑ·ûì·üÅ·üá·ûë·üÖ·ûë·üÄ·ûè·ûì·üÑ·üá ·ûÇ·ûπ·ûä·ûÄ·ûî·ûì·üí·ûë·û∂·ûè·üã·ûï·üí·ûè·üÅ·ûÄ·ûÖ·üÅ·ûâ·üî ·ûí·üí·ûú·ûæ·ûî·üÇ·ûî·ûì·üÅ·üá·ûë·üÖ·ûî·û∂·ûì·ûä·üÑ·ûô·ûö·ûæ·ûü·ûô·ûÄ borders_layout ·ûä·üÇ·ûõ·ûò·û∂·ûì·ûá·ûò·üí·ûö·ûæ·ûü·ûá·û∂·ûÖ·üí·ûö·ûæ·ûì·ûì·üÖ·ûë·û∏·ûì·üÑ·üá: TableBordersLayout.

·ûÄ·üí·ûì·ûª·ûÑ·ûò·üÅ·ûö·üÄ·ûì·ûì·üÅ·üá·ûô·ûæ·ûÑ·ûì·ûπ·ûÑ·ûñ·ûì·üí·ûô·ûõ·üã·û¢·üÜ·ûñ·û∏·ûö·ûî·üÄ·ûî·ûá·û∂·ûÖ·üí·ûö·ûæ·ûì·ûÄ·üí·ûì·ûª·ûÑ·ûÄ·û∂·ûö·ûä·û∂·ûÄ·üã·ûè·üÜ·ûé·ûö·ûì·üÖ·ûõ·ûæ·ûØ·ûÄ·ûü·û∂·ûö pdf ·û†·ûæ·ûô·ûô·ûæ·ûÑ·ûÄ·üè·ûä·û∂·ûÄ·üã·ûè·üÜ·ûé·ûö·ûä·üÖ·ûë·üÖ·ûî·üí·ûö·ûó·ûñ·ûï·üí·ûü·üÅ·ûÑ·ûì·üÖ·ûÄ·üí·ûö·üÖ·ûï·ûÑ·ûä·üÇ·ûö·üî

·ûô·ûæ·ûÑ·ûì·ûπ·ûÑ·ûî·ûÑ·üí·û†·û∂·ûâ·ûñ·û∏·ûö·ûî·üÄ·ûî·ûá·û∂·ûÖ·üí·ûö·ûæ·ûì·ûë·üÄ·ûè·ûÄ·üí·ûì·ûª·ûÑ·ûÄ·û∂·ûö·ûõ·üÅ·ûÑ·ûò·üâ·ûº·ûä·û¢·ûè·üí·ûê·ûî·ûë·ûö·ûΩ·ûò·ûò·û∂·ûì·ûä·ûº·ûÖ·ûá·û∂·ûò·üâ·ûº·ûä·ûå·û∑·ûè ·ûë·üí·ûö·üÅ·ûè ·ûò·û∂·ûì·ûî·ûì·üí·ûë·û∂·ûè·üã·ûñ·û∏·ûÄ·üí·ûö·üÑ·ûò (bold, italic, underline)·üî

·ûõ·ûë·üí·ûí·ûï·ûõ·ûü·ûò·üí·ûö·üÅ·ûÖ PDF - fpdf2-logo

·ûö·ûî·üÄ·ûî·ûê·üí·ûò·û∏·ûò·ûΩ·ûô·ûë·üÄ·ûè·ûÄ·üí·ûì·ûª·ûÑ·ûÄ·û∂·ûö·ûî·ûÑ·üí·û†·û∂·ûâ·û¢·ûè·üí·ûê·ûî·ûë·ûä·ûæ·ûò·üí·ûî·û∏·ûî·üÑ·üá·ûñ·ûª·ûò·üí·ûó write()·üî ·ûú·û∂·ûò·û∂·ûì·ûó·û∂·ûñ·ûü·üí·ûö·ûä·üÄ·ûÑ·ûë·üÖ·ûì·ûπ·ûÑ multi_cell() ·ûÖ·üÜ·ûé·üÇ·ûÄ·ûó·û∂·ûñ·ûÅ·ûª·ûü·ûÇ·üí·ûì·û∂·ûò·û∂·ûì:

·ûä·üÑ·ûô·û†·üÅ·ûè·ûª·ûì·üÅ·üá·ûô·ûæ·ûÑ·û¢·û∂·ûÖ·ûü·ûö·ûü·üÅ·ûö·û¢·ûè·üí·ûê·ûî·ûë·ûá·û∂·ûÄ·üÜ·ûé·û∂·ûè·üã·üó·ûî·û∂·ûì ·ûä·üÑ·ûô·ûÄ·û∂·ûö·ûÄ·üÜ·ûé·û∂·ûè·üã·ûò·üâ·ûº·ûä·ûÅ·ûª·ûü·üó·ûÇ·üí·ûì·û∂·ûè·û∂·ûò·ûä·üÇ·ûõ·ûô·ûæ·ûÑ·ûÖ·ûÑ·üã·ûî·û∂·ûì ·û†·ûæ·ûô ·ûî·ûì·üí·ûè·ûë·üÖ·ûë·üÄ·ûè·ûô·ûæ·ûÑ·ûÖ·ûÑ·üã·ûä·û∂·ûÄ·üã·ûú·û∂·ûì·üÖ·ûÄ·ûì·üí·ûõ·üÇ·ûÑ·ûé·û∂·ûÄ·üè·ûî·û∂·ûì·üî ·ûò·üí·ûô·üâ·û∂·ûÑ·ûú·û∑·ûâ·ûë·üÄ·ûè ·ûÇ·ûª·ûé·ûú·û∑·ûî·ûè·üí·ûè·û∑·ûÖ·ûò·üí·ûî·ûÑ·ûö·ûî·ûü·üã·ûú·û∂·ûÇ·û∫·ûê·û∂·ûô·ûæ·ûÑ·ûò·û∑·ûì·û¢·û∂·ûÖ·ûè·ûò·üí·ûö·ûπ·ûò ·û¨ ·ûÄ·üÇ·ûö·û¢·ûè·üí·ûè·ûî·ûë·ûÖ·üí·ûö·ûæ·ûì·ûî·ûì·üí·ûë·û∂·ûè·üã·ûî·û∂·ûì·ûä·ûº·ûÖ·ûô·ûæ·ûÑ·ûí·üí·ûú·ûæ·ûú·û∑·ûí·û∏ multi_cell() ·ûë·üÅ·üî

·ûÇ·üÑ·ûõ·ûî·üÜ·ûé·ûÑ·ûõ·ûæ·ûß·ûë·û∂·ûö·û†·üç·ûë·û∏·ûò·ûΩ·ûô·ûÇ·û∫·û¢·üÑ·ûô·ûô·ûæ·ûÑ·ûö·üÄ·ûì·ûî·üí·ûö·ûæ write() . ·ûì·üÖ·ûá·üÜ·û†·û∂·ûì·ûä·üÜ·ûî·ûº·ûÑ·ûì·üÉ·ûî·üí·ûö·ûô·üÑ·ûÇ ·ûô·ûæ·ûÑ·ûî·û∂·ûì·ûö·üÄ·ûì·ûü·ûö·ûü·üÅ·ûö·ûì·ûº·ûú·û¢·ûè·üí·ûê·ûî·ûë·ûä·üÑ·ûô·ûä·üÑ·ûô·ûö·ûÖ·ûì·û∂·ûî·üÇ·ûî·ûí·ûò·üí·ûò·ûè·û∂ ·û†·ûæ·ûô·ûî·ûì·üí·ûë·û∂·ûî·üã·ûë·üÄ·ûè·ûô·ûæ·ûÑ·ûî·üí·ûö·ûæ·ûú·û∑·ûí·û∏ set_font() ·ûè·ûò·ûÄ·ûë·üÄ·ûè·ûô·ûæ·ûÑ·ûö·ûÖ·ûì·û∂·ûä·û∂·ûÄ·üã·ûî·ûì·üí·ûë·û∂·ûè·üã·ûñ·û∏·ûÄ·üí·ûö·üÑ·ûò·ûñ·û∂·ûÄ·üí·ûô·ûì·üÖ·ûÖ·ûª·ûÑ·ûî·ûâ·üí·ûÖ·ûî·üã·ûì·üÉ·ûî·üí·ûö·ûô·üÑ·ûÇ·üî

·ûö·ûî·üÄ·ûî·ûä·û∂·ûÄ·üã·ûì·ûº·ûú·ûè·üÜ·ûé·ûö·ûó·üí·ûá·û∂·ûî·üã·ûë·üÖ·ûë·üÜ·ûñ·üê·ûö·ûë·û∏·ûñ·û∏·ûö·ûô·ûæ·ûÑ·û¢·û∂·ûÖ·ûî·üí·ûö·ûæ·ûú·û∑·ûí·û∏ add_link() ·ûä·üÇ·ûõ·ûî·ûÑ·üí·ûÄ·ûæ·ûè·ûì·ûº·ûú·ûè·üÜ·ûî·ûì·üã·ûä·üÇ·ûõ·ûô·ûæ·ûÑ·û¢·û∂·ûÖ·ûÖ·ûª·ûÖ·ûî·û∂·ûì·û†·üÖ·ûê·û∂ "link" ·û†·ûæ·ûô·ûú·û∂·ûö·ûè·üã·ûë·üÖ·ûö·ûÄ·ûë·üÜ·ûñ·üê·ûö·ûò·ûΩ·ûô·ûï·üí·ûü·üÅ·ûÑ·ûë·üÄ·ûè·ûì·üÖ·ûõ·ûæ·ûØ·ûÄ·ûü·û∂·ûö·ûä·üÇ·ûõ·ûô·ûæ·ûÑ·ûÄ·üÜ·ûñ·ûª·ûÑ·ûî·ûæ·ûÄ·üî

·ûä·ûæ·ûò·üí·ûî·û∏·ûî·ûÑ·ûè·üÜ·ûé·ûö·ûë·üÖ·ûÅ·û∂·ûÑ·ûÄ·ûì·üí·ûõ·üÇ·ûÑ·ûï·üí·ûü·üÅ·ûÑ·ûë·üÄ·ûè·ûè·û∂·ûò·ûö·ûô·üà·ûö·ûº·ûî·ûó·û∂·ûñ·ûä·üÑ·ûô·ûî·üí·ûö·ûæ image() . ·ûî·üí·ûö·ûæ·ûú·û∑·ûí·û∏·ûì·üÅ·üá·ûä·ûæ·ûò·üí·ûî·û∏·ûó·üí·ûá·û∂·ûî·üã·ûè·üÜ·ûé·ûö·ûë·üÖ·ûÄ·û∂·ûì·üã·ûî·üí·ûö·ûó·ûñ·ûò·ûΩ·ûô·ûï·üí·ûü·üÅ·ûÑ·ûë·üÄ·ûè ·û†·ûæ·ûô·ûè·üÜ·ûé·ûö·ûì·üÅ·üá·û¢·û∂·ûÖ·ûè·üí·ûö·ûº·ûú·ûî·û∂·ûì·ûî·üí·ûö·ûæ·ûî·üí·ûö·û∂·ûü·ûá·û∂·ûò·ûΩ·ûô·ûî·üí·ûö·ûó·ûñ·ûÅ·û∂·ûÑ·ûÄ·üí·ûì·ûª·ûÑ ·ûì·û∑·ûÑ ·ûÅ·û∂·ûÑ·ûÄ·üí·ûö·üÖ·üî

·ûá·üÜ·ûö·ûæ·ûü·ûò·ûΩ·ûô·ûï·üí·ûü·üÅ·ûÑ·ûë·üÄ·ûè·ûô·ûæ·ûÑ·û¢·û∂·ûÖ·ûä·û∂·ûÄ·üã·ûö·ûÖ·ûì·û∂·ûñ·ûª·ûò·üí·ûó·û¢·ûÄ·üí·ûü·ûö·ûë·üÖ·ûõ·ûæ·ûÄ·û∂·ûö·ûä·û∂·ûÄ·üã·ûè·üÜ·ûé·ûö·ûó·üí·ûá·û∂·ûî·üã·ûè·û∂·ûò·ûú·û∑·ûí·û∏ write_html()·üî ·û¢·û∂·ûÖ·ûî·üí·ûö·ûæ·ûó·û∂·ûü·û∂·ûö·ûÄ·ûº·ûä html ·ûä·üÇ·ûõ·û¢·üÑ·ûô·ûô·ûæ·ûÑ·ûê·üÇ·ûò·û¢·ûè·üí·ûê·ûî·ûë ·ûï·üí·ûõ·û∂·ûü·üã·ûî·üí·ûè·ûº·ûö·ûö·ûÖ·ûì·û∂·ûñ·ûª·ûò·üí·ûó·û¢·ûÄ·üí·ûü·ûö ·ûì·û∑·ûÑ ·ûä·û∂·ûÄ·üã·ûè·üÜ·ûé·ûö·ûó·üí·ûá·û∂·ûî·üã(link) ·ûä·üÑ·ûô·ûî·üí·ûö·ûæ·ûó·û∂·ûü·û∂ HTML·üî

**Examples:**

Example 1 (python):
```python
from fpdf import FPDF

pdf = FPDF()
pdf.add_page()
pdf.set_font("helvetica", style="B", size=16)
pdf.cell(40, 10, "Hello World!")
pdf.output("tuto1.pdf")
```

Example 2 (unknown):
```unknown
pdf = FPDF(orientation="P", unit="mm", format="A4")
```

Example 3 (unknown):
```unknown
pdf.set_font('Helvetica', style='B', size=16)
```

Example 4 (unknown):
```unknown
pdf.cell(40, 10, 'Hello World!', 1)
```

---

## HTML¬∂

**URL:** https://py-pdf.github.io/fpdf2/HTML.html

**Contents:**
- HTML¬∂
- write_html usage example¬∂
  - Styling HTML tags globally¬∂
  - Default font¬∂
- Supported HTML features¬∂
  - Page breaks¬∂
- Known limitations¬∂
- Using Markdown¬∂

fpdf2 supports basic rendering from HTML.

This is implemented by using html.parser.HTMLParser from the Python standard library. The whole HTML 5 specification is not supported, and neither is CSS, but bug reports & contributions are very welcome to improve this. cf. Supported HTML features below for details on its current limitations.

For a more robust & feature-full HTML-to-PDF converter in Python, you may want to check Reportlab (or xhtml2pdf based on it), WeasyPrint or borb.

HTML rendering requires the use of FPDF.write_html():

Internally FPDF.write_html() uses the fpdf.html.HTML2FPDF class that implements HTML parsing using html.parser.HTMLParser.

The style of several HTML tags (<a>, <blockquote>, <code>, <pre>, <h1>, <h2>, <h3>...) can be set globally, for the whole HTML document, by passing tag_styles to FPDF.write_html():

Similarly, the indentation of several HTML tags (<blockquote>, <dd>, <li>) can be set globally, for the whole HTML document, by passing tag_styles to FPDF.write_html():

‚ö†Ô∏è Note that this styling is currently only supported for a subset of all HTML tags, and that some FontFace or TextStyle properties may not be honored. However, Pull Request are welcome to implement missing features!

The default font used by FPDF.write_html() is Times.

You can change this default font by passing font_family to this method: from fpdf import FPDF pdf = FPDF() pdf.add_page() pdf.write_html(""" <h1>Big title</h1> <section> <h2>Section title</h2> <p>Hello world!</p> </section> """, font_family="Helvetica") pdf.output("html_helvetica.pdf")

Page breaks can be triggered explicitly using the break-before or break-after CSS properties. For example you can use: <br style="break-after: page"> or: <p style="break-before: page"> Top of a new page. </p>

fpdf2 HTML renderer does not support some configurations of nested tags. For example:

You can also check the currently open GitHub issues with the tag html: label:html is:open

Check the dedicated page: Combine with Markdown

**Examples:**

Example 1 (jsx):
```jsx
from fpdf import FPDF

pdf = FPDF()
pdf.add_page()
pdf.write_html("""
  <dl>
      <dt>Description title</dt>
      <dd>Description Detail</dd>
  </dl>
  <h1>Big title</h1>
  <section>
    <h2>Section title</h2>
    <p><b>Hello</b> world. <u>I am</u> <i>tired</i>.</p>
    <p><a href="https://github.com/py-pdf/fpdf2">py-pdf/fpdf2 GitHub repo</a></p>
    <p align="right">right aligned text</p>
    <p>i am a paragraph <br>in two parts.</p>
    <font color="#00ff00"><p>hello in green</p></font>
    <font size="7"><p>hello small</p></font>
    <font face="helvetica"><p>hello helvetica</p></font>
    <font face="times"><p>hello times</p></font>
  </section>
  <section>
    <h2>Other section title</h2>
    <ul type="circle">
      <li>unordered</li>
      <li>list</li>
      <li>items</li>
    </ul>
    <ol start="3" type="i">
      <li>ordered</li>
      <li>list</li>
      <li>items</li>
    </ol>
    <br>
    <br>
    <pre>i am preformatted text.</pre>
    <br>
    <blockquote>hello blockquote</blockquote>
    <table width="50%">
      <thead>
        <tr>
          <th width="30%">ID</th>
          <th width="70%">Name</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>1</td>
          <td>Alice</td>
        </tr>
        <tr>
          <td>2</td>
          <td>Bob</td>
        </tr>
      </tbody>
    </table>
  </section>
""")
pdf.output("html.pdf")
```

Example 2 (python):
```python
from fpdf import FPDF, FontFace

pdf = FPDF()
pdf.add_page()
pdf.write_html("""
  <h1>Big title</h1>
  <section>
    <h2>Section title</h2>
    <p>Hello world!</p>
  </section>
""", tag_styles={
    "h1": FontFace(color="#948b8b", size_pt=32),
    "h2": FontFace(color="#948b8b", size_pt=24),
})
pdf.output("html_styled.pdf")
```

Example 3 (python):
```python
from fpdf import FPDF, TextStyle

pdf = FPDF()
pdf.add_page()
pdf.write_html("""
  <dl>
      <dt>Term</dt>
      <dd>Definition</dd>
  </dl>
  <blockquote>
  Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed non risus.
  Suspendisse lectus tortor, dignissim sit amet, adipiscing nec, ultricies sed, dolor.
  Cras elementum ultrices diam.
  </blockquote>
""", tag_styles={
    "dd": TextStyle(l_margin=5),
    "blockquote": TextStyle(color="#ccc", font_style="I",
                            t_margin=5, b_margin=5, l_margin=10),
  })
pdf.output("html_dd_indented.pdf")
```

Example 4 (python):
```python
from fpdf import FPDF

pdf = FPDF()
pdf.add_page()
pdf.write_html("""
  <h1>Big title</h1>
  <section>
    <h2>Section title</h2>
    <p>Hello world!</p>
  </section>
""", font_family="Helvetica")
pdf.output("html_helvetica.pdf")
```

---

## Encryption¬∂

**URL:** https://py-pdf.github.io/fpdf2/Encryption.html

**Contents:**
- Encryption¬∂
- Password locking¬∂
- Access permissions¬∂
- Encryption method¬∂

A PDF document can be encrypted to protect access to its contents.

An owner password is mandatory. Using the owner password anyone can perform any change on the document, including removing all encryption and access permissions.

The optional parameters are user password, access permissions and encryption method.

User password is optional. If none is provided the document content is accessible for everyone.

If a user password is set, the content of the document will be encrypted and a password prompt displayed when a user opens the document. The document will only be displayed after either the user or owner password is entered.

Using access permissions flags you can restrict how the user interact with the document. The available access permission flags are:

PRINT_LOW_RES Print the document, limiting the quality of the printed version.

PRINT_HIGH_RES Print the document at the highest quality.

MODIFY Modify the contents of the document.

COPY Copy or extract text and graphics from the document.

ANNOTATION Add or modify text annotations.

FILL_FORMS Fill in existing interactive form fields.

COPY_FOR_ACCESSIBILITY Extract text and graphics in support of accessibility to users with disabilities

ASSEMBLE Insert, rotate or delete pages and create bookmarks or thumbnail images.

The flags can be combined using |:

The method all() grants all permissions and none() denies all permissions.

If no permission is specified it will default to all().

There are 4 available encryption methods:

NO_ENCRYPTION Data is not encrypted, only add the access permission flags.

RC4 (default) Default PDF encryption algorithm.

AES_128 Encrypts the data with 128 bit key AES algorithm. Requires the cryptography package.

AES_256 Encrypts the data with 256 bit key AES algorithm. Requires the cryptography package.

**Examples:**

Example 1 (unknown):
```unknown
pdf.set_encryption(
    owner_password="foo",
    user_password="bar"
)
```

Example 2 (python):
```python
from fpdf import FPDF
from fpdf.enums import AccessPermission

pdf = FPDF()
pdf.add_page()
pdf.set_font("helvetica", size=12)
pdf.cell(text="hello world")

pdf.set_encryption(
    owner_password="98765421",
    permissions=AccessPermission.PRINT_LOW_RES | AccessPermission.PRINT_HIGH_RES
)

pdf.output("output.pdf")
```

Example 3 (unknown):
```unknown
pdf.set_encryption(
    owner_password="xyz",
    permissions=AccessPermission.all()
)
```

Example 4 (python):
```python
from fpdf import FPDF
from fpdf.enums import AccessPermission, EncryptionMethod

pdf = FPDF()
pdf.add_page()
pdf.set_font("helvetica", size=12)
pdf.cell(text="hello world")

pdf.set_encryption(
    owner_password="123",
    encryption_method=EncryptionMethod.AES_128,
    permissions=AccessPermission.none()
)

pdf.output("output.pdf")
```

---

## Module fpdf.linearization

**URL:** https://py-pdf.github.io/fpdf2/fpdf/linearization.html

**Contents:**
- Module fpdf.linearization
- Classes
  - Ancestors
  - Methods
  - Ancestors
  - Methods
  - Ancestors
  - Methods
  - Ancestors
  - Class variables

This module is in work-in-progress state. Hint tables / hint streams have not been implemented yet, and there are a few "TODO" comment remaining. cf. https://github.com/py-pdf/fpdf2/issues/62

Generates the final bytearray representing the PDF document, based on a FPDF instance.

Inherited from: OutputProducer.bufferize

This method alters the target FPDF instance by assigning IDs to all PDF objects, plus a few other properties on PDFPage instances

Inherited from: PDFContentStream.content_stream

Subclasses can override this method to indicate the presence of a content stream

Inherited from: PDFContentStream.serialize

Serialize the PDF object as an obj<</>>endobj text block

Inherited from: PDFObject.content_stream

Subclasses can override this method to indicate the presence of a content stream

Inherited from: PDFObject.serialize

Serialize the PDF object as an obj<</>>endobj text block

Helper class that provides a standard way to create an ABC using inheritance.

The type of the None singleton.

**Examples:**

Example 1 (python):
```python
class LinearizedOutputProducer(OutputProducer):
    def bufferize(self) -> bytearray:
        fpdf = self.fpdf

        # 1. Setup - Insert all PDF objects
        #    (in the order required to build a linearized PDF),
        #    and assign unique consecutive numeric IDs to all of them

        # Part 1: Header
        self.pdf_objs.append(PDFHeader(fpdf.pdf_version))
        # Part 2: Linearization parameter dictionary
        linearization_obj = PDFLinearization(fpdf.pages_count)
        self._add_pdf_obj(linearization_obj)
        # Part 3: First-page cross-reference table and trailer
        first_xref = PDFXrefAndTrailer(self)
        self.pdf_objs.append(first_xref)
        # Part 4: Document catalogue and other required document-level objects
        catalog_obj = self._add_catalog()
        # Part 5: Primary hint stream (may precede or follow part 6)
        hint_stream_obj = PDFHintStream("".encode("latin-1"))  # TODO
        self.pdf_objs.append(hint_stream_obj)
        # Part 6: First-page section (may precede or follow part 5)
        page_objs = self._add_pages(slice(0, 1))
        # The following objects shall be contained in the first-page section:
        #   + This page object shall explicitly specify all required attributes, e.g. Resources, MediaBox
        #   + The entire outline hierarchy, if the PageMode entry in the catalogue is UseOutlines
        #   + All objects that the page object refers to [including] Contents, Resources, Annots
        # TODO

        first_xref.count = self.obj_id + 1
        first_xref_pdf_objs = list(self.pdf_objs)
        self.obj_id = 0

        # Part 7: Remaining pages
        page_objs.extend(self._add_pages(slice(1, None)))
        # Part 8: Shared objects for all pages except the first
        # = resources, that are referenced from more than one page but [not] from the first page
        pages_root_obj = self._add_pages_root()
        sig_annotation_obj = self._add_annotations_as_objects()
        img_objs_per_index = self._add_images()
        gfxstate_objs_per_name = self._add_gfxstates()
        shading_objs_per_name = self._add_shadings()
        pattern_objs_per_name = self._add_patterns()
        font_objs_per_index = self._add_fonts(
            img_objs_per_index,
            gfxstate_objs_per_name,
            pattern_objs_per_name,
        )
        resources_dict_obj = self._add_resources_dict(
            font_objs_per_index,
            img_objs_per_index,
            gfxstate_objs_per_name,
            shading_objs_per_name,
            pattern_objs_per_name,
        )
        # Part 9: Objects not associated with pages, if any
        for embedded_file in fpdf.embedded_files:
            self._add_pdf_obj(embedded_file, "embedded_files")
        struct_tree_root_obj = self._add_structure_tree()
        outline_dict_obj, outline_items = self._add_document_outline()
        xmp_metadata_obj = self._add_xmp_metadata()
        info_obj = self._add_info()
        # Part 11: Main cross-reference table and trailer
        main_xref = PDFXrefAndTrailer(self)
        self.pdf_objs.append(main_xref)

        # Re-assigning IDs of all PDF objects in the 1st xref table:
        first_xref.start_obj_id = self.obj_id + 1
        for pdf_obj in first_xref_pdf_objs:
            if (
                not isinstance(pdf_obj, ContentWithoutID)
                and pdf_obj is not hint_stream_obj
            ):
                self.obj_id += 1
                pdf_obj.id = self.obj_id
        # The hint streams shall be assigned the last object numbers in the file:
        self.obj_id += 1
        hint_stream_obj.id = self.obj_id

        # 2. Plumbing - Inject all PDF object references required:
        linearization_obj.o = page_objs[0].id  # type: ignore[assignment]
        pages_root_obj.kids = PDFArray(page_objs)
        self._finalize_catalog(
            catalog_obj,
            pages_root_obj=pages_root_obj,
            first_page_obj=page_objs[0],
            sig_annotation_obj=sig_annotation_obj,
            xmp_metadata_obj=xmp_metadata_obj,
            struct_tree_root_obj=struct_tree_root_obj,
            outline_dict_obj=outline_dict_obj,
        )
        dests: list[DestinationXYZ] = []
        for page_obj in page_objs:
            page_obj.parent = pages_root_obj
            page_obj.resources = resources_dict_obj
            assert page_obj.annots is not None
            for annot in page_obj.annots:
                if annot.dest:
                    dests.append(annot.dest)
                if annot.a and hasattr(annot.a, "dest"):
                    dests.append(annot.a.dest)
            if not page_obj.annots:
                # Avoid serializing an empty PDFArray:
                page_obj.annots = None
        for outline_item in outline_items:
            if outline_item.dest is not None:
                dests.append(outline_item.dest)
        # Assigning the .page_ref property of all Destination objects:
        for dest in dests:
            dest.page_ref = pdf_ref(  # pyright: ignore[reportAttributeAccessIssue]
                page_objs[
                    dest.page_number - 1  # pyright: ignore[reportAttributeAccessIssue]
                ].id
            )
        for struct_elem in fpdf.struct_builder.doc_struct_elem.k:
            struct_elem.pg = page_objs[struct_elem.page_number() - 1]
        main_xref.first_xref = first_xref
        first_xref.main_xref = main_xref
        for xref in [main_xref, first_xref]:
            xref.catalog_obj = catalog_obj
            xref.info_obj = info_obj

        # 3. Serializing - Append all PDF objects to the buffer:
        assert (
            not self.buffer
        ), f"Nothing should have been appended to the .buffer at this stage: {self.buffer}"
        assert (
            not self.offsets
        ), f"No offset should have been set at this stage: {len(self.offsets)}"
        for pdf_obj in self.pdf_objs:
            if isinstance(pdf_obj, ContentWithoutID):
                # top header, xref table & trailer:
                trace_label = None
            else:
                self.offsets[pdf_obj.id] = len(self.buffer)
                trace_label = self.trace_labels_per_obj_id.get(pdf_obj.id)
            if trace_label:
                with self._trace_size(trace_label):
                    self._out(pdf_obj.serialize())
            else:
                self._out(pdf_obj.serialize())
        self._log_final_sections_sizes()

        # Now that the file size & all the offsets are known,
        # substitute the values of the Linearization properties:
        hs1_offset = self.offsets[hint_stream_obj.id]
        hs1_length = len(hint_stream_obj.serialize())
        self.buffer = buffer_subst(
            self.buffer,
            HINT_STREAM_OFFSET_LENGTH_PLACEHOLDER,
            f"[{hs1_offset: 12d} {hs1_length: 12d}]",
        )
        self.buffer = buffer_subst(
            self.buffer,
            FIRST_PAGE_END_OFFSET_PLACEHOLDER,
            f"{self.offsets[page_objs[0].id + 1]: 12d}",
        )
        self.buffer = buffer_subst(
            self.buffer,
            MAIN_XREF_1ST_ENTRY_OFFSET_PLACEHOLDER,
            f"{self.offsets[main_xref.start_obj_id]: 12d}",
        )
        self.buffer = buffer_subst(
            self.buffer,
            FILE_LENGTH_PLACEHOLDER,
            f"{len(self.buffer): 12d}",
        )

        if fpdf._sign_key:  # pyright: ignore[reportPrivateUsage]
            self.buffer = sign_content(
                signer,  # pyright: ignore[reportArgumentType]
                self.buffer,
                fpdf._sign_key,  # pyright: ignore[reportPrivateUsage]
                fpdf._sign_cert,  # pyright: ignore[reportPrivateUsage]
                fpdf._sign_extra_certs,  # pyright: ignore[reportPrivateUsage]
                fpdf._sign_hashalgo,  # pyright: ignore[reportPrivateUsage]
                fpdf._sign_time,  # pyright: ignore[reportPrivateUsage]
            )

        return self.buffer
```

Example 2 (python):
```python
def bufferize(self) -> bytearray:
    fpdf = self.fpdf

    # 1. Setup - Insert all PDF objects
    #    (in the order required to build a linearized PDF),
    #    and assign unique consecutive numeric IDs to all of them

    # Part 1: Header
    self.pdf_objs.append(PDFHeader(fpdf.pdf_version))
    # Part 2: Linearization parameter dictionary
    linearization_obj = PDFLinearization(fpdf.pages_count)
    self._add_pdf_obj(linearization_obj)
    # Part 3: First-page cross-reference table and trailer
    first_xref = PDFXrefAndTrailer(self)
    self.pdf_objs.append(first_xref)
    # Part 4: Document catalogue and other required document-level objects
    catalog_obj = self._add_catalog()
    # Part 5: Primary hint stream (may precede or follow part 6)
    hint_stream_obj = PDFHintStream("".encode("latin-1"))  # TODO
    self.pdf_objs.append(hint_stream_obj)
    # Part 6: First-page section (may precede or follow part 5)
    page_objs = self._add_pages(slice(0, 1))
    # The following objects shall be contained in the first-page section:
    #   + This page object shall explicitly specify all required attributes, e.g. Resources, MediaBox
    #   + The entire outline hierarchy, if the PageMode entry in the catalogue is UseOutlines
    #   + All objects that the page object refers to [including] Contents, Resources, Annots
    # TODO

    first_xref.count = self.obj_id + 1
    first_xref_pdf_objs = list(self.pdf_objs)
    self.obj_id = 0

    # Part 7: Remaining pages
    page_objs.extend(self._add_pages(slice(1, None)))
    # Part 8: Shared objects for all pages except the first
    # = resources, that are referenced from more than one page but [not] from the first page
    pages_root_obj = self._add_pages_root()
    sig_annotation_obj = self._add_annotations_as_objects()
    img_objs_per_index = self._add_images()
    gfxstate_objs_per_name = self._add_gfxstates()
    shading_objs_per_name = self._add_shadings()
    pattern_objs_per_name = self._add_patterns()
    font_objs_per_index = self._add_fonts(
        img_objs_per_index,
        gfxstate_objs_per_name,
        pattern_objs_per_name,
    )
    resources_dict_obj = self._add_resources_dict(
        font_objs_per_index,
        img_objs_per_index,
        gfxstate_objs_per_name,
        shading_objs_per_name,
        pattern_objs_per_name,
    )
    # Part 9: Objects not associated with pages, if any
    for embedded_file in fpdf.embedded_files:
        self._add_pdf_obj(embedded_file, "embedded_files")
    struct_tree_root_obj = self._add_structure_tree()
    outline_dict_obj, outline_items = self._add_document_outline()
    xmp_metadata_obj = self._add_xmp_metadata()
    info_obj = self._add_info()
    # Part 11: Main cross-reference table and trailer
    main_xref = PDFXrefAndTrailer(self)
    self.pdf_objs.append(main_xref)

    # Re-assigning IDs of all PDF objects in the 1st xref table:
    first_xref.start_obj_id = self.obj_id + 1
    for pdf_obj in first_xref_pdf_objs:
        if (
            not isinstance(pdf_obj, ContentWithoutID)
            and pdf_obj is not hint_stream_obj
        ):
            self.obj_id += 1
            pdf_obj.id = self.obj_id
    # The hint streams shall be assigned the last object numbers in the file:
    self.obj_id += 1
    hint_stream_obj.id = self.obj_id

    # 2. Plumbing - Inject all PDF object references required:
    linearization_obj.o = page_objs[0].id  # type: ignore[assignment]
    pages_root_obj.kids = PDFArray(page_objs)
    self._finalize_catalog(
        catalog_obj,
        pages_root_obj=pages_root_obj,
        first_page_obj=page_objs[0],
        sig_annotation_obj=sig_annotation_obj,
        xmp_metadata_obj=xmp_metadata_obj,
        struct_tree_root_obj=struct_tree_root_obj,
        outline_dict_obj=outline_dict_obj,
    )
    dests: list[DestinationXYZ] = []
    for page_obj in page_objs:
        page_obj.parent = pages_root_obj
        page_obj.resources = resources_dict_obj
        assert page_obj.annots is not None
        for annot in page_obj.annots:
            if annot.dest:
                dests.append(annot.dest)
            if annot.a and hasattr(annot.a, "dest"):
                dests.append(annot.a.dest)
        if not page_obj.annots:
            # Avoid serializing an empty PDFArray:
            page_obj.annots = None
    for outline_item in outline_items:
        if outline_item.dest is not None:
            dests.append(outline_item.dest)
    # Assigning the .page_ref property of all Destination objects:
    for dest in dests:
        dest.page_ref = pdf_ref(  # pyright: ignore[reportAttributeAccessIssue]
            page_objs[
                dest.page_number - 1  # pyright: ignore[reportAttributeAccessIssue]
            ].id
        )
    for struct_elem in fpdf.struct_builder.doc_struct_elem.k:
        struct_elem.pg = page_objs[struct_elem.page_number() - 1]
    main_xref.first_xref = first_xref
    first_xref.main_xref = main_xref
    for xref in [main_xref, first_xref]:
        xref.catalog_obj = catalog_obj
        xref.info_obj = info_obj

    # 3. Serializing - Append all PDF objects to the buffer:
    assert (
        not self.buffer
    ), f"Nothing should have been appended to the .buffer at this stage: {self.buffer}"
    assert (
        not self.offsets
    ), f"No offset should have been set at this stage: {len(self.offsets)}"
    for pdf_obj in self.pdf_objs:
        if isinstance(pdf_obj, ContentWithoutID):
            # top header, xref table & trailer:
            trace_label = None
        else:
            self.offsets[pdf_obj.id] = len(self.buffer)
            trace_label = self.trace_labels_per_obj_id.get(pdf_obj.id)
        if trace_label:
            with self._trace_size(trace_label):
                self._out(pdf_obj.serialize())
        else:
            self._out(pdf_obj.serialize())
    self._log_final_sections_sizes()

    # Now that the file size & all the offsets are known,
    # substitute the values of the Linearization properties:
    hs1_offset = self.offsets[hint_stream_obj.id]
    hs1_length = len(hint_stream_obj.serialize())
    self.buffer = buffer_subst(
        self.buffer,
        HINT_STREAM_OFFSET_LENGTH_PLACEHOLDER,
        f"[{hs1_offset: 12d} {hs1_length: 12d}]",
    )
    self.buffer = buffer_subst(
        self.buffer,
        FIRST_PAGE_END_OFFSET_PLACEHOLDER,
        f"{self.offsets[page_objs[0].id + 1]: 12d}",
    )
    self.buffer = buffer_subst(
        self.buffer,
        MAIN_XREF_1ST_ENTRY_OFFSET_PLACEHOLDER,
        f"{self.offsets[main_xref.start_obj_id]: 12d}",
    )
    self.buffer = buffer_subst(
        self.buffer,
        FILE_LENGTH_PLACEHOLDER,
        f"{len(self.buffer): 12d}",
    )

    if fpdf._sign_key:  # pyright: ignore[reportPrivateUsage]
        self.buffer = sign_content(
            signer,  # pyright: ignore[reportArgumentType]
            self.buffer,
            fpdf._sign_key,  # pyright: ignore[reportPrivateUsage]
            fpdf._sign_cert,  # pyright: ignore[reportPrivateUsage]
            fpdf._sign_extra_certs,  # pyright: ignore[reportPrivateUsage]
            fpdf._sign_hashalgo,  # pyright: ignore[reportPrivateUsage]
            fpdf._sign_time,  # pyright: ignore[reportPrivateUsage]
        )

    return self.buffer
```

Example 3 (python):
```python
class PDFHintStream(PDFContentStream):
    def __init__(self, contents: bytes, compress: bool = False) -> None:
        super().__init__(contents=contents, compress=compress)
        self.s = None  # (Required) Shared object hint table
        self.t = None  # (Present only if thumbnail images exist) Thumbnail hint table
        self.o = None  # (Present only if a document outline exists) Outline hint table
        self.a = None  # (Present only if article threads exist) Thread information hint table
        self.e = None  # (Present only if named destinations exist) Named destination hint table
        self.v = None  # (Present only if an interactive form dictionary exists) Interactive form hint table
        self.i = None  # (Present only if a document information dictionary exists) Information dictionary hint table
        self.c = None  # (Present only if a logical structure hierarchy exists; PDF 1.3) Logical structure hint table
        self.l = None  # (PDF 1.3) Page label hint table
        self.r = None  # (Present only if a renditions name tree exists; PDF 1.5) Renditions name tree hint table
        self.b = None  # (Present only if embedded file streams exist; PDF 1.5) Embedded file stream hint table
```

Example 4 (python):
```python
class PDFLinearization(PDFObject):
    def __init__(self, pages_count: int) -> None:
        super().__init__()
        self.linearized = "1"  # Version
        self.n = pages_count
        # Primary hint stream offset and length (part 5):
        self.h = HINT_STREAM_OFFSET_LENGTH_PLACEHOLDER
        self.o = None  # Object number of first page‚Äôs page object (part 6)
        self.e = FIRST_PAGE_END_OFFSET_PLACEHOLDER  # Offset of end of first page
        # Offset of first entry in main cross-reference table (part 11):
        self.t = MAIN_XREF_1ST_ENTRY_OFFSET_PLACEHOLDER
        self.l = FILE_LENGTH_PLACEHOLDER  # The length of the entire file in bytes
```

---

## Module fpdf.graphics_state

**URL:** https://py-pdf.github.io/fpdf2/fpdf/graphics_state.html

**Contents:**
- Module fpdf.graphics_state
- Classes
  - Instance variables
  - Methods
  - Instance variables
  - Methods
  - Subclasses
  - Class variables
  - Instance variables
  - Methods

Mixin class for managing a stack of graphics state variables.

The contents of this module are internal to fpdf2, and not part of the public API. They may change at any time without prior warning or any deprecation period, in non-backward-compatible ways.

Usage documentation at: https://py-pdf.github.io/fpdf2/Internals.html#graphicsstatemixin

Mutable snapshot of the current graphics state for fragments and local contexts.

Mutable snapshot of the current graphics state for fragments and local contexts.

Mixin class for managing a stack of graphics state variables.

To the subclassing library and its users, the variables look like normal instance attributes. But by the magic of properties, we can push and pop levels as needed, and users will always see and modify just the current version.

This class is mixed in by fpdf.FPDF(), and is not meant to be used directly by user code.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

Return vertical character position relative to line. (docs)

Return lift factor for denominator text. (docs)

Return scale factor for denominator text. (docs)

Return lift factor for nominator text. (docs)

Return scale factor for nominator text. (docs)

Return lift factor for subscript text. (docs)

Return scale factor for subscript text. (docs)

Return lift factor for superscript text. (docs)

Return scale factor for superscript text. (docs)

Retrieve the current graphics state

Indicate if a nested graphics state is active

Pop the last graphics state on the stack

Push a graphics state on the stack

Return a FontFace instance representing a subset of properties of this GraphicsState.

**Examples:**

Example 1 (python):
```python
@dataclass(slots=True)
class GraphicsState:
    """Mutable snapshot of the current graphics state for fragments and local contexts."""

    draw_color: Optional[DeviceRGB | DeviceCMYK | DeviceGray] = _DEFAULT_DRAW_COLOR
    fill_color: Optional[DeviceRGB | DeviceCMYK | DeviceGray] = _DEFAULT_FILL_COLOR
    text_color: Optional[DeviceRGB | DeviceCMYK | DeviceGray] = _DEFAULT_TEXT_COLOR
    underline: bool = False
    strikethrough: bool = False
    font_style: str = ""
    font_stretching: float = 100
    char_spacing: float = 0
    font_family: str = ""
    font_size_pt: float = 0
    current_font: Optional[CoreFont | TTFFont] = None
    current_font_is_set_on_page: bool = False
    dash_pattern: dict[str, float] = field(
        default_factory=lambda: dict(dash=0, gap=0, phase=0)
    )
    line_width: float = 0
    text_mode: TextMode = TextMode.FILL
    char_vpos: CharVPos = CharVPos.LINE
    sub_scale: float = 0.7
    sup_scale: float = 0.7
    nom_scale: float = 0.75
    denom_scale: float = 0.75
    sub_lift: float = -0.15
    sup_lift: float = 0.4
    nom_lift: float = 0.2
    denom_lift: float = 0.0
    text_shaping: Optional[dict[str, Any]] = None

    def copy(self) -> "GraphicsState":
        new_state = copy(self)
        new_state.text_shaping = copy(new_state.text_shaping)
        return new_state

    def as_kwargs(self) -> dict[str, Any]:
        return {
            state_field.name: getattr(self, state_field.name)
            for state_field in fields(self)
        }
```

Example 2 (python):
```python
@dataclass(slots=True)
class GraphicsState:
    """Mutable snapshot of the current graphics state for fragments and local contexts."""

    draw_color: Optional[DeviceRGB | DeviceCMYK | DeviceGray] = _DEFAULT_DRAW_COLOR
    fill_color: Optional[DeviceRGB | DeviceCMYK | DeviceGray] = _DEFAULT_FILL_COLOR
    text_color: Optional[DeviceRGB | DeviceCMYK | DeviceGray] = _DEFAULT_TEXT_COLOR
    underline: bool = False
    strikethrough: bool = False
    font_style: str = ""
    font_stretching: float = 100
    char_spacing: float = 0
    font_family: str = ""
    font_size_pt: float = 0
    current_font: Optional[CoreFont | TTFFont] = None
    current_font_is_set_on_page: bool = False
    dash_pattern: dict[str, float] = field(
        default_factory=lambda: dict(dash=0, gap=0, phase=0)
    )
    line_width: float = 0
    text_mode: TextMode = TextMode.FILL
    char_vpos: CharVPos = CharVPos.LINE
    sub_scale: float = 0.7
    sup_scale: float = 0.7
    nom_scale: float = 0.75
    denom_scale: float = 0.75
    sub_lift: float = -0.15
    sup_lift: float = 0.4
    nom_lift: float = 0.2
    denom_lift: float = 0.0
    text_shaping: Optional[dict[str, Any]] = None

    def copy(self) -> "GraphicsState":
        new_state = copy(self)
        new_state.text_shaping = copy(new_state.text_shaping)
        return new_state

    def as_kwargs(self) -> dict[str, Any]:
        return {
            state_field.name: getattr(self, state_field.name)
            for state_field in fields(self)
        }
```

Example 3 (python):
```python
@dataclass(slots=True)
class GraphicsState:
    """Mutable snapshot of the current graphics state for fragments and local contexts."""

    draw_color: Optional[DeviceRGB | DeviceCMYK | DeviceGray] = _DEFAULT_DRAW_COLOR
    fill_color: Optional[DeviceRGB | DeviceCMYK | DeviceGray] = _DEFAULT_FILL_COLOR
    text_color: Optional[DeviceRGB | DeviceCMYK | DeviceGray] = _DEFAULT_TEXT_COLOR
    underline: bool = False
    strikethrough: bool = False
    font_style: str = ""
    font_stretching: float = 100
    char_spacing: float = 0
    font_family: str = ""
    font_size_pt: float = 0
    current_font: Optional[CoreFont | TTFFont] = None
    current_font_is_set_on_page: bool = False
    dash_pattern: dict[str, float] = field(
        default_factory=lambda: dict(dash=0, gap=0, phase=0)
    )
    line_width: float = 0
    text_mode: TextMode = TextMode.FILL
    char_vpos: CharVPos = CharVPos.LINE
    sub_scale: float = 0.7
    sup_scale: float = 0.7
    nom_scale: float = 0.75
    denom_scale: float = 0.75
    sub_lift: float = -0.15
    sup_lift: float = 0.4
    nom_lift: float = 0.2
    denom_lift: float = 0.0
    text_shaping: Optional[dict[str, Any]] = None

    def copy(self) -> "GraphicsState":
        new_state = copy(self)
        new_state.text_shaping = copy(new_state.text_shaping)
        return new_state

    def as_kwargs(self) -> dict[str, Any]:
        return {
            state_field.name: getattr(self, state_field.name)
            for state_field in fields(self)
        }
```

Example 4 (python):
```python
@dataclass(slots=True)
class GraphicsState:
    """Mutable snapshot of the current graphics state for fragments and local contexts."""

    draw_color: Optional[DeviceRGB | DeviceCMYK | DeviceGray] = _DEFAULT_DRAW_COLOR
    fill_color: Optional[DeviceRGB | DeviceCMYK | DeviceGray] = _DEFAULT_FILL_COLOR
    text_color: Optional[DeviceRGB | DeviceCMYK | DeviceGray] = _DEFAULT_TEXT_COLOR
    underline: bool = False
    strikethrough: bool = False
    font_style: str = ""
    font_stretching: float = 100
    char_spacing: float = 0
    font_family: str = ""
    font_size_pt: float = 0
    current_font: Optional[CoreFont | TTFFont] = None
    current_font_is_set_on_page: bool = False
    dash_pattern: dict[str, float] = field(
        default_factory=lambda: dict(dash=0, gap=0, phase=0)
    )
    line_width: float = 0
    text_mode: TextMode = TextMode.FILL
    char_vpos: CharVPos = CharVPos.LINE
    sub_scale: float = 0.7
    sup_scale: float = 0.7
    nom_scale: float = 0.75
    denom_scale: float = 0.75
    sub_lift: float = -0.15
    sup_lift: float = 0.4
    nom_lift: float = 0.2
    denom_lift: float = 0.0
    text_shaping: Optional[dict[str, Any]] = None

    def copy(self) -> "GraphicsState":
        new_state = copy(self)
        new_state.text_shaping = copy(new_state.text_shaping)
        return new_state

    def as_kwargs(self) -> dict[str, Any]:
        return {
            state_field.name: getattr(self, state_field.name)
            for state_field in fields(self)
        }
```

---

## √ñƒüretici¬∂

**URL:** https://py-pdf.github.io/fpdf2/Tutorial-tr.html

**Contents:**
- √ñƒüretici¬∂
- √ñƒüretici 1 - Minimal √ñrnek¬∂
- √ñƒüretici 2 - Ba≈ülƒ±k, altbilgi, sayfa sonu ve resim¬∂
- √ñƒüretici 3 - Satƒ±r sonlarƒ± ve renkler¬∂
- √ñƒüretici 4 - √áoklu S√ºtunlar¬∂
- √ñƒüretici 5 - Tablolar Olu≈üturma¬∂
- √ñƒüretici 6 - Baƒülantƒ±lar Olu≈üturma ve Metin Stillerini Harmanlayarak Kullanma¬∂

Metodlarƒ±n tam d√∂k√ºmantasyonu: fpdf.FPDF API d√∂k√ºmanƒ±

Hadi klasik bir √∂rnekle ba≈ülayalƒ±m:

K√ºt√ºphaneyi dahil ettikten sonra, FPDF objesi olu≈üturuyoruz. FPDF olu≈üturucusu buradaki varsayƒ±lan deƒüerleri kullanƒ±r: sayfalar dikey A4 formatƒ±nda ve milimetre cinsinden √∂l√ß√ºl√ºd√ºr. Ayrƒ±ca bu ≈üekilde a√ßƒ±k√ßa da belirtilebilir:

Diƒüer sayfa formatlarƒ± (Letter ve Legal gibi) ve √∂l√ß√º birimleri (pt, cm, in) de kullanƒ±labilir.

≈ûu an i√ßin bir sayfamƒ±z yok, bu y√ºzden bir tane eklememiz gerekiyor add_page. Ba≈ülangƒ±√ß noktasƒ± sol √ºst k√∂≈üededir ve ge√ßerli konum varsayƒ±lan olarak sƒ±nƒ±rlardan 1 cm uzaƒüa yerle≈ütirilir; kenar bo≈üluklarƒ± set_margins ile deƒüi≈ütirilebilir.

Metni yazdƒ±rmadan √∂nce, a≈üaƒüƒ±daki √∂zelliklere sahip bir yazƒ± tipi se√ßmek zorunludur set_font, aksi takdirde belge ge√ßersiz olur. Helvetica bold 16'yƒ± se√ßiyoruz:

Yazƒ± tipi stilleriyle oynayabiliriz. √ñrneƒüin, italikleri I ile, altƒ± √ßizgili U ile veya d√ºz bir yazƒ± tipiyle bo≈ü bir dizeyle (veya herhangi bir kombinasyonla) belirtebiliriz. Yazƒ± tipi boyutu puan cinsinden belirtilir, milimetre (veya ba≈üka bir kullanƒ±cƒ± birimi) deƒüil; bu tek istisnadƒ±r. Diƒüer yerle≈üik yazƒ± tipleri Times, Courier, Symbol ve ZapfDingbats'tir.

Artƒ±k bir h√ºcreyi cell ile yazdƒ±rabiliriz. H√ºcre, muhtemelen √ßer√ßeveli, metin i√ßeren bir dikd√∂rtgen alanƒ±dƒ±r. H√ºcre ge√ßerli konumda olu≈üturulur. Boyutlarƒ±nƒ±, metnini (merkezlenmi≈ü veya hizalanmƒ±≈ü), √ßer√ßevelerinin √ßizilip √ßizilmeyeceƒüini ve sonrasƒ±nda nereye gidileceƒüini (saƒüa, a≈üaƒüƒ±ya veya bir sonraki satƒ±rƒ±n ba≈üƒ±na) belirtiriz. Bir √ßer√ßeve eklemek i√ßin ≈üunu yapabiliriz:

Yanƒ±na merkezlenmi≈ü metin eklemek ve bir sonraki satƒ±ra gitmek i√ßin, ≈üunu yapabiliriz:

Not: Satƒ±r sonu ayrƒ±ca ln ile de yapƒ±labilir. Bu metot ayrƒ±ca, satƒ±r aralƒ±ƒüƒ±nƒ± belirtmeye de olanak tanƒ±r.

Son olarak, belge kapatƒ±lƒ±r ve verilen dosya yoluna kaydedilir. output. Herhangi bir parametre saƒülanmadƒ±ƒüƒ±nda, output() PDF bytearray buffer deƒüerini d√∂nd√ºr√ºr.

≈ûimdi bir ba≈ülƒ±k, altbilgi ve logo i√ßeren iki sayfalƒ±k bir √∂rnek yapalƒ±m:

Bu √∂rnek, sayfa ba≈ülƒ±klarƒ±nƒ± ve altbilgilerini i≈ülemek i√ßin header ve footer metodlarƒ±nƒ± kullanƒ±r. Bunlar otomatik olarak √ßaƒürƒ±lƒ±r. Bu √∂zellikler FPDF sƒ±nƒ±fƒ±nda zaten mevcuttur ancak varsayƒ±lan olduklarƒ±ndan bo≈üturlar, bu y√ºzden sƒ±nƒ±fƒ± geni≈ületmeli ve i√ßeriklerini doldurarak onlarƒ± √∂zelle≈ütirmeliyiz.

Logo, image metoduyla √ºst sol k√∂≈üesini ve geni≈üliƒüini belirterek yazdƒ±rƒ±lƒ±r. Y√ºkseklik otomatik olarak hesaplanƒ±r ve resmin oranlarƒ±nƒ± korumak i√ßin kullanƒ±lƒ±r.

Sayfa numarasƒ±nƒ± yazdƒ±rmak i√ßin, h√ºcre geni≈üliƒüi olarak null bir deƒüer ge√ßilir. Bu, metnin saƒü kenarƒ±na kadar uzanmasƒ± gerektiƒüi anlamƒ±na gelir; metni ortalamak i√ßin kullanƒ±≈ülƒ±dƒ±r. Ge√ßerli sayfa numarasƒ± page_no metodu ile alƒ±nƒ±r; toplam sayfa sayƒ±sƒ± ise belge kapatƒ±ldƒ±ƒüƒ±nda {nb} ile deƒüi≈ütirilecek √∂zel bir deƒüerle alƒ±nƒ±r (bu √∂zel deƒüer alias_nb_pages() ile deƒüi≈ütirilebilir). Not olarak, set_y metodu, sayfanƒ±n √ºst√ºnden veya altƒ±ndan ba≈ülayarak mutlak bir konum belirlemeye izin verir.

Burada kullanƒ±lan ba≈üka ilgin√ß bir √∂zellik de otomatik sayfa sƒ±nƒ±rlandƒ±rmalarƒ±dƒ±r. Bir h√ºcre sayfanƒ±n bir sƒ±nƒ±rƒ±nƒ± ge√ßeceƒüi anda (varsayƒ±lan olarak alttan 2 cm uzakta) bir kesme ger√ßekle≈ütirilir ve yazƒ± tipi geri y√ºklenir. Ba≈ülƒ±k ve altbilgi kendi yazƒ± tipini (helvetica) se√ßerken, g√∂vde Times ile devam eder. Bu otomatik geri y√ºkleme mekanizmasƒ±, renkler ve √ßizgi kalƒ±nlƒ±ƒüƒ± i√ßin de ge√ßerlidir. Sayfa kesimlerini tetikleyen sƒ±nƒ±r, set_auto_page_break ile ayarlanabilir.

≈ûimdi, paragraflarƒ± hizalayarak yazdƒ±ran bir √∂rneƒüe devam edelim. Ayrƒ±ca renklerin nasƒ±l kullanƒ±lacaƒüƒ±nƒ± g√∂sterir.

get_string_width metodu, kullanƒ±lan yazƒ± tipindeki bir dizenin uzunluƒüunu belirlemeye olanak tanƒ±r. Bu, ba≈ülƒ±ƒüƒ± √ßevreleyen kƒ±smƒ±n konumunu ve geni≈üliƒüini hesaplamak i√ßin kullanƒ±lƒ±r. Ardƒ±ndan renkler ayarlanƒ±r (set_draw_color, set_fill_color ve set_text_color) ve √ßizgi kalƒ±nlƒ±ƒüƒ± varsayƒ±lan 0.2 mm'ye kar≈üƒ± 1 mm'ye ayarlanƒ±r set_line_width. Son olarak, h√ºcre √ßƒ±ktƒ±sƒ± yapƒ±lƒ±r (arka planƒ±n doldurulmasƒ± gerektiƒüini belirten son parametre true'dur).

Paragraflarƒ± yazdƒ±rmak i√ßin kullanƒ±lan y√∂ntem multi_cell metotudur. Metin varsayƒ±lan olarak hizalanƒ±r. Her bir satƒ±r saƒü sƒ±nƒ±rƒ± h√ºcrenin saƒü kenarƒ±na ula≈ütƒ±ƒüƒ±nda veya bir satƒ±r sonu karakteri (\n) kar≈üƒ±la≈üƒ±ldƒ±ƒüƒ±nda, bir satƒ±r sonu verilir ve yeni bir h√ºcre otomatik olarak mevcut h√ºcrenin altƒ±na olu≈üturulur. Otomatik bir kesme, en yakƒ±n bo≈üluƒüa veya yumu≈üak kƒ±sa √ßizgi karakterine (\u00ad) saƒü sƒ±nƒ±ra ula≈üƒ±ldƒ±ƒüƒ±nda ger√ßekle≈ütirilir. Bir satƒ±r sonu tetiklendiƒüinde, bir yumu≈üak kƒ±sa √ßizgi normal bir kƒ±sa √ßizgiyle deƒüi≈ütirilir ve aksi takdirde yoksayƒ±lƒ±r.

ƒ∞ki belge √∂zelliƒüi tanƒ±mlanmƒ±≈ütƒ±r: ba≈ülƒ±k (set_title) ve yazar (set_author). √ñzellikler iki ≈üekilde g√∂r√ºlebilir. ƒ∞lk olarak, belgeyi doƒürudan Acrobat Reader ile a√ßarak, Dosya men√ºs√ºne gidin ve Belge √ñzellikleri se√ßeneƒüini se√ßin. ƒ∞kincisi, eklentiden de mevcut olan, belge √∂zelliklerini saƒü tƒ±klayarak se√ßmek.

Bu √∂rnek, metni birden fazla s√ºtuna yayarak, metni birden fazla s√ºtuna yayarak nasƒ±l yapƒ±lacaƒüƒ±nƒ± g√∂sterir. This example is a variant of the previous one, showing how to lay the text across multiple columns.

√ñnceki √∂ƒüreticiyle ana fark, text_columns metodunun kullanƒ±lmasƒ±dƒ±r. Metni toplar ve istenen s√ºtun sayƒ±sƒ±na daƒüƒ±tƒ±r, gerekirse otomatik olarak sayfa kesmeleri ekler. TextColumns √∂rneƒüi bir baƒülam y√∂neticisi olarak etkin olduƒüunda, metin stilleri ve diƒüer yazƒ± tipi √∂zellikleri deƒüi≈ütirilebilir. Bu deƒüi≈üiklikler baƒülamla sƒ±nƒ±rlƒ± olacaktƒ±r. Kapatƒ±ldƒ±ƒüƒ±nda √∂nceki ayarlar yeniden y√ºklenecektir.

Bu √∂ƒüretici, iki farklƒ± tablo olu≈üturmayƒ± a√ßƒ±klar, basit ayarlamalarla nelerin elde edilebileceƒüini g√∂stermek i√ßin.

Sonu√ß PDF - √úlkelerin CSV verisi

ƒ∞lk √∂rnek m√ºmk√ºn olan en basit y√∂ntem ile elde edilebilir, verileri FPDF.table() metoduna vererek. Sonu√ß basit olsa da √ßok hƒ±zlƒ± bir ≈üekilde elde edilir.

ƒ∞kinci tablo bazƒ± iyile≈ütirmeler getirir: renkler, sƒ±nƒ±rlƒ± tablo geni≈üliƒüi, azaltƒ±lmƒ±≈ü satƒ±r y√ºksekliƒüi, ba≈ülƒ±klarƒ±n ortalanmasƒ±, √∂zel geni≈üliklere sahip s√ºtunlar, rakamlarƒ±n saƒüa hizalanmasƒ±... Ayrƒ±ca yatay √ßizgiler kaldƒ±rƒ±lmƒ±≈ütƒ±r. Bu, mevcut deƒüerler arasƒ±ndan bir borders_layout se√ßilerek yapƒ±lmƒ±≈ütƒ±r: TableBordersLayout.

Bu √∂ƒüretici, bir pdf belgesi i√ßine baƒülantƒ±lar eklemenin birka√ß yolunu a√ßƒ±klar, ayrƒ±ca dƒ±≈ü kaynaklara baƒülantƒ± eklemeyi g√∂sterir.

Ayrƒ±ca, aynƒ± metin i√ßinde farklƒ± metin stillerini (kalƒ±n, italik, altƒ± √ßizili) nasƒ±l kullanabileceƒüimizi g√∂sterecektir.

Sonu√ß PDF - fpdf2-logo

Bu √∂ƒüreticide, metin yazdƒ±rmak i√ßin g√∂sterilen yeni y√∂ntem write() . Burada g√∂sterilen yeni y√∂ntem, metni yazdƒ±rmak i√ßin kullanƒ±lan multi_cell() metoduna olduk√ßa benzer, temel farklar ≈üunlardƒ±r:

Bu y√∂ntem, bir metin par√ßasƒ± yazmamƒ±za, yazƒ± tipi stilini deƒüi≈ütirmemize ve kaldƒ±ƒüƒ±mƒ±z yerden devam etmemize olanak tanƒ±r. √ñte yandan, metni multi_cell() metoduyla olduƒüu gibi d√ºzg√ºn hizalayamayƒ±z.

ƒ∞lk sayfada, bu ama√ßla write() kullanƒ±ldƒ±. C√ºmlenin ba≈ülangƒ±cƒ± d√ºz yazƒ± tipinde yazƒ±ldƒ±, ardƒ±ndan set_font() metoduyla altƒ± √ßizili haline getirildi ve c√ºmle tamamlandƒ±.

ƒ∞kinci sayfaya y√∂nlendiren bir i√ß baƒülantƒ± eklemek i√ßin, ikinci sayfayƒ± ekledik ve add_link() metoduyla ikinci sayfaya y√∂nlendiren bir baƒülantƒ± linki olu≈üturduk.

Dƒ±≈ü baƒülantƒ± olu≈üturmak i√ßin bir resim kullanarak dƒ±≈ü baƒülantƒ± olu≈üturduk image() . Metodun bir baƒülantƒ±yƒ± bir arg√ºman olarak ge√ßme se√ßeneƒüi vardƒ±r. Baƒülantƒ± hem i√ß hem de dƒ±≈ü baƒülantƒ± olabilir.

Alternatif olarak, yazƒ± tipi stilini deƒüi≈ütirmek ve baƒülantƒ±lar eklemek i√ßin ba≈üka bir se√ßenek de write_html() y√∂ntemini kullanƒ±n. Metin eklemeyi saƒülayan bir html ayrƒ±≈ütƒ±rƒ±cƒ±dƒ±r, yazƒ± tipi stilini deƒüi≈ütirme ve html kullanarak baƒülantƒ± ekleme √∂zelliklerine sahiptir.

**Examples:**

Example 1 (python):
```python
from fpdf import FPDF

pdf = FPDF()
pdf.add_page()
pdf.set_font("helvetica", style="B", size=16)
pdf.cell(40, 10, "Hello World!")
pdf.output("tuto1.pdf")
```

Example 2 (unknown):
```unknown
pdf = FPDF(orientation="P", unit="mm", format="A4")
```

Example 3 (unknown):
```unknown
pdf.set_font('Helvetica', style='B', size=16)
```

Example 4 (unknown):
```unknown
pdf.cell(40, 10, 'Merhaba D√ºnya!', 1)
```

---

## Templates¬∂

**URL:** https://py-pdf.github.io/fpdf2/Templates.html

**Contents:**
- Templates¬∂
- Using Template¬∂
- Using FlexTemplate¬∂
- Details - Template definition¬∂
- How to create a template¬∂
  - Example - Python dict¬∂
  - Example - Elements defined in JSON file¬∂
  - Example - Elements defined in CSV file¬∂

Templates are a fpdf2 feature that define predefined documents (like invoices, tax forms, etc.), or parts of such documents, where each element (text, lines, barcodes, etc.) has a fixed position (x1, y1, x2, y2), style (font, size, etc.) and a default text.

These elements can act as placeholders, so the program can change the default text "filling in" the document.

Besides being defined in code, the elements can also be defined in a CSV file, a JSON file, or in a database, so the user can easily adapt the form to his printing needs.

A template is used like a dict, setting its items' values.

There are two approaches to using templates:

The traditional approach is to use the Template class. This class accepts one template definition, and can apply it to each page of a document. The usage pattern here is:

The Template class will create and manage its own FPDF instance, so you don't need to worry about how it all works together. It also allows to set the page format, title of the document, measuring unit, and other metadata for the PDF file.

Check the dedicated page for the full method signatures: Template.

You can also check the unit tests in test_template.py for more usage examples of Template.

Setting text values for specific template items is done by treating the class as a dict, with the name of the item as the key:

When more flexibility is desired, then the FlexTemplate class comes into play. In this case, you first need to create your own FPDF instance. You can then pass this to the constructor of one or several FlexTemplate instances, and have each of them load a template definition. For any page of the document, you can set text values on a template, and then render it on that page. After rendering, the template will be reset to its default values.

Evidently, this can end up quite a bit more involved, but there are hardly any limits on how you can combine templated and non-templated content on each page. Just think of the different templates as of building blocks, like configurable rubber stamps, which you can apply in any combination on any page you like.

Of course, you can just as well use a set of full-page templates, possibly differentiating between cover page, table of contents, normal content pages, and an index page, or something along those lines.

And here's how you can use a template several times on one page (and by extension, several times on several pages). When rendering with an offsetx and/or offsety argument, the contents of the template will end up in a different place on the page. A rotate argument will change its orientation, rotated around the origin of the template. The pivot of the rotation is the offset location. And finally, a scale argument allows you to insert the template larger or smaller than it was defined.

Check the dedicated page for the full method signatures: FlexTemplate.

You can also check the unit tests in test_flextemplate.py for more usage examples of FlexTemplate.

The dict syntax for setting text values is the same as above:

A template definition consists of a number of elements, which have the following properties (columns in a CSV, items in a dict, name/value pairs in a JSON object, fields in a database). Dimensions (except font size, which always uses points) are given in user defined units (default: mm). Those are the units that can be specified when creating a Template or a FPDF instance.

Fields that are not relevant to a specific element type will be ignored there, but if not left empty, they must still adhere to the specified data type (in dicts, string fields may be None).

A template can be created in several ways:

The JSON file must consist of an array of objects. Each object with its name/value pairs define a template element:

Then you import and use that template as follows:

You can define template elements in a CSV file template_definition.csv. It can look like this: line0;L;20.0;12.0;190.0;12.0;times;0.5;0;0;0;0;16777215;C;;0;0;0.0 line1;L;20.0;36.0;190.0;36.0;times;0.5;0;0;0;0;16777215;C;;0;0;0.0 name0;T;21.0;14.0;104.0;25.0;times;16.0;0;0;0;0;16777215;L;name;2;0;0.0 title0;T;21.0;26.0;104.0;30.0;times;10.0;0;0;0;0;16777215;L;title;2;0;0.0 multiline;T;21.0;50.0;28.0;54.0;times;10.5;0;0;0;0;0xffff00;L;multi line;0;1;0.0 numeric_text;T;21.0;80.0;100.0;84.0;times;10.5;0;0;0;0;;R;007;0;0;0.0 empty_fields;T;21.0;100.0;100.0;104.0 rotated;T;21.0;80.0;100.0;84.0;times;10.5;0;0;0;0;;R;ROTATED;0;0;30.0

Remember that each line represents an element and each field represents one of the properties of the element in the following order: ('name','type','x1','y1','x2','y2','font','size','bold','italic','underline','foreground','background','align','text','priority', 'multiline', 'rotate', 'wrapmode') As noted above, most fields may be left empty, so a line is valid with only 6 items. The empty_fields line of the example demonstrates all that can be left away. In addition, for the barcode types, x2 may be empty.

Then you can use the file like this:

**Examples:**

Example 1 (markdown):
```markdown
tmpl = Template(elements=elements)
# first page and content
tmpl.add_page()
tmpl[item_key_01] = "Text 01"
tmpl[item_key_02] = "Text 02"
...

# second page and content
tmpl.add_page()
tmpl[item_key_01] = "Text 11"
tmpl[item_key_02] = "Text 12"
...

# possibly more pages
...

# finalize document and write to file
tmpl.render(outfile="example.pdf")
```

Example 2 (unknown):
```unknown
Template["company_name"] = "Sample Company"
```

Example 3 (python):
```python
from fpdf import FlexTemplate, FPDF

pdf = FPDF()
pdf.add_page()
# One template for the first page
fp_tmpl = FlexTemplate(pdf, elements=fp_elements)
fp_tmpl["item_key_01"] = "Text 01"
fp_tmpl["item_key_02"] = "Text 02"
...
fp_tmpl.render() # add template items to first page

# add some more non-template content to the first page
pdf.polyline(point_list, fill=False, polygon=False)

# second page
pdf.add_page()
# header for the second page
h_tmpl = FlexTemplate(pdf, elements=h_elements)
h_tmpl["item_key_HA"] = "Text 2A"
h_tmpl["item_key_HB"] = "Text 2B"
...
h_tmpl.render() # add header items to second page

# footer for the second page
f_tmpl = FlexTemplate(pdf, elements=f_elements)
f_tmpl["item_key_FC"] = "Text 2C"
f_tmpl["item_key_FD"] = "Text 2D"
...
f_tmpl.render() # add footer items to second page

# other content on the second page
pdf.set_dash_pattern(dash=1, gap=1)
pdf.line(x1, y1, x2, y2):
pdf.set_dash_pattern()

# third page
pdf.add_page()
# header for the third page, just reuse the same template instance after render()
h_tmpl["item_key_HA"] = "Text 3A"
h_tmpl["item_key_HB"] = "Text 3B"
...
h_tmpl.render() # add header items to third page

# footer for the third page
f_tmpl["item_key_FC"] = "Text 3C"
f_tmpl["item_key_FD"] = "Text 3D"
...
f_tmpl.render() # add footer items to third page

# other content on the third page
pdf.rect(x, y, w, h, style=None)

# possibly more pages
pdf.add_page()
...
...

# finally write everything to a file
pdf.output("example.pdf")
```

Example 4 (json):
```json
from fpdf import FlexTemplate, FPDF

pdf = FPDF()
pdf.add_page()
templ = FlexTemplate(pdf, [
    {"name":"box", "type":"B", "x1":0, "y1":0, "x2":50, "y2":50,},
    {"name":"d1", "type":"L", "x1":0, "y1":0, "x2":50, "y2":50,},
    {"name":"d2", "type":"L", "x1":0, "y1":50, "x2":50, "y2":0,},
    {"name":"label", "type":"T", "x1":0, "y1":52, "x2":50, "y2":57, "text":"Label",},
])
templ["label"] = "Offset: 50 / 50 mm"
templ.render(offsetx=50, offsety=50)
templ["label"] = "Offset: 50 / 120 mm"
templ.render(offsetx=50, offsety=120)
templ["label"] = "Offset: 120 / 50 mm, Scale: 0.5"
templ.render(offsetx=120, offsety=50, scale=0.5)
templ["label"] = "Offset: 120 / 120 mm, Rotate: 30¬∞, Scale=0.5"
templ.render(offsetx=120, offsety=120, rotate=30.0, scale=0.5)
pdf.output("example.pdf")
```

---

## Module fpdf.transitions

**URL:** https://py-pdf.github.io/fpdf2/fpdf/transitions.html

**Contents:**
- Module fpdf.transitions
- Classes
  - Ancestors
  - Methods
  - Ancestors
  - Methods
  - Ancestors
  - Methods
  - Ancestors
  - Methods

Usage documentation at: https://py-pdf.github.io/fpdf2/Presentations.html#transitions

Helper class that provides a standard way to create an ABC using inheritance.

Helper class that provides a standard way to create an ABC using inheritance.

Helper class that provides a standard way to create an ABC using inheritance.

Helper class that provides a standard way to create an ABC using inheritance.

Helper class that provides a standard way to create an ABC using inheritance.

Helper class that provides a standard way to create an ABC using inheritance.

Helper class that provides a standard way to create an ABC using inheritance.

Helper class that provides a standard way to create an ABC using inheritance.

Helper class that provides a standard way to create an ABC using inheritance.

Helper class that provides a standard way to create an ABC using inheritance.

Helper class that provides a standard way to create an ABC using inheritance.

Helper class that provides a standard way to create an ABC using inheritance.

**Examples:**

Example 1 (python):
```python
class BlindsTransition(Transition):
    def __init__(self, dimension: str) -> None:
        if dimension not in ("H", "V"):
            raise ValueError(
                f"Unsupported dimension '{dimension}', must be H(horizontal) or V(ertical)"
            )
        self.dimension = dimension

    def serialize(
        self,
        _security_handler: Optional["StandardSecurityHandler"] = None,
        _obj_id: Optional[int] = None,
    ) -> str:
        return f"<</Type /Trans /S /Blinds /DM /{self.dimension}>>"
```

Example 2 (python):
```python
def serialize(
    self,
    _security_handler: Optional["StandardSecurityHandler"] = None,
    _obj_id: Optional[int] = None,
) -> str:
    return f"<</Type /Trans /S /Blinds /DM /{self.dimension}>>"
```

Example 3 (python):
```python
class BoxTransition(Transition):
    def __init__(self, direction: str) -> None:
        if direction not in ("I", "O"):
            raise ValueError(
                f"Unsupported direction '{direction}', must be I(nward) or O(utward)"
            )
        self.direction = direction

    def serialize(
        self,
        _security_handler: Optional["StandardSecurityHandler"] = None,
        _obj_id: Optional[int] = None,
    ) -> str:
        return f"<</Type /Trans /S /Blinds /M /{self.direction}>>"
```

Example 4 (python):
```python
def serialize(
    self,
    _security_handler: Optional["StandardSecurityHandler"] = None,
    _obj_id: Optional[int] = None,
) -> str:
    return f"<</Type /Trans /S /Blinds /M /{self.direction}>>"
```

---

## Margins¬∂

**URL:** https://py-pdf.github.io/fpdf2/Margins.html

**Contents:**
- Margins¬∂

By default a FPDF document has a 2cm margin at the bottom, and 1cm margin on the other sides.

Those margins control the initial current X & Y position to render elements on a page, and also define the height limit that triggers automatic page breaks when they are enabled.

Margins can be completely removed:

Several methods can be used to set margins:

**Examples:**

Example 1 (unknown):
```unknown
pdf.set_margin(0)
```

---

## Adding Text¬∂

**URL:** https://py-pdf.github.io/fpdf2/Text.html

**Contents:**
- Adding Text¬∂
- Simple Text Methods¬∂
- Flowable Text Regions¬∂
- Typography and Language Specific Concepts¬∂
  - Supported Features¬∂
  - Limitations¬∂
  - Character or Word Based Line Wrapping¬∂
- Text Formatting¬∂
- Change in current position¬∂
- .text()¬∂

There are several ways in fpdf to add text to a PDF document, each of which comes with its own special features and its own set of advantages and disadvantages. You will need to pick the right one for your specific task.

Text regions allow to insert flowing text into a predefined region on the page. It is possible to change the formatting and even the font within paragraphs, which will still be aligned as one text block. The currently implemented type of text regions is text_columns(), which defines one or several columns that can be filled sequentially or height-balanced.

With supporting Unicode fonts, fpdf2 should handle the following text shaping features correctly. More details can be found in TextShaping.

There are a few advanced typesetting features that fpdf2 doesn't currently support:

By default, multi_cell() and write() will wrap lines based on words, using space characters and soft hyphens as separators. Non-breaking spaces (\U00a0) do not trigger a word wrap, but are otherwise treated exactly as a normal space character. For languages like Chinese and Japanese, that don't usually separate their words, character based wrapping is more appropriate. In such a case, the argument wrapmode="CHAR" can be used (the default is "WORD"), and each line will get broken right before the character that doesn't fit anymore.

For all text insertion methods, the relevant font related properties (eg. font/style and foreground/background color) must be set before invoking them. This includes using:

All three set_*_colors() methods accept either a single greyscale value, 3 values as RGB components, a single #abc or #abcdef hexadecimal color string, or an instance of fpdf.drawing.DeviceCMYK, fpdf.drawing.DeviceRGB or fpdf.drawing.DeviceGray. You can even use named web colors by using html.color_as_decimal().

More text styling options can be found on the page Text styling, including Markdown syntax and HTML markup.

.cell() and .multi_cell() let you specify where the current position (.x/.y) should go after the call. This is handled by the parameters new_x and new_y. Their values must one of the following enums values or an equivalent string:

Prints a single-line character string. In contrast to the other text methods, the position is given explicitly, and not taken from .x/.y. The origin is on the left of the first character, on the baseline. This method allows placing a string with typographical precision on the page, but it is usually easier to use the .cell(), .multi_cell() or .write() methods.

Signature and parameters for .text()

Prints a cell (rectangular area) with optional borders, background color and character string. The upper-left corner of the cell corresponds to the current position. The text can be aligned or centered. After the call, the current position moves to the selected new_x/new_y position. It is possible to put a link on the text. If markdown=True, then minimal markdown styling is enabled, to render parts of the text in bold, italics, strikethrough and/or underlined.

If automatic page breaking is enabled and the cell goes beyond the limit, a page break is performed before outputting.

Signature and parameters for.cell()

Allows printing text with word or character based line breaks. Those can be automatic (breaking at the most recent space or soft-hyphen character) as soon as the text reaches the right border of the cell, or explicit (via the \\n character). As many cells as necessary are stacked, one below the other. Text can be aligned, centered or justified. The cell block can be framed and the background painted. Padding between text and the cell edge can be specified in the same way as for tables.

Using new_x="RIGHT", new_y="TOP", maximum height=pdf.font_size can be useful to build tables with multiline text in cells.

In normal operation, returns a boolean indicating if page break was triggered. The return value can be altered by specifying the output parameter.

Signature and parameters for.multi_cell()

Prints multi-line text between the page margins, starting from the current position. When the right margin is reached, a line break occurs at the most recent space or soft-hyphen character (in word wrap mode) or at the current position (in character break mode), and text continues from the left margin. A manual break happens any time the \n character is met. Upon method exit, the current position is left near the end of the text, ready for the next call to continue without a gap, potentially with a different font or size set. Returns a boolean indicating if page break was triggered.

The primary purpose of this method is to print continuously wrapping text, where different parts may be rendered in different fonts or font sizes. This contrasts eg. with .multi_cell(), where a change in font family or size can only become effective on a new line.

Signature and parameters for.write()

This method is very similar to .write(), but accepts basic HTML formatted text as input. See html.py for more details and the supported HTML tags.

Note that when using data from actual web pages, the result may not look exactly as expected, because .write_html() prints all whitespace unchanged as it finds them, while webbrowsers rather collapse each run of consecutive whitespace into a single space character.

Signature and parameters for .write_html()

---

## Combine with livereload¬∂

**URL:** https://py-pdf.github.io/fpdf2/CombineWithLivereload.html

**Contents:**
- Combine with livereload¬∂

A nice feature of PDF readers is when they detect changes to the .pdf files open and automatically reload them in the viewer. Adobe Acrobat Reader does not provide this feature but other viewers offer it, like the free & open source Sumatra PDF Reader under Windows.

When using such PDF reader, it can be very useful to use a "watch" mode, so that every change to the Python code will trigger the regeneration of the PDF file.

The following script is an example of using livereload with fpdf2 to do that. Launched without parameters, this script only generates a PDF document. But when launched with --watch as argument, it will detect changes to the Python script itself, and then reload itself with xreload, and finally regenerate the PDF document.

Note that the module reloading mechanism provided by xreload has several limitations, cf. xreload.py.

**Examples:**

Example 1 (python):
```python
#!/usr/bin/env python3
# Script Dependencies:
#    fpdf2
#    livereload
#    xreload
import asyncio, logging, sys
from traceback import print_exc

from fpdf import FPDF
from livereload.watcher import get_watcher_class
from xreload import xreload

OUT_FILEPATH = "fpdf2-demo.pdf"


def build_pdf():
    pdf = FPDF()
    pdf.set_font("Helvetica", size=16)
    pdf.add_page()
    pdf.y += 50
    pdf.multi_cell(
        h=10,
        w=0,
        align="C",
        text="""Hello fpdf2 user!
Launch this script with --watch
and then try to modify this text while the script is running""",
    )
    pdf.output(OUT_FILEPATH)
    print(f"{OUT_FILEPATH} has been rebuilt")


async def start_watch_and_rebuild():
    logging.basicConfig(
        format="%(asctime)s %(name)s [%(levelname)s] %(message)s",
        datefmt="%H:%M:%S",
        level=logging.INFO,
    )
    logging.getLogger("livereload").setLevel(logging.INFO)
    watcher = get_watcher_class()()
    watcher.watch(__file__, build_pdf)
    print("Watcher started...")
    await watch_periodically(watcher)


async def watch_periodically(watcher, delay_secs=0.8):
    try:
        watcher.examine()
    except Exception:
        print_exc()
    await asyncio.sleep(delay_secs)
    xreload(sys.modules[__name__], new_annotations={"XRELOADED": True})
    await asyncio.create_task(watch_periodically(watcher))


# This conditional ensure that the code below
# does not get executed when calling xreload on this module:
if not __annotations__.get("XRELOADED"):
    build_pdf()
    # The --watch mode is very handy when using a PDF reader
    # that performs hot-reloading, like Sumatra PDF Reader:
    if "--watch" in sys.argv:
        asyncio.run(start_watch_and_rebuild())
```

---

## Tutorial¬∂

**URL:** https://py-pdf.github.io/fpdf2/Tutorial-it.html

**Contents:**
- Tutorial¬∂
- Tuto 1 - Esempio base¬∂
- Tuto 2 - Intestazione, pi√® di pagina, interruzione di pagina ed immagini¬∂
- Tuto 3 - Interruzioni di riga e colori¬∂
- Tuto 4 - Colonne multiple¬∂
- Tuto 5 - Creare tabelle¬∂
- Tuto 6 - Creare link e mescolare stili di testo¬∂

Documentazione completa dei metodi: fpdf.FPDF API doc

Iniziamo con un esempio comune:

Dopo aver incluso la libreria, creiamo un oggetto FPDF. Cos√¨ facendo il costruttore FPDF viene utilizzato con i suoi valori di default: le pagine sono in A4 verticale e l'unit√† di misura √® millimetri. Avremmo potuto specificarle esplicitamente facendo:

pdf = FPDF(orientation="P", unit="mm", format="A4") √à possibile impostare il PDF in modalit√† orizzontale (L) o utilizzare altri formati (come Letter e Legal) e unit√† di misura (pt, cm, in).

Non esiste una pagina al momento, quindi dobbiamo aggiungerne una con add_page. L'origine √® in alto a sinistra e la posizione corrente √® a 1cm dai bordi; i margini possono essere cambiati con set_margins.

Prima di poter stampare del testo, √® obbligatorio selezionare un font con set_font, altrimenti il documento risulterebbe non valido. Scegliamo Helvetica bold 16:

Avremmo potuto scegliere il corsivo con I, sottolineato con U o un font regolare lasciando la stringa vuota (o ogni combinazione). Notare che la dimensione dei caratteri √® specificata in punti, non millimetri (o altre unit√† di misura); questa √® l'unica eccezione. Gli altri font disponibili sono Times, Courier, Symbol and ZapfDingbats.

Adesso possiamo disegnare una cella con cell. Una cella √® un'area rettangolare, in caso con bordo, che contiene del testo. √à disegnata nella attuale posizione. Specifichiamo le sue dimensioni, il suo testo (centrato o allineato), se i bordi devono essere mostrati, e dove verr√† spostata la posizione quando avremo finito (a destra, sotto, o all'inizio della riga successiva). Faremmo cos√¨:

Per aggiungere una nuova cella di fianco alla precedente con testo centrato e poi spostarci alla riga successiva, faremmo:

NB: si pu√≤ andare a capo anche con ln. Questo metodo permette di specificare l'altezza dello spazio.

In fine, il documento √® chiuso e salvato nella destinazione fornita attraverso output. Senza alcun parametro, output() ritorna il PDF in un buffer bytearray.

Ecco un esempio composto da due pagine con intestazione, pi√® di pagina e logo:

Questo esempio sfrutta i metodi header e footer per processare intestazioni e pi√® di pagina. Vengono chiamati automaticamente. Esistono nella classe FPDF ma non eseguono operazioni, quindi √® necessario estendere la classe e sovrascriverli.

Il logo √® stampato con il metodo image specificando la posizione del suo angolo in alto a sinistra e la sua larghezza. L'altezza √® calcolata automaticamente per rispettare le proporzioni dell'immagine.

Per stampare il numero della pagina, un valore nullo pu√≤ essere passato come larghezza della cella. Significa che la cella "crescer√†" fino al margine destro della pagina; √® utile per centrare il testo. Il numero di pagina √® ritornato da page_no; mentre per il numero totale di pagine, si ottiene attraverso il valore speciale {nb} che verr√† sostituito quando le pagine saranno generate. Importante menzionare il metodo set_y che permette di selezionare una posizione assoluta all'interno della pagina, incominciando dall'alto o dal basso.

Un'altra feature interessante: l'interruzione di pagina automatica. Non appena una cella dovesse superare il limite nella pagina (a 2 centimetri dal fondo di default), ci sarebbe un'interruzione e un reset del font. Nonostante l'intestazione e il pi√® di pagina scelgano il proprio font (helvetica), il contenuto continua in Times. Questo meccanismo di reset automatico si applica anche ai colori e allo spessore della linea. Il limite pu√≤ essere scelto con set_auto_page_break.

Continuiamo con un esempio che stampa paragrafi giustificati. Mostreremo anche l'utilizzo dei colori.

Il metodo get_string_width permette di determinare la lunghezza di una stringa nel font selezionato, e viene utilizzato per calcolare la posizione e la larghezza della cornice intorno al titolo. Successivamente selezioniamo i colori (utilizzando set_draw_color, set_fill_color e set_text_color) e aumentiamo la larghezza della linea a 1mm (invece dei 0.2 di default) con set_line_width. In fine, stampiamo la cella (l'ultimo parametro a true indica che lo sfondo dovr√† essere riempito).

Il metodo utilizzato per stampare i paragrafi √® multi_cell. Ogni volta che una linea raggiunge l'estremit√† destra della cella o c'√® un carattere carriage return, avremo un'interruzione di linea e una nuova cella verr√† automaticamente creata. Il testo √® giustificato di default.

Due propriet√† del documento vengono definite: il titolo (set_title) e l'autore (set_author). Le propriet√† possono essere controllate in due modi. Il primo √® aprire direttamente il documento con Acrobat Reader, cliccare sul men√π File e scegliere l'opzione Propriet√† del documento. la seconda, √® di cliccare con il tasto destro e scegliere Propriet√† del documento.

Questo esempio √® una variante del precedente, mostra come disporre il test attraverso colonne multiple.

‚ö†Ô∏è This section has changed a lot and requires a new translation: https://github.com/py-pdf/fpdf2/issues/267

Risultato PDF - Testo delle nazioni

‚ö†Ô∏è This section has changed a lot and requires a new translation: https://github.com/py-pdf/fpdf2/issues/267

Questo tutorial spiegher√† molti modi di inserire link interni al pdf, e come inserirne a sorgenti esterne.

Saranno mostrati anche molti modi di utilizzare diversi stili di testo (grassetto, corsivo e sottolineato) nello stesso testo.

Risultato PDF - fpdf2-logo

Il nuovo metodo qui utilizzato per stampare testo √® write() . √à molto simile a multi_cell() , ma con delle differenze:

Il metodo quindi ci permette di scrivere un blocco di testo, cambiare lo stile del testo, e continuare a scrivere esattamente da dove eravamo rimasti. D'altro canto, il suo peggior svantaggio √® che non possiamo giustificare il testo come con multi_cell() method.

Nella prima pagina dell'esempio, abbiamo usato write() per questo scopo. L'inizio della frase √® scritta in font normale, poi utilizzando set_font() siamo passati al sottolineato e abbiamo finito la frase.

Per aggiungere un link interno che puntasse alla seconda pagina, abbiamo utilizzato add_link() che crea un area cliccabile che abbiamo chiamato "link" che redirige ad un altro punto del documento.

Per creare un link esterno utilizzando un'immagine, abbiamo usato image() . Il metodo ha l'opzione di passare un link come argomento. Il link pu√≤ essere sia interno che esterno.

In alternativa, un'altra opzione per cambiare lo stile e aggiungere link √® di utilizzare write_html(). √à un parser hrml che permette di aggiungere testo, cambiare stile e aggiungere link utilizzando html.

**Examples:**

Example 1 (python):
```python
from fpdf import FPDF

pdf = FPDF()
pdf.add_page()
pdf.set_font("helvetica", style="B", size=16)
pdf.cell(40, 10, "Hello World!")
pdf.output("tuto1.pdf")
```

Example 2 (unknown):
```unknown
pdf = FPDF(orientation="P", unit="mm", format="A4")
```

Example 3 (unknown):
```unknown
pdf.set_font('Helvetica', style='B', size=16)
```

Example 4 (unknown):
```unknown
pdf.cell(40, 10, 'Hello World!', 1)
```

---

## Module fpdf.image_parsing

**URL:** https://py-pdf.github.io/fpdf2/fpdf/image_parsing.html

**Contents:**
- Module fpdf.image_parsing
- Functions
- Args
- Args
- Classes
  - Instance variables

returns the byte offset and length of the CCITT payload in the original TIFF data

Reset the encoding table and coding state to initial conditions.

Checks the validity of an ICC profile

This method is used to load external resources, such as images. It is automatically called when resource added to document by FPDF.image(). It always return a BytesIO buffer.

Convert the list of result codes into a continuous byte stream, with codes packed as per the code bit-width. The bit-width starts at 9 bits and expands as needed.

Read an image and load it into memory.

For raster images: following this call, the image is inserted in image_cache.images, and following calls to FPDF.image() will re-use the same cached values, without re-reading the image.

For vector images: the data is loaded and the metadata extracted.

Returns: A tuple, consisting of 3 values: the name, the image data, and an instance of a subclass of ImageInfo.

Convert the open PIL.Image imgdata to compressed CCITT Group4 data.

ImageSettings(compression_level: int = -1)

The type of the None singleton.

temporary change the attribute of an object using a context manager

**Examples:**

Example 1 (python):
```python
def ccitt_payload_location_from_pil(img: "PILImage") -> tuple[int, int]:
    """
    returns the byte offset and length of the CCITT payload in the original TIFF data
    """
    # assert(img.info["compression"] == "group4")

    # Read the TIFF tags to find the offset(s) of the compressed data strips.
    strip_offsets = img.tag_v2[TiffImagePlugin.STRIPOFFSETS]  # type: ignore[attr-defined]
    strip_bytes = img.tag_v2[TiffImagePlugin.STRIPBYTECOUNTS]  # type: ignore[attr-defined]

    # PIL always seems to create a single strip even for very large TIFFs when
    # it saves images, so assume we only have to read a single strip.
    # A test ~10 GPixel image was still encoded as a single strip. Just to be
    # safe check throw an error if there is more than one offset.
    if (
        len(strip_offsets) != 1  # pyright: ignore[reportUnknownArgumentType]
        or len(strip_bytes) != 1  # pyright: ignore[reportUnknownArgumentType]
    ):  # pyright: ignore[reportUnknownArgumentType]
        raise NotImplementedError(
            "Transcoding multiple strips not supported by the PDF format"
        )

    (offset,), (length,) = (  # pyright: ignore[reportUnknownVariableType]
        strip_offsets,
        strip_bytes,
    )  # pyright: ignore[reportUnknownVariableType]

    return offset, length  # pyright: ignore[reportUnknownVariableType]
```

Example 2 (python):
```python
def clear_table() -> tuple[dict[bytes, int], int, int, int]:
    """
    Reset the encoding table and coding state to initial conditions.

    """

    table = {bytes([i]): i for i in range(256)}
    next_code = LZW_EOD_MARKER + 1
    bits_per_code = LZW_INITIAL_BITS_PER_CODE
    max_code_value = (1 << bits_per_code) - 1
    return table, next_code, bits_per_code, max_code_value
```

Example 3 (python):
```python
def get_img_info(
    filename: Union[str, BinaryIO, Path],
    img: Union["PILImage", bytes, BinaryIO, Path, str, None] = None,
    image_filter: ImageFilter = "AUTO",
    dims: Optional[tuple[float, float]] = None,
) -> RasterImageInfo:
    """
    Args:
        filename: in a format that can be passed to load_image
        img: optional `bytes`, `BytesIO` or `PIL.Image.Image` instance
        image_filter (str): one of the SUPPORTED_IMAGE_FILTERS
    """
    if Image is None:
        raise EnvironmentError("Pillow not available - fpdf2 cannot insert images")

    is_pil_img = True
    keep_bytes_io_open = False
    # Flag to check whether a cmyk image is jpeg or not, if set to True the decode array
    # is inverted in output.py
    jpeg_inverted = False
    img_raw_data: Optional[BinaryIO] = None
    if not img or isinstance(img, (Path, str)):
        img_raw_data = load_image(filename)
        img = Image.open(img_raw_data)
        is_pil_img = False
    elif not _is_pil_image(img):
        keep_bytes_io_open = isinstance(img, BytesIO)
        if isinstance(img, bytes):
            img_raw_data = BytesIO(img)
        else:
            img_raw_data = img  # type: ignore[assignment]
        assert img_raw_data is not None
        img = Image.open(img_raw_data)
        is_pil_img = False
    assert _is_pil_image(img)

    img_altered = False
    if dims:
        img = img.resize(dims, resample=RESAMPLE)  # type: ignore[arg-type]
        img_altered = True

    if image_filter == "AUTO":
        # Very simple logic for now:
        if img.format == "JPEG":
            image_filter = "DCTDecode"
        elif img.mode == "1" and PIL_features.check("libtiff"):
            # The 2nd condition prevents from running in a bug sometimes,
            # cf. test_transcode_monochrome_and_libtiff_support_custom_tags()
            image_filter = "CCITTFaxDecode"
        else:
            image_filter = "FlateDecode"

    if img.mode in ("P", "PA") and image_filter != "FlateDecode":
        img = img.convert("RGBA")

    if img.mode not in ("1", "L", "LA", "RGB", "RGBA", "P", "PA", "CMYK"):
        img = img.convert("RGBA")
        img_altered = True

    if img.mode in ("P", "RGBA") and image_filter == "LZWDecode":
        img = img.convert("RGB")
    elif img.mode in ("LA") and image_filter == "LZWDecode":
        img = img.convert("L")

    w, h = img.size
    info = RasterImageInfo()

    iccp = None
    if "icc_profile" in img.info:
        if is_iccp_valid(img.info["icc_profile"], filename):
            iccp = img.info["icc_profile"]

    if img_raw_data is not None and not img_altered:
        # if we can use the original image bytes directly we do (JPEG and group4 TIFF only):
        if img.format == "JPEG" and image_filter == "DCTDecode":
            if img.mode in ("RGB", "RGBA"):
                dpn, bpc, colspace = 3, 8, "DeviceRGB"
            elif img.mode == "CMYK":
                dpn, bpc, colspace = 4, 8, "DeviceCMYK"
                jpeg_inverted = True
            elif img.mode == "L":
                dpn, bpc, colspace = 1, 8, "DeviceGray"
            else:
                raise ValueError(f"Unsupported image mode: {img.mode}")
            img_raw_data.seek(0)
            info.update(
                {
                    "data": img_raw_data.read(),
                    "w": w,
                    "h": h,
                    "cs": colspace,
                    "iccp": iccp,
                    "dpn": dpn,
                    "bpc": bpc,
                    "f": image_filter,
                    "inverted": jpeg_inverted,
                    "dp": f"/Predictor 15 /Colors {dpn} /Columns {w}",
                }
            )
            return info
        # We can directly copy the data out of a CCITT Group 4 encoded TIFF, if it
        # only contains a single strip
        if (
            img.format == "TIFF"
            and image_filter == "CCITTFaxDecode"
            and img.info["compression"] == "group4"
            and len(img.tag_v2[TiffImagePlugin.STRIPOFFSETS]) == 1  # type: ignore[attr-defined]
            and len(img.tag_v2[TiffImagePlugin.STRIPBYTECOUNTS]) == 1  # type: ignore[attr-defined]
        ):
            photo = img.tag_v2[TiffImagePlugin.PHOTOMETRIC_INTERPRETATION]  # type: ignore[attr-defined]
            inverted = False
            if photo == 0:
                inverted = True
            elif photo != 1:
                raise ValueError(
                    f"unsupported photometric interpretation for g4 tiff: {photo}"
                )
            offset, length = ccitt_payload_location_from_pil(img)
            img_raw_data.seek(offset)
            ccittrawdata: bytes | bytearray = img_raw_data.read(length)
            fillorder = img.tag_v2.get(TiffImagePlugin.FILLORDER)  # type: ignore[attr-defined]
            if fillorder is None or fillorder == 1:
                # no FillOrder or msb-to-lsb: nothing to do
                pass
            elif fillorder == 2:
                # lsb-to-msb: reverse bits of each byte
                ccittrawdata = bytearray(ccittrawdata)
                for i, n in enumerate(ccittrawdata):
                    ccittrawdata[i] = TIFFBitRevTable[n]
                ccittrawdata = bytes(ccittrawdata)
            else:
                raise ValueError(f"unsupported FillOrder: {fillorder}")
            dpn, bpc, colspace = 1, 1, "DeviceGray"
            info.update(
                {
                    "data": ccittrawdata,
                    "w": w,
                    "h": h,
                    "iccp": None,
                    "dpn": dpn,
                    "cs": colspace,
                    "bpc": bpc,
                    "f": image_filter,
                    "inverted": jpeg_inverted,
                    "dp": f"/BlackIs1 {str(not inverted).lower()} /Columns {w} /K -1 /Rows {h}",
                }
            )
            return info

    # garbage collection
    img_raw_data = None

    if img.mode == "1":
        dpn, bpc, colspace = 1, 1, "DeviceGray"
        info["data"] = _to_data(img, image_filter)
    elif img.mode == "L":
        dpn, bpc, colspace = 1, 8, "DeviceGray"
        info["data"] = _to_data(img, image_filter)
    elif img.mode == "LA":
        dpn, bpc, colspace = 1, 8, "DeviceGray"
        alpha_channel = slice(1, None, 2)
        info["data"] = _to_data(img, image_filter, remove_slice=alpha_channel)
        if _has_alpha(img) and image_filter not in (
            "DCTDecode",
            "JPXDecode",
        ):
            info["smask"] = _to_data(img, image_filter, select_slice=alpha_channel)
    elif img.mode == "P":
        dpn, bpc, colspace = 1, 8, "Indexed"
        info["data"] = _to_data(img, image_filter)
        info["pal"] = img.palette.palette if img.palette is not None else None

        # check if the P image has transparency
        if img.info.get("transparency", None) is not None and image_filter not in (
            "DCTDecode",
            "JPXDecode",
        ):
            # convert to RGBA to get the alpha channel for creating the smask
            info["smask"] = _to_data(
                img.convert("RGBA"), image_filter, select_slice=slice(3, None, 4)
            )
    elif img.mode == "PA":
        dpn, bpc, colspace = 1, 8, "Indexed"
        info["pal"] = img.palette.palette if img.palette is not None else None
        alpha_channel = slice(1, None, 2)
        info["data"] = _to_data(img, image_filter, remove_slice=alpha_channel)
        if _has_alpha(img) and image_filter not in (
            "DCTDecode",
            "JPXDecode",
        ):
            info["smask"] = _to_data(img, image_filter, select_slice=alpha_channel)
    elif img.mode == "CMYK":
        dpn, bpc, colspace = 4, 8, "DeviceCMYK"
        info["data"] = _to_data(img, image_filter)
    elif img.mode == "RGB":
        dpn, bpc, colspace = 3, 8, "DeviceRGB"
        info["data"] = _to_data(img, image_filter)
    else:  # RGBA image
        dpn, bpc, colspace = 3, 8, "DeviceRGB"
        alpha_channel = slice(3, None, 4)
        info["data"] = _to_data(img, image_filter, remove_slice=alpha_channel)
        if _has_alpha(img) and image_filter not in (
            "DCTDecode",
            "JPXDecode",
        ):
            info["smask"] = _to_data(img, image_filter, select_slice=alpha_channel)

    dp = f"/Predictor 15 /Colors {dpn} /Columns {w}"

    if img.mode == "1":
        dp = f"/BlackIs1 true /Columns {w} /K -1 /Rows {h}"

    if not is_pil_img:
        if keep_bytes_io_open:
            setattr(img, "fp", None)
        else:
            img.close()

    info.update(
        {
            "w": w,
            "h": h,
            "cs": colspace,
            "iccp": iccp,
            "bpc": bpc,
            "dpn": dpn,
            "f": image_filter,
            "inverted": jpeg_inverted,
            "dp": dp,
        }
    )
    return info
```

Example 4 (python):
```python
def get_svg_info(
    filename: str, img: BinaryIO, image_cache: ImageCache
) -> tuple[str, SVGObject, VectorImageInfo]:
    img.seek(0)
    svg_data = img.read()
    svg = SVGObject(svg_data, image_cache=image_cache)
    if svg.viewbox:
        _, _, w, h = svg.viewbox
    else:
        w = h = 0.0
    if svg.width:
        w = svg.width
    if svg.height:
        h = svg.height
    info = VectorImageInfo(data=svg, w=w, h=h)
    return filename, svg, info
```

---

## Œ†œÅœåŒ≥œÅŒ±ŒºŒºŒ± ŒïŒ∫ŒºŒ¨Œ∏Œ∑œÉŒ∑œÇ¬∂

**URL:** https://py-pdf.github.io/fpdf2/Tutorial-gr.html

**Contents:**
- Œ†œÅœåŒ≥œÅŒ±ŒºŒºŒ± ŒïŒ∫ŒºŒ¨Œ∏Œ∑œÉŒ∑œÇ¬∂
- ŒúŒ¨Œ∏Œ∑ŒºŒ± 1 - ŒëœÄŒªœå Œ†Œ±œÅŒ¨Œ¥ŒµŒπŒ≥ŒºŒ±¬∂
- ŒúŒ¨Œ∏Œ∑ŒºŒ± 2 - ŒïœÄŒπŒ∫ŒµœÜŒ±ŒªŒØŒ¥Œ±, œÖœÄŒøœÉŒ≠ŒªŒπŒ¥Œø, Œ±ŒªŒªŒ±Œ≥ŒÆ œÉŒµŒªŒØŒ¥Œ±œÇ Œ∫Œ±Œπ ŒµŒπŒ∫œåŒΩŒ±¬∂
- ŒúŒ¨Œ∏Œ∑ŒºŒ± 3 - ŒëŒªŒªŒ±Œ≥Œ≠œÇ Œ≥œÅŒ±ŒºŒºŒÆœÇ Œ∫Œ±Œπ œáœÅœéŒºŒ±œÑŒ±¬∂
- ŒúŒ¨Œ∏Œ∑ŒºŒ± 4 - Œ†ŒøŒªŒªŒ±œÄŒªŒ≠œÇ Œ£œÑŒÆŒªŒµœÇ¬∂
- ŒúŒ¨Œ∏Œ∑ŒºŒ± 5 - ŒîŒ∑ŒºŒπŒøœÖœÅŒ≥ŒØŒ± Œ†ŒπŒΩŒ¨Œ∫œâŒΩ¬∂
- ŒúŒ¨Œ∏Œ∑ŒºŒ± 6 - ŒîŒ∑ŒºŒπŒøœÖœÅŒ≥ŒØŒ± œÉœÖŒΩŒ¥Œ≠œÉŒºœâŒΩ Œ∫Œ±Œπ ŒºŒØŒæŒ∑ œÉœÑœÖŒª Œ∫ŒµŒπŒºŒ≠ŒΩŒøœÖ¬∂

Œ†ŒªŒÆœÅŒ∑œÇ œÑŒµŒ∫ŒºŒ∑œÅŒØœâœÉŒ∑ œÑœâŒΩ ŒºŒµŒ∏œåŒ¥œâŒΩ: fpdf.FPDF API doc

ŒëœÇ ŒæŒµŒ∫ŒπŒΩŒÆœÉŒøœÖŒºŒµ ŒºŒµ Œ≠ŒΩŒ± Œ∫ŒªŒ±œÉœÉŒπŒ∫œå œÄŒ±œÅŒ¨Œ¥ŒµŒπŒ≥ŒºŒ±:

ŒëœÜŒøœç œÉœÖŒºœÄŒµœÅŒπŒªŒ¨Œ≤ŒøœÖŒºŒµ œÑŒø Œ±œÅœáŒµŒØŒø Œ≤ŒπŒ≤ŒªŒπŒøŒ∏ŒÆŒ∫Œ∑œÇ, Œ¥Œ∑ŒºŒπŒøœÖœÅŒ≥ŒøœçŒºŒµ Œ≠ŒΩŒ± Œ±ŒΩœÑŒπŒ∫ŒµŒØŒºŒµŒΩŒø FPDF. Œü Œ∫Œ±œÑŒ±œÉŒ∫ŒµœÖŒ±œÉœÑŒÆœÇ FPDF œáœÅŒ∑œÉŒπŒºŒøœÄŒøŒπŒµŒØœÑŒ±Œπ œÉœÑŒ∑ŒΩ œÄœÅŒøŒ∫ŒµŒπŒºŒ≠ŒΩŒ∑ œÄŒµœÅŒØœÄœÑœâœÉŒ∑ ŒºŒµ œÑŒπœÇ œÄœÅŒøŒ∫Œ±Œ∏ŒøœÅŒπœÉŒºŒ≠ŒΩŒµœÇ œÑŒπŒºŒ≠œÇ: ŒøŒπ œÉŒµŒªŒØŒ¥ŒµœÇ Œ≠œáŒøœÖŒΩ Œ¥ŒπŒ±œÉœÑŒ¨œÉŒµŒπœÇ Œë4 Œ∫Œ±Œπ Œ∑ ŒºŒøŒΩŒ¨Œ¥Œ±œÇ ŒºŒ≠œÑœÅŒ∑œÉŒ∑œÇ ŒµŒØŒΩŒ±Œπ œÑŒø œáŒπŒªŒπŒøœÉœÑœåŒºŒµœÑœÅŒø. ŒüŒπ œÉœÖŒ≥Œ∫ŒµŒ∫œÅŒπŒºŒ≠ŒΩŒµœÇ œÑŒπŒºŒ≠œÇ ŒºœÄŒøœÅŒøœçŒΩ ŒΩŒ± œÄœÅŒøœÉŒ¥ŒπŒøœÅŒπœÉœÑŒøœçŒΩ Œ±ŒΩŒ±ŒªœÖœÑŒπŒ∫Œ¨ œâœÇ ŒµŒæŒÆœÇ:

ŒîŒØŒΩŒµœÑŒ±Œπ Œ∑ Œ¥œÖŒΩŒ±œÑœåœÑŒ∑œÑŒ± ŒΩŒ± ŒøœÅŒØœÉŒøœÖŒºŒµ œÑŒø PDF œÉŒµ ŒªŒµŒπœÑŒøœÖœÅŒ≥ŒØŒ± œÑŒøœÄŒØŒøœÖ (L) ŒÆ ŒΩŒ± œáœÅŒ∑œÉŒπŒºŒøœÄŒøŒπŒÆœÉŒøœÖŒºŒµ Œ¨ŒªŒªŒµœÇ ŒºŒøœÅœÜŒøœÄŒøŒπŒÆœÉŒµŒπœÇ œÉŒµŒªŒØŒ¥Œ±œÇ (œåœÄœâœÇ Letter Œ∫Œ±Œπ Legal) Œ∫Œ±Œπ ŒºŒøŒΩŒ¨Œ¥ŒµœÇ ŒºŒ≠œÑœÅŒ∑œÉŒ∑œÇ (pt, cm, in).

Œ†œÅŒøœÇ œÑŒø œÄŒ±œÅœåŒΩ Œ¥ŒµŒΩ œÖœÄŒ¨œÅœáŒµŒπ œÉŒµŒªŒØŒ¥Œ±, ŒøœÄœåœÑŒµ Œ∏Œ± œÄœÅŒøœÉŒ∏Œ≠œÉŒøœÖŒºŒµ ŒºŒØŒ± ŒºŒµ œÑŒ∑ŒΩ ŒºŒ≠Œ∏ŒøŒ¥Œø add_page. Œó Œ±œÅœáŒÆ Œ≤œÅŒØœÉŒ∫ŒµœÑŒ±Œπ œÉœÑŒ∑ŒΩ Œ±œÅŒπœÉœÑŒµœÅŒÆ Œ¨ŒΩœâ Œ≥œâŒΩŒØŒ± Œ∫Œ±Œπ Œ∑ œÑœÅŒ≠œáŒøœÖœÉŒ± Œ∏Œ≠œÉŒ∑ œÑŒøœÄŒøŒ∏ŒµœÑŒµŒØœÑŒ±Œπ, Œ±œÄœå œÄœÅŒøŒµœÄŒπŒªŒøŒ≥ŒÆ, œÉŒµ Œ±œÄœåœÉœÑŒ±œÉŒ∑ 1 cm Œ±œÄœå œÑŒø œÄŒµœÅŒØŒ≥œÅŒ±ŒºŒºŒ±. Œ§Œ± œÄŒµœÅŒπŒ∏œéœÅŒπŒ± ŒºœÄŒøœÅŒøœçŒΩ ŒΩŒ± ŒøœÅŒπœÉœÑŒøœçŒΩ ŒºŒµ set_margins.

Œ†œÅœâœÑŒøœç ŒºœÄŒøœÅŒ≠œÉŒøœÖŒºŒµ ŒΩŒ± ŒµŒ∫œÑœÖœÄœéœÉŒøœÖŒºŒµ Œ∫ŒµŒØŒºŒµŒΩŒø, ŒµŒØŒΩŒ±Œπ œÖœÄŒøœáœÅŒµœâœÑŒπŒ∫œå ŒΩŒ± ŒµœÄŒπŒªŒ≠ŒæŒøœÖŒºŒµ Œ≥œÅŒ±ŒºŒºŒ±œÑŒøœÉŒµŒπœÅŒ¨ ŒºŒµ set_font, Œ±ŒªŒªŒπœéœÇ œÑŒø Œ±œÅœáŒµŒØŒø Œ¥ŒµŒΩ Œ∏Œ± ŒµŒØŒΩŒ±Œπ Œ≠Œ≥Œ∫œÖœÅŒø. ŒïœÄŒπŒªŒ≠Œ≥ŒøœÖŒºŒµ œÑŒ∑ Œ≥œÅŒ±ŒºŒºŒ±œÑŒøœÉŒµŒπœÅŒ¨ Helvetica bold 16:

ŒúœÄŒøœÅŒøœçŒºŒµ ŒΩŒ± ŒµœÄŒπŒªŒ≠ŒæŒøœÖŒºŒµ œÄŒªŒ¨Œ≥ŒπŒ± Œ≥œÅŒ±œÜŒÆ ŒºŒµ I, œÖœÄŒøŒ≥œÅŒ¨ŒºŒºŒπœÉŒ∑ ŒºŒµ U Œ∑ ŒºŒØŒ± Œ±œÄŒªŒÆ Œ≥œÅŒ±ŒºŒºŒ±œÑŒøœÉŒµŒπœÅŒ¨ ŒºŒµ ŒºŒØŒ± Œ∫ŒµŒΩŒÆ œÉœÖŒºŒ≤ŒøŒªŒøœÉŒµŒπœÅŒ¨ (ŒÆ ŒøœÄŒøŒπŒøŒΩŒ¥ŒÆœÄŒøœÑŒµ œÉœÖŒΩŒ¥ŒπŒ±œÉŒºœå). ŒëŒæŒØŒ∂ŒµŒπ ŒΩŒ± œÉŒ∑ŒºŒµŒπœâŒ∏ŒµŒØ œåœÑŒπ œÑŒø ŒºŒ≠Œ≥ŒµŒ∏ŒøœÇ œÑŒ∑œÇ Œ≥œÅŒ±ŒºŒºŒ±œÑŒøœÉŒµŒπœÅŒ¨œÇ Œ¥ŒØŒΩŒµœÑŒ±Œπ œÉŒµ œÉŒ∑ŒºŒµŒØŒ±, œåœáŒπ œáŒπŒªŒπŒøœÉœÑœåŒºŒµœÑœÅŒ± (ŒÆ Œ∫Œ¨œÄŒøŒπŒ± Œ¨ŒªŒªŒ∑ ŒºŒøŒΩŒ¨Œ¥Œ± ŒºŒ≠œÑœÅŒ∑œÉŒ∑œÇ). Œ§Œø œÄŒ±œÅŒ±œÄŒ¨ŒΩœâ Œ±œÄŒøœÑŒµŒªŒµŒØ œÑŒ∑ ŒºŒøŒΩŒ±Œ¥ŒπŒ∫ŒÆ ŒµŒæŒ±ŒØœÅŒµœÉŒ∑. ŒüŒπ œÖœÄœåŒªŒøŒπœÄŒµœÇ ŒµŒΩœÉœâŒºŒ±œÑœâŒºŒ≠ŒΩŒµœÇ Œ≥œÅŒ±ŒºŒºŒ±œÑŒøœÉŒµŒØœÅŒµœÇ ŒµŒØŒΩŒ±Œπ Times, Courier, Symbol and ZapfDingbats.

Œ†ŒªŒ≠ŒøŒΩ, ŒºœÄŒøœÅŒøœçŒºŒµ ŒΩŒ± ŒµŒ∫œÑœÖœÄœéœÉŒøœÖŒºŒµ Œ≠ŒΩŒ± Œ∫ŒµŒªŒØ cell. ŒàŒΩŒ± Œ∫ŒµŒªŒØ Œ±œÄŒøœÑŒµŒªŒµŒØ ŒºŒØŒ± ŒøœÅŒ∏ŒøŒ≥œéŒΩŒπŒ± ŒµœÄŒπœÜŒ¨ŒΩŒµŒπŒ±, œÄŒπŒ∏Œ±ŒΩœéœÇ œÄŒªŒ±ŒπœÉŒπœâŒºŒ≠ŒΩŒ∑, Œ∑ ŒøœÄŒøŒØŒ± œÄŒµœÅŒπŒ≠œáŒµŒπ Œ∫ŒµŒØŒºŒµŒΩŒø. ŒëœÄŒµŒπŒ∫ŒøŒΩŒØŒ∂ŒµœÑŒ±Œπ œÉœÑŒ∑ŒΩ œÑœÅŒ≠œáŒøœÖœÉŒ± Œ∏Œ≠œÉŒ∑. ŒüœÅŒØŒ∂ŒøœÖŒºŒµ œÑŒπœÇ Œ¥ŒπŒ±œÉœÑŒ¨œÉŒµŒπœÇ œÑŒ∑œÇ, œÑŒø Œ∫ŒµŒØŒºŒµŒΩœå œÑŒ∑œÇ (Œ∫ŒµŒΩœÑœÅŒ±œÅŒπœÉŒºŒ≠ŒΩŒø ŒÆ ŒµœÖŒ∏œÖŒ≥œÅŒ±ŒºŒºŒπœÉŒºŒ≠ŒΩŒø), ŒµŒ¨ŒΩ ŒµœÄŒπŒ∏œÖŒºŒøœçŒºŒµ ŒµŒºœÜŒ¨ŒΩŒπœÉŒ∑ œÑŒøœÖ œÄŒµœÅŒπŒ≥œÅŒ¨ŒºŒºŒ±œÑŒøœÇ, Œ∫Œ±Œπ œÄŒøœÖ Œ∏Œ± ŒºŒµœÑŒ±Œ∫ŒπŒΩŒ∑Œ∏ŒµŒØ Œ∑ œÑœÅŒ≠œáŒøœÖœÉŒ± Œ∏Œ≠œÉŒ∑ ŒºŒµœÑŒ¨ Œ±œÄœå Œ±œÖœÑŒÆ (œÉœÑŒ± Œ¥ŒµŒæŒπŒ¨ œÑŒ∑œÇ ŒøœÅŒ∏ŒøŒ≥œéŒΩŒπŒ±œÇ ŒµœÄŒπœÜŒ¨ŒΩŒµŒπŒ±œÇ, Œ±œÄœå Œ∫Œ¨œÑœâ œÑŒ∑œÇ ŒÆ œÉœÑŒ∑ŒΩ Œ±œÜŒµœÑŒ∑œÅŒØŒ± œÑŒ∑œÇ ŒµœÄœåŒºŒµŒΩŒ∑œÇ Œ≥œÅŒ±ŒºŒºŒÆœÇ). ŒúœÄŒøœÅŒøœçŒºŒµ ŒΩŒ± œÄœÅŒøœÉŒ∏Œ≠œÉŒøœÖŒºŒµ Œ≠ŒΩŒ± œÄŒªŒ±ŒØœÉŒπŒø œâœÇ ŒµŒæŒÆœÇ:

ŒìŒπŒ± ŒΩŒ± œÄœÅŒøœÉŒ∏Œ≠œÉŒøœÖŒºŒµ Œ≠ŒΩŒ± ŒΩŒ≠Œø Œ∫ŒµŒªŒØ Œ¥ŒØœÄŒªŒ± œÉœÑŒø Œ±œÅœáŒπŒ∫œå ŒºŒµ Œ∫ŒµŒΩœÑœÅŒ±œÅŒπœÉŒºŒ≠ŒΩŒø Œ∫ŒµŒØŒºŒµŒΩŒø Œ∫Œ±Œπ œÉœÑŒ∑ œÉœÖŒΩŒ≠œáŒµŒπŒ± ŒΩŒ± ŒºŒµœÑŒ±Œ≤ŒøœçŒºŒµ œÉœÑŒ∑ŒΩ ŒµœÄœåŒºŒµŒΩŒ∑ Œ≥œÅŒ±ŒºŒºŒÆ, œáœÅŒ∑œÉŒπŒºŒøœÄŒøŒπŒøœçŒºŒµ:

Œ†Œ±œÅŒ±œÑŒÆœÅŒ∑œÉŒ∑: Œ∑ Œ±ŒªŒªŒ±Œ≥ŒÆ Œ≥œÅŒ±ŒºŒºŒÆœÇ ŒºœÄŒøœÅŒµŒØ ŒΩŒ± œÄœÅŒ±Œ≥ŒºŒ±œÑŒøœÄŒøŒπŒ∑Œ∏ŒµŒØ Œ∫Œ±Œπ ŒºŒµ ln. ŒëœÖœÑŒÆ Œ∑ ŒºŒ≠Œ∏ŒøŒ¥ŒøœÇ ŒµœÄŒπœÑœÅŒ≠œÄŒµŒπ ŒµœÄŒØœÉŒ∑œÇ œÑŒøŒΩ œÄœÅŒøœÉŒ¥ŒπŒøœÅŒπœÉŒºœå œÑŒøœÖ œçœàŒøœÖœÇ œÑŒ∑œÇ Œ±ŒªŒªŒ±Œ≥ŒÆœÇ Œ≥œÅŒ±ŒºŒºŒÆœÇ.

ŒïŒΩ œÑŒ≠ŒªŒµŒπ, œÑŒø Œ±œÅœáŒµŒØŒø ŒºŒ±œÇ ŒµŒØŒΩŒ±Œπ Œ∫ŒªŒµŒπœÉœÑœå Œ∫Œ±Œπ Œ≠œáŒµŒπ Œ±œÄŒøŒ∏Œ∑Œ∫ŒµœÖœÑŒµŒØ œÉœÑŒ∑ŒΩ œÄŒ±œÅŒµœáœåŒºŒµŒΩŒ∑ Œ¥ŒπŒ±Œ¥œÅŒøŒºŒÆ Œ±œÅœáŒµŒØŒøœÖ œáœÅŒ∑œÉŒπŒºŒøœÄŒøŒπœéŒΩœÑŒ±œÇ output. ŒëŒΩ Œ¥ŒµŒΩ œÄŒ±œÅŒ≠œáŒøœÖŒºŒµ œÄŒ±œÅŒ±ŒºŒ≠œÑœÅŒøœÖœÇ, Œ∑ ŒºŒ≠Œ∏ŒøŒ¥ŒøœÇ output() ŒµœÄŒπœÉœÑœÅŒ≠œÜŒµŒπ œÑŒø Œ±œÅœáŒµŒØŒø PDF œÉŒµ ŒºŒøœÅœÜŒÆ bytearray.

Œ†Œ±œÅŒ±Œ∫Œ¨œÑœâ, œÄŒ±œÅŒøœÖœÉŒπŒ¨Œ∂ŒµœÑŒ±Œπ Œ≠ŒΩŒ± œÄŒ±œÅŒ¨Œ¥ŒµŒπŒ≥ŒºŒ± ŒºŒµ œÑŒ∑ œáœÅŒÆœÉŒ∑ ŒµœÄŒπŒ∫ŒµœÜŒ±ŒªŒØŒ¥Œ±œÇ, œÖœÄŒøœÉŒ≠ŒªŒπŒ¥ŒøœÖ Œ∫Œ±Œπ ŒªŒøŒ≥œåœÑœÖœÄŒøœÖ:

Œ£œÑŒø œÉœÖŒ≥Œ∫ŒµŒ∫œÅŒπŒºŒ≠ŒΩŒø œÄŒ±œÅŒ¨Œ¥ŒµŒπŒ≥ŒºŒ± Œ≥ŒØŒΩŒµœÑŒ±Œπ œáœÅŒÆœÉŒ∑ œÑœâŒΩ ŒºŒµŒ∏œåŒ¥œâŒΩ header Œ∫Œ±Œπ footer Œ≠œÑœÉŒπ œéœÉœÑŒµ ŒΩŒ± ŒµœÄŒµŒæŒµœÅŒ≥Œ±œÉœÑŒøœçŒºŒµ œÑŒπœÇ ŒµœÄŒπŒ∫ŒµœÜŒ±ŒªŒØŒ¥ŒµœÇ Œ∫Œ±Œπ œÑŒ± œÖœÄŒøœÉŒ≠ŒªŒπŒ¥Œ± œÑœâŒΩ œÉŒµŒªŒØŒ¥œâŒΩ ŒµŒΩœåœÇ Œ±œÅœáŒµŒØŒøœÖ. Œó Œ∫ŒªŒÆœÉŒ∑ œÑŒøœÖœÇ Œ≥ŒØŒΩŒµœÑŒ±Œπ Œ±œÖœÑœåŒºŒ±œÑŒ±. Œ•œÄŒ¨œÅœáŒøœÖŒΩ ŒÆŒ¥Œ∑ œÉœÑŒ∑ŒΩ Œ∫ŒªŒ¨œÉŒ∑ FPDF Œ±ŒªŒªŒ¨ Œ¥ŒµŒΩ œÄœÅŒøœÉœÜŒ≠œÅŒøœÖŒΩ Œ∫Œ±ŒºŒØŒ± ŒªŒµŒπœÑŒøœÖœÅŒ≥ŒØŒ±, ŒµœÄŒøŒºŒ≠ŒΩœâœÇ œáœÅŒµŒπŒ¨Œ∂ŒµœÑŒ±Œπ ŒΩŒ± ŒµœÄŒµŒ∫œÑŒµŒØŒΩŒøœÖŒºŒµ œÑŒ∑ŒΩ Œ∫ŒªŒ¨œÉŒ∑ Œ∫Œ±Œπ ŒΩŒ± œÑŒπœÇ œÖœÄŒµœÅŒ∫Œ±ŒªœçœàŒøœÖŒºŒµ.

Œ§Œø ŒªŒøŒ≥œåœÑœÖœÄŒø ŒµŒ∫œÑœÖœÄœéŒΩŒµœÑŒ±Œπ ŒºŒµ œÑŒ∑ŒΩ ŒºŒ≠Œ∏ŒøŒ¥Œø image Œ¥ŒπŒµœÖŒ∫œÅŒπŒΩŒØŒ∂ŒøŒΩœÑŒ±œÇ œÑŒ∑ŒΩ Œ±œÅŒπœÉœÑŒµœÅŒÆ Œ¨ŒΩœâ Œ≥œâŒΩŒØŒ± Œ∫Œ±Œπ œÑŒø œÄŒªŒ¨œÑŒøœÇ œÑŒøœÖ. Œ§Œø œçœàŒøœÇ œÑŒ∑œÇ œÖœÄŒøŒªŒøŒ≥ŒØŒ∂ŒµœÑŒ±Œπ Œ±œÖœÑœåŒºŒ±œÑŒ± ŒªŒ±ŒºŒ≤Œ¨ŒΩŒøŒΩœÑŒ±œÇ œÖœÄœåœàŒ∑ œÑŒπœÇ Œ±ŒΩŒ±ŒªŒøŒ≥ŒØŒµœÇ œÑŒ∑œÇ ŒµŒπŒ∫œåŒΩŒ±œÇ.

ŒìŒπŒ± ŒΩŒ± ŒµŒ∫œÑœÖœÄœéœÉŒøœÖŒºŒµ œÑŒøŒΩ Œ±œÅŒπŒ∏Œºœå œÑŒ∑œÇ œÉŒµŒªŒØŒ¥Œ±œÇ, œáœÅŒµŒπŒ¨Œ∂ŒµœÑŒ±Œπ ŒΩŒ± œÄŒµœÅŒ¨œÉŒøœÖŒºŒµ œÑŒ∑ŒΩ ŒºŒ∑Œ¥ŒµŒΩŒπŒ∫ŒÆ œÑŒπŒºŒÆ œÉœÑŒ∑ŒΩ œÄŒ±œÅŒ¨ŒºŒµœÑœÅŒø œÑŒøœÖ œÄŒªŒ¨œÑŒøœÖœÇ Œ∫ŒµŒªŒπŒøœç. ŒëœÖœÑœå œÉŒ∑ŒºŒ±ŒØŒΩŒµŒπ œåœÑŒπ œÑŒø Œ∫ŒµŒªŒØ Œ∏Œ± ŒµœÄŒµŒ∫œÑŒ±Œ∏ŒµŒØ ŒºŒ≠œáœÅŒπ Œ∫Œ±Œπ œÑŒø Œ¥ŒµŒæŒØ œÄŒµœÅŒπŒ∏œéœÅŒπŒø œÑŒ∑œÇ œÉŒµŒªŒØŒ¥Œ±œÇ, œÑŒø ŒøœÄŒøŒØŒø Œ≤ŒøŒªŒµœçŒµŒπ œÉœÑŒø Œ∫ŒµŒΩœÑœÅŒ¨œÅŒπœÉŒºŒ± œÑŒøœÖ Œ∫ŒµŒπŒºŒ≠ŒΩŒøœÖ. Œü Œ±œÅŒπŒ∏ŒºœåœÇ œÑŒ∑œÇ œÑœâœÅŒπŒΩŒÆœÇ œÉŒµŒªŒØŒ¥Œ±œÇ œÄŒ±œÅŒ≠œáŒµœÑŒ±Œπ Œ±œÄœå œÑŒ∑ŒΩ ŒºŒ≠Œ∏ŒøŒ¥Œø page_no. Œü œÉœÖŒΩŒøŒªŒπŒ∫œåœÇ Œ±œÅŒπŒ∏ŒºœåœÇ œÉŒµŒªŒØŒ¥œâŒΩ œÑŒøœÖ Œ∫ŒµŒπŒºŒ≠ŒΩŒøœÖ ŒµŒØŒΩŒ±Œπ Œ¥ŒπŒ±Œ∏Œ≠œÉŒπŒºŒøœÇ ŒºŒ≠œÉœâ œÑŒ∑œÇ ŒµŒπŒ¥ŒπŒ∫ŒÆœÇ ŒºŒµœÑŒ±Œ≤ŒªŒ∑œÑŒÆœÇ {nb}, Œ∑ ŒøœÄŒøŒØŒ± ŒøœÅŒØŒ∂ŒµœÑŒ±Œπ ŒºŒµ œÑŒø Œ∫ŒªŒµŒØœÉŒπŒºŒø œÑŒøœÖ Œ±œÅœáŒµŒØŒøœÖ. ŒëœÖœÑŒÆ Œ∑ ŒµŒπŒ¥ŒπŒ∫ŒÆ œÑŒπŒºŒÆ ŒºœÄŒøœÅŒµŒØ ŒΩŒ± œÑœÅŒøœÄŒøœÄŒøŒπŒ∑Œ∏ŒµŒØ ŒºŒ≠œÉœâ œÑŒ∑œÇ ŒºŒµŒ∏œåŒ¥ŒøœÖ alias_nb_pages(). ŒëŒæŒØŒ∂ŒµŒπ ŒΩŒ± œÉŒ∑ŒºŒµŒπœâŒ∏ŒµŒØ œåœÑŒπ Œ∑ ŒºŒ≠Œ∏ŒøŒ¥ŒøœÇ set_y ŒµœÄŒπœÑœÅŒ≠œÄŒµŒπ œÑŒøŒΩ ŒøœÅŒπœÉŒºœå œÑŒ∑œÇ œÑœÅŒ≠œáŒøœÖœÉŒ±œÇ Œ∏Œ≠œÉŒ∑œÇ œÉŒµ ŒøœÄŒøŒπŒ±Œ¥ŒÆœÄŒøœÑŒµ œÑŒøœÄŒøŒ∏ŒµœÉŒØŒ± œÉœÑŒ∑ œÉŒµŒªŒØŒ¥Œ±, ŒæŒµŒ∫ŒπŒΩœéŒΩœÑŒ±œÇ Œ±œÄœå œÑŒ∑ŒΩ Œ∫ŒøœÅœÖœÜŒÆ ŒÆ œÑŒø œÑŒ≠ŒªŒøœÇ œÑŒ∑œÇ œÉŒµŒªŒØŒ¥Œ±œÇ.

ŒàŒΩŒ± Œ±Œ∫œåŒºŒ∑ ŒµŒΩŒ¥ŒπŒ±œÜŒ≠œÅŒøŒΩ œáŒ±œÅŒ±Œ∫œÑŒ∑œÅŒπœÉœÑŒπŒ∫œå œÄŒ±œÅŒøœÖœÉŒπŒ¨Œ∂ŒµœÑŒ±Œπ œÉœÑŒ∑ŒΩ œÉœÖŒ≥Œ∫ŒµŒ∫œÅŒπŒºŒ≠ŒΩŒ∑ œÄŒµœÅŒØœÄœÑœâœÉŒ∑: Œ∑ Œ±œÖœÑœåŒºŒ±œÑŒ∑ Œ±ŒªŒªŒ±Œ≥ŒÆ œÉŒµŒªŒØŒ¥Œ±œÇ. ŒúœåŒªŒπœÇ Œ≠ŒΩŒ± Œ∫ŒµŒªŒØ ŒæŒµœÄŒµœÅŒ¨œÉŒµŒπ Œ≠ŒΩŒ± œÄœÅŒøŒ∫Œ±Œ∏ŒøœÅŒπœÉŒºŒ≠ŒΩŒø œåœÅŒπŒø œÉœÑŒ∑ œÉŒµŒªŒØŒ¥Œ± (2 ŒµŒ∫Œ±œÑŒøœÉœÑŒ¨ Œ±œÄœå œÑŒø Œ∫Œ¨œÑœâ ŒºŒ≠œÅŒøœÇ œÑŒ∑œÇ œÉŒµŒªŒØŒ¥Œ±œÇ ŒµŒæ ŒøœÅŒπœÉŒºŒøœç), œÄœÅŒ±Œ≥ŒºŒ±œÑŒøœÄŒøŒπŒµŒØœÑŒ±Œπ Œ±ŒªŒªŒ±Œ≥ŒÆ Œ≥œÅŒ±ŒºŒºŒÆœÇ Œ∫Œ±Œπ Œ∑ Œ≥œÅŒ±ŒºŒºŒ±œÑŒøœÉŒµŒπœÅŒ¨ ŒµœÄŒ±ŒΩŒ±œÜŒ≠œÅŒµœÑŒ±Œπ. Œ†Œ±œÅœåŒªŒø œÄŒøœÖ Œ∑ ŒµœÄŒπŒ∫ŒµœÜŒ±ŒªŒØŒ¥Œ± Œ∫Œ±Œπ œÑŒø œÖœÄŒøœÉŒ≠ŒªŒπŒ¥Œø ŒµœÄŒπŒªŒ≠Œ≥ŒøœÖŒΩ œÑŒ∑ŒΩ Œ¥ŒπŒ∫ŒπŒ¨ œÑŒøœÖœÇ Œ≥œÅŒ±ŒºŒºŒ±œÑŒøœÉŒµŒπœÅŒ¨ (helvetica), œÑŒø Œ∫œçœÅŒπŒø œÑŒºŒÆŒºŒ± œÑŒøœÖ Œ∫ŒµŒπŒºŒ≠ŒΩŒøœÖ œÉœÖŒΩŒµœáŒØŒ∂ŒµŒπ ŒºŒµ œÑŒ∑ Œ≥œÅŒ±ŒºŒºŒ±œÑŒøœÉŒµŒπœÅŒ¨ Times. ŒëœÖœÑœåœÇ Œø ŒºŒ∑œáŒ±ŒΩŒπœÉŒºœåœÇ œÑŒ∑œÇ Œ±œÖœÑœåŒºŒ±œÑŒ∑œÇ ŒµœÄŒ±ŒΩŒ±œÜŒøœÅŒ¨œÇ ŒµœÜŒ±œÅŒºœåŒ∂ŒµœÑŒ±Œπ ŒµœÄŒπœÄŒªŒ≠ŒøŒΩ œÉœÑŒø œáœÅœéŒºŒ± Œ∫Œ±Œπ œÉœÑŒø œÄŒªŒ¨œÑŒøœÇ Œ≥œÅŒ±ŒºŒºŒÆœÇ. Œ§Œø œåœÅŒπŒø œÄŒøœÖ œÄœÅŒøŒ∫Œ±ŒªŒµŒØ œÑŒ∑ŒΩ Œ±ŒªŒªŒ±Œ≥ŒÆ œÉŒµŒªŒØŒ¥Œ±œÇ ŒºœÄŒøœÅŒµŒØ ŒΩŒ± ŒøœÅŒπœÉœÑŒµŒØ ŒºŒ≠œÉœâ œÑŒ∑œÇ ŒºŒµŒ∏œåŒ¥ŒøœÖ set_auto_page_break.

ŒëœÇ œÉœÖŒΩŒµœáŒØœÉŒøœÖŒºŒµ ŒºŒµ Œ≠ŒΩŒ± œÄŒ±œÅŒ¨Œ¥ŒµŒπŒ≥ŒºŒ± œÑŒø ŒøœÄŒøŒØŒø ŒµŒ∫œÑœÖœÄœéŒΩŒµŒπ ŒµœÖŒ∏œÖŒ≥œÅŒ±ŒºŒºŒπœÉŒºŒ≠ŒΩŒµœÇ œÄŒ±œÅŒ±Œ≥œÅŒ¨œÜŒøœÖœÇ. ŒïœÄŒØœÉŒ∑œÇ ŒµœÄŒµŒæŒ∑Œ≥ŒµŒØ œÑŒ∑ œáœÅŒÆœÉŒ∑ œáœÅœâŒºŒ¨œÑœâŒΩ.

ŒöŒµŒØŒºŒµŒΩŒø œÑŒøœÖ Jules Verne

Œó ŒºŒ≠Œ∏ŒøŒ¥ŒøœÇ get_string_width ŒµœÄŒπœÑœÅŒ≠œÄŒµŒπ œÑŒøŒΩ Œ∫Œ±Œ∏ŒøœÅŒπœÉŒºœå œÑŒøœÖ ŒºŒÆŒ∫ŒøœÖœÇ ŒºŒØŒ±œÇ œÉœÖŒºŒ≤ŒøŒªŒøœÉŒµŒπœÅŒ¨œÇ œÉœÑŒ∑ŒΩ œÑœâœÅŒπŒΩŒÆ Œ≥œÅŒ±ŒºŒºŒ±œÑŒøœÉŒµŒπœÅŒ¨, œÑŒø ŒøœÄŒøŒØŒø œáœÅŒ∑œÉŒπŒºŒøœÄŒøŒπŒµŒØœÑŒ±Œπ œÉœÑŒ∑ œÉœÖŒ≥Œ∫ŒµŒ∫œÅŒπŒºŒ≠ŒΩŒ∑ œÄŒµœÅŒØœÄœÑœâœÉŒ∑ Œ≥ŒπŒ± œÑŒøŒΩ œÖœÄŒøŒªŒøŒ≥ŒπœÉŒºœå œÑŒ∑œÇ Œ∏Œ≠œÉŒ∑œÇ Œ∫Œ±Œπ œÑŒøœÖ œÄŒªŒ¨œÑŒøœÖœÇ œÑŒøœÖ œÄŒªŒ±ŒπœÉŒØŒøœÖ œÄŒøœÖ œÄŒµœÅŒπŒ≤Œ¨ŒªŒªŒµŒπ œÑŒøŒΩ œÑŒØœÑŒªŒø. ŒàœÄŒµŒπœÑŒ± ŒøœÅŒØŒ∂ŒøŒΩœÑŒ±Œπ œÑŒ± œáœÅœéŒºŒ±œÑŒ± (ŒºŒ≠œÉœâ set_draw_color, set_fill_color Œ∫Œ±Œπ set_text_color) Œ∫Œ±Œπ œÑŒø œÄŒ¨œáŒøœÇ œÑŒ∑œÇ Œ≥œÅŒ±ŒºŒºŒÆœÇ ŒøœÅŒØŒ∂ŒµœÑŒ±Œπ œâœÇ 1 œáŒπŒªŒπŒøœÉœÑœåŒºŒµœÑœÅŒø (Œ±ŒΩœÑŒπŒ∏Œ≠œÑœâœÇ œÑŒ∑œÇ œÄœÅŒøŒ∫Œ±Œ∏ŒøœÅŒπœÉŒºŒ≠ŒΩŒ∑œÇ œÑŒπŒºŒÆœÇ 0.2) ŒºŒ≠œÉœâ œÑŒ∑œÇ ŒºŒµŒ∏œåŒ¥ŒøœÖ set_line_width. Œ§ŒµŒªŒπŒ∫Œ¨, ŒµŒ∫œÑœÖœÄœéŒΩŒøœÖŒºŒµ œÑŒø Œ∫ŒµŒªŒØ (Œ∑ œÑŒµŒªŒµœÖœÑŒ±ŒØŒ± œÄŒ±œÅŒ¨ŒºŒµœÑœÅŒøœÇ ŒØœÉŒ∑ ŒºŒµ true œÖœÄŒøŒ¥Œ∑ŒªœéŒΩŒµŒπ œÑŒ∑ŒΩ Œ∫Œ¨ŒªœÖœàŒ∑ œÑŒøœÖ œÖœÄœåŒ≤Œ±Œ∏œÅŒøœÖ).

ŒìŒπŒ± œÑŒ∑ŒΩ ŒµŒ∫œÑœçœÄœâœÉŒ∑ œÑœâŒΩ œÄŒ±œÅŒ±Œ≥œÅŒ¨œÜœâŒΩ œáœÅŒ∑œÉŒπŒºŒøœÄŒøŒπŒÆœÉŒ±ŒºŒµ œÑŒ∑ŒΩ ŒºŒ≠Œ∏ŒøŒ¥Œø multi_cell. Œ§Œø Œ∫ŒµŒØŒºŒµŒΩŒø ŒµœÖŒ∏œÖŒ≥œÅŒ±ŒºŒºŒØŒ∂ŒµœÑŒ±Œπ Œ±œÖœÑœåŒºŒ±œÑŒ±. ŒöŒ¨Œ∏Œµ œÜŒøœÅŒ¨ œÄŒøœÖ ŒºŒØŒ± Œ≥œÅŒ±ŒºŒºŒÆ œÜœÑŒ¨ŒΩŒµŒπ œÉœÑŒ∑ŒΩ Œ±Œ∫œÅŒ±ŒØŒ± Œ¥ŒµŒæŒπŒ¨ Œ∏Œ≠œÉŒ∑ œÑŒøœÖ Œ∫ŒµŒªŒπŒøœç ŒÆ œÉœÖŒΩŒ±ŒΩœÑŒ¨œÑŒ±Œπ œáŒ±œÅŒ±Œ∫œÑŒÆœÅŒ±œÇ ŒµœÄŒπœÉœÑœÅŒøœÜŒÆœÇ œÜŒøœÅŒ≠Œ± (\n), Œ∫Œ±ŒªŒµŒØœÑŒ±Œπ Œ±ŒªŒªŒ±Œ≥ŒÆ Œ≥œÅŒ±ŒºŒºŒÆœÇ Œ∫Œ±Œπ Œ≠ŒΩŒ± ŒΩŒ≠Œø Œ∫ŒµŒªŒØ Œ¥Œ∑ŒºŒπŒøœÖœÅŒ≥ŒµŒØœÑŒ±Œπ Œ±œÖœÑœåŒºŒ±œÑŒ± Œ∫Œ¨œÑœâ Œ±œÄœå œÑŒø œÑœâœÅŒπŒΩœå. ŒúŒØŒ± Œ±œÖœÑœåŒºŒ±œÑŒ∑ Œ±ŒªŒªŒ±Œ≥ŒÆ Œ≥œÅŒ±ŒºŒºŒÆœÇ œÄœÅŒ±Œ≥ŒºŒ±œÑŒøœÄŒøŒπŒµŒØœÑŒ±Œπ œÉœÑŒø œÉŒ∑ŒºŒµŒØŒø ŒºŒµ œÑŒø œÄŒªŒ∑œÉŒπŒ≠œÉœÑŒµœÅŒø œáŒ±œÅŒ±Œ∫œÑŒÆœÅŒ± Œ∫ŒµŒΩŒøœç ŒÆ ŒµŒΩœâœÑŒπŒ∫Œøœç œÉœÖŒªŒªŒ±Œ≤ŒÆœÇ (\u00ad) œÄœÅŒπŒΩ œÑŒ∑ŒΩ Œ±Œ∫œÅŒ±ŒØŒ± Œ¥ŒµŒæŒπŒ¨ Œ∏Œ≠œÉŒ∑. ŒàŒΩŒ± ŒµŒΩœâœÑŒπŒ∫œå œÉœÖŒªŒªŒ±Œ≤ŒÆœÇ Œ∏Œ± Œ±ŒΩœÑŒπŒ∫Œ±œÑŒ±œÉœÑŒ±Œ∏ŒµŒØ Œ±œÄœå Œ≠ŒΩŒ± Œ±œÄŒªœå ŒµŒΩœâœÑŒπŒ∫œå œåœÑŒ±ŒΩ œÄœÅŒ±Œ≥ŒºŒ±œÑŒøœÄŒøŒπŒµŒØœÑŒ±Œπ Œ±ŒªŒªŒ±Œ≥ŒÆ Œ≥œÅŒ±ŒºŒºŒÆœÇ, Œ±ŒªŒªŒπœéœÇ Œ∏Œ± Œ±Œ≥ŒΩŒøŒ∑Œ∏ŒµŒØ.

ŒüœÅŒØŒ∂ŒøŒΩœÑŒ±Œπ Œ¥œçŒø ŒπŒ¥ŒπœåœÑŒ∑œÑŒµœÇ Œ±œÅœáŒµŒØŒøœÖ: Œø œÑŒØœÑŒªŒøœÇ (set_title) Œ∫Œ±Œπ Œø œÉœÖŒ≥Œ≥œÅŒ±œÜŒ≠Œ±œÇ (set_author). ŒüŒπ ŒπŒ¥ŒπœåœÑŒ∑œÑŒµœÇ ŒºœÄŒøœÅŒøœçŒΩ ŒΩŒ± œÄœÅŒøŒ≤ŒªŒ∑Œ∏ŒøœçŒΩ ŒºŒµ Œ¥œçŒø œÑœÅœåœÄŒøœÖœÇ. Œ†œÅœéœÑŒøŒΩ, ŒºœÄŒøœÅŒøœçŒºŒµ ŒΩŒ± Œ±ŒΩŒøŒØŒæŒøœÖŒºŒµ œÑŒø Œ±œÅœáŒµŒØŒø Œ±œÄŒµœÖŒ∏ŒµŒØŒ±œÇ ŒºŒ≠œÉœâ Acrobat Reader, ŒΩŒ± Œ∫Œ±œÑŒµœÖŒ∏œÖŒΩŒ∏ŒøœçŒºŒµ œÉœÑŒø ŒúŒµŒΩŒøœç ŒëœÅœáŒµŒØœâŒΩ Œ∫Œ±Œπ ŒΩŒ± ŒµœÄŒπŒªŒ≠ŒæŒøœÖŒºŒµ œÑŒ∑ŒΩ ŒµœÄŒπŒªŒøŒ≥ŒÆ ŒôŒ¥ŒπœåœÑŒ∑œÑŒµœÇ ŒëœÅœáŒµŒØŒøœÖ. ŒîŒµœçœÑŒµœÅŒøŒΩ, ŒºœÄŒøœÅŒøœçŒºŒµ Œ±œÄŒµœÖŒ∏ŒµŒØŒ±œÇ ŒΩŒ± Œ∫Œ¨ŒΩŒøœÖŒºŒµ Œ¥ŒµŒæŒØ Œ∫ŒªŒπŒ∫ œÉœÑŒø ŒµŒπŒ∫ŒøŒΩŒØŒ¥ŒπŒø Œ±œÅœáŒµŒØŒøœÖ Œ∫Œ±Œπ ŒΩŒ± ŒµœÄŒπŒªŒ≠ŒæŒøœÖŒºŒµ œÑŒπœÇ ŒôŒ¥ŒπœåœÑŒ∑œÑŒµœÇ ŒëœÅœáŒµŒØŒøœÖ.

ŒëœÖœÑœå œÑŒø œÄŒ±œÅŒ¨Œ¥ŒµŒπŒ≥ŒºŒ± Œ±œÄŒøœÑŒµŒªŒµŒØ ŒºŒØŒ± œÄŒ±œÅŒ±ŒªŒªŒ±Œ≥ŒÆ œÑŒøœÖ œÄœÅŒøŒ∑Œ≥ŒøœçŒºŒµŒΩŒøœÖ Œ∫Œ±Œπ ŒºŒ±œÇ œÄŒ±œÅŒøœÖœÉŒπŒ¨Œ∂ŒµŒπ œÄœâœÇ ŒΩŒ± Œ∫Œ±œÑŒ±ŒΩŒ≠ŒºŒøœÖŒºŒµ œÑŒø Œ∫ŒµŒØŒºŒµŒΩœå ŒºŒ±œÇ œÉŒµ œÄŒøŒªŒªŒ±œÄŒªŒ≠œÇ œÉœÑŒÆŒªŒµœÇ.

ŒöŒµŒØŒºŒµŒΩŒø œÑŒøœÖ Jules Verne

‚ö†Ô∏è This section has changed a lot and requires a new translation: https://github.com/py-pdf/fpdf2/issues/267

Œ†Œ±œÅŒ±Œ≥œåŒºŒµŒΩŒø PDF - ŒöŒµŒØŒºŒµŒΩŒø ŒßœâœÅœéŒΩ

‚ö†Ô∏è This section has changed a lot and requires a new translation: https://github.com/py-pdf/fpdf2/issues/267

Œ£Œµ Œ±œÖœÑœå œÑŒø ŒºŒ¨Œ∏Œ∑ŒºŒ± Œ∏Œ± ŒµŒæŒ∑Œ≥ŒÆœÉŒøœÖŒºŒµ œÄŒøŒªŒªŒ±œÄŒªŒøœçœÇ œÑœÅœåœÄŒøœÖœÇ ŒµŒπœÉŒ±Œ≥œâŒ≥ŒÆœÇ ŒµœÉœâœÑŒµœÅŒπŒ∫œéŒΩ Œ±ŒªŒªŒ± Œ∫Œ±Œπ ŒµŒæœâœÑŒµœÅŒπŒ∫œéŒΩ œÉœÖŒΩŒ¥Œ≠œÉŒºœâŒΩ œÉŒµ Œ≠ŒΩŒ± Œ±œÅœáŒµŒØŒø pdf.

ŒòŒ± Œ±ŒΩŒ±ŒªœçœÉŒøœÖŒºŒµ ŒµœÄŒØœÉŒ∑œÇ œÄœâœÇ ŒºœÄŒøœÅŒøœçŒºŒµ ŒΩŒ± œáœÅŒ∑œÉŒπŒºŒøœÄŒøŒπŒÆœÉŒøœÖŒºŒµ Œ¥ŒπŒ¨œÜŒøœÅŒ± œÉœÑœÖŒª Œ∫ŒµŒπŒºŒ≠ŒΩŒøœÖ (Œ≠ŒΩœÑŒøŒΩŒ∑ Œ≥œÅŒ±œÜŒÆ, œÄŒªŒ¨Œ≥ŒπŒ± Œ≥œÅŒ±œÜŒÆ, œÖœÄŒøŒ≥œÅŒ¨ŒºŒºŒπœÉŒ∑) ŒµŒΩœÑœåœÇ œÑŒøœÖ ŒØŒ¥ŒπŒøœÖ Œ∫ŒµŒπŒºŒ≠ŒΩŒøœÖ.

Œ†Œ±œÅŒ±Œ≥œåŒºŒµŒΩŒø PDF - fpdf2-logo

Œ†Œ±œÅŒ±œÑŒ∑œÅŒøœçŒºŒµ ŒºŒØŒ± ŒΩŒ≠Œ± ŒºŒ≠Œ∏ŒøŒ¥Œø Œ≥ŒπŒ± œÑŒ∑ŒΩ ŒµŒ∫œÑœçœÄœâœÉŒ∑ Œ∫ŒµŒπŒºŒ≠ŒΩŒøœÖ, œÑŒ∑ŒΩ write() . Œó ŒºŒ≠Œ∏ŒøŒ¥ŒøœÇ Œ±œÖœÑŒÆ, Œ∏œÖŒºŒØŒ∂ŒµŒπ Œ±œÅŒ∫ŒµœÑŒ¨ œÑŒ∑ŒΩ multi_cell() , œÄŒ±œÅœåŒªŒ± Œ±œÖœÑŒ¨ ŒµŒºœÜŒ±ŒΩŒØŒ∂ŒµŒπ œÑŒπœÇ ŒµŒæŒÆœÇ Œ¥ŒπŒ±œÜŒøœÅŒ≠œÇ:

ŒëœÖœÑŒÆ Œ∑ ŒºŒ≠Œ∏ŒøŒ¥ŒøœÇ, ŒµœÄŒøŒºŒ≠ŒΩœâœÇ ŒºŒ±œÇ ŒµœÄŒπœÑœÅŒ≠œÄŒµŒπ ŒΩŒ± Œ≥œÅŒ¨œàŒøœÖŒºŒµ Œ≠ŒΩŒ± Œ∫ŒøŒºŒºŒ¨œÑŒπ Œ∫ŒµŒπŒºŒ≠ŒΩŒøœÖ, ŒΩŒ± Œ±ŒªŒªŒ¨ŒæŒøœÖŒºŒµ œÑŒ∑ Œ≥œÅŒ±ŒºŒºŒ±œÑŒøœÉŒµŒπœÅŒ¨, Œ∫Œ±Œπ ŒΩŒ± œÉœÖŒΩŒµœáŒØœÉŒøœÖŒºŒµ Œ±Œ∫œÅŒπŒ≤œéœÇ œÉœÑŒø œÉŒ∑ŒºŒµŒØŒø œÄŒøœÖ ŒµŒØœáŒ±ŒºŒµ Œ±œÄŒøŒºŒµŒØŒΩŒµŒπ. ŒëœÄœå œÑŒ∑ŒΩ Œ¨ŒªŒªŒ∑ œÄŒªŒµœÖœÅŒ¨, œÑŒø Œ≤Œ±œÉŒπŒ∫œå œÑŒ∑œÇ ŒºŒµŒπŒøŒΩŒ≠Œ∫œÑŒ∑ŒºŒ± ŒµŒØŒΩŒ±Œπ œåœÑŒπ Œ¥ŒµŒΩ ŒºœÄŒøœÅŒøœçŒºŒµ ŒΩŒ± ŒµœÖŒ∏œÖŒ≥œÅŒ±ŒºŒºŒØœÉŒøœÖŒºŒµ œÑŒø Œ∫ŒµŒØŒºŒµŒΩŒø œåœÄœâœÇ ŒºŒµ œÑŒ∑ŒΩ ŒºŒ≠Œ∏ŒøŒ¥Œø multi_cell().

Œ£œÑŒ∑ŒΩ œÄœÅœéœÑŒ∑ œÉŒµŒªŒØŒ¥Œ± œÑŒøœÖ œÄŒ±œÅŒ±Œ¥ŒµŒØŒ≥ŒºŒ±œÑŒøœÇ œáœÅŒ∑œÉŒπŒºŒøœÄŒøŒπŒÆœÉŒ±ŒºŒµ œÑŒ∑ŒΩ ŒºŒ≠Œ∏ŒøŒ¥Œø write() Œ≥ŒπŒ± Œ±œÖœÑœå œÑŒø œÉŒ∫ŒøœÄœå. Œ§Œø œÄœÅœéœÑŒø Œ∫ŒøŒºŒºŒ¨œÑŒπ œÑŒ∑œÇ œÄœÅœåœÑŒ±œÉŒ∑œÇ ŒµŒØŒΩŒ±Œπ Œ≥œÅŒ±ŒºŒºŒ≠ŒΩŒø œâœÇ Œ±œÄŒªœå Œ∫ŒµŒØŒºŒµŒΩŒø, ŒµŒΩœé œÉœÑŒ∑ œÉœÖŒΩŒ≠œáŒµŒπŒ±, Œ±œÜŒøœç œáœÅŒ∑œÉŒπŒºŒøœÄŒøŒπŒÆœÉŒ±ŒºŒµ œÑŒ∑ŒΩ ŒºŒ≠Œ∏ŒøŒ¥Œø set_font(), Œ±ŒªŒªŒ¨ŒæŒ±ŒºŒµ œÑŒø œÉœÑœÖŒª Œ∫ŒµŒπŒºŒ≠ŒΩŒøœÖ œÉŒµ œÖœÄŒøŒ≥œÅŒ¨ŒºŒºŒπœÉŒ∑ Œ∫Œ±Œπ Œ∫ŒªŒµŒØœÉŒ±ŒºŒµ œÑŒ∑ŒΩ œÄœÅœåœÑŒ±œÉŒ∑.

ŒìŒπŒ± ŒΩŒ± œÄœÅŒøœÉŒ∏Œ≠œÉŒøœÖŒºŒµ Œ≠ŒΩŒ±ŒΩ ŒµœÉœâœÑŒµœÅŒπŒ∫œå œÉœçŒΩŒ¥ŒµœÉŒºŒø Œø ŒøœÄŒøŒØŒøœÇ Œ∏Œ± Œ∫Œ±œÑŒµœÖŒ∏œçŒΩŒµŒπ œÉœÑŒ∑ŒΩ ŒµœÄœåŒºŒµŒΩŒ∑ œÉŒµŒªŒØŒ¥Œ±, œáœÅŒ∑œÉŒπŒºŒøœÄŒøŒπŒÆœÉŒ±ŒºŒµ œÑŒ∑ŒΩ ŒºŒ≠Œ∏ŒøŒ¥Œø add_link(), Œ∑ ŒøœÄŒøŒØŒ± Œ¥Œ∑ŒºŒπŒøœÖœÅŒ≥ŒµŒØ ŒºŒØŒ± ŒµœÄŒπœÜŒ±ŒΩŒµŒØŒ± ŒºŒµ œåŒΩŒøŒºŒ± "link". ŒëŒΩ Œ∫ŒªŒπŒ∫Œ¨œÅŒøœÖŒºŒµ œÑŒ∑ŒΩ ŒµœÄŒπœÜŒ¨ŒΩŒµŒπŒ± Œ±œÖœÑŒÆ ŒºŒµœÑŒ±œÜŒµœÅœåŒºŒ±œÉœÑŒµ œÉŒµ ŒºŒØŒ± Œ¨ŒªŒªŒ∑ œÑŒøœÄŒøŒ∏ŒµœÉŒØŒ± œÑŒøœÖ Œ±œÅœáŒµŒØŒøœÖ.

ŒìŒπŒ± ŒΩŒ± Œ¥Œ∑ŒºŒπŒøœÖœÅŒ≥ŒÆœÉŒøœÖŒºŒµ Œ≠ŒΩŒ±ŒΩ ŒµŒæœâœÑŒµœÅŒπŒ∫œå œÉœçŒΩŒ¥ŒµœÉŒºŒø ŒºŒ≠œÉœâ ŒºŒπŒ±œÇ ŒµŒπŒ∫œåŒΩŒ±œÇ, Œ∏Œ± œáœÅŒ∑œÉŒπŒºŒøœÄŒøŒπŒÆœÉŒøœÖŒºŒµ œÑŒ∑ŒΩ ŒºŒ≠Œ∏ŒøŒ¥Œø image(). ŒëœÖœÑŒÆ Œ∑ ŒºŒ≠Œ∏ŒøŒ¥ŒøœÇ ŒºŒ±œÇ Œ¥ŒØŒΩŒµŒπ œÑŒ∑ŒΩ ŒµœÄŒπŒªŒøŒ≥ŒÆ ŒΩŒ± œÄŒµœÅŒ¨œÉŒøœÖŒºŒµ Œ≠ŒΩŒ±ŒΩ œÉœçŒΩŒ¥ŒµœÉŒºŒø œâœÇ œÑŒπŒºŒÆ œÉŒµ ŒºŒØŒ± Œ±œÄœå œÑŒπœÇ œÄŒ±œÅŒ±ŒºŒ≠œÑœÅŒøœÖœÇ œÑŒ∑œÇ. Œü œÉœçŒΩŒ¥ŒµœÉŒºŒøœÇ ŒºœÄŒøœÅŒµŒØ ŒΩŒ± ŒµŒØŒΩŒ±Œπ ŒµœÉœâœÑŒµœÅŒπŒ∫œåœÇ ŒÆ ŒµŒæœâœÑŒµœÅŒπŒ∫œåœÇ.

ŒïŒΩŒ±ŒªŒªŒ±Œ∫œÑŒπŒ∫Œ¨, ŒºŒØŒ± Œ±Œ∫œåŒºŒ∑ ŒµœÄŒπŒªŒøŒ≥ŒÆ Œ≥ŒπŒ± ŒΩŒ± Œ±ŒªŒªŒ¨ŒæŒøœÖŒºŒµ œÑŒø œÉœÑœÖŒª Œ∫ŒµŒπŒºŒ≠ŒΩŒøœÖ Œ∫Œ±Œπ ŒΩŒ± œÄœÅŒøœÉŒ∏Œ≠œÉŒøœÖŒºŒµ œÉœÖŒΩŒ¥Œ≠œÉŒºŒøœÖœÇ ŒµŒØŒΩŒ±Œπ Œ∑ œáœÅŒÆœÉŒ∑ œÑŒ∑œÇ ŒºŒµŒ∏œåŒ¥ŒøœÖ write_html(). Œó ŒºŒ≠Œ∏ŒøŒ¥ŒøœÇ Œ±œÖœÑŒÆ, Œ±œÄŒøœÑŒµŒªŒµŒØ Œ≠ŒΩŒ±ŒΩ Œ±ŒΩŒ±ŒªœÖœÑŒÆ html Œø ŒøœÄŒøŒØŒøœÇ ŒµœÄŒπœÑœÅŒ≠œÄŒµŒπ œÑŒ∑ŒΩ œÄœÅŒøœÉŒ∏ŒÆŒ∫Œ∑ Œ∫ŒµŒπŒºŒ≠ŒΩŒøœÖ, œÑŒ∑ŒΩ Œ±ŒªŒªŒ±Œ≥ŒÆ Œ≥œÅŒ±ŒºŒºŒ±œÑŒøœÉŒµŒπœÅŒ¨œÇ Œ∫Œ±Œπ œÑŒ∑ŒΩ œÄœÅŒøœÉŒ∏ŒÆŒ∫Œ∑ œÉœÖŒΩŒ¥Œ≠œÉŒºœâŒΩ ŒºŒµ œÑŒ∑ŒΩ œáœÅŒÆœÉŒ∑ œÑŒ∑œÇ html.

**Examples:**

Example 1 (python):
```python
from fpdf import FPDF

pdf = FPDF()
pdf.add_page()
pdf.set_font("helvetica", style="B", size=16)
pdf.cell(40, 10, "Hello World!")
pdf.output("tuto1.pdf")
```

Example 2 (unknown):
```unknown
pdf = FPDF(orientation="P", unit="mm", format="A4")
```

Example 3 (unknown):
```unknown
pdf.set_font('Helvetica', style='B', size=16)
```

Example 4 (unknown):
```unknown
pdf.cell(40, 10, 'Hello World!', 1)
```

---

## Emojis, Symbols & Dingbats¬∂

**URL:** https://py-pdf.github.io/fpdf2/EmojisSymbolsDingbats.html

**Contents:**
- Emojis, Symbols & Dingbats¬∂
- Emojis¬∂
- Color fonts and emojis¬∂
- Symbols¬∂
- Dingbats¬∂
- Fallback fonts¬∂

Displaying emojis requires the use of a Unicode font file. Here is an example using the DejaVu font:

This code produces this PDF file: fonts_emoji_glyph.pdf

Another font supporting emojis is: twemoji

A wide variety of color fonts are supported - SBIX, CBDT/CBLC, SVG, COLRv0 and COLRv1. If a loaded font provides color glyphs, fpdf2 will render them automatically.

To always draw emoji as outline/monochrome even if the font includes color glyphs, set: FPDF.render_color_fonts = False

The Symbol font is one of the built-in fonts in the PDF format. Hence you can include its symbols very easily:

The following table will help you find which characters map to which symbol: symbol.pdf. For reference, it was built using this script: symbol.py.

The ZapfDingbats font is one of the built-in fonts in the PDF format. Hence you can include its dingbats very easily:

The following table will help you find which characters map to which dingbats: zapfdingbats.pdf. For reference, it was built using this script: zapfdingbats.py.

If you need to mix special characters and emojis within normal text, it is possible to specify alternative fonts for FPDF to use as fallback fonts. See an example of use Here

**Examples:**

Example 1 (swift):
```swift
import fpdf

pdf = fpdf.FPDF()
pdf.add_font(fname="DejaVuSans.ttf")
pdf.set_font("DejaVuSans", size=64)
pdf.add_page()
pdf.multi_cell(0, text="".join([chr(0x1F600 + x) for x in range(68)]))
pdf.set_font_size(32)
pdf.text(10, 270, "".join([chr(0x1F0A0 + x) for x in range(15)]))
pdf.output("fonts_emoji_glyph.pdf")
```

Example 2 (python):
```python
import fpdf

pdf = fpdf.FPDF()
pdf.add_page()
pdf.set_font("symbol", size=36)
pdf.cell(h=16, text="\u0022 \u0068 \u0024 \u0065 \u00ce \u00c2, \u0068/\u0065 \u0040 \u00a5",
        new_x="LMARGIN", new_y="NEXT")
pdf.cell(h=16, text="\u0044 \u0046 \u0053 \u0057 \u0059 \u0061 \u0062 \u0063",
        new_x="LMARGIN", new_y="NEXT")
pdf.cell(h=16, text="\u00a0 \u00a7 \u00a8 \u00a9 \u00aa \u00ab \u00ac \u00ad \u00ae \u00af \u00db \u00dc \u00de",
        new_x="LMARGIN", new_y="NEXT")
pdf.output("symbol.pdf")
```

Example 3 (python):
```python
import fpdf

pdf = fpdf.FPDF()
pdf.add_page()
pdf.set_font("zapfdingbats", size=36)
pdf.cell(text="+ 3 8 A r \u00a6 } \u00a8 \u00a9 \u00aa \u00ab ~")
pdf.output("zapfdingbat.pdf")
```

---

## Text styling¬∂

**URL:** https://py-pdf.github.io/fpdf2/TextStyling.html

**Contents:**
- Text styling¬∂
- .set_font()¬∂
- .set_stretching(stretching=100)¬∂
- .set_char_spacing(spacing=0)¬∂
- Subscript, Superscript, and Fractional Numbers¬∂
- .text_mode¬∂
- markdown=True¬∂
- .write_html()¬∂

Setting emphasis on text can be controlled by using .set_font(style=...):

Letters can be combined, for example: style="BI" indicates bold italics

Text can be stretched horizontally with this setting, measured in percent. If the argument is less than 100, then all characters are rendered proportionally narrower and the text string will take less space. If it is larger than 100, then the width of all characters will be expanded accordingly.

The example shows the same text justified to the same width, with stretching values of 100 and 150. pdf = FPDF() pdf.add_page() pdf.set_font("Helvetica", size=8) pdf.set_fill_color(255, 255, 0) pdf.multi_cell(w=50, text=LOREM_IPSUM[:100], new_x="LEFT", fill=True) pdf.ln() pdf.set_stretching(150) pdf.multi_cell(w=50, text=LOREM_IPSUM[:100], new_x="LEFT", fill=True)

This method changes the distance between individual characters of a test string. Normally, characters are placed at a given distance according the width information in the font file. If spacing is larger than 0, then their distance will be larger, creating a gap in between. If it is less than 0, then their distance will be smaller, possibly resulting in an overlap. The change in distance is given in typographic points (Pica), which makes it easy to adapt it relative to the current font size.

Character spacing works best for formatting single line text created by any method, or for highlighting individual words included in a block of text with .write().

Limitations: Spacing will only be changed within a sequence of characters that fpdf2 adds to the PDF in one go. This means that there will be no extra distance eg. between text parts that are placed successively with write(). Also, if you apply different font styles using the Markdown functionality of .cell() and .multi_cell() or by using html_write(), then any parts given different styles will have the original distance between them. This is so because fpdf2 has to add each styled fragment to the PDF file separately.

The example shows the same text justified to the same width, with char_spacing values of 0 and 10 (font size 8 pt). pdf = FPDF() pdf.add_page() pdf.set_font("Helvetica", size=8) pdf.set_fill_color(255, 255, 0) pdf.multi_cell(w=150, text=LOREM_IPSUM[:200], new_x="LEFT", fill=True) pdf.ln() pdf.set_char_spacing(10) pdf.multi_cell(w=150, text=LOREM_IPSUM[:200], new_x="LEFT", fill=True)

For a more complete support of Markdown syntax, check out this guide to combine fpdf2 with the mistletoe library: Combine with Markdown.

The class attribute .char_vpos controls special vertical positioning modes for text:

For each positioning mode there are two parameters that can be configured. The defaults have been set to result in a decent layout with most fonts, and are given in parens.

The size multiplier for the font size:

The lift is given as fraction of the unscaled font size and indicates how much the glyph gets lifted above the base line (negative for below):

Limitations: The individual glyphs will be scaled down as configured. This is not typographically correct, as it will also reduce the stroke width, making them look lighter than the normal text. Unicode fonts may include characters in the subscripts and superscripts range. In a high quality font, those glyphs will be smaller than the normal ones, but have a proportionally stronger stroke width in order to maintain the same visual density. If available in good quality, using Characters from this range is preferred and will look better. Unfortunately, many fonts either don't (fully) cover this range, or the glyphs are of unsatisfactory quality. In those cases, this feature of fpdf2 offers a reliable workaround with suboptimal but consistent output quality.

Practical use is essentially limited to .write() and html_write(). The feature does technically work with .cell() and .multi_cell, but is of limited usefulness there, since you can't change font properties in the middle of a line (there is no markdown support). It currently gets completely ignored by .text().

The example shows the most common use cases:

pdf = fpdf.FPDF() pdf.add_page() pdf.set_font("Helvetica", size=20) pdf.write(text="2") pdf.char_vpos = "SUP" pdf.write(text="56") pdf.char_vpos = "LINE" pdf.write(text=" more line text") pdf.char_vpos = "SUB" pdf.write(text="(idx)") pdf.char_vpos = "LINE" pdf.write(text=" end") pdf.ln() pdf.write(text="1234 + ") pdf.char_vpos = "NOM" pdf.write(text="5") pdf.char_vpos = "LINE" pdf.write(text="/") pdf.char_vpos = "DENOM" pdf.write(text="16") pdf.char_vpos = "LINE" pdf.write(text=" + 987 = x")

The PDF spec defines several text modes:

The text mode can be controlled with the .text_mode attribute. With STROKE modes, the line width is induced by .line_width, and its color can be configured with set_draw_color(). With FILL modes, the filling color can be controlled by set_fill_color() or set_text_color().

With any of the 4 CLIP modes, the letters will be filled by vector drawings made afterwards, as can be seen in this example:

from fpdf import FPDF pdf = FPDF(orientation="landscape") pdf.add_page() pdf.set_font("Helvetica", size=100) with pdf.local_context(text_mode="STROKE", line_width=2): pdf.cell(text="Hello world") # Outside the local context, text_mode & line_width are reverted # back to their original default values pdf.ln() with pdf.local_context(text_mode="CLIP"): pdf.cell(text="CLIP text mode") for r in range(0, 250, 2): # drawing concentric circles pdf.circle(x=130-r/2, y=70-r/2, radius=r) pdf.output("text-modes.pdf")

More examples from test_text_mode.py:

An optional markdown=True parameter can be passed to the cell() & multi_cell() methods in order to enable basic Markdown-like styling: **bold**, __italics__, --underlined--.

If the printable text contains a character sequence that would be incorrectly interpreted as a formatting marker, it can be escaped using \. The escape character works the same way it generally does in Python (see the example below).

Bold & italics require using dedicated fonts for each style.

For the standard fonts (Courier, Helvetica & Times), those dedicated fonts are configured by default:

Using other fonts means that their variants (bold, italics) must be registered using add_font with style="B" and style="I". Several unit tests in test/text/ demonstrate that:

.write_html() allows to set emphasis on text through the <b>, <i> and <u> tags:

**Examples:**

Example 1 (python):
```python
from fpdf import FPDF

pdf = FPDF()
pdf.add_page()
pdf.set_font("Times", size=36)
pdf.cell(text="This")
pdf.set_font(style="B")
pdf.cell(text="is")
pdf.set_font(style="I")
pdf.cell(text="a")
pdf.set_font(style="U")
pdf.cell(text="PDF")
pdf.output("style.pdf")
```

Example 2 (json):
```json
pdf = FPDF()
pdf.add_page()
pdf.set_font("Helvetica", size=8)
pdf.set_fill_color(255, 255, 0)
pdf.multi_cell(w=50, text=LOREM_IPSUM[:100], new_x="LEFT", fill=True)
pdf.ln()
pdf.set_stretching(150)
pdf.multi_cell(w=50, text=LOREM_IPSUM[:100], new_x="LEFT", fill=True)
```

Example 3 (json):
```json
pdf = FPDF()
pdf.add_page()
pdf.set_font("Helvetica", size=8)
pdf.set_fill_color(255, 255, 0)
pdf.multi_cell(w=150, text=LOREM_IPSUM[:200], new_x="LEFT", fill=True)
pdf.ln()
pdf.set_char_spacing(10)
pdf.multi_cell(w=150, text=LOREM_IPSUM[:200], new_x="LEFT", fill=True)
```

Example 4 (julia):
```julia
pdf = fpdf.FPDF()
    pdf.add_page()
    pdf.set_font("Helvetica", size=20)
    pdf.write(text="2")
    pdf.char_vpos = "SUP"
    pdf.write(text="56")
    pdf.char_vpos = "LINE"
    pdf.write(text=" more line text")
    pdf.char_vpos = "SUB"
    pdf.write(text="(idx)")
    pdf.char_vpos = "LINE"
    pdf.write(text=" end")
    pdf.ln()
    pdf.write(text="1234 + ")
    pdf.char_vpos = "NOM"
    pdf.write(text="5")
    pdf.char_vpos = "LINE"
    pdf.write(text="/")
    pdf.char_vpos = "DENOM"
    pdf.write(text="16")
    pdf.char_vpos = "LINE"
    pdf.write(text=" + 987 = x")
```

---

## Module fpdf.syntax

**URL:** https://py-pdf.github.io/fpdf2/fpdf/syntax.html

**Contents:**
- Module fpdf.syntax
- Functions
- Args
- Returns
- Raises
- Classes
  - Ancestors
  - Subclasses
  - Methods
  - Ancestors

Classes & functions that represent core elements of the PDF syntax

Most of what happens in a PDF happens in objects, which are formatted like so:

The first line says that this is the third object in the structure of the document.

There are 8 kinds of objects (Adobe Reference, 51):

The << in the second line and the >> in the line preceding endobj denote that it is a dictionary object. Dictionaries map Names to other objects.

Names are the strings preceded by /, valid Names do not have to start with a capital letter, they can be any ascii characters, # and two characters can escape non-printable ascii characters, described on page 57.

3 0 obj means what follows here is the third object, but the name Type (represented here by /Type) is mapped to an indirect object reference: 0 obj vs 0 R.

The structure of this data, in python/dict form, is thus:

Content streams are of the form:

The contents of this module are internal to fpdf2, and not part of the public API. They may change at any time without prior warning or any deprecation period, in non-backward-compatible ways.

Build the PDF Object associative map to serialize, based on a key-values dict. The property names are converted from snake_case to CamelCase, and prefixed with a slash character "/".

format dictionary as PDF dictionary

@param dict_: dictionary of values to render @param open_dict: string to open PDF dictionary @param close_dict: string to close PDF dictionary @param field_join: string to join fields with @param key_value_join: string to join key to value with @param has_empty_fields: whether or not to clear_empty_fields first.

format list of strings as PDF array

format an indirect PDF Object reference from its id number

Render a Python value as a PDF primitive type.

Container types (tuples/lists and dicts) are rendered recursively. This supports values of the type Name, str, bytes, numbers, booleans, list/tuple, and dict.

Any custom type can be passed in as long as it provides a serialize method that takes no arguments and returns a string. The primitive object is returned directly if it is an instance of the Raw class. Otherwise, The existence of the serialize method is checked before any other type checking is performed, so, for example, a dict subclass with a serialize method would be converted using its pdf_repr method rather than the built-in dict conversion process.

Raw-wrapped str of the PDF representation.

Wrap a series of draw commands (list of strings) in a local context marker, so that changes to draw style only apply to these commands.

Helper class that provides a standard way to create an ABC using inheritance.

Helper class that provides a standard way to create an ABC using inheritance.

str subclass signifying a PDF name, which are emitted differently than normal strings.

The type of the None singleton.

Built-in mutable sequence.

If no argument is given, the constructor creates a new empty list. The argument must be an iterable if specified.

Inherited from: PDFObject.content_stream

Subclasses can override this method to indicate the presence of a content stream

Inherited from: PDFObject.serialize

Serialize the PDF object as an obj<</>>endobj text block

Subclasses can override this method to indicate the presence of a content stream

Serialize the PDF object as an obj<</>>endobj text block

str(object='') -> str str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.

The type of the None singleton.

Setting this to False can reduce the encoded strings size, but then there can be a risk of badly encoding some unicode strings - cf. issue #458

Base class for protocol classes.

Protocol classes are defined as::

Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing).

See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as::

str subclass signifying raw data to be directly emitted to PDF without transformation.

**Examples:**

Example 1 (unknown):
```unknown
3 0 obj
<</Type /Page
/Parent 1 0 R
/Resources 2 0 R
/Contents 4 0 R>>
endobj
```

Example 2 (unknown):
```unknown
third_obj = {
  '/Type': '/Page'),
  '/Parent': iobj_ref(1),
  '/Resources': iobj_ref(2),
  '/Contents': iobj_ref(4),
}
```

Example 3 (unknown):
```unknown
4 0 obj
<</Filter /ASCIIHexDecode /Length 22>>
stream
68656c6c6f20776f726c64
endstream
endobj
```

Example 4 (python):
```python
def build_obj_dict(
    key_values: Dict[str, object],
    _security_handler: Optional["StandardSecurityHandler"] = None,
    _obj_id: Optional[int] = None,
) -> Dict[str, object]:
    """
    Build the PDF Object associative map to serialize, based on a key-values dict.
    The property names are converted from snake_case to CamelCase,
    and prefixed with a slash character "/".
    """

    obj_dict = {}
    for key, value in key_values.items():
        if (
            callable(value)
            or key.startswith("_")
            or key in ("id", "ref")
            or value is None
        ):
            continue
        # pylint: disable=redefined-loop-name
        if hasattr(value, "value"):  # e.g. Enum subclass
            value = value.value
        if isinstance(value, PDFObject):  # indirect object reference
            value = value.ref
        elif hasattr(value, "serialize"):  # pyright: ignore[reportUnknownArgumentType]
            # e.g. PDFArray, PDFString, Name, Destination, Action...
            value = value.serialize(
                _security_handler=_security_handler, _obj_id=_obj_id
            )
        elif isinstance(value, bool):
            value = str(value).lower()
        obj_dict[f"/{camel_case(key)}"] = value
    return obj_dict
```

---

## –ü—ñ–¥—Ä—É—á–Ω–∏–∫¬∂

**URL:** https://py-pdf.github.io/fpdf2/Tutorial-ua.html

**Contents:**
- –ü—ñ–¥—Ä—É—á–Ω–∏–∫¬∂
- –¢—É—Ç–æ—Ä—ñ–∞–ª 1 ‚Äî –ú—ñ–Ω—ñ–º–∞–ª—å–Ω–∏–π –ø—Ä–∏–∫–ª–∞–¥¬∂
- –¢—É—Ç–æ—Ä—ñ–∞–ª 2 ‚Äî –ö–æ–ª–æ–Ω—Ç–∏—Ç—É–ª–∏, —Ä–æ–∑—Ä–∏–≤ —Å—Ç–æ—Ä—ñ–Ω–∫–∏ —Ç–∞ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è¬∂
- –¢—É—Ç–æ—Ä—ñ–∞–ª 3 ‚Äî –†–æ–∑—Ä–∏–≤–∏ —Ä—è–¥–∫—ñ–≤ —ñ –∫–æ–ª—å–æ—Ä–∏¬∂
- –¢—É—Ç–æ—Ä—ñ–∞–ª 4 ‚Äî –î–µ–∫—ñ–ª—å–∫–∞ –∫–æ–ª–æ–Ω–æ–∫¬∂
- –¢—É—Ç–æ—Ä—ñ–∞–ª 5 ‚Äî –°—Ç–≤–æ—Ä–µ–Ω–Ω—è —Ç–∞–±–ª–∏—Ü—å¬∂
- –¢—É—Ç–æ—Ä—ñ–∞–ª 6 ‚Äî –°—Ç–≤–æ—Ä–µ–Ω–Ω—è –ø–æ—Å–∏–ª–∞–Ω—å —ñ –∑–º—ñ—à—É–≤–∞–Ω–Ω—è —Å—Ç–∏–ª—ñ–≤ —Ç–µ–∫—Å—Ç—É¬∂
- –¢—É—Ç–æ—Ä—ñ–∞–ª 7 ‚Äî –°—Ç–≤–æ—Ä–µ–Ω–Ω—è –¥–æ–∫—É–º–µ–Ω—Ç—ñ–≤ PDF/A¬∂
  - –°—Ç–∞–Ω–¥–∞—Ä—Ç–∏ PDF/A¬∂
  - –ö–ª–∞—Å–∏ –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–æ—Å—Ç—ñ¬∂

–ü–æ–≤–Ω–∞ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü—ñ—è –º–µ—Ç–æ–¥—ñ–≤: fpdf.FPDF ‚Äì –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü—ñ—è API

–ü–æ—á–Ω–µ–º–æ –∑ –∫–ª–∞—Å–∏—á–Ω–æ–≥–æ –ø—Ä–∏–∫–ª–∞–¥—É:

–ü—ñ—Å–ª—è –ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è –±—ñ–±–ª—ñ–æ—Ç–µ–∫–∏ –º–∏ —Å—Ç–≤–æ—Ä—é—î–º–æ –æ–±‚Äô—î–∫—Ç FPDF. –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä FPDF —Ç—É—Ç –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è –∑—ñ –∑–Ω–∞—á–µ–Ω–Ω—è–º–∏ –∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º: —Å—Ç–æ—Ä—ñ–Ω–∫–∏ —Ñ–æ—Ä–º–∞—Ç—É A4, –æ—Ä—ñ—î–Ω—Ç–∞—Ü—ñ—è ‚Äî –∫–Ω–∏–∂–∫–æ–≤–∞ (portrait), –æ–¥–∏–Ω–∏—Ü—è –≤–∏–º—ñ—Ä—É ‚Äî –º—ñ–ª—ñ–º–µ—Ç—Ä–∏. –¶–µ –º–æ–∂–Ω–∞ –±—É–ª–æ –± –∑–∞–¥–∞—Ç–∏ —è–≤–Ω–æ —Ç–∞–∫:

–ú–æ–∂–Ω–∞ –≤—Å—Ç–∞–Ω–æ–≤–∏—Ç–∏ –∞–ª—å–±–æ–º–Ω—É –æ—Ä—ñ—î–Ω—Ç–∞—Ü—ñ—é —Å—Ç–æ—Ä—ñ–Ω–∫–∏ (L) –∞–±–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞—Ç–∏ —ñ–Ω—à—ñ —Ñ–æ—Ä–º–∞—Ç–∏ —Å—Ç–æ—Ä—ñ–Ω–æ–∫ (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, Letter —ñ Legal) —Ç–∞ –æ–¥–∏–Ω–∏—Ü—ñ –≤–∏–º—ñ—Ä—É (pt, cm, in).

–ü–æ–∫–∏ —â–æ —Å—Ç–æ—Ä—ñ–Ω–æ–∫ –Ω–µ–º–∞—î, —Ç–æ–∂ —Ç—Ä–µ–±–∞ –¥–æ–¥–∞—Ç–∏ –æ–¥–Ω—É –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é add_page. –ü–æ—á–∞—Ç–æ–∫ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç ‚Äî —É –≤–µ—Ä—Ö–Ω—å–æ–º—É –ª—ñ–≤–æ–º—É –∫—É—Ç—ñ, –ø–æ—Ç–æ—á–Ω–∞ –ø–æ–∑–∏—Ü—ñ—è –∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º —Ä–æ–∑–º—ñ—â–µ–Ω–∞ –Ω–∞ –≤—ñ–¥—Å—Ç–∞–Ω—ñ 1 —Å–º –≤—ñ–¥ –∫—Ä–∞—ó–≤; –ø–æ–ª—è –º–æ–∂–Ω–∞ –∑–º—ñ–Ω–∏—Ç–∏ –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é set_margins.

–ü–µ—Ä—à –Ω—ñ–∂ –¥—Ä—É–∫—É–≤–∞—Ç–∏ —Ç–µ–∫—Å—Ç, –æ–±–æ–≤‚Äô—è–∑–∫–æ–≤–æ –ø–æ—Ç—Ä—ñ–±–Ω–æ –æ–±—Ä–∞—Ç–∏ —à—Ä–∏—Ñ—Ç –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é set_font, —ñ–Ω–∞–∫—à–µ –¥–æ–∫—É–º–µ–Ω—Ç –±—É–¥–µ –Ω–µ–∫–æ—Ä–µ–∫—Ç–Ω–∏–º. –û–±–∏—Ä–∞—î–º–æ Helvetica –Ω–∞–ø—ñ–≤–∂–∏—Ä–Ω–∏–π —Ä–æ–∑–º—ñ—Ä—É 16:

–ú–æ–∂–Ω–∞ –±—É–ª–æ –± –≤–∫–∞–∑–∞—Ç–∏ –∫—É—Ä—Å–∏–≤ —á–µ—Ä–µ–∑ I, –ø—ñ–¥–∫—Ä–µ—Å–ª–µ–Ω–Ω—è ‚Äî —á–µ—Ä–µ–∑ U, –∞–±–æ –∑–≤–∏—á–∞–π–Ω–∏–π —à—Ä–∏—Ñ—Ç ‚Äî –ø–æ—Ä–æ–∂–Ω—ñ–º —Ä—è–¥–∫–æ–º (–∞–±–æ –±—É–¥—å-—è–∫–æ—é –∫–æ–º–±—ñ–Ω–∞—Ü—ñ—î—é). –ó–≤–µ—Ä–Ω—ñ—Ç—å —É–≤–∞–≥—É, —â–æ —Ä–æ–∑–º—ñ—Ä —à—Ä–∏—Ñ—Ç—É –∑–∞–¥–∞—î—Ç—å—Å—è –≤ –ø—É–Ω–∫—Ç–∞—Ö, –∞ –Ω–µ –≤ –º—ñ–ª—ñ–º–µ—Ç—Ä–∞—Ö (—á–∏ —ñ–Ω—à–∏—Ö –æ–¥–∏–Ω–∏—Ü—è—Ö –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞); —Ü–µ —î–¥–∏–Ω–∏–π –≤–∏–Ω—è—Ç–æ–∫. –Ü–Ω—à—ñ –≤–±—É–¥–æ–≤–∞–Ω—ñ —à—Ä–∏—Ñ—Ç–∏: Times, Courier, Symbol —Ç–∞ ZapfDingbats.

–¢–µ–ø–µ—Ä –º–æ–∂–µ–º–æ –≤–∏–≤–µ—Å—Ç–∏ ¬´–∫–æ–º—ñ—Ä–∫—É¬ª –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é cell. –ö–æ–º—ñ—Ä–∫–∞ ‚Äî —Ü–µ –ø—Ä—è–º–æ–∫—É—Ç–Ω–∞ –æ–±–ª–∞—Å—Ç—å, –∑–∞ –ø–æ—Ç—Ä–µ–±–∏ –∑ —Ä–∞–º–∫–æ—é, —â–æ –º—ñ—Å—Ç–∏—Ç—å —Ç–µ–∫—Å—Ç. –í–æ–Ω–∞ —Ä–µ–Ω–¥–µ—Ä–∏—Ç—å—Å—è —É –ø–æ—Ç–æ—á–Ω—ñ–π –ø–æ–∑–∏—Ü—ñ—ó. –ú–∏ –∑–∞–¥–∞—î–º–æ —ó—ó —Ä–æ–∑–º—ñ—Ä–∏, —Ç–µ–∫—Å—Ç (–≤–∏—Ä—ñ–≤–Ω—è–Ω–∏–π –ø–æ —Ü–µ–Ω—Ç—Ä—É –∞–±–æ —ñ–Ω–∞–∫—à–µ), —á–∏ –ø–æ—Ç—Ä—ñ–±–Ω–æ –º–∞–ª—é–≤–∞—Ç–∏ —Ä–∞–º–∫—É, –∞ —Ç–∞–∫–æ–∂ –∫—É–¥–∏ –º–∞—î –∑–º—ñ—Å—Ç–∏—Ç–∏—Å—è –ø–æ—Ç–æ—á–Ω–∞ –ø–æ–∑–∏—Ü—ñ—è –ø—ñ—Å–ª—è –≤–∏–≤–µ–¥–µ–Ω–Ω—è (–ø—Ä–∞–≤–æ—Ä—É—á, –≤–Ω–∏–∑ –∞–±–æ –Ω–∞ –ø–æ—á–∞—Ç–æ–∫ –Ω–∞—Å—Ç—É–ø–Ω–æ–≥–æ —Ä—è–¥–∫–∞). –©–æ–± –¥–æ–¥–∞—Ç–∏ —Ä–∞–º–∫—É, –∑—Ä–æ–±–∏–º–æ —Ç–∞–∫:

–©–æ–± –¥–æ–¥–∞—Ç–∏ –ø–æ—Ä—É—á –Ω–æ–≤—É –∫–æ–º—ñ—Ä–∫—É –∑ —Ç–µ–∫—Å—Ç–æ–º, –≤–∏—Ä—ñ–≤–Ω—è–Ω–∏–º –ø–æ —Ü–µ–Ω—Ç—Ä—É, —ñ –ø–µ—Ä–µ–π—Ç–∏ –Ω–∞ –Ω–æ–≤–∏–π —Ä—è–¥–æ–∫, –∑—Ä–æ–±–∏–º–æ —Ç–∞–∫:

–ü—Ä–∏–º—ñ—Ç–∫–∞: —Ä–æ–∑—Ä–∏–≤ —Ä—è–¥–∫–∞ —Ç–∞–∫–æ–∂ –º–æ–∂–Ω–∞ –∑—Ä–æ–±–∏—Ç–∏ –º–µ—Ç–æ–¥–æ–º ln. –¶–µ–π –º–µ—Ç–æ–¥ –¥–æ–¥–∞—Ç–∫–æ–≤–æ –¥–æ–∑–≤–æ–ª—è—î –≤–∫–∞–∑–∞—Ç–∏ –≤–∏—Å–æ—Ç—É —Ä–æ–∑—Ä–∏–≤—É.

–ù–∞—Ä–µ—à—Ç—ñ, –¥–æ–∫—É–º–µ–Ω—Ç –∑–∞–∫—Ä–∏–≤–∞—î—Ç—å—Å—è –π –∑–±–µ—Ä—ñ–≥–∞—î—Ç—å—Å—è –∑–∞ –≤–∫–∞–∑–∞–Ω–∏–º —à–ª—è—Ö–æ–º —Ñ–∞–π–ª—É –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é output. –Ø–∫—â–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏ –Ω–µ –ø–µ—Ä–µ–¥–∞–Ω–æ, output() –ø–æ–≤–µ—Ä—Ç–∞—î PDF —è–∫ –±—É—Ñ–µ—Ä bytearray.

–û—Å—å –ø—Ä–∏–∫–ª–∞–¥ –Ω–∞ –¥–≤—ñ —Å—Ç–æ—Ä—ñ–Ω–∫–∏ –∑ –≤–µ—Ä—Ö–Ω—ñ–º/–Ω–∏–∂–Ω—ñ–º –∫–æ–ª–æ–Ω—Ç–∏—Ç—É–ª–∞–º–∏ —Ç–∞ –ª–æ–≥–æ—Ç–∏–ø–æ–º:

–£ —Ü—å–æ–º—É –ø—Ä–∏–∫–ª–∞–¥—ñ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—é—Ç—å—Å—è –º–µ—Ç–æ–¥–∏ header —ñ footer –¥–ª—è –æ–±—Ä–æ–±–∫–∏ –∫–æ–ª–æ–Ω—Ç–∏—Ç—É–ª—ñ–≤. –í–æ–Ω–∏ –≤–∏–∫–ª–∏–∫–∞—é—Ç—å—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ. –¶—ñ –º–µ—Ç–æ–¥–∏ –≤–∂–µ —î –≤ –∫–ª–∞—Å—ñ FPDF, –∞–ª–µ –Ω—ñ—á–æ–≥–æ –Ω–µ —Ä–æ–±–ª—è—Ç—å, —Ç–æ–º—É –º–∏ —Ä–æ–∑—à–∏—Ä—é—î–º–æ –∫–ª–∞—Å —ñ –ø–µ—Ä–µ–≤–∏–∑–Ω–∞—á–∞—î–º–æ —ó—Ö.

–õ–æ–≥–æ—Ç–∏–ø –≤–∏–≤–æ–¥–∏—Ç—å—Å—è –º–µ—Ç–æ–¥–æ–º image —ñ–∑ –∑–∞–∑–Ω–∞—á–µ–Ω–Ω—è–º –π–æ–≥–æ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –≤–µ—Ä—Ö–Ω—å–æ–≥–æ –ª—ñ–≤–æ–≥–æ –∫—É—Ç–∞ —Ç–∞ —à–∏—Ä–∏–Ω–∏. –í–∏—Å–æ—Ç–∞ –æ–±—á–∏—Å–ª—é—î—Ç—å—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ, —â–æ–± –∑–±–µ—Ä–µ–≥—Ç–∏ –ø—Ä–æ–ø–æ—Ä—Ü—ñ—ó –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è.

–©–æ–± –≤–∏–≤–µ—Å—Ç–∏ –Ω–æ–º–µ—Ä —Å—Ç–æ—Ä—ñ–Ω–∫–∏, —à–∏—Ä–∏–Ω—É –∫–æ–º—ñ—Ä–∫–∏ –∑–∞–¥–∞—î–º–æ –Ω—É–ª—å–æ–≤–æ—é. –¶–µ –æ–∑–Ω–∞—á–∞—î, —â–æ –∫–æ–º—ñ—Ä–∫–∞ —Ä–æ–∑—à–∏—Ä—é—î—Ç—å—Å—è –¥–æ –ø—Ä–∞–≤–æ–≥–æ –ø–æ–ª—è —Å—Ç–æ—Ä—ñ–Ω–∫–∏; —Ü–µ –∑—Ä—É—á–Ω–æ –¥–ª—è —Ü–µ–Ω—Ç—Ä—É–≤–∞–Ω–Ω—è —Ç–µ–∫—Å—Ç—É. –ü–æ—Ç–æ—á–Ω–∏–π –Ω–æ–º–µ—Ä —Å—Ç–æ—Ä—ñ–Ω–∫–∏ –ø–æ–≤–µ—Ä—Ç–∞—î –º–µ—Ç–æ–¥ page_no; –∞ –∑–∞–≥–∞–ª—å–Ω—É –∫—ñ–ª—å–∫—ñ—Å—Ç—å —Å—Ç–æ—Ä—ñ–Ω–æ–∫ –æ—Ç—Ä–∏–º—É—é—Ç—å –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é —Å–ø–µ—Ü—ñ–∞–ª—å–Ω–æ–≥–æ –∑–Ω–∞—á–µ–Ω–Ω—è {nb}, —è–∫–µ –±—É–¥–µ –ø—ñ–¥—Å—Ç–∞–≤–ª–µ–Ω–µ –ø—ñ–¥ —á–∞—Å –∑–∞–∫—Ä–∏—Ç—Ç—è –¥–æ–∫—É–º–µ–Ω—Ç–∞ (—Ü–µ –∑–Ω–∞—á–µ–Ω–Ω—è –º–æ–∂–Ω–∞ –∑–º—ñ–Ω–∏—Ç–∏ –º–µ—Ç–æ–¥–æ–º alias_nb_pages()). –ó–≤–µ—Ä–Ω—ñ—Ç—å —É–≤–∞–≥—É –Ω–∞ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è –º–µ—Ç–æ–¥—É set_y, —è–∫–∏–π –¥–æ–∑–≤–æ–ª—è—î –≤—Å—Ç–∞–Ω–æ–≤–∏—Ç–∏ –ø–æ–∑–∏—Ü—ñ—é –≤ –∞–±—Å–æ–ª—é—Ç–Ω–æ–º—É –º—ñ—Å—Ü—ñ –Ω–∞ —Å—Ç–æ—Ä—ñ–Ω—Ü—ñ ‚Äî –≤—ñ–¥ –≤–µ—Ä—Ö—É –∞–±–æ –≤—ñ–¥–Ω–∏–∑—É.

–¢—É—Ç —Ç–∞–∫–æ–∂ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–æ —Ü—ñ–∫–∞–≤—É –º–æ–∂–ª–∏–≤—ñ—Å—Ç—å: –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω—ñ —Ä–æ–∑—Ä–∏–≤–∏ —Å—Ç–æ—Ä—ñ–Ω–∫–∏. –©–æ–π–Ω–æ –∫–æ–º—ñ—Ä–∫–∞ –ø–µ—Ä–µ—Ö–æ–¥–∏—Ç—å —á–µ—Ä–µ–∑ –º–µ–∂—É —Å—Ç–æ—Ä—ñ–Ω–∫–∏ (—Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ –∑–∞ 2 —Å–∞–Ω—Ç–∏–º–µ—Ç—Ä–∏ –≤—ñ–¥ –Ω–∏–∑—É), –≤–∏–∫–æ–Ω—É—î—Ç—å—Å—è —Ä–æ–∑—Ä–∏–≤, –∞ —à—Ä–∏—Ñ—Ç –≤—ñ–¥–Ω–æ–≤–ª—é—î—Ç—å—Å—è. –•–æ—á–∞ –≤ –∫–æ–ª–æ–Ω—Ç–∏—Ç—É–ª–∞—Ö –æ–±—Ä–∞–Ω–æ –≤–ª–∞—Å–Ω–∏–π —à—Ä–∏—Ñ—Ç (helvetica), –æ—Å–Ω–æ–≤–Ω–∏–π —Ç–µ–∫—Å—Ç –ø—Ä–æ–¥–æ–≤–∂—É—î—Ç—å—Å—è –∑—ñ —à—Ä–∏—Ñ—Ç–æ–º Times. –¶–µ–π –º–µ—Ö–∞–Ω—ñ–∑–º –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ–≥–æ –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è —Ç–∞–∫–æ–∂ —Å—Ç–æ—Å—É—î—Ç—å—Å—è –∫–æ–ª—å–æ—Ä—ñ–≤ —ñ —Ç–æ–≤—â–∏–Ω–∏ –ª—ñ–Ω—ñ–π. –ú–µ–∂—É, —â–æ —ñ–Ω—ñ—Ü—ñ—é—î —Ä–æ–∑—Ä–∏–≤–∏ —Å—Ç–æ—Ä—ñ–Ω–æ–∫, –∑–∞–¥–∞—é—Ç—å –º–µ—Ç–æ–¥–æ–º set_auto_page_break.

–ü—Ä–æ–¥–æ–≤–∂–∏–º–æ –ø—Ä–∏–∫–ª–∞–¥–æ–º, —â–æ –¥—Ä—É–∫—É—î –≤–∏—Ä—ñ–≤–Ω—è–Ω—ñ –ø–æ —à–∏—Ä–∏–Ω—ñ –∞–±–∑–∞—Ü–∏. –í—ñ–Ω —Ç–∞–∫–æ–∂ –¥–µ–º–æ–Ω—Å—Ç—Ä—É—î —Ä–æ–±–æ—Ç—É –∑ –∫–æ–ª—å–æ—Ä–∞–º–∏.

–ú–µ—Ç–æ–¥ get_string_width –¥–æ–∑–≤–æ–ª—è—î –≤–∏–∑–Ω–∞—á–∏—Ç–∏ –¥–æ–≤–∂–∏–Ω—É —Ä—è–¥–∫–∞ –≤ –ø–æ—Ç–æ—á–Ω–æ–º—É —à—Ä–∏—Ñ—Ç—ñ ‚Äî —Ç—É—Ç —Ü–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è, —â–æ–± —Ä–æ–∑—Ä–∞—Ö—É–≤–∞—Ç–∏ –ø–æ–∑–∏—Ü—ñ—é –π —à–∏—Ä–∏–Ω—É —Ä–∞–º–∫–∏ –Ω–∞–≤–∫–æ–ª–æ –∑–∞–≥–æ–ª–æ–≤–∫–∞. –î–∞–ª—ñ –≤—Å—Ç–∞–Ω–æ–≤–ª—é—î–º–æ –∫–æ–ª—å–æ—Ä–∏ (—á–µ—Ä–µ–∑ set_draw_color, set_fill_color —ñ set_text_color) —Ç–∞ —Ç–æ–≤—â–∏–Ω—É –ª—ñ–Ω—ñ—ó 1 –º–º (–ø—Ä–æ—Ç–∏ 0,2 –∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º) –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é set_line_width. –ù–∞—Ä–µ—à—Ç—ñ, –≤–∏–≤–æ–¥–∏–º–æ –∫–æ–º—ñ—Ä–∫—É (–æ—Å—Ç–∞–Ω–Ω—ñ–π –ø–∞—Ä–∞–º–µ—Ç—Ä, –≤—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–π —É True, –æ–∑–Ω–∞—á–∞—î, —â–æ —Ç–ª–æ —Ç—Ä–µ–±–∞ –∑–∞—Ñ–∞—Ä–±—É–≤–∞—Ç–∏).

–î–ª—è –¥—Ä—É–∫—É –∞–±–∑–∞—Ü—ñ–≤ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è –º–µ—Ç–æ–¥ multi_cell. –¢–µ–∫—Å—Ç –∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º –≤–∏—Ä—ñ–≤–Ω—é—î—Ç—å—Å—è –ø–æ —à–∏—Ä–∏–Ω—ñ. –ö–æ–∂–Ω–æ–≥–æ —Ä–∞–∑—É, –∫–æ–ª–∏ —Ä—è–¥–æ–∫ —Å—è–≥–∞—î –ø—Ä–∞–≤–æ—ó –º–µ–∂—ñ –∫–æ–º—ñ—Ä–∫–∏ –∞–±–æ –∑—É—Å—Ç—Ä—ñ—á–∞—î—Ç—å—Å—è —Å–∏–º–≤–æ–ª –ø–µ—Ä–µ–≤–µ–¥–µ–Ω–Ω—è —Ä—è–¥–∫–∞ (\n), –≤–∏–∫–æ–Ω—É—î—Ç—å—Å—è —Ä–æ–∑—Ä–∏–≤ —Ä—è–¥–∫–∞, —ñ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ —Å—Ç–≤–æ—Ä—é—î—Ç—å—Å—è –Ω–æ–≤–∞ –∫–æ–º—ñ—Ä–∫–∞ –ø—ñ–¥ –ø–æ—Ç–æ—á–Ω–æ—é. –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–∏–π —Ä–æ–∑—Ä–∏–≤ –≤—ñ–¥–±—É–≤–∞—î—Ç—å—Å—è –≤ –ø–æ–∑–∏—Ü—ñ—ó –Ω–∞–π–±–ª–∏–∂—á–æ–≥–æ –ø—Ä–æ–±—ñ–ª—É –∞–±–æ ¬´–º‚Äô—è–∫–æ–≥–æ –ø–µ—Ä–µ–Ω–æ—Å—É¬ª (\u00ad) –ø–µ—Ä–µ–¥ –ø—Ä–∞–≤–æ—é –º–µ–∂–µ—é. –ü—ñ–¥ —á–∞—Å –ø–µ—Ä–µ–Ω–æ—Å—É —Ä—è–¥–∫–∞ ¬´–º‚Äô—è–∫–∏–π –ø–µ—Ä–µ–Ω–æ—Å¬ª –±—É–¥–µ –∑–∞–º—ñ–Ω–µ–Ω–æ –Ω–∞ –∑–≤–∏—á–∞–π–Ω–∏–π –¥–µ—Ñ—ñ—Å; —ñ–Ω–∞–∫—à–µ –≤—ñ–Ω —ñ–≥–Ω–æ—Ä—É—î—Ç—å—Å—è.

–ó–∞–¥–∞—é—Ç—å—Å—è –¥–≤—ñ –≤–ª–∞—Å—Ç–∏–≤–æ—Å—Ç—ñ –¥–æ–∫—É–º–µ–Ω—Ç–∞: –∑–∞–≥–æ–ª–æ–≤–æ–∫ (set_title) —Ç–∞ –∞–≤—Ç–æ—Ä (set_author). –ü–µ—Ä–µ–≥–ª—è–Ω—É—Ç–∏ –≤–ª–∞—Å—Ç–∏–≤–æ—Å—Ç—ñ –º–æ–∂–Ω–∞ –¥–≤–æ–º–∞ —Å–ø–æ—Å–æ–±–∞–º–∏. –ü–µ—Ä—à–∏–π ‚Äî –≤—ñ–¥–∫—Ä–∏—Ç–∏ –¥–æ–∫—É–º–µ–Ω—Ç —É Acrobat Reader, –ø–µ—Ä–µ–π—Ç–∏ –≤ –º–µ–Ω—é File —ñ –æ–±—Ä–∞—Ç–∏ Document Properties. –î—Ä—É–≥–∏–π ‚Äî –¥–æ—Å—Ç—É–ø–Ω–∏–π —Ç–∞–∫–æ–∂ —ñ–∑ –ø–ª–∞–≥—ñ–Ω–∞: –Ω–∞—Ç–∏—Å–Ω—É—Ç–∏ –ø—Ä–∞–≤–æ—é –∫–Ω–æ–ø–∫–æ—é —Ç–∞ –≤–∏–±—Ä–∞—Ç–∏ Document Properties.

–¶–µ–π –ø—Ä–∏–∫–ª–∞–¥ ‚Äî –≤–∞—Ä—ñ–∞–Ω—Ç –ø–æ–ø–µ—Ä–µ–¥–Ω—å–æ–≥–æ, –¥–µ–º–æ–Ω—Å—Ç—Ä—É—î, —è–∫ —Ä–æ–∑–º—ñ—Å—Ç–∏—Ç–∏ —Ç–µ–∫—Å—Ç —É –∫—ñ–ª—å–∫–æ—Ö –∫–æ–ª–æ–Ω–∫–∞—Ö.

–ö–ª—é—á–æ–≤–∞ –≤—ñ–¥–º—ñ–Ω–Ω—ñ—Å—Ç—å –≤—ñ–¥ –ø–æ–ø–µ—Ä–µ–¥–Ω—å–æ–≥–æ —Ç—É—Ç–æ—Ä—ñ–∞–ª—É ‚Äî –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è –º–µ—Ç–æ–¥—É text_columns. –í—ñ–Ω –∑–±–∏—Ä–∞—î –≤–µ—Å—å —Ç–µ–∫—Å—Ç (–º–æ–∂–ª–∏–≤–æ, –ø–æ —á–∞—Å—Ç–∏–Ω–∞—Ö) —ñ —Ä–æ–∑–ø–æ–¥—ñ–ª—è—î –π–æ–≥–æ –Ω–∞ –≤–∫–∞–∑–∞–Ω—É –∫—ñ–ª—å–∫—ñ—Å—Ç—å –∫–æ–ª–æ–Ω–æ–∫, –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –≤—Å—Ç–∞–≤–ª—è—é—á–∏ —Ä–æ–∑—Ä–∏–≤–∏ —Å—Ç–æ—Ä—ñ–Ω–æ–∫ –∑–∞ –ø–æ—Ç—Ä–µ–±–∏. –ó–≤–µ—Ä–Ω—ñ—Ç—å —É–≤–∞–≥—É: –¥–æ–∫–∏ –µ–∫–∑–µ–º–ø–ª—è—Ä TextColumns –∞–∫—Ç–∏–≤–Ω–∏–π —è–∫ –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω–∏–π –º–µ–Ω–µ–¥–∂–µ—Ä, —Å—Ç–∏–ª—ñ —Ç–µ–∫—Å—Ç—É —Ç–∞ —ñ–Ω—à—ñ –≤–ª–∞—Å—Ç–∏–≤–æ—Å—Ç—ñ —à—Ä–∏—Ñ—Ç—ñ–≤ –º–æ–∂–Ω–∞ –∑–º—ñ–Ω—é–≤–∞—Ç–∏ ‚Äî —Ü—ñ –∑–º—ñ–Ω–∏ –±—É–¥—É—Ç—å –æ–±–º–µ–∂–µ–Ω—ñ —Ü–∏–º –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º. –ü—ñ—Å–ª—è –π–æ–≥–æ –∑–∞–∫—Ä–∏—Ç—Ç—è –ø–æ–ø–µ—Ä–µ–¥–Ω—ñ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏ –±—É–¥–µ –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–æ.

–£ —Ü—å–æ–º—É —Ç—É—Ç–æ—Ä—ñ–∞–ª—ñ –ø–æ—è—Å–Ω—é—î—Ç—å—Å—è, —è–∫ —Å—Ç–≤–æ—Ä–∏—Ç–∏ –¥–≤—ñ —Ä—ñ–∑–Ω—ñ —Ç–∞–±–ª–∏—Ü—ñ, —â–æ–± –ø—Ä–æ–¥–µ–º–æ–Ω—Å—Ç—Ä—É–≤–∞—Ç–∏, —á–æ–≥–æ –º–æ–∂–Ω–∞ –¥–æ—Å—è–≥—Ç–∏ –ø—Ä–æ—Å—Ç–∏–º–∏ –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è–º–∏.

–û—Ç—Ä–∏–º–∞–Ω–∏–π PDF ‚Äî CSV-–¥–∞–Ω—ñ –ø—Ä–æ –∫—Ä–∞—ó–Ω–∏

–ü–µ—Ä—à–∏–π –ø—Ä–∏–∫–ª–∞–¥ —Ä–µ–∞–ª—ñ–∑–æ–≤–∞–Ω–æ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –ø—Ä–æ—Å—Ç–∏–º —Å–ø–æ—Å–æ–±–æ–º ‚Äî –ø–µ—Ä–µ–¥–∞—é—á–∏ –¥–∞–Ω—ñ –≤ FPDF.table(). –†–µ–∑—É–ª—å—Ç–∞—Ç –µ–ª–µ–º–µ–Ω—Ç–∞—Ä–Ω–∏–π, –∞–ª–µ –æ—Ç—Ä–∏–º—É—î—Ç—å—Å—è –¥—É–∂–µ —à–≤–∏–¥–∫–æ.

–î—Ä—É–≥–∞ —Ç–∞–±–ª–∏—Ü—è –º—ñ—Å—Ç–∏—Ç—å –ø–æ–∫—Ä–∞—â–µ–Ω–Ω—è: –∫–æ–ª—å–æ—Ä–∏, –æ–±–º–µ–∂–µ–Ω—É —à–∏—Ä–∏–Ω—É —Ç–∞–±–ª–∏—Ü—ñ, –∑–º–µ–Ω—à–µ–Ω—É –≤–∏—Å–æ—Ç—É —Ä—è–¥–∫—ñ–≤, –≤–∏—Ä—ñ–≤–Ω—é–≤–∞–Ω–Ω—è –∑–∞–≥–æ–ª–æ–≤–∫—ñ–≤ –ø–æ —Ü–µ–Ω—Ç—Ä—É, –∫–æ–ª–æ–Ω–∫–∏ –∑ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—Ü—å–∫–∏–º–∏ —à–∏—Ä–∏–Ω–∞–º–∏, –≤–∏—Ä—ñ–≤–Ω—é–≤–∞–Ω–Ω—è —á–∏—Å–µ–ª –ø—Ä–∞–≤–æ—Ä—É—á... –ö—Ä—ñ–º —Ç–æ–≥–æ, –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ñ –ª—ñ–Ω—ñ—ó –ø—Ä–∏–±—Ä–∞–Ω–æ. –¶—å–æ–≥–æ –¥–æ—Å—è–≥–Ω—É—Ç–æ –≤–∏–±–æ—Ä–æ–º –∑–Ω–∞—á–µ–Ω–Ω—è borders_layout –∑-–ø–æ–º—ñ–∂ –¥–æ—Å—Ç—É–ø–Ω–∏—Ö —É TableBordersLayout.

–£ —Ü—å–æ–º—É —Ç—É—Ç–æ—Ä—ñ–∞–ª—ñ –ø–æ–∫–∞–∑–∞–Ω–æ –∫—ñ–ª—å–∫–∞ —Å–ø–æ—Å–æ–±—ñ–≤ –≤—Å—Ç–∞–≤–∫–∏ –ø–æ—Å–∏–ª–∞–Ω—å —É PDF-–¥–æ–∫—É–º–µ–Ω—Ç, –∞ —Ç–∞–∫–æ–∂ –¥–æ–¥–∞–≤–∞–Ω–Ω—è –ø–æ—Å–∏–ª–∞–Ω—å –Ω–∞ –∑–æ–≤–Ω—ñ—à–Ω—ñ —Ä–µ—Å—É—Ä—Å–∏.

–¢–∞–∫–æ–∂ –±—É–¥–µ –ø–æ–∫–∞–∑–∞–Ω–æ –∫—ñ–ª—å–∫–∞ —Å–ø–æ—Å–æ–±—ñ–≤ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è —Ä—ñ–∑–Ω–∏—Ö —Å—Ç–∏–ª—ñ–≤ —Ç–µ–∫—Å—Ç—É (–Ω–∞–ø—ñ–≤–∂–∏—Ä–Ω–∏–π, –∫—É—Ä—Å–∏–≤, –ø—ñ–¥–∫—Ä–µ—Å–ª–µ–Ω–∏–π) –≤ –æ–¥–Ω–æ–º—É —Ñ—Ä–∞–≥–º–µ–Ω—Ç—ñ.

–û—Ç—Ä–∏–º–∞–Ω–∏–π PDF ‚Äî fpdf2-logo

–ù–æ–≤–∏–π –º–µ—Ç–æ–¥, —â–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è —Ç—É—Ç –¥–ª—è –≤–∏–≤–µ–¥–µ–Ω–Ω—è —Ç–µ–∫—Å—Ç—É, ‚Äî write(). –í—ñ–Ω –¥—É–∂–µ —Å—Ö–æ–∂–∏–π –Ω–∞ multi_cell(), –∞–ª–µ –∑ —Ç–∞–∫–∏–º–∏ –∫–ª—é—á–æ–≤–∏–º–∏ –≤—ñ–¥–º—ñ–Ω–Ω–æ—Å—Ç—è–º–∏:

–¢–æ–∂ –º–µ—Ç–æ–¥ –¥–æ–∑–≤–æ–ª—è—î –Ω–∞–ø–∏—Å–∞—Ç–∏ —Ñ—Ä–∞–≥–º–µ–Ω—Ç —Ç–µ–∫—Å—Ç—É, –∑–º—ñ–Ω–∏—Ç–∏ —Å—Ç–∏–ª—å —à—Ä–∏—Ñ—Ç—É —ñ –ø—Ä–æ–¥–æ–≤–∂–∏—Ç–∏ –∑ —Ç–æ–≥–æ —Å–∞–º–æ–≥–æ –º—ñ—Å—Ü—è. –ó —ñ–Ω—à–æ–≥–æ –±–æ–∫—É, –≥–æ–ª–æ–≤–Ω–∏–π –Ω–µ–¥–æ–ª—ñ–∫ –ø–æ–ª—è–≥–∞—î –≤ —Ç–æ–º—É, —â–æ –Ω–µ –º–æ–∂–Ω–∞ –≤–∏—Ä—ñ–≤–Ω—è—Ç–∏ —Ç–µ–∫—Å—Ç –ø–æ —à–∏—Ä–∏–Ω—ñ, —è–∫ —Ü–µ —Ä–æ–±–∏—Ç—å –º–µ—Ç–æ–¥ multi_cell().

–ù–∞ –ø–µ—Ä—à—ñ–π —Å—Ç–æ—Ä—ñ–Ω—Ü—ñ –ø—Ä–∏–∫–ª–∞–¥—É –º–∏ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–ª–∏ write() —Å–∞–º–µ –∑ —Ü—ñ—î—é –º–µ—Ç–æ—é. –ü–æ—á–∞—Ç–æ–∫ —Ä–µ—á–µ–Ω–Ω—è –Ω–∞–¥—Ä—É–∫–æ–≤–∞–Ω–æ –∑–≤–∏—á–∞–π–Ω–∏–º —Å—Ç–∏–ª–µ–º, –ø–æ—Ç—ñ–º –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é set_font() –ø–µ—Ä–µ–º–∫–Ω—É–ª–∏—Å—è –Ω–∞ –ø—ñ–¥–∫—Ä–µ—Å–ª–µ–Ω–Ω—è —ñ –∑–∞–≤–µ—Ä—à–∏–ª–∏ —Ä–µ—á–µ–Ω–Ω—è.

–©–æ–± –¥–æ–¥–∞—Ç–∏ –≤–Ω—É—Ç—Ä—ñ—à–Ω—î –ø–æ—Å–∏–ª–∞–Ω–Ω—è –Ω–∞ –¥—Ä—É–≥—É —Å—Ç–æ—Ä—ñ–Ω–∫—É, –º–∏ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–ª–∏ –º–µ—Ç–æ–¥ add_link(), —è–∫–∏–π —Å—Ç–≤–æ—Ä—é—î –∫–ª—ñ–∫–∞–±–µ–ª—å–Ω—É –æ–±–ª–∞—Å—Ç—å (–º–∏ –Ω–∞–∑–≤–∞–ª–∏ —ó—ó ¬´link¬ª), —â–æ –≤–µ–¥–µ –Ω–∞ —ñ–Ω—à—É —Å—Ç–æ—Ä—ñ–Ω–∫—É –¥–æ–∫—É–º–µ–Ω—Ç–∞.

–©–æ–± —Å—Ç–≤–æ—Ä–∏—Ç–∏ –∑–æ–≤–Ω—ñ—à–Ω—î –ø–æ—Å–∏–ª–∞–Ω–Ω—è –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è, –º–∏ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–ª–∏ image(). –¶–µ–π –º–µ—Ç–æ–¥ –º–∞—î –ø–∞—Ä–∞–º–µ—Ç—Ä –¥–ª—è –ø–µ—Ä–µ–¥–∞–≤–∞–Ω–Ω—è –ø–æ—Å–∏–ª–∞–Ω–Ω—è. –ü–æ—Å–∏–ª–∞–Ω–Ω—è –º–æ–∂–µ –±—É—Ç–∏ —è–∫ –≤–Ω—É—Ç—Ä—ñ—à–Ω—ñ–º, —Ç–∞–∫ —ñ –∑–æ–≤–Ω—ñ—à–Ω—ñ–º.

–Ø–∫ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤—É, –¥–ª—è –∑–º—ñ–Ω–∏ —Å—Ç–∏–ª—é —à—Ä–∏—Ñ—Ç—É —Ç–∞ –¥–æ–¥–∞–≤–∞–Ω–Ω—è –ø–æ—Å–∏–ª–∞–Ω—å –º–æ–∂–Ω–∞ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞—Ç–∏ –º–µ—Ç–æ–¥ write_html(). –¶–µ HTML-—Ä–æ–∑–±—ñ—Ä–Ω–∏–∫, —â–æ –¥–æ–∑–≤–æ–ª—è—î –¥–æ–¥–∞–≤–∞—Ç–∏ —Ç–µ–∫—Å—Ç, –∑–º—ñ–Ω—é–≤–∞—Ç–∏ —Å—Ç–∏–ª—å —à—Ä–∏—Ñ—Ç—É —Ç–∞ –¥–æ–¥–∞–≤–∞—Ç–∏ –ø–æ—Å–∏–ª–∞–Ω–Ω—è –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é HTML.

PDF/A-1 –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î PDF-–≤–µ—Ä—Å—ñ—é 1.4. –£—Å—ñ —Ä–µ—Å—É—Ä—Å–∏ (–∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è, –≥—Ä–∞—Ñ—ñ–∫–∞, —à—Ä–∏—Ñ—Ç–∏) –º–∞—é—Ç—å –±—É—Ç–∏ –≤–±—É–¥–æ–≤–∞–Ω—ñ –≤ –¥–æ–∫—É–º–µ–Ω—Ç. –ö–µ—Ä—É–≤–∞–Ω–Ω—è –∫–æ–ª—å–æ—Ä–∞–º–∏ –º–∞—î –±—É—Ç–∏ —Ç–æ—á–Ω–∏–º —ñ –ø–ª–∞—Ç—Ñ–æ—Ä–º–æ–Ω–µ–∑–∞–ª–µ–∂–Ω–∏–º, —ñ–∑ –∑–∞–∑–Ω–∞—á–µ–Ω–Ω—è–º –ø—Ä–æ—Ñ—ñ–ª—ñ–≤ ICC, –∞ –º–µ—Ç–∞–¥–∞–Ω—ñ –¥–æ–∫—É–º–µ–Ω—Ç–∞ –º–∞—é—Ç—å –±—É—Ç–∏ –Ω–∞–¥–∞–Ω—ñ —É –≤–∏–≥–ª—è–¥—ñ XMP-–º–µ—Ç–∞–¥–∞–Ω–∏—Ö.

PDF/A-2 –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î PDF-–≤–µ—Ä—Å—ñ—é 1.7. –î–æ–∑–≤–æ–ª—è—î —Å—Ç–∏—Å–Ω–µ–Ω–Ω—è JPEG2000, –ø—Ä–æ–∑–æ—Ä—ñ –µ–ª–µ–º–µ–Ω—Ç–∏, —à—Ä–∏—Ñ—Ç–∏ OpenType —Ç–∞ —Ü–∏—Ñ—Ä–æ–≤—ñ –ø—ñ–¥–ø–∏—Å–∏.

–Ñ–¥–∏–Ω–µ —Ä–æ–∑—à–∏—Ä–µ–Ω–Ω—è –¥–ª—è PDF/A-3 ‚Äî –º–æ–∂–ª–∏–≤—ñ—Å—Ç—å –≤–±—É–¥–æ–≤—É–≤–∞—Ç–∏ –±—É–¥—å-—è–∫—ñ —Ñ–∞–π–ª–∏.

–†—ñ–≤–µ–Ω—å A (accessible, ¬´–¥–æ—Å—Ç—É–ø–Ω–∏–π¬ª) –æ—Ö–æ–ø–ª—é—î –≤—Å—ñ –≤–∏–º–æ–≥–∏ —Å—Ç–∞–Ω–¥–∞—Ä—Ç—É, –∑–æ–∫—Ä–µ–º–∞ –≤—ñ–¥–æ–±—Ä–∞–∂–µ–Ω–Ω—è —Å—Ç—Ä—É–∫—Ç—É—Ä–æ–≤–∞–Ω–æ–≥–æ –∑–º—ñ—Å—Ç—É —Ç–∞ –ø—Ä–∞–≤–∏–ª—å–Ω–∏–π –ø–æ—Ä—è–¥–æ–∫ —á–∏—Ç–∞–Ω–Ω—è –≤–º—ñ—Å—Ç—É –¥–æ–∫—É–º–µ–Ω—Ç–∞. –¢–µ–∫—Å—Ç –º–∞—î –±—É—Ç–∏ –≤–∏—Ç—è–≥—É–≤–∞–Ω–∏–º, –∞ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ ‚Äî –≤—ñ–¥–æ–±—Ä–∞–∂–∞—Ç–∏ –ø—Ä–∏—Ä–æ–¥–Ω—É –ø–æ—Å–ª—ñ–¥–æ–≤–Ω—ñ—Å—Ç—å —á–∏—Ç–∞–Ω–Ω—è.

–†—ñ–≤–µ–Ω—å B (Basic, ¬´–±–∞–∑–æ–≤–∏–π¬ª) –≥–∞—Ä–∞–Ω—Ç—É—î —á—ñ—Ç–∫–µ –≤—ñ–∑—É–∞–ª—å–Ω–µ –≤—ñ–¥—Ç–≤–æ—Ä–µ–Ω–Ω—è –≤–º—ñ—Å—Ç—É. –†—ñ–≤–µ–Ω—å B –∑–∞–∑–≤–∏—á–∞–π –ª–µ–≥—à–µ –∑–≥–µ–Ω–µ—Ä—É–≤–∞—Ç–∏, –Ω—ñ–∂ —Ä—ñ–≤–µ–Ω—å A, –∞–ª–µ –≤—ñ–Ω –Ω–µ –∑–∞–±–µ–∑–ø–µ—á—É—î 100-–≤—ñ–¥—Å–æ—Ç–∫–æ–≤–æ–≥–æ –≤–∏–ª—É—á–µ–Ω–Ω—è —Ç–µ–∫—Å—Ç—É —á–∏ –º–æ–∂–ª–∏–≤–æ—Å—Ç—ñ –ø–æ—à—É–∫—É. –ë–µ–∑–ø—Ä–æ–±–ª–µ–º–Ω–µ –ø–æ–≤—Ç–æ—Ä–Ω–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è –≤–º—ñ—Å—Ç—É –Ω–µ –æ–±–æ–≤‚Äô—è–∑–∫–æ–≤–æ –≥–∞—Ä–∞–Ω—Ç–æ–≤–∞–Ω–µ.

–©–æ–± —Ü—å–æ–≥–æ –¥–æ—Å—è–≥—Ç–∏, –æ—Å—å –Ω–µ–≤–µ–ª–∏–∫–∏–π –ø—Ä–∏–∫–ª–∞–¥:

–û—Ç—Ä–∏–º–∞–Ω–∏–π PDF: tuto7.pdf

–¢–∞–∫—ñ —ñ–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∏, —è–∫ VeraPDF, –º–æ–∂—É—Ç—å –ø–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω—ñ—Å—Ç—å —Å—Ç–≤–æ—Ä–µ–Ω–∏—Ö PDF-–¥–æ–∫—É–º–µ–Ω—Ç—ñ–≤:

**Examples:**

Example 1 (python):
```python
from fpdf import FPDF

pdf = FPDF()
pdf.add_page()
pdf.set_font("helvetica", style="B", size=16)
pdf.cell(40, 10, "Hello World!")
pdf.output("tuto1.pdf")
```

Example 2 (unknown):
```unknown
pdf = FPDF(orientation="P", unit="mm", format="A4")
```

Example 3 (unknown):
```unknown
pdf.set_font('Helvetica', style='B', size=16)
```

Example 4 (unknown):
```unknown
pdf.cell(40, 10, 'Hello World!', 1)
```

---

## Drawing¬∂

**URL:** https://py-pdf.github.io/fpdf2/Drawing.html

**Contents:**
- Drawing¬∂
- Getting Started¬∂
- Adding Some Style¬∂
- Transforms And You¬∂
- Clipping Paths¬∂
- Compositing operations¬∂
- Next Steps¬∂

The fpdf.drawing module provides an API for composing paths out of an arbitrary sequence of straight lines and curves. This allows fairly low-level control over the graphics primitives that PDF provides, giving the user the ability to draw pretty much any vector shape on the page.

The drawing API makes use of features (notably transparency and blending modes) that were introduced in PDF 1.4. Therefore, use of the features of this module will automatically set the output version to 1.4 (fpdf normally defaults to version 1.3. Because the PDF 1.4 specification was originally published in 2001, this version should be compatible with all viewers currently in general use).

The easiest way to add a drawing to the document is via fpdf.FPDF.new_path. This is a context manager that takes care of serializing the path to the document once the context is exited.

Drawings follow the fpdf convention that the origin (that is, coordinate(0, 0)), is at the top-left corner of the page. The numbers specified to the various path commands are interpreted in the document units.

import fpdf pdf = fpdf.FPDF(unit='mm', format=(10, 10)) pdf.add_page() with pdf.new_path() as path: path.move_to(2, 2) path.line_to(8, 8) path.horizontal_line_relative(-6) path.line_relative(6, -6) path.close() pdf.output("drawing-demo.pdf") This example draws an hourglass shape centered on the page:

Drawings can be styled, changing how they look and blend with other drawings. Styling can change the color, opacity, stroke shape, and other attributes of a drawing.

Let's add some color to the above example:

If you make color choices like these, it's probably not a good idea to quit your day job to become a graphic designer. Here's what the output should look like:

Transforms provide the ability to manipulate the placement of points within a path without having to do any pesky math yourself. Transforms are composable using python's matrix multiplication operator (@), so, for example, a transform that both rotates and scales an object can be create by matrix multiplying a rotation transform with a scaling transform.

An important thing to note about transforms is that the result is order dependent, which is to say that something like performing a rotation followed by scaling will not, in the general case, result in the same output as performing the same scaling followed by the same rotation.

Additionally, it's not generally possible to deconstruct a composed transformation (representing an ordered sequence of translations, scaling, rotations, shearing) back into the sequence of individual transformation functions that produced it. That's okay, because this isn't important unless you're trying to do something like animate transforms after they've been composed, which you can't do in a PDF anyway.

All that said, let's take the example we've been working with for a spin (the pun is intended, you see, because we're going to rotate the drawing). Explaining the joke does make it better.

An easy way to apply a transform to a path is through the path.transform property.

The transform in the above example rotates the path 45 degrees clockwise and scales it by 1/sqrt(2) around its center point. This transform could be equivalently written as:

Because all transforms operate on points relative to the origin, if we had rotated the path without first centering it on the origin, we would have rotated it partway off of the page. Similarly, the size-reduction from the scaling would have moved it closer to the origin. By bracketing the transforms with the two translations, the placement of the drawing on the page is preserved.

The clipping path is used to define the region that the normal path is actually painted. This can be used to create drawings that would otherwise be difficult to produce.

The drawing API also supports compositing operations, which control how a path blends with another. These are based on the Porter‚ÄìDuff compositing model and the blend modes defined in PDF 1.4.

You can set a compositing operation via the PaintComposite class: from fpdf import FPDF from fpdf.drawing import PaintedPath, PaintComposite from fpdf.enums import CompositingOperation from pathlib import Path pdf = FPDF() pdf.add_page() with pdf.drawing_context() as gc: blue_square = PaintedPath() blue_square.rectangle(10, 10, 50, 50) blue_square.style.fill_color = "#0000ff" red_square = PaintedPath() red_square.rectangle(35, 35, 50, 50) red_square.style.fill_color = "#ff0000" composite = PaintComposite(backdrop=red_square, source=blue_square, operation=CompositingOperation.DESTINATION_ATOP) gc.add_item(composite) pdf.output('compositing-demo.pdf')

The presented API style is designed to make it simple to produce shapes declaratively in your Python scripts. However, paths can just as easily be created programmatically by creating instances of the fpdf.drawing.PaintedPath for paths and fpdf.drawing.GraphicsContext for groups of paths.

Storing paths in intermediate objects allows reusing them and can open up more advanced use-cases. The fpdf.svg SVG converter, for example, is implemented using the fpdf.drawing interface.

**Examples:**

Example 1 (python):
```python
import fpdf

pdf = fpdf.FPDF(unit='mm', format=(10, 10))
pdf.add_page()

with pdf.new_path() as path:
    path.move_to(2, 2)
    path.line_to(8, 8)
    path.horizontal_line_relative(-6)
    path.line_relative(6, -6)
    path.close()

pdf.output("drawing-demo.pdf")
```

Example 2 (python):
```python
import fpdf

pdf = fpdf.FPDF(unit='mm', format=(10, 10))
pdf.add_page()

with pdf.new_path() as path:
    path.style.fill_color = '#A070D0'
    path.style.stroke_color = fpdf.drawing.gray8(210)
    path.style.stroke_width = 1
    path.style.stroke_opacity = 0.75
    path.style.stroke_join_style = 'round'

    path.move_to(2, 2)
    path.line_to(8, 8)
    path.horizontal_line_relative(-6)
    path.line_relative(6, -6)
    path.close()

pdf.output("drawing-demo.pdf")
```

Example 3 (csharp):
```csharp
import fpdf

pdf = fpdf.FPDF(unit="mm", format=(10, 10))
pdf.add_page()

with pdf.new_path() as path:
    path.style.fill_color = "#A070D0"
    path.style.stroke_color = fpdf.drawing.gray8(210)
    path.style.stroke_width = 1
    path.style.stroke_opacity = 0.75
    path.style.stroke_join_style = "round"
    path.transform = fpdf.drawing.Transform.rotation_d(45).scale(0.707).about(5, 5)

    path.move_to(2, 2)
    path.line_to(8, 8)
    path.horizontal_line_relative(-6)
    path.line_relative(6, -6)

    path.close()

pdf.output("drawing-demo.pdf")
```

Example 4 (csharp):
```csharp
import fpdf
T = fpdf.drawing.Transform

T.translation(-5, -5) @ T.rotation_d(45) @ T.scaling(0.707) @ T.translation(5, 5)
```

---

## Module fpdf.encryption

**URL:** https://py-pdf.github.io/fpdf2/fpdf/encryption.html

**Contents:**
- Module fpdf.encryption
- Functions
- Classes
  - Class variables
  - Methods
  - Methods
  - Ancestors
  - Methods
  - Class variables
  - Static methods

Utilities to perform encryption following the PDF standards.

The contents of this module are internal to fpdf2, and not part of the public API. They may change at any time without prior warning or any deprecation period, in non-backward-compatible ways.

Usage documentation at: https://py-pdf.github.io/fpdf2/Encryption.html

convert long to signed 32 bit integer

This is a simplified version of the ARC4 (alleged RC4) algorithm, created based on the following sources: * Wikipedia article on RC4 * github.com/manojpandey/rc4 (MIT License) * http://people.csail.mit.edu/rivest/pubs/RS14.pdf

Having this ARC4 implementation makes it possible to have basic encryption functions without additional dependencies

The type of the None singleton.

Represents one crypt filter, listed under CF inside the encryption dictionary

This class represents an encryption dictionary PDF 32000 reference - Table 20 The PDF trailer must reference this object (/Encrypt)

Inherited from: PDFObject.content_stream

Subclasses can override this method to indicate the presence of a content stream

Inherited from: PDFObject.serialize

Serialize the PDF object as an obj<</>>endobj text block

This class is referenced in the main PDF class and is used to handle all encryption functions * Calculate password and hashes * Provide encrypt method to be called by stream and strings * Set the access permissions on the document

The type of the None singleton.

Algorithm 2B - section 7.6.4.3.4 of the ISO 32000-2:2020 Applied on Security handlers revision 6

https://docs.python.org/3/library/os.html#os.urandom os.urandom will use OS-specific sources to generate random bytes suitable for cryptographic use

PDF2.0 - ISO 32000-2:2020 All passwords for revision 6 shall be based on Unicode. Preprocessing of a user-provided password consists first of normalizing its representation by applying the "SASLPrep" profile (Internet RFC 4013) of the "stringprep" algorithm (Internet RFC 3454) to the supplied password using the Normalize and BiDi options. Next, the password string shall be converted to UTF-8 encoding, and then truncated to the first 127 bytes if the string is longer than 127 bytes

Python offers a stringprep module with the tables mapped in methods

Method invoked by PDFObject and PDFContentStream to encrypt strings and streams

Encrypts an array of bytes using AES algorithms (AES 128 or AES 256)

PDF32000 reference - Algorithm 1: Encryption of data using the RC4 or AES algorithms Append object ID and generation ID to the key and encrypt the data Generation ID is fixed as 0. Will need to revisit if the application start changing generation ID

PDF32000 reference Algorithm 2: Computing an encryption key

PDF32000 reference - Algorithm 3: Computing the encryption dictionary's O (owner password) value The security handler is only using revision 3 or 4, so the legacy r2 version is not implemented here

Generating the O (owner password) and OE (owner encryption) for security handlers of revision 6 Algorithm 9 - Section 7.6.4.4.8 of the ISO 32000-2:2020

File_id is the first hash of the PDF file id

7.6.4.4.9 Algorithm 10: Computing the encryption dictionary‚Äôs Perms (permissions) value (Security handlers of revision 6) of the ISO 32000-2:2020

PDF32000 reference - Algorithm 5: Computing the encryption dictionary's U (user password) value The security handler is only using revision 3 or 4, so the legacy r2 version is not implemented here

Generating the U (user password) and UE (user encryption) for security handlers of revision 6 Algorithm 8 - Section 7.6.4.4.7 of the ISO 32000-2:2020

Return an encryption dictionary

PDF32000 reference - Algorithm 2: Computing an encryption key Step (a) - Add the default padding at the end of provided password to make it 32 bit long

**Examples:**

Example 1 (python):
```python
def int32(n: int) -> int:
    """convert long to signed 32 bit integer"""
    n = n & 0xFFFFFFFF
    return (n ^ 0x80000000) - 0x80000000
```

Example 2 (python):
```python
def md5(data: Union[bytes, bytearray]) -> bytes:
    h = hashlib.new("md5", usedforsecurity=False)
    h.update(data)
    return h.digest()
```

Example 3 (python):
```python
class ARC4:
    """
    This is a simplified version of the ARC4 (alleged RC4) algorithm,
    created based on the following sources:
    * Wikipedia article on RC4
    * github.com/manojpandey/rc4 (MIT License)
    * http://people.csail.mit.edu/rivest/pubs/RS14.pdf

    Having this ARC4 implementation makes it possible to have basic
    encryption functions without additional dependencies
    """

    MOD = 256

    def KSA(self, key: bytes) -> list[int]:
        key_length = len(key)
        S = list(range(self.MOD))
        j = 0
        for i in range(self.MOD):
            j = (j + S[i] + key[i % key_length]) % self.MOD
            S[i], S[j] = S[j], S[i]
        return S

    def PRGA(self, S: list[int]) -> Iterator[int]:
        i = 0
        j = 0
        while True:
            i = (i + 1) % self.MOD
            j = (j + S[i]) % self.MOD
            S[i], S[j] = S[j], S[i]
            K = S[(S[i] + S[j]) % self.MOD]
            yield K

    def encrypt(self, key: bytes, text: bytes | bytearray) -> list[int]:
        keystream = self.PRGA(self.KSA(key))
        res: list[int] = []
        for c in text:
            res.append(c ^ next(keystream))
        return res
```

Example 4 (python):
```python
def KSA(self, key: bytes) -> list[int]:
    key_length = len(key)
    S = list(range(self.MOD))
    j = 0
    for i in range(self.MOD):
        j = (j + S[i] + key[i % key_length]) % self.MOD
        S[i], S[j] = S[j], S[i]
    return S
```

---

## Combine with pypdf¬∂

**URL:** https://py-pdf.github.io/fpdf2/CombineWithPypdf.html

**Contents:**
- Combine with pypdf¬∂
- Adding content onto an existing PDF page¬∂
- Adding a page to an existing PDF¬∂
- Altering with pypdf a document generated with fpdf2¬∂

fpdf2 cannot parse existing PDF files.

However, other Python libraries can be combined with fpdf2 in order to add new content to existing PDF files.

This page provides several examples of doing so using pypdf, an actively-maintained library formerly known as PyPDF2.

In this code snippet, new content will be added on top of existing content: #!/usr/bin/env python3 # USAGE: ./add_on_page_with_pypdf.py src_file.pdf dest_file.pdf import io, sys from contextlib import contextmanager # Before 2.8.2 use: from fpdf.util import get_scale_factor from fpdf import FPDF, get_scale_factor from pypdf import PdfReader, PdfWriter IN_FILEPATH = sys.argv[1] OUT_FILEPATH = sys.argv[2] @contextmanager def add_to_page(reader_page, unit="mm"): k = get_scale_factor(unit) format = (reader_page.mediabox[2] / k, reader_page.mediabox[3] / k) pdf = FPDF(format=format, unit=unit) pdf.add_page() yield pdf page_overlay = PdfReader(io.BytesIO(pdf.output())).pages[0] reader_page.merge_page(page2=page_overlay) reader = PdfReader(IN_FILEPATH) with add_to_page(reader.pages[0]) as pdf: pdf.set_font("times", style="B", size=30) pdf.text(50, 150, "Hello World!") writer = PdfWriter() writer.append_pages_from_reader(reader) writer.write(OUT_FILEPATH)

A document created with fpdf2 can the be edited with pypdf by passing its .output() to a pypdf.PdfReader: import io from fpdf import FPDF from pypdf import PdfReader pdf = FPDF() pdf.add_page() pdf.set_font('times', style='B', size=19) pdf.text(50, 10, 'Hello World!') reader = PdfReader(io.BytesIO(pdf.output()))

**Examples:**

Example 1 (python):
```python
#!/usr/bin/env python3
# USAGE: ./add_on_page_with_pypdf.py src_file.pdf dest_file.pdf
import io, sys
from contextlib import contextmanager

# Before 2.8.2 use: from fpdf.util import get_scale_factor
from fpdf import FPDF, get_scale_factor
from pypdf import PdfReader, PdfWriter

IN_FILEPATH = sys.argv[1]
OUT_FILEPATH = sys.argv[2]


@contextmanager
def add_to_page(reader_page, unit="mm"):
    k = get_scale_factor(unit)
    format = (reader_page.mediabox[2] / k, reader_page.mediabox[3] / k)
    pdf = FPDF(format=format, unit=unit)
    pdf.add_page()
    yield pdf
    page_overlay = PdfReader(io.BytesIO(pdf.output())).pages[0]
    reader_page.merge_page(page2=page_overlay)


reader = PdfReader(IN_FILEPATH)
with add_to_page(reader.pages[0]) as pdf:
    pdf.set_font("times", style="B", size=30)
    pdf.text(50, 150, "Hello World!")

writer = PdfWriter()
writer.append_pages_from_reader(reader)
writer.write(OUT_FILEPATH)
```

Example 2 (python):
```python
#!/usr/bin/env python3
# USAGE: ./add_new_page_with_pypdf.py src_file.pdf dest_file.pdf
import io, sys

from fpdf import FPDF
from pypdf import PdfReader, PdfWriter

IN_FILEPATH = sys.argv[1]
OUT_FILEPATH = sys.argv[2]
ON_PAGE_INDEX = 2  # Index at which the page will be inserted (starts at zero)


def build_page():
    pdf = FPDF()
    pdf.add_page()
    pdf.set_font("times", style="B", size=19)
    pdf.text(50, 10, "Hello World!")
    return io.BytesIO(pdf.output())


writer = PdfWriter(clone_from=IN_FILEPATH)
new_page = PdfReader(build_page()).pages[0]
writer.insert_page(new_page, index=ON_PAGE_INDEX)
writer.write(OUT_FILEPATH)
```

Example 3 (swift):
```swift
import io
from fpdf import FPDF
from pypdf import PdfReader

pdf = FPDF()
pdf.add_page()
pdf.set_font('times', style='B', size=19)
pdf.text(50, 10, 'Hello World!')

reader = PdfReader(io.BytesIO(pdf.output()))
```

---

## Fonts and Unicode¬∂

**URL:** https://py-pdf.github.io/fpdf2/Unicode.html

**Contents:**
- Fonts and Unicode¬∂
  - Web fonts (WOFF and WOFF2)¬∂
  - Built-in Fonts vs. Unicode Fonts¬∂
  - Adding and Using Fonts¬∂
  - Note on non-latin languages¬∂
  - Right-to-Left scripts¬∂
- Example¬∂
- Free Font Pack¬∂
- Fallback fonts¬∂
- Unicode range limits¬∂

Besides the limited set of latin fonts built into the PDF format, fpdf2 offers full support for using and embedding Unicode (TrueType "ttf" and OpenType "otf") fonts. To keep the output file size small, it only embeds the subset of each font that is actually used in the document. This part of the code has been completely rewritten since the fork from PyFPDF. It uses the fonttools library for parsing the font data, and harfbuzz (via uharfbuzz) for text shaping.

To make use of that functionality, you have to install at least one Unicode font, either in the system font folder or in some other location accessible to your program. For professional work, many designers prefer commercial fonts, suitable to their specific needs. There are also many sources of free TTF fonts that can be downloaded online and used free of cost (some of them may have restrictions on commercial redistribution, such as server installations or including them in a software project).

Font Library - A collection of fonts for many languages with an open source type license.

Google Fonts - A collection of free to use fonts for many languages.

Microsoft Font Library - A large collection of fonts that are free to use.

GitHub: Fonts - Links to public repositories of open source font projects as well as font related software projects.

GNU FreeFont family: FreeSans, FreeSerif, FreeMono

To use a Unicode font in your program, use the add_font(), and then the set_font() method calls.

WOFF and WOFF2 are web-optimized, compressed containers for TrueType and OpenType fonts, designed to reduce download size for browsers. fpdf2 supports these formats by decompressing them before embedding the resulting font data into the generated PDF.

The PDF file format knows a small number of "standard" fonts, namely Courier, Helvetica, Times, Symbol, and ZapfDingbats. The first three are available in regular, bold, italic, and bold-italic versions. This gives us a set of fonts known as "14 Standard PDF fonts". Any PDF processor (eg. a viewer) must provide those fonts for display. To use them, you don't need to call .add_font(), but only .set_font().

( script used to generate this: tutorial/core_fonts.py )

While that may seem convenient, there's a big drawback. Those fonts only support latin characters, or a set of special characters for the last two. If you try to render any Unicode character outside of those ranges, then you'll get an error like: "Character "Œ∏" at index 13 in text is outside the range of characters supported by the font used: "courier". Please consider using a Unicode font.". So if you want to create documents with any characters other than those common in English and a small number of european languages, then you need to add a Unicode font containing the respective glyph as described in this document.

Note that even if you have a font eg. named "Courier" installed as a system font on your computer, by default this will not be used. You'll have to explicitly call eg. .add_font("Courier2", fname=r"C:\Windows\Fonts\cour.ttf") to make it available. If the name is really the same (ignoring case), then you'll have to use a suitable variation, since trying to overwrite one of the "standard" names with .add_font() will result in an error.

Before using a Unicode font, you need to load it from a font file. Usually you'll have call add_font() for each style of the same font family you want to use. The styles that fpdf2 understands are:

Note that we use the same family name for each of them, but load them from different files. Only when a font has variants (eg. "narrow"), or there are more styles than the four standard ones (eg. "black" or "extra light"), you'll have to add those with a different family name. If the font files are not located in the current directory, you'll have to provide a file name with a relative or absolute path. If the font is not found elsewhere, then fpdf2 will look for it in a subdirectory named "font".

To actually use the loaded font, or to use one of the standard built-in fonts, you'll have to set the current font before calling any text generating method. .set_font() uses the same combinations of family name and style as arguments, plus the font size in typographic points. In addition to the previously mentioned styles, the letter u may be included for creating underlined text, and s for creating strikethrough text. If the family or size are omitted, the already set values will be retained. If the style is omitted, it defaults to regular.

Many non-latin writing systems have complex ways to combine characters, ligatures, and possibly multiple diacritic symbols together, change the shape of characters depending on its location in a word, or use a different writing direction. A small number of examples are:

To make sure those scripts to be rendered correctly, text shaping must be enabled with .set_text_shaping(True).

When text shaping is enabled, fpdf2 will apply the Unicode Bidirectional Algorithm to render correctly any text, including bidirectional (mix of right-to-left and left-to-right scripts).

This example uses several free fonts to display some Unicode strings. Be sure to install the fonts in the font directory first.

View the result here: unicode.pdf

For your convenience, the author of the original PyFPDF has collected 96 TTF files in an optional "Free Unicode TrueType Font Pack for FPDF", with useful fonts commonly distributed with GNU/Linux operating systems. Note that this collection is from 2015, so it will not contain any newer fonts or possible updates.

The method set_fallback_fonts() allows you to specify a list of fonts to be used if any character is not available on the font currently set. When a character doesn‚Äôt exist on the current font, fpdf2 will look if it‚Äôs available on the fallback fonts, on the same order the list was provided.

Common scenarios are use of special characters like emojis within your text, greek characters in formulas or citations mixing different languages.

Example: import fpdf pdf = fpdf.FPDF() pdf.add_page() pdf.add_font(fname="Roboto.ttf") # twitter emoji font: https://github.com/13rac1/twemoji-color-font/releases pdf.add_font(fname="TwitterEmoji.ttf") pdf.set_font("Roboto", size=15) pdf.set_fallback_fonts(["TwitterEmoji"]) pdf.write(text="text with an emoji üå≠") pdf.output("text_with_emoji.pdf")

When a glyph cannot be rendered uing the current font, fpdf2 will look for a fallback font matching the current character emphasis (bold/italics). By default, if it does not find such matching font, the character will not be rendered using any fallback font. This behaviour can be relaxed by passing exact_match=False to set_fallback_fonts().

Moreover, for more control over font fallback election logic, the get_fallback_font() can be overridden. An example of this can be found in test/fonts/test_font_fallback.py.

The unicode_range parameter in add_font() allows you to restrict which Unicode characters a font will handle, similar to CSS @font-face unicode-range rules. This gives you fine-grained control over font priority on a per-character basis.

This is particularly useful when you want fallback fonts to take priority for specific character ranges, even when the main font technically supports those characters. A common scenario is preferring colorful emoji fonts over monochrome glyphs that exist in regular fonts.

Supported Formats for unicode_range param

When you specify a unicode_range, the font's internal character map (cmap) is trimmed to only include codepoints within the specified ranges. This ensures that:

For more information on fallback fonts, see the Fallback fonts section.

A variable font allows users to use a single font file containing many variations of a typeface, such as weight, width, optical size, and slant. Each such variable which modifies the typeface is called an axis. These variables have specific tags which are used to specify their values, such as "wdth" for modifying width, and "wght" for modifying weight. For a full list of tags, please check the documentation of your variable font.

The variations parameter in add_font allows you to specify the value of one or more axes, thus creating a static font from the variable font.

The following examples assume that the provided font is a variable font.

The above examples provide the axes dictionary to specify the styles. If an axis is not mentioned, the default width will be used, and the axis will be dropped as shown below.

It is also possible to specify more than 1 style in the variations dictionary. If a separate axes dictionary is specified for each style, then the style parameter is ignored as shown below.

pdf.add_font( "Roboto Variable", style="", # ignored fname="Roboto-Variable.ttf", variations={"": {"wght": 300}, "B": {"wght": 700}}, ) A TypeError will be raised if variations is not a dictionary, and an AttributeError will be raised if variations is used but the font is not a variable font.

Some color fonts (COLRv0, COLRv1, CBDT, SBIX, SVG) contain multiple predefined color palettes. The palette parameter in add_font() allows you to select which palette to use when rendering the font.

This is useful when you want to use different color schemes from the same font file without having to embed the font multiple times.

If you specify a palette index that is out of range, fpdf2 will log a warning and fall back to palette 0. You can check the number of available palettes in your color font's documentation or by inspecting the font file.

**Examples:**

Example 1 (python):
```python
from fpdf import FPDF

pdf = FPDF()
pdf.add_page()
# Different styles of the same font family.
pdf.add_font("dejavu-sans", style="", fname="DejaVuSans.ttf")
pdf.add_font("dejavu-sans", style="b", fname="DejaVuSans-Bold.ttf")
pdf.add_font("dejavu-sans", style="i", fname="DejaVuSans-Oblique.ttf")
pdf.add_font("dejavu-sans", style="bi", fname="DejaVuSans-BoldOblique.ttf")
# Different type of the same font design.
pdf.add_font("dejavu-sans-narrow", style="", fname="DejaVuSansCondensed.ttf")
pdf.add_font("dejavu-sans-narrow", style="i", fname="DejaVuSansCondensed-Oblique.ttf")
```

Example 2 (markdown):
```markdown
# Set and use first family in regular style.
pdf.set_font(family="dejavu-sans", style="", size=12)
pdf.cell(text="Hello")
# Set and use the same family in bold style.
pdf.set_font(style="b", size=18)  # still uses the same dejavu-sans font family.
pdf.cell(text="Fat World")
# Set and use a variant in italic and underlined.
pdf.set_font(family="dejavu-sans-narrow", style="iu", size=12)
pdf.cell(text="lean on me")
```

Example 3 (sql):
```sql
#!/usr/bin/env python
# -*- coding: utf8 -*-

from fpdf import FPDF

pdf = FPDF()
pdf.add_page()
pdf.set_text_shaping(True)

# Add a DejaVu Unicode font (uses UTF-8)
# Supports more than 200 languages. For a coverage status see:
# http://dejavu.svn.sourceforge.net/viewvc/dejavu/trunk/dejavu-fonts/langcover.txt
pdf.add_font(fname='DejaVuSansCondensed.ttf')
pdf.set_font('DejaVuSansCondensed', size=14)

text = u"""
English: Hello World
Greek: ŒìŒµŒπŒ¨ œÉŒøœÖ Œ∫œåœÉŒºŒøœÇ
Polish: Witaj ≈õwiecie
Portuguese: Ol√° mundo
Russian: –ó–¥—Ä–∞–≤—Å—Ç–≤—É–π, –ú–∏—Ä
Vietnamese: Xin ch√†o th·∫ø gi·ªõi
Arabic: ŸÖÿ±ÿ≠ÿ®ÿß ÿßŸÑÿπÿßŸÑŸÖ
Hebrew: ◊©◊ú◊ï◊ù ◊¢◊ï◊ú◊ù
"""

for txt in text.split('\n'):
    pdf.write(8, txt)
    pdf.ln(8)

# Add a Indic Unicode font (uses UTF-8)
# Supports: Bengali, Devanagari, Gujarati, 
#           Gurmukhi (including the variants for Punjabi) 
#           Kannada, Malayalam, Oriya, Tamil, Telugu, Tibetan
pdf.add_font(fname='gargi.ttf')
pdf.set_font('gargi', size=14)
pdf.write(8, u'Hindi: ‡§®‡§Æ‡§∏‡•ç‡§§‡•á ‡§¶‡•Å‡§®‡§ø‡§Ø‡§æ')
pdf.ln(20)

# Add a AR PL New Sung Unicode font (uses UTF-8)
# The Open Source Chinese Font (also supports other east Asian languages)
pdf.add_font(fname='fireflysung.ttf')
pdf.set_font('fireflysung', size=14)
pdf.write(8, u'Chinese: ‰Ω†Â•Ω‰∏ñÁïå\n')
pdf.write(8, u'Japanese: „Åì„Çì„Å´„Å°„ÅØ‰∏ñÁïå\n')
pdf.ln(10)

# Add a Alee Unicode font (uses UTF-8)
# General purpose Hangul truetype fonts that contain Korean syllable 
# and Latin9 (iso8859-15) characters.
pdf.add_font(fname='Eunjin.ttf')
pdf.set_font('Eunjin', size=14)
pdf.write(8, u'Korean: ÏïàÎÖïÌïòÏÑ∏Ïöî')
pdf.ln(20)

# Add a Fonts-TLWG (formerly ThaiFonts-Scalable) (uses UTF-8)
pdf.add_font(fname='Waree.ttf')
pdf.set_font('Waree', size=14)
pdf.write(8, u'Thai: ‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ‡∏ä‡∏≤‡∏ß‡πÇ‡∏•‡∏Å')
pdf.ln(20)

# Select a standard font (uses windows-1252)
pdf.set_font('helvetica', size=14)
pdf.ln(10)
pdf.write(5, 'This is standard built-in font')

pdf.output("unicode.pdf")
```

Example 4 (markdown):
```markdown
import fpdf

pdf = fpdf.FPDF()
pdf.add_page()
pdf.add_font(fname="Roboto.ttf")
# twitter emoji font: https://github.com/13rac1/twemoji-color-font/releases
pdf.add_font(fname="TwitterEmoji.ttf")
pdf.set_font("Roboto", size=15)
pdf.set_fallback_fonts(["TwitterEmoji"])
pdf.write(text="text with an emoji üå≠")
pdf.output("text_with_emoji.pdf")
```

---

## ‰ΩøÁî®ÊïôÁ®ã¬∂

**URL:** https://py-pdf.github.io/fpdf2/Tutorial-zh.html

**Contents:**
- ‰ΩøÁî®ÊïôÁ®ã¬∂
- ÊïôÁ®ã‰∏Ä - ÁÆÄÂçïÁöÑÁ§∫‰æã¬∂
- ÊïôÁ®ã‰∫å - È°µÁúâ„ÄÅÈ°µËÑö„ÄÅÂàÜÈ°µÁ¨¶‰∏éÂõæÂÉè¬∂
- ÊïôÁ®ã‰∏â - Êç¢Ë°åÁ¨¶ÂíåÈ¢úËâ≤¬∂
- ÊïôÁ®ãÂõõ - Â§öÊ†èÁõÆ¬∂
- ÊïôÁ®ã‰∫î - ÂàõÂª∫Ë°®¬∂
- ÊïôÁ®ãÂÖ≠ - ÂàõÂª∫ÈìæÊé•ÂíåÊ∑∑ÂêàÊñáÊú¨Ê†∑Âºè¬∂

ÂÆåÊï¥ËØ¥ÊòéÊñá‰ª∂Ôºö fpdf.FPDF API ÊñáÊ°£

ÂºïÂÖ•Â∫ìÊñá‰ª∂ÂêéÔºåÂàõÂª∫FPDFÂØπË±°„ÄÇ FPDF ÊûÑÈÄ†ÂáΩÊï∞Âú®Ê≠§‰ΩøÁî®ÈªòËÆ§ÂÄºÔºöÈ°µÈù¢ A4 Á∫µÂêëÔºõÂçï‰ΩçÊØ´Á±≥„ÄÇ ÂΩìÁÑ∂ÔºåËøôÂèØ‰ª•Ë¢´ÊòéÁ°ÆÂÆö‰πâÔºö

ÂêåÊó∂Ôºå‰πüÂèØ‰ª•Â∞Ü PDF ËÆæÁΩÆ‰∏∫Ê®™ÂêëÊ®°Âºè (L) Êàñ‰ΩøÁî®ÂÖ∂‰ªñÈ°µÈù¢Ê†ºÂºè ÔºàÂ¶Ç Letter Âíå LegalÔºâÂíåÂ∫¶ÈáèÂçï‰ΩçÔºàpt„ÄÅcm„ÄÅinÔºâ„ÄÇ

Âà∞Ê≠§ÔºåÊñá‰ª∂ÊöÇÊó†È°µÈù¢„ÄÇË∞ÉÁî® add_page Ê∑ªÂä†È°µÈù¢ÔºåÂéüÁÇπ‰Ωç‰∫éÈ°µÈù¢Â∑¶‰∏äËßíÔºåÂΩìÂâç‰ΩçÁΩÆÈªòËÆ§‰∏∫Ë∑ùËæπÁïå 1 ÂéòÁ±≥Â§Ñ„ÄÇ ËæπË∑ù‰πüÂèØ‰ª•Ë∞ÉÁî® set_margins Êõ¥Êîπ„ÄÇ

Âú®Âä†ÂÖ•ÊñáÊú¨‰πãÂâçÔºåÂøÖÈ°ªÈÄâÂÆöÂ≠ó‰Ωì set_font ÔºåÂê¶ÂàôÊñá‰ª∂Êó†Êïà„ÄÇ ÈÄâÊã©Â≠ó‰Ωì HelveticaÔºåÁ≤ó‰ΩìÔºå16Âè∑Ôºö

‰ΩøÁî® I ÊåáÂÆöÊñú‰ΩìÔºåU Âä†‰∏ãÂàíÁ∫øÊàñÁ©∫Â≠óÁ¨¶‰∏≤ÊåáÂÆöÂ∏∏ËßÑÂ≠ó‰Ωì„ÄÇ ËØ∑Ê≥®ÊÑèÔºåÂ≠óÂè∑Âçï‰ΩçÊòØÁÇπÊï∞ÔºåËÄåÈùûÊØ´Á±≥ÔºàÊàñÂÖ∂‰ªñÊåáÂÆöÁöÑÂçï‰ΩçÔºâ„ÄÇ ËøôÊòØÂçï‰ΩçËÆæÁΩÆÁöÑÂîØ‰∏Ä‰æãÂ§ñ„ÄÇÂÖ∂‰ªñÂÜÖÁΩÆÂ≠ó‰ΩìÊúâ Times„ÄÅCourier„ÄÅSymbol ‰∏é ZapfDingbats„ÄÇ

Ë∞ÉÁî® cell ÂàõÂª∫‰∏Ä‰∏™ÂçïÂÖÉÊ†º„ÄÇÂçïÂÖÉÊ†ºÊòØ‰∏Ä‰∏™Áü©ÂΩ¢Âå∫ÂüüÔºåÂèØËÉΩÂ∏¶ÊúâÂ§ñÊ°ÜÔºå ÂÖ∂‰∏≠ÂåÖÂê´‰∏Ä‰∫õÊñáÊú¨Ôºå‰∏îÁΩÆ‰∫éÂΩìÂâç‰ΩçÁΩÆ„ÄÇ ÂçïÂÖÉÊ†ºÁöÑÂ∞∫ÂØ∏ÔºåÊéíÁâàÔºàÂ±Ö‰∏≠ÊàñÂØπÈΩêÔºâÔºåÊòØÂê¶ÊúâËæπÊ°Ü Ôºå‰ª•ÂèäÊâÄÊîæÁΩÆÁöÑ‰ΩçÁΩÆÔºàÂêëÂè≥ÔºåÂêë‰∏ãÊàñÊç¢Ë°åÔºâÂèØÈÖçÁΩÆÁöÑ„ÄÇ Ê∑ªÂä†‰∏Ä‰∏™Ê°ÜÊû∂Ôºö

Â§áÊ≥®ÔºöÊç¢Ë°å‰πüÂèØË∞ÉÁî® ln ÂÆûÁé∞„ÄÇÊ≠§ÊñπÊ≥ïÂÖÅËÆ∏ÊåáÂÆöÊç¢Ë°åË°åË∑ù„ÄÇ

ÊúÄÁªàÔºåÂÖ≥Èó≠Êñá‰ª∂Âπ∂‰øùÂ≠ò‰∫éÁªôÂÆöË∑ØÂæÑ output„ÄÇ Êó†ÂèÇÊï∞Êó∂Ôºåoutput()ËøîÂõû PDF bytearray ÁºìÂÜ≤Âå∫„ÄÇ

Ê≠§ÊïôÁ®ã‰ΩøÁî®‰∫Ü‰∏ãËø∞ÂåÖÂê´È°µÁúâ„ÄÅÈ°µËÑöÂíåÂæΩÊ†áÁöÑÁ§∫‰æãÔºö

Ê≠§Á§∫‰æã‰ΩøÁî® header ‰∏é footer Â§ÑÁêÜÈ°µÁúâÂíåÈ°µËÑö„ÄÇ ËôΩÁÑ∂‰∫åËÄÖÂ±û‰∫é FPDF Á±ªÔºåË¢´Ëá™Âä®Ë∞ÉÁî®Ôºå‰ΩÜÈªòËÆ§ÊòØÁ©∫ÁΩÆÁöÑÔºå Âõ†Ê≠§ÈúÄË¶ÅÊâ©Â±ïÁ±ª‰ªéËÄåË¶ÜÁõñÁº∫ÁúÅÂÄº„ÄÇ

Ë∞ÉÁî® image ‰æùÁÖßÊåáÂÆöÁöÑËµ∑ÂßãÂùêÊ†áÔºàÂ∑¶‰∏äËßíÔºâ‰∏éÂÆΩÂ∫¶Ê∑ªÂä†ÂõæÊ†á„ÄÇ È´òÂ∫¶Â∞Ü‰æùÁÖßÂõæÂÉèÊØî‰æãËá™Âä®ËÆ°ÁÆó„ÄÇ

ÂèØÂ∞ÜÁ©∫ÂÄº‰Ωú‰∏∫ÂçïÂÖÉÊ†ºÂÆΩÂ∫¶‰ª•ÊâìÂç∞È°µÁ†Å„ÄÇËøô‰ΩøÂçïÂÖÉÊ†ºÂª∂‰º∏Âà∞È°µÈù¢ÁöÑÂè≥ËæπÁºòÔºå ‰æø‰∫éÊñáÊú¨Â±Ö‰∏≠„ÄÇÂΩìÂâçÈ°µÁ†ÅÁî± page_no ËøîÂõû„ÄÇËá≥‰∫éÊÄªÈ°µÊï∞ÔºåÂèØ‰ª•ÈÄöËøáÂÄº{nb}Ëé∑Âæó„ÄÇ {nb}Â∞ÜÂú®ÊñáÊ°£ÂÖ≥Èó≠Êó∂Ë¢´ÊõøÊç¢ÔºàÊ≠§ÂÄºË∞ÉÁî® alias_nb_pages() Êõ¥Êîπ)„ÄÇÊ≥®ÊÑèÔºåË∞ÉÁî® set_y ËÉΩÂ§ü‰ªéÈ°∂ÈÉ®ÊàñÂ∫ïÈÉ®Ëµ∑ÔºåËÆæÁΩÆÂú®È°µÈù¢‰∏≠ÁöÑÁªùÂØπ‰ΩçÁΩÆ„ÄÇ

Á§∫‰æã‰∏≠‰ΩøÁî®‰∫ÜÂè¶‰∏Ä‰∏™ÊúâË∂£ÁöÑÁâπÊÄßÔºöËá™Âä®ÂàÜÈ°µ„ÄÇ ‰∏ÄÊó¶ÂçïÂÖÉÊ†º‰ºöË∂äËøáÈ°µÈù¢‰∏≠ÁöÑÈôêÂà∂ÔºàÈªòËÆ§Ë∑ùÁ¶ªÂ∫ïÈÉ® 2 ÂéòÁ±≥Â§ÑÔºâÔºå Â∞ÜÊâßË°å‰∏≠Êñ≠Âπ∂ÊÅ¢Â§çÂ≠ó‰ΩìËÆæÁΩÆ„ÄÇ ËôΩÁÑ∂Ê†áÈ¢òÂíåÈ°µËÑö‰ªçÁÑ∂‰ΩøÁî®Ëá™Ë∫´ÁöÑÂ≠ó‰ΩìÔºàhelveticaÔºâÔºå‰ΩÜÊ≠£ÊñáÂ∞ÜÁªßÁª≠‰ΩøÁî® Times Â≠ó‰Ωì„ÄÇ ËøôÁßçËá™Âä®ÊÅ¢Â§çÊú∫Âà∂ÂêåÊ†∑ÈÄÇÁî®‰∫éÂ≠ó‰ΩìÈ¢úËâ≤‰∏éË°åË∑ù„ÄÇ Ëß¶ÂèëÂàÜÈ°µÁ¨¶ÁöÑÊú∫Âà∂ÂèØ‰ª•ÈÄöËøá set_auto_page_break ÈÖçÁΩÆ„ÄÇ

ËÆ©Êàë‰ª¨ÁªßÁª≠‰∏äËø∞ÂØπÈΩêÊÆµËêΩÁöÑÁ§∫‰æã„ÄÇÊ≠§ÊïôÁ®ã‰πüÂ∞ÜÊºîÁ§∫È¢úËâ≤ÁöÑÈÖçÁΩÆÊñπÊ≥ï„ÄÇ

Ë∞ÉÁî® get_string_width ÂáΩÊï∞ËÆæÂÆöÂΩìÂâçÂ≠ó‰Ωì‰∏ãÂ≠óÁ¨¶‰∏≤ÁöÑÈïøÂ∫¶Ôºå ‰ªéËÄåËÆ°ÁÆóÂΩìÂâç‰ΩçÁΩÆÊ†áÈ¢òÂ§ñÊ°ÜÁöÑÂÆΩÂ∫¶„ÄÇ ÈÄöËøá set_draw_color„ÄÅ set_fill_colorÂíå set_text_color ËÆæÁΩÆÈ¢úËâ≤„ÄÇË°åË∑ùÁî± set_line_width ËÆæÂÆö‰∏∫ 1 mmÔºàÈªòËÆ§‰∏∫ 0.2Ôºâ„ÄÇ ÊúÄÁªàÔºåËæìÂá∫ÂçïÂÖÉÊ†ºÔºàÊú´‰ΩçÂèÇÊï∞ true Ë°®Á§∫ÂøÖÈ°ªÂ°´ÂÖÖËÉåÊôØÔºâ„ÄÇ

Ë∞ÉÁî®multi_cell ÂáΩÊï∞ÊâìÂç∞ÊÆµËêΩÔºàÊñáÊú¨ÈªòËÆ§ÂØπÈΩêÔºâ„ÄÇ ÊØèÂΩìÂà∞ËææÂçïÂÖÉÊ†ºÁöÑÂè≥Á´ØÊàñÈÅáÂà∞ÂõûËΩ¶Á¨¶ (\n) Êó∂Ôºå Êç¢Ë°åÂπ∂Âú®ÂΩìÂâçÂçïÂÖÉÊ†º‰∏ãËá™Âä®ÂàõÂª∫‰∏Ä‰∏™Êñ∞ÁöÑÂçïÂÖÉÊ†º„ÄÇ Ëá™Âä®Êç¢Ë°åÂú®Âè≥Ëµ∑ÊúÄËøëÁöÑÁ©∫Ê†ºÊàñËΩØËøûÂ≠óÁ¨¶ (\u00ad) Ëß¶Âèë„ÄÇ ÂΩìËß¶ÂèëÊç¢Ë°åÁ¨¶Êó∂ÔºåËΩØËøûÂ≠óÁ¨¶Â∞ÜË¢´ÊôÆÈÄöËøûÂ≠óÁ¨¶ÊõøÊç¢ÔºåÂê¶ÂàôÂ∞ÜË¢´ÂøΩÁï•„ÄÇ

Á§∫‰æã‰∏≠ËÆæÂÆö‰∫Ü‰∏§‰∏™ÊñáÊ°£Â±ûÊÄßÔºöÊ†áÈ¢ò (set_title) ‰∏é‰ΩúËÄÖ (set_author)„ÄÇ ÊñáÊ°£ÁöÑÂ±ûÊÄßÂèØ‰ª•Áõ¥Êé•Áî® Acrobat ÈòÖËØªÂô® ÊâìÂºÄÔºå Âú®Êñá‰ª∂ËèúÂçï‰∏≠ÈÄâÊã©ÊñáÊ°£Â±ûÊÄßÊü•ÁúãÔºõ ‰πüÂèØ‰ª•‰ΩøÁî®Êèí‰ª∂ÔºåÂè≥ÂáªÂπ∂ÈÄâÊã© ÊñáÊ°£Â±ûÊÄß Êü•Áúã„ÄÇ

Ê≠§Á§∫‰æãÊòØ‰∏ä‰∏Ä‰∏™Á§∫‰æãÁöÑÂèò‰ΩìÔºåÂ±ïÁ§∫‰∫ÜÂ¶Ç‰ΩïÂ∞ÜÊñáÊú¨ÊîæÁΩÆÂú®Â§ö‰∏™Ê†èÁõÆ‰∏≠„ÄÇ

Ê≠§ÁâàÊú¨‰∏éÂÖà‰æãÁöÑÈáçÁÇπÂå∫Âà´‰∫é‰ΩøÁî®‰∫Ütext_columns„ÄÇÊ≠§ÂáΩÊï∞Áî®‰∫éÔºàÈÄêÊÆµÔºâÊî∂ÈõÜÊñáÊú¨Âπ∂ÊääÂÖ∂ÊîæÁΩÆ‰∫éÂ§ö‰∏™Ê†èÁõÆ‰∏≠ÔºåËá™‰∏ªÊåâÈúÄÊèíÂÖ•Êç¢È°µÁ¨¶„ÄÇÈúÄÊ≥®ÊÑèÔºåËôΩ(TextColumns)ÂÆû‰æã‰ºöËµ∑Âà∞‰∏ä‰∏ãÊñáÁÆ°ÁêÜÂô®ÁöÑ‰ΩúÁî®Ôºå‰ΩÜÊñáÊú¨Ê†∑Âºè‰∏éÂÖ∂‰ªñÂ≠ó‰ΩìÂ±ûÊÄß‰æùÊóßÂèØË¢´Êõ¥Êîπ„ÄÇÊ≠§Á±ªÂèòÊõ¥‰ªÖ‰ºöË¢´‰ΩøÁî®‰∏éÂΩìÂâçÁöÑÊâßË°åÁéØÂ¢É‰∏≠ÔºåËã•ÈÄÄÂá∫ÊâßË°åÁéØÂ¢ÉÂàô‰ºöÊÅ¢Â§çÂéüÂÆöËÆæÁΩÆ„ÄÇ

Êú¨ÊïôÁ®ãÂ∞ÜÊºîÁ§∫Â¶Ç‰ΩïÂàõÂª∫‰∏§‰ªΩ‰∏çÂêåÁöÑË°®Ê†ºÔºå‰ª•Ê≠§Â±ïÁ§∫ÁÆÄÂçïÊîπÂä®ÂèÇÊï∞ÂèØÂ∏¶Êù•ÁöÑÊïàÊûú„ÄÇ

Ê°à‰æã‰∏ÄÊúÄ‰∏∫Âü∫Á°ÄÔºå‰ªÖ‰ΩøÁî®‰∫ÜFPDF.table()Êù•Âø´ÈÄüÁîüÊàê‰∏ÄÂº†Âü∫Á°ÄË°®Ê†º„ÄÇ

Ê°à‰æã‰∫åÂú®Ê≠§Âü∫Á°Ä‰∏äËøõË°å‰∫ÜËâ≤ÂΩ©„ÄÅË°®Ê†ºÈôêÂÆΩ„ÄÅÁº©ÂáèÊñáÊú¨È´òÂ∫¶„ÄÅÊ†áÈ¢òÂ±Ö‰∏≠„ÄÅËá™ÂÆö‰πâÈ°πÁõÆÊ†èÂÆΩÂ∫¶„ÄÅÂè≥ÂØπÈΩêÊï∞ÊçÆÁ≠âÊñπÈù¢ÁöÑÊîπËâØ„ÄÇÂπ∂ÈÄâÁî®‰∫ÜTableBordersLayout‰∏≠ÂêàÈÄÇÁöÑ(borders_layout)ÂèÇÊï∞Êù•ÂéªÈô§‰∏ãËæπÊ°Ü„ÄÇ

Êú¨ÊïôÁ®ãÂ∞ÜÊºîÁ§∫Âá†ÁßçÂú® pdf ÊñáÊ°£‰∏≠ÊèíÂÖ•ÂÜÖÈÉ®ÈìæÊé•ÔºåÊàñÊåáÂêëÂ§ñÈÉ®ËµÑÊ∫ê ÁöÑË∂ÖÈìæÊé•ÁöÑÊñπÊ≥ïÔºå‰ª•ÂèäÂá†ÁßçÂú®Âêå‰∏ÄÊñáÊú¨‰∏≠‰ΩøÁî®‰∏çÂêåÊñáÊú¨Ê†∑Âºè ÔºàÁ≤ó‰Ωì„ÄÅÊñú‰Ωì„ÄÅ‰∏ãÂàíÁ∫øÔºâÁöÑÊñπÊ≥ï„ÄÇ

Ê≠§Â§ÑÊòæÁ§∫ÁöÑÊâìÂç∞ÊñáÊú¨ÁöÑÊñ∞ÊñπÊ≥ïÊòØ write() ÔºåÁ±ª‰ºº‰∫é multi_cell() „ÄÇ‰∫åËÄÖ‰∏ªË¶ÅÂå∫Âà´Âú®‰∫éÔºö

Âõ†Ê≠§ÔºåËØ•ÊñπÊ≥ïÂÖÅËÆ∏Âú®‰∏ÄÊÆµÊñáÊú¨‰∏≠Êõ¥ÊîπÂ≠ó‰ΩìÊ†∑ÂºèÔºåÂπ∂‰ªéÂàùÂßã‰ΩçÁΩÆÁªßÁª≠„ÄÇ Âèç‰πãÔºåÂÆÉÁöÑÁº∫ÁÇπÂú®‰∫éÂÖ∂‰∏çËÉΩÂ¶ÇÂêå multi_cell() ÂØπÈΩêÊñáÊú¨„ÄÇ

Âõ†‰∏∫‰∏äËø∞ÂéüÂõ†ÔºåÂú®Á§∫‰æãÁöÑÁ¨¨‰∏ÄÈ°µ‰∏≠ÔºåË∞ÉÁî®‰∫Ü write() ÊâìÂç∞Â∏∏ËßÑÂ≠ó‰ΩìÔºåÁÑ∂Âêé‰ΩøÁî® set_font() ÊñπÊ≥ïÔºåÂàáÊç¢Âà∞‰∏ãÂàíÁ∫øÊ†∑ÂºèÂπ∂ÁªßÁª≠ÊâìÂç∞„ÄÇ

‰∏∫Ê∑ªÂä†ÊåáÂêëÁ¨¨‰∫åÈ°µÁöÑÂÜÖÈÉ®ÈìæÊé•ÔºåË∞ÉÁî®‰∫Ü add_link() „ÄÇËøôÂ∞ÜÂàõÂª∫‰∏Ä‰∏™ÂèØÁÇπÂáªÂå∫ÂüüÔºåÂëΩÂêç‰∏∫‚ÄúÈìæÊé•‚ÄùÔºåÊåáÂêë ÊñáÊ°£‰∏≠ÁöÑÂè¶‰∏ÄÈ°µ„ÄÇ

‰ΩøÁî®ÂõæÂÉèÂàõÂª∫Â§ñÈÉ®ÈìæÊé•ÔºåÂàôË∞ÉÁî® image() „ÄÇËØ•ÂáΩÊï∞ÂèØÂ∞ÜÈìæÊé•‰Ωú‰∏∫ÂÖ∂ÂèÇÊï∞‰πã‰∏Ä„ÄÇÈìæÊé•‰πüÂèØ‰ª•ÊåáÂêëÂÜÖÈÉ®ÊàñÂ§ñÈÉ®„ÄÇ

‰Ωú‰∏∫Êõø‰ª£ÊñπÊ°àÔºåÊõ¥ÊîπÂ≠ó‰ΩìÊ†∑ÂºèÂíåÊ∑ªÂä†ÈìæÊé•ÁöÑÂè¶‰∏ÄÁßçÈÄâÊã©ÊòØ ‰ΩøÁî® write_html() ÊñπÊ≥ï„ÄÇËøôÊòØ‰∏Ä‰∏™ html Ëß£ÊûêÂô®Ôºå ÂÖÅËÆ∏Ê∑ªÂä†ÊñáÊú¨ÔºåÊõ¥ÊîπÂ≠ó‰ΩìÊ†∑ÂºèÂπ∂Ê∑ªÂä†ÈìæÊé•„ÄÇ

**Examples:**

Example 1 (python):
```python
from fpdf import FPDF

pdf = FPDF()
pdf.add_page()
pdf.set_font("helvetica", style="B", size=16)
pdf.cell(40, 10, "Hello World!")
pdf.output("tuto1.pdf")
```

Example 2 (unknown):
```unknown
pdf = FPDF(orientation="P", unit="mm", format="A4")
```

Example 3 (unknown):
```unknown
pdf.set_font('Helvetica', style='B', size=16)
```

Example 4 (unknown):
```unknown
pdf.cell(40, 10, 'Hello World!', 1)
```

---

## Module fpdf.deprecation

**URL:** https://py-pdf.github.io/fpdf2/fpdf/deprecation.html

**Contents:**
- Module fpdf.deprecation
- Functions
- Classes
  - Ancestors

Utilities to manage deprecation errors & warnings.

The contents of this module are internal to fpdf2, and not part of the public API. They may change at any time without prior warning or any deprecation period, in non-backward-compatible ways.

Decorator removing deprecated keyword arguments from a function call.

Get the first place in the call stack that is not inside fpdf2

Decorator converting txt= arguments into text= arguments

Create a module object.

The name must be a string; the optional doc argument can have any type.

**Examples:**

Example 1 (python):
```python
def deprecated_parameter(
    parameters: Iterable[tuple[str, str]],
) -> Callable[[Callable[P, R]], Callable[P, R]]:
    """Decorator removing deprecated keyword arguments from a function call."""

    deprecated_info = tuple(parameters)
    _sentinel = object()

    def decorator(fn: Callable[P, R]) -> Callable[P, R]:
        @wraps(fn)
        def wrapper(*args: P.args, **kwargs: P.kwargs) -> R:
            for name, version in deprecated_info:
                if kwargs.pop(name, _sentinel) is not _sentinel:
                    warnings.warn(
                        f'"{name}" parameter is deprecated since v{version} and will be removed in a future release',
                        DeprecationWarning,
                        stacklevel=get_stack_level(),
                    )
            return fn(*args, **kwargs)

        return wrapper

    return decorator
```

Example 2 (python):
```python
def get_stack_level() -> int:
    """Get the first place in the call stack that is not inside fpdf2"""

    # pylint: disable=import-outside-toplevel
    import fpdf  # pylint: disable=cyclic-import

    pkg_dir = os.path.dirname(fpdf.__file__)
    contextlib_dir = os.path.dirname(contextlib.__file__)

    frame = inspect.currentframe()
    n = 0
    while frame is not None:
        fname = inspect.getfile(frame)
        if fname.startswith(pkg_dir) or fname.startswith(contextlib_dir):
            frame = frame.f_back
            n += 1
        else:
            break
    return n
```

Example 3 (python):
```python
def support_deprecated_txt_arg(fn: Callable[P, R]) -> Callable[P, R]:
    """Decorator converting `txt=` arguments into `text=` arguments"""

    @wraps(fn)
    def wrapper(*args: P.args, **kwargs: P.kwargs) -> R:
        txt_value = kwargs.pop("txt", None)
        if txt_value is not None:
            if "text" in kwargs:
                raise ValueError("Both txt= & text= arguments cannot be provided")
            kwargs["text"] = txt_value
            warnings.warn(
                'The parameter "txt" has been renamed to "text" in 2.7.6',
                DeprecationWarning,
                stacklevel=get_stack_level(),
            )
        return fn(*args, **kwargs)

    return wrapper
```

Example 4 (python):
```python
class WarnOnDeprecatedModuleAttributes(ModuleType):
    def __call__(self) -> None:
        raise TypeError(
            "You tried to instantied the fpdf module."
            " You probably want to import the FPDF class instead:"
            " from fpdf import FPDF"
        )

    def __getattr__(self, name: str) -> Any:
        if name in ("FPDF_CACHE_DIR", "FPDF_CACHE_MODE"):
            warnings.warn(
                (
                    "fpdf.FPDF_CACHE_DIR & fpdf.FPDF_CACHE_MODE"
                    " have been deprecated in favour of"
                    " FPDF(font_cache_dir=...)"
                ),
                DeprecationWarning,
                stacklevel=get_stack_level(),
            )
            return None
        return super().__getattribute__(name)

    def __setattr__(self, name: str, value: Any) -> None:
        if name in ("FPDF_CACHE_DIR", "FPDF_CACHE_MODE"):
            warnings.warn(
                (
                    "fpdf.FPDF_CACHE_DIR & fpdf.FPDF_CACHE_MODE"
                    " have been deprecated in favour of"
                    " FPDF(font_cache_dir=...)"
                ),
                DeprecationWarning,
                stacklevel=get_stack_level(),
            )
            return
        super().__setattr__(name, value)
```

---

## Module fpdf.font_type_3

**URL:** https://py-pdf.github.io/fpdf2/fpdf/font_type_3.html

**Contents:**
- Module fpdf.font_type_3
- Functions
- Classes
  - Ancestors
  - Methods
  - Ancestors
  - Static methods
  - Methods
  - Ancestors
  - Class variables

This module provides support for embedding and rendering various color font formats in PDF documents using Type 3 fonts. It defines classes and utilities to handle different color font technologies, including:

Support for CBDT+CBLC bitmap color fonts.

Support for COLRv0 and COLRv1 OpenType color vector fonts. https://learn.microsoft.com/en-us/typography/opentype/spec/colr

COLRv0 is a sequence of glyphs layers with color specification and they are built one on top of the other.

COLRv1 allows for more complex color glyphs by including gradients, transformations, and composite operations.

This class handles both versions of the COLR table by using the drawing API to render the glyphs as vector graphics.

Get the FPDF BlendMode for a given CompositeMode.

Draw a COLRv1 Paint object into the given GraphicsContext. This is an implementation of the COLR version 1 rendering algorithm: https://learn.microsoft.com/en-us/typography/opentype/spec/colr#colr-version-1-rendering-algorithm

Creates a surface representing the whole glyph area for actions that require painting an infinite surface and clipping to a geometry path

Base class for protocol classes.

Protocol classes are defined as::

Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing).

See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as::

The type of the None singleton.

The type of the None singleton.

Base class for protocol classes.

Protocol classes are defined as::

Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing).

See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as::

The type of the None singleton.

Support for SBIX bitmap color fonts.

Support for SVG OpenType vector color fonts.

**Examples:**

Example 1 (python):
```python
def get_color_font_object(
    fpdf: "FPDF", base_font: "TTFFont", palette_index: int = 0
) -> Union[Type3Font, None]:
    if "CBDT" in base_font.ttfont:
        LOGGER.debug("Font %s is a CBLC+CBDT color font", base_font.name)
        return CBDTColorFont(fpdf, base_font)
    if "EBDT" in base_font.ttfont:
        raise NotImplementedError(
            f"{base_font.name} - EBLC+EBDT color font is not supported yet"
        )
    if "COLR" in base_font.ttfont:
        if base_font.ttfont["COLR"].version == 0:
            LOGGER.debug("Font %s is a COLRv0 color font", base_font.name)
        else:
            LOGGER.debug("Font %s is a COLRv1 color font", base_font.name)
        return COLRFont(fpdf, base_font, palette_index)
    if "SVG " in base_font.ttfont:
        LOGGER.debug("Font %s is a SVG color font", base_font.name)
        return SVGColorFont(fpdf, base_font)
    if "sbix" in base_font.ttfont:
        LOGGER.debug("Font %s is a SBIX color font", base_font.name)
        return SBIXColorFont(fpdf, base_font)
    return None
```

Example 2 (python):
```python
class CBDTColorFont(Type3Font):
    """Support for CBDT+CBLC bitmap color fonts."""

    # Only looking at the first strike - Need to look all strikes available on the CBLC table first?
    def glyph_exists(self, glyph_name: str) -> bool:
        return glyph_name in self.base_font.ttfont["CBDT"].strikeData[0]

    def load_glyph_image(self, glyph: Type3FontGlyph) -> None:
        ppem = self.base_font.ttfont["CBLC"].strikes[0].bitmapSizeTable.ppemX
        g = self.base_font.ttfont["CBDT"].strikeData[0][glyph.glyph_name]
        glyph_bitmap = g.data[9:]
        metrics = g.metrics
        if isinstance(metrics, SmallGlyphMetrics):
            x_min = round(metrics.BearingX * self.upem / ppem)
            y_min = round((metrics.BearingY - metrics.height) * self.upem / ppem)
            x_max = round(metrics.width * self.upem / ppem)
            y_max = round(metrics.BearingY * self.upem / ppem)
        elif isinstance(metrics, BigGlyphMetrics):
            x_min = round(metrics.horiBearingX * self.upem / ppem)
            y_min = round((metrics.horiBearingY - metrics.height) * self.upem / ppem)
            x_max = round(metrics.width * self.upem / ppem)
            y_max = round(metrics.horiBearingY * self.upem / ppem)
        else:  # fallback scenario: use font bounding box
            x_min = self.base_font.ttfont["head"].xMin
            y_min = self.base_font.ttfont["head"].yMin
            x_max = self.base_font.ttfont["head"].xMax
            y_max = self.base_font.ttfont["head"].yMax

        bio = BytesIO(glyph_bitmap)
        bio.seek(0)
        _, _, info = self.fpdf.preload_glyph_image(glyph_image_bytes=bio)
        w = round(self.base_font.ttfont["hmtx"].metrics[glyph.glyph_name][0] + 0.001)
        glyph.glyph = (
            f"{round(w * self.scale)} 0 d0\n"
            "q\n"
            f"{(x_max - x_min)* self.scale} 0 0 {(-y_min + y_max)*self.scale} {x_min*self.scale} {y_min*self.scale} cm\n"
            f"/I{info['i']} Do\nQ"
        )
        self.images_used.add(info["i"])  # type: ignore[arg-type]
        glyph.glyph_width = w
```

Example 3 (python):
```python
def glyph_exists(self, glyph_name: str) -> bool:
    return glyph_name in self.base_font.ttfont["CBDT"].strikeData[0]
```

Example 4 (python):
```python
def load_glyph_image(self, glyph: Type3FontGlyph) -> None:
    ppem = self.base_font.ttfont["CBLC"].strikes[0].bitmapSizeTable.ppemX
    g = self.base_font.ttfont["CBDT"].strikeData[0][glyph.glyph_name]
    glyph_bitmap = g.data[9:]
    metrics = g.metrics
    if isinstance(metrics, SmallGlyphMetrics):
        x_min = round(metrics.BearingX * self.upem / ppem)
        y_min = round((metrics.BearingY - metrics.height) * self.upem / ppem)
        x_max = round(metrics.width * self.upem / ppem)
        y_max = round(metrics.BearingY * self.upem / ppem)
    elif isinstance(metrics, BigGlyphMetrics):
        x_min = round(metrics.horiBearingX * self.upem / ppem)
        y_min = round((metrics.horiBearingY - metrics.height) * self.upem / ppem)
        x_max = round(metrics.width * self.upem / ppem)
        y_max = round(metrics.horiBearingY * self.upem / ppem)
    else:  # fallback scenario: use font bounding box
        x_min = self.base_font.ttfont["head"].xMin
        y_min = self.base_font.ttfont["head"].yMin
        x_max = self.base_font.ttfont["head"].xMax
        y_max = self.base_font.ttfont["head"].yMax

    bio = BytesIO(glyph_bitmap)
    bio.seek(0)
    _, _, info = self.fpdf.preload_glyph_image(glyph_image_bytes=bio)
    w = round(self.base_font.ttfont["hmtx"].metrics[glyph.glyph_name][0] + 0.001)
    glyph.glyph = (
        f"{round(w * self.scale)} 0 d0\n"
        "q\n"
        f"{(x_max - x_min)* self.scale} 0 0 {(-y_min + y_max)*self.scale} {x_min*self.scale} {y_min*self.scale} cm\n"
        f"/I{info['i']} Do\nQ"
    )
    self.images_used.add(info["i"])  # type: ignore[arg-type]
    glyph.glyph_width = w
```

---

## Module fpdf.annotations

**URL:** https://py-pdf.github.io/fpdf2/fpdf/annotations.html

**Contents:**
- Module fpdf.annotations
- Classes
  - Ancestors
  - Instance variables
  - Methods
  - Subclasses
  - Ancestors
  - Instance variables
  - Methods
  - Ancestors

Usage documentation at: https://py-pdf.github.io/fpdf2/Annotations.html

A PDF annotation that get serialized as an inline <>

Inherited from: PDFObject.content_stream

Subclasses can override this method to indicate the presence of a content stream

Inherited from: PDFObject.serialize

Serialize the PDF object as an obj<</>>endobj text block

A PDF annotation that get serialized as an obj<</>>endobj block

Inherited from: PDFObject.content_stream

Subclasses can override this method to indicate the presence of a content stream

Inherited from: PDFObject.serialize

Serialize the PDF object as an obj<</>>endobj text block

Inherited from: PDFContentStream.content_stream

Subclasses can override this method to indicate the presence of a content stream

Inherited from: PDFContentStream.serialize

Serialize the PDF object as an obj<</>>endobj text block

**Examples:**

Example 1 (python):
```python
class AnnotationDict(AnnotationMixin):
    "A PDF annotation that get serialized as an inline <<dictionary>>"

    __slots__ = (  # RAM usage optimization
        "type",
        "subtype",
        "rect",
        "border",
        "f_t",
        "v",
        "f",
        "contents",
        "a",
        "dest",
        "c",
        "t",
        "quad_points",
        "p",
        "name",
        "ink_list",
        "f_s",
        "d_a",
    )

    def serialize(
        self,
        _security_handler: Optional["StandardSecurityHandler"] = None,
        _obj_id: Optional[int] = None,
    ) -> str:
        obj_dict = build_obj_dict(
            {key: getattr(self, key) for key in dir(self)},
            _security_handler=_security_handler,
            _obj_id=_obj_id,
        )
        return pdf_dict(obj_dict)

    def __repr__(self) -> str:
        keys = [key for key in dir(self) if not key.startswith("__")]
        d = {key: getattr(self, key) for key in keys}
        d = {key: value for key, value in d.items() if not callable(value)}
        return f"AnnotationDict(**{d})"
```

Example 2 (python):
```python
class AnnotationDict(AnnotationMixin):
    "A PDF annotation that get serialized as an inline <<dictionary>>"

    __slots__ = (  # RAM usage optimization
        "type",
        "subtype",
        "rect",
        "border",
        "f_t",
        "v",
        "f",
        "contents",
        "a",
        "dest",
        "c",
        "t",
        "quad_points",
        "p",
        "name",
        "ink_list",
        "f_s",
        "d_a",
    )

    def serialize(
        self,
        _security_handler: Optional["StandardSecurityHandler"] = None,
        _obj_id: Optional[int] = None,
    ) -> str:
        obj_dict = build_obj_dict(
            {key: getattr(self, key) for key in dir(self)},
            _security_handler=_security_handler,
            _obj_id=_obj_id,
        )
        return pdf_dict(obj_dict)

    def __repr__(self) -> str:
        keys = [key for key in dir(self) if not key.startswith("__")]
        d = {key: getattr(self, key) for key in keys}
        d = {key: value for key, value in d.items() if not callable(value)}
        return f"AnnotationDict(**{d})"
```

Example 3 (python):
```python
class AnnotationDict(AnnotationMixin):
    "A PDF annotation that get serialized as an inline <<dictionary>>"

    __slots__ = (  # RAM usage optimization
        "type",
        "subtype",
        "rect",
        "border",
        "f_t",
        "v",
        "f",
        "contents",
        "a",
        "dest",
        "c",
        "t",
        "quad_points",
        "p",
        "name",
        "ink_list",
        "f_s",
        "d_a",
    )

    def serialize(
        self,
        _security_handler: Optional["StandardSecurityHandler"] = None,
        _obj_id: Optional[int] = None,
    ) -> str:
        obj_dict = build_obj_dict(
            {key: getattr(self, key) for key in dir(self)},
            _security_handler=_security_handler,
            _obj_id=_obj_id,
        )
        return pdf_dict(obj_dict)

    def __repr__(self) -> str:
        keys = [key for key in dir(self) if not key.startswith("__")]
        d = {key: getattr(self, key) for key in keys}
        d = {key: value for key, value in d.items() if not callable(value)}
        return f"AnnotationDict(**{d})"
```

Example 4 (python):
```python
class AnnotationDict(AnnotationMixin):
    "A PDF annotation that get serialized as an inline <<dictionary>>"

    __slots__ = (  # RAM usage optimization
        "type",
        "subtype",
        "rect",
        "border",
        "f_t",
        "v",
        "f",
        "contents",
        "a",
        "dest",
        "c",
        "t",
        "quad_points",
        "p",
        "name",
        "ink_list",
        "f_s",
        "d_a",
    )

    def serialize(
        self,
        _security_handler: Optional["StandardSecurityHandler"] = None,
        _obj_id: Optional[int] = None,
    ) -> str:
        obj_dict = build_obj_dict(
            {key: getattr(self, key) for key in dir(self)},
            _security_handler=_security_handler,
            _obj_id=_obj_id,
        )
        return pdf_dict(obj_dict)

    def __repr__(self) -> str:
        keys = [key for key in dir(self) if not key.startswith("__")]
        d = {key: getattr(self, key) for key in keys}
        d = {key: value for key, value in d.items() if not callable(value)}
        return f"AnnotationDict(**{d})"
```

---

## Page Labels¬∂

**URL:** https://py-pdf.github.io/fpdf2/PageLabels.html

**Contents:**
- Page Labels¬∂
- Overview¬∂
- Page Label Components¬∂
  - 1. Style¬∂
  - 2. Prefix¬∂
  - 3. Start¬∂
- Using Page Labels in fpdf2¬∂
  - Adding a Page with Labels in add_page()¬∂
  - Modifying Page Labels with set_page_label()¬∂
  - Retrieving the Current Page Label with get_page_label()¬∂

In a PDF document, each page is identified by an integer page index, representing the page's position within the document. Optionally, a document can also define page labels to visually display page identifiers.

Page labels can be customized. For example, a document might begin with front matter numbered in roman numerals and transition to arabic numerals for the main content. In this case:

The most popular PDF readers, such as Sumatra PDF and Adobe Acrobat Reader, will accurately display page labels as configured in the PDF. However, not all PDF readers support this feature, and some may not honor or display page labels correctly. In particular, browser-based PDF viewers, like those in Chrome and Edge, currently do not display page labels and will only show default page numbering.

A page label consists of three main parts: Style, Prefix, and Start.

The style defines the numbering format for the numeric portion of each page label. Available styles are:

The prefix is an optional string added before the numeric portion of each page label. For instance, a prefix of "Appendix-" with a style of "D" might result in labels like "Appendix-1", "Appendix-2", etc.

The starting number for the first page of a labeled section. This is the initial numeric value applied to the first page of the label range.

You can add page labels directly when adding a new page using the add_page() method or update them later using set_page_label().

When adding a page, you can specify the values for label_style, label_prefix, and label_start to define the page label. Here‚Äôs how to do it:

You can also modify page labels after a page has been added by using set_page_label(). This is helpful to set a new label after adding a ToC placeholder or other action that automatically adds a page break, but keep in mind set_page_label() will always happen after the header have been rendered. If you need this, prefer to have the label written on footer only.

If you need to get the current page label, for example, to display it in a header or footer, you can use the get_page_label() method.

In case of a table of contents spanning more than one page, the page number returned by get_page_label() will be incorrect.cf. GitHub issue #1343

Below is a complete example that demonstrates adding multiple pages with different page label styles and prefixes:

This example creates a document with three sections, each using a different labeling style and prefix.

**Examples:**

Example 1 (python):
```python
from fpdf import FPDF

pdf = FPDF()

# Add a page with specific label parameters
pdf.add_page(
    label_style="r",           # Lowercase Roman numerals
    label_prefix="Preface-",   # Prefix for the label
    label_start=1              # Start numbering at 1
)
pdf.output("document_with_labels.pdf")
```

Example 2 (markdown):
```markdown
# Set a page label with style, prefix, and start value
pdf.set_page_label(
    label_style="D",           # Decimal Arabic numerals
    label_prefix="Chapter-",   # Prefix for the label
    label_start=1              # Start numbering at 1
)
```

Example 3 (python):
```python
from fpdf import FPDF

pdf = FPDF()

# Adding front matter with lowercase Roman numerals
pdf.add_page(label_style="r", label_start=1)  # Starts with "i", "ii", "iii", etc.

# Adding main content with decimal numbers and a prefix
pdf.add_page(label_style="D", label_prefix="Chapter-", label_start=1)  # "Chapter-1", "Chapter-2", etc.

# Adding an appendix section with uppercase letters
pdf.add_page(label_style="A", label_prefix="Appendix-", label_start=1)  # "Appendix-A", "Appendix-B", etc.

pdf.output("labeled_document.pdf")
```

---

## Module fpdf.svg

**URL:** https://py-pdf.github.io/fpdf2/fpdf/svg.html

**Contents:**
- Module fpdf.svg
- Functions
- Classes
  - Ancestors
  - Ancestors
  - Instance variables
  - Methods
  - Static methods
- Args
- Returns

Utilities to parse SVG graphics into fpdf.drawing objects.

The contents of this module are internal to fpdf2, and not part of the public API. They may change at any time without prior warning or any deprecation period, in non-backward-compatible ways.

Usage documentation at: https://py-pdf.github.io/fpdf2/SVG.html

Apply the known styles from svg_element to the pdf path/group stylable.

Convert SVG/CSS transform functions into PDF transforms.

Convert an angle value to our canonical angle unit, radians

Convert a length unit to our canonical length unit, pt.

Remove the xmlns namespace from a qualified XML tag name

Create an XML namespace string representation for the given tag name.

Create a lookup for the given name in the given XML namespace.

class to represent percentage values

SVGImage(href, x, y, width, height, svg_obj)

Alias for field number 4

Alias for field number 0

Alias for field number 5

Alias for field number 3

Alias for field number 1

Alias for field number 2

A representation of an SVG that has been converted to a PDF representation.

Create an SVGObject from the contents of the file at filename.

A converted SVGObject.

Handle nested items within a group tag.

Convert an SVG tag into a PDF path object.

Convert an SVG shape tag into a PDF path object. Necessary to make xref (because ShapeBuilder doesn't have access to this object.)

Convert (and simple ) into a PaintedPath with Text runs. - Uses Text baseline at (x,y) - Honors x/y and dx/dy on and direct child - Flattens nested tspans; advanced per-character positioning is not implemented

Resolve a cross-reference to an already-seen SVG element by ID.

Convert the graphics contained in the SVG into the PDF representation.

Directly draw the converted SVG to the given PDF's current page.

The page viewport is used for sizing the SVG.

Collect shape info from the given SVG.

Produce lookups for groups and paths inside the tag

Size the converted SVG paths to the page viewport.

The SVG document size can be specified relative to the rendering viewport (e.g. width=50%). If the converted SVG sizes are relative units, then this computes the appropriate scale transform to size the SVG to the correct dimensions for a page in the current PDF document.

If the SVG document size is specified in absolute units, then it is not scaled.

The same thing as SVGObject.transform_to_rect_viewport().

Size the converted SVG paths to an arbitrarily sized viewport.

The SVG document size can be specified relative to the rendering viewport (e.g. width=50%). If the converted SVG sizes are relative units, then this computes the appropriate scale transform to size the SVG to the correct dimensions for a page in the current PDF document.

A tuple of (width, height, GraphicsContext), where width and height are the resolved width and height (they may be 0. If 0, the returned GraphicsContext will be empty). The GraphicsContext contains all of the paths that were converted from the SVG, scaled to the given viewport size.

A namespace within which methods for converting basic shapes can be looked up.

Convert an SVG into a PDF path.

Convert an SVG into a PDF path.

Convert an SVG into a PDF path.

Create a new path with the appropriate styles.

Convert an SVG into a PDF path.

Convert an SVG into a PDF path.

Convert an SVG into a PDF path.

**Examples:**

Example 1 (python):
```python
@force_nodocument
def apply_styles(
    stylable: PaintedPath | GraphicsContext,
    svg_element: "Element",
    computed_style: Optional[dict[str, Any]] = None,
) -> None:
    """Apply the known styles from `svg_element` to the pdf path/group `stylable`."""
    if computed_style is not None:
        style = computed_style
    else:
        style = {}
        for key, value in html.parse_css_style(
            svg_element.attrib.get("style", "")
        ).items():
            norm_value = _normalize_css_value(value)
            if norm_value is not None:
                style[key] = norm_value
    stylable.style.auto_close = False

    for attr_name, converter in svg_attr_map.items():
        attr_value = _normalize_css_value(style.get(attr_name))
        if attr_value is None:
            attr_value = _normalize_css_value(svg_element.attrib.get(attr_name))
        if attr_value is not None:
            setattr(stylable.style, *converter(attr_value))

    # handle this separately for now
    opacity_str = _normalize_css_value(style.get("opacity"))
    if opacity_str is None:
        opacity_str = _normalize_css_value(svg_element.attrib.get("opacity"))
    if opacity_str is not None:
        opacity = float(opacity_str)
        stylable.style.fill_opacity = opacity
        stylable.style.stroke_opacity = opacity

    tfstr = svg_element.attrib.get("transform")
    if tfstr:
        stylable.transform = convert_transforms(tfstr)
```

Example 2 (python):
```python
@force_nodocument
def clamp_float(min_val: float, max_val: float) -> Callable[[str], float]:
    def converter(value: str) -> float:
        val = float(value)
        if val < min_val:
            return min_val
        if val > max_val:
            return max_val
        return val

    return converter
```

Example 3 (python):
```python
@force_nodocument
def convert_miterlimit(incoming: str) -> float:
    val = float(incoming)
    if val < 1.0:
        raise ValueError(f"miter limit {incoming} cannot be less than 1")
    return val
```

Example 4 (python):
```python
@force_nodocument
def convert_stroke_width(incoming: str) -> Optional[float]:
    val = resolve_length(incoming)
    if val < 0:
        raise ValueError(f"stroke width {incoming} cannot be negative")
    if val == 0:
        return None
    return val
```

---

## fpdf2¬∂

**URL:** https://py-pdf.github.io/fpdf2/index.html

**Contents:**
- fpdf2¬∂
- Main features¬∂
- Tutorials¬∂
- Installation¬∂
  - Displaying deprecation warnings¬∂
- Community¬∂
  - Support¬∂
  - They use fpdf2¬∂
  - Usage statistics¬∂
  - Related¬∂

fpdf2 is a library for simple & fast PDF document generation in Python. It is a fork and the successor of PyFPDF (cf. history).

Latest Released Version:

Go try it now online in a Jupyter notebook: or

From PyPI: pip install fpdf2

To get the latest, unreleased, development version straight from the development branch of this repository:

Development: check the dedicated documentation page.

DeprecationWarnings are not displayed by Python by default.

Hence, every time you use a newer version of fpdf2, we strongly encourage you to execute your scripts with the -Wd option (cf. documentation) in order to get warned about deprecated features used in your code.

This can also be enabled programmatically with warnings.simplefilter('default', DeprecationWarning).

For community support, please feel free to file an issue or open a discussion.

Online classes & open source projects:

**Examples:**

Example 1 (python):
```python
from fpdf import FPDF

pdf = FPDF()
pdf.add_page()
pdf.set_font('Helvetica', size=12)
pdf.cell(text="Hello world!")
pdf.output("hello_world.pdf")
```

Example 2 (unknown):
```unknown
pip install fpdf2
```

Example 3 (python):
```python
pip install git+https://github.com/py-pdf/fpdf2.git@master
```

---

## Module fpdf.actions

**URL:** https://py-pdf.github.io/fpdf2/fpdf/actions.html

**Contents:**
- Module fpdf.actions
- Classes
- Args
  - Ancestors
  - Subclasses
  - Methods
- Args
  - Ancestors
  - Methods
- Args

Helper class that provides a standard way to create an ABC using inheritance.

Helper class that provides a standard way to create an ABC using inheritance.

Helper class that provides a standard way to create an ABC using inheritance.

As of 2022, this does not seem honored by neither Adobe Acrobat nor Sumatra readers.

Helper class that provides a standard way to create an ABC using inheritance.

Helper class that provides a standard way to create an ABC using inheritance.

**Examples:**

Example 1 (python):
```python
class Action(ABC):
    def __init__(self, next_action: Optional["Action"] = None) -> None:
        """
        Args:
            next (PDFObject | str): optional reference to another Action to trigger after this one
        """
        self.next = next_action

    def serialize(
        self,
        _security_handler: Optional["StandardSecurityHandler"] = None,
        _obj_id: Optional[int] = None,
    ) -> str:
        raise NotImplementedError

    def _serialize(
        self,
        key_values: Optional[dict[str, object]] = None,
        _security_handler: Optional["StandardSecurityHandler"] = None,
        _obj_id: Optional[int] = None,
    ) -> str:
        if key_values is None:
            key_values = {}
        if self.next:
            key_values["Next"] = self.next
        obj_dict = build_obj_dict(key_values, _security_handler, _obj_id)
        return create_dictionary_string(obj_dict, field_join=" ")
```

Example 2 (python):
```python
def serialize(
    self,
    _security_handler: Optional["StandardSecurityHandler"] = None,
    _obj_id: Optional[int] = None,
) -> str:
    raise NotImplementedError
```

Example 3 (python):
```python
class GoToAction(Action):
    def __init__(
        self, dest: Union[str, "Destination"], next_action: Optional[Action] = None
    ) -> None:
        super().__init__(next_action)
        if isinstance(dest, str) and dest.startswith("#"):
            dest = PDFString(dest[1:], encrypt=True)
        self.dest = dest

    def serialize(
        self,
        _security_handler: Optional["StandardSecurityHandler"] = None,
        _obj_id: Optional[int] = None,
    ) -> str:
        return super()._serialize(
            {"s": "/GoTo", "d": self.dest},
            _security_handler=_security_handler,
            _obj_id=_obj_id,
        )
```

Example 4 (python):
```python
def serialize(
    self,
    _security_handler: Optional["StandardSecurityHandler"] = None,
    _obj_id: Optional[int] = None,
) -> str:
    return super()._serialize(
        {"s": "/GoTo", "d": self.dest},
        _security_handler=_security_handler,
        _obj_id=_obj_id,
    )
```

---

## Package fpdf

**URL:** https://py-pdf.github.io/fpdf2/fpdf/index.html

**Contents:**
- Package fpdf
- Sub-modules
- Global variables

Root module. Gives direct access to some classes defined in submodules:

Usage documentation at: https://py-pdf.github.io/fpdf2/Annotations.html

Utilities to manage deprecation errors & warnings ‚Ä¶

Vector drawing: managing colors, graphics states, paths, transforms ‚Ä¶

Core drawing primitives for fpdf2 ‚Ä¶

Utilities to perform encryption following the PDF standards ‚Ä¶

This module provides support for embedding and rendering various color font formats in PDF documents using Type 3 fonts. It defines classes and ‚Ä¶

Font-related classes & constants. Includes the definition of the character widths of all PDF standard fonts ‚Ä¶

Mixin class for managing a stack of graphics state variables ‚Ä¶

Routines for organizing lines and larger blocks of text, with manual and automatic line wrapping ‚Ä¶

This module is in work-in-progress state. Hint tables / hint streams have not been implemented yet, and there are a few "TODO" comment remaining. cf ‚Ä¶

Quoting section 8.2.2 "Document Outline" of the 2006 PDF spec 1.7:

The document outline consists of a tree-structured hierarchy of outline items ‚Ä¶

This module contains the serialization logic that produces a PDF document from a FPDF instance. Most of the code in this module is used when ‚Ä¶

Handles the creation of patterns and gradients ‚Ä¶

Usage documentation at: https://py-pdf.github.io/fpdf2/PageFormatAndOrientation.html#viewer-preferences

A wrapper class to allow rewinding/replaying changes made to a FPDF instance ‚Ä¶

Module dedicated to document signature generation ‚Ä¶

Quoting the PDF spec:

PDF‚Äôs logical structure facilities provide a mechanism for incorporating structural information about a document‚Äôs content ‚Ä¶

Utilities to parse SVG graphics into fpdf.drawing objects ‚Ä¶

Classes & functions that represent core elements of the PDF syntax ‚Ä¶

Usage documentation at: https://py-pdf.github.io/fpdf2/Tables.html

PDF template helpers for fpdf2 ‚Ä¶

Usage documentation at: https://py-pdf.github.io/fpdf2/TextRegion.html

Usage documentation at: https://py-pdf.github.io/fpdf2/Presentations.html#transitions

The hardcoded information on this module was loaded from the Unicode file Scripts-16.0.0.txt https://www.unicode.org/Public/UNIDATA/Scripts.txt ‚Ä¶

Various utilities that could not be gathered logically in a specific module ‚Ä¶

Extra filesystem folder where fpdf2 looks for fonts files, after the current directory

Current fpdf2 version, also available as __version__

---

## Module fpdf.drawing

**URL:** https://py-pdf.github.io/fpdf2/fpdf/drawing.html

**Contents:**
- Module fpdf.drawing
- Functions
- Classes
  - Ancestors
  - Static methods
- Args
- Yields
  - Instance variables
  - Methods
- Args

Vector drawing: managing colors, graphics states, paths, transforms‚Ä¶

The contents of this module are internal to fpdf2, and not part of the public API. They may change at any time without prior warning or any deprecation period, in non-backward-compatible ways.

Usage documentation at: https://py-pdf.github.io/fpdf2/Drawing.html

An elliptical arc path element.

The arc is drawn from the end of the current path element to its specified end point using a number of parameters to determine how it is constructed.

See: PaintedPath.arc_to()

A generator that subdivides a swept angle into segments no larger than a quarter turn.

Any sweep that is larger than a quarter turn is subdivided into as many equally sized segments as necessary to prevent any individual segment from being larger than a quarter turn.

This is used for approximating a circular curve segment using cubic B√©zier curves. This computes the parameters used for the B√©zier approximation up front, as well as the transform necessary to place the segment in the correct position.

A tuple of (ctrl1, ctrl2, end) representing the control and end points of the cubic B√©zier curve approximating the segment as a unit circle centered at the origin.

The end point of the arc.

The end point of this path element.

If True, sweep the arc over an angle greater than or equal to 180 degrees.

The x- and y-radii of the arc. If radii.x == radii.y the arc will be circular.

The rotation of the arc's major/minor axes relative to the coordinate frame.

If True, the arc is swept in the positive angular direction.

Compute the bounding box of this arc by approximating it with a series of Bezier curves and aggregating their bounding boxes.

Render this path element to its PDF representation.

a tuple of (str, new_last_item), where new_last_item is a resolved BezierCurve.

A cubic B√©zier curve path element.

This draws a B√©zier curve parameterized by the end point of the previous path element, two off-curve control points, and an end point.

See: PaintedPath.curve_to()

The curve's first control point.

The curve's second control point.

The curve's end point.

The end point of this path element.

Compute the bounding box of this cubic B√©zier curve.

Render this path element to its PDF representation.

a tuple of (str, new_last_item), where new_last_item is self

Represents a bounding box, with utility methods for creating and manipulating them.

Return an 'empty' bounding box with extreme values that collapse on merge.

Given a list of points, create a bounding box that encloses them all.

Return the height of the bounding box.

Return the width of the bounding box.

Alias for field number 0

Alias for field number 2

Alias for field number 1

Alias for field number 3

Clockwise corners (x,y): (x0,y0),(x1,y0),(x1,y1),(x0,y1).

Return a new bounding box expanded by the given amounts in each direction.

Expand this bbox to include stroke coverage, given a graphics style.

Return True if the bounding box is not empty.

Max Euclidean distance from (cx,cy) to any bbox corner.

Expand this bounding box to include another one.

Project bbox corners onto the axis from (x1,y1) to (x2,y2). Returns (tmin, tmax, L) where: - L is the axis length - t are distances along the axis with t=0 at (x1,y1)

Convert bounding box to a PDF array string.

Convert bounding box to a 4-tuple.

Return a new bounding box resulting from applying a transform to this one.

The PaintedPath API but to be used to create clipping paths.

Unless you really know what you're doing, changing attributes of the clipping path style is likely to produce unexpected results. This is because the clipping path styles override implicit style inheritance of the PaintedPath it applies to.

For example, clippath.style.stroke_width = 2 can unexpectedly override paintpath.style.stroke_width = GraphicsStyle.INHERIT and cause the painted path to be rendered with a stroke of 2 instead of what it would have normally inherited. Because a ClippingPath can be painted like a normal PaintedPath, it would be overly restrictive to remove the ability to style it, so instead this warning is here.

Inherited from: PaintedPath.auto_close

If true, the path should automatically close itself before painting.

Inherited from: PaintedPath.clipping_path

Set the clipping path for this path.

Inherited from: PaintedPath.paint_rule

Manually specify the PathPaintRule to use for rendering the path.

Inherited from: PaintedPath.style

The GraphicsStyle applied to all elements of this path.

Inherited from: PaintedPath.transform

The Transform that applies to all of the elements of this path.

Inherited from: PaintedPath.add_path_element

Add the given element as a path item of this path ‚Ä¶

Inherited from: PaintedPath.arc_relative

Append an elliptical arc from the end of the previous path point to an offset point ‚Ä¶

Inherited from: PaintedPath.arc_to

Append an elliptical arc from the end of the previous path point to the specified end point ‚Ä¶

Inherited from: PaintedPath.bounding_box

Compute the bounding box of this painted path, including nested contexts and transformations.

Inherited from: PaintedPath.circle

Append a circle as a closed subpath to the current path ‚Ä¶

Inherited from: PaintedPath.close

Explicitly close the current (sub)path.

Inherited from: PaintedPath.curve_relative

Append a cubic B√©zier curve whose points are expressed relative to the end point of the previous path element ‚Ä¶

Inherited from: PaintedPath.curve_to

Append a cubic B√©zier curve to this path ‚Ä¶

Inherited from: PaintedPath.ellipse

Append an ellipse as a closed subpath to the current path ‚Ä¶

Inherited from: PaintedPath.horizontal_line_relative

Append a straight horizontal line to the given offset from the previous path element. The ordinate is retrieved from the end point of the previous ‚Ä¶

Inherited from: PaintedPath.horizontal_line_to

Append a straight horizontal line to the given abscissa. The ordinate is retrieved from the end point of the previous path element ‚Ä¶

Inherited from: PaintedPath.line_relative

Append a straight line whose end is computed as an offset from the end of the previous path element ‚Ä¶

Inherited from: PaintedPath.line_to

Append a straight line to this path ‚Ä¶

Inherited from: PaintedPath.move_relative

Start a new subpath or move the path start point relative to the previous point ‚Ä¶

Inherited from: PaintedPath.move_to

Start a new subpath or move the path starting point ‚Ä¶

Inherited from: PaintedPath.quadratic_curve_relative

Append a cubic B√©zier curve mimicking the specified quadratic B√©zier curve ‚Ä¶

Inherited from: PaintedPath.quadratic_curve_to

Append a cubic B√©zier curve mimicking the specified quadratic B√©zier curve ‚Ä¶

Inherited from: PaintedPath.rectangle

Append a rectangle as a closed subpath to the current path ‚Ä¶

Inherited from: PaintedPath.text

Append a text run at (x, y) to this path ‚Ä¶

Inherited from: PaintedPath.transform_group

Apply the provided Transform to all points added within this context.

Inherited from: PaintedPath.vertical_line_relative

Append a straight vertical line to the given offset from the previous path element. The abscissa is retrieved from the end point of the previous path ‚Ä¶

Inherited from: PaintedPath.vertical_line_to

Append a straight vertical line to the given ordinate. The abscissa is retrieved from the end point of the previous path element ‚Ä¶

A path close element.

Instructs the renderer to draw a straight line from the end of the last path element to the start of the current path.

See: PaintedPath.close()

The end point of a Close is undefined; return (0, 0).

Return an empty bounding box; Close does not affect the geometry.

Render this path element to its PDF representation.

a tuple of (str, new_last_item), where new_last_item is whatever the old last_item was.

Base context for a drawing in a PDF

This context is not stylable and is mainly responsible for transforming path drawing coordinates into user coordinates (i.e. it ensures that the output drawing is correctly scaled).

Append an item to this drawing context

Render the drawing context to PDF format.

A string composed of the PDF representation of all the paths and groups in this context (an empty string is returned if there are no paths or groups)

See: PaintedPath.ellipse()

The abscissa and ordinate of the center of the ellipse

The x- and y-radii of the ellipse

Compute the bounding box of this ellipse by decomposing it and merging the bounding boxes of its components.

Render this path element to its PDF representation.

a tuple of (str, new_last_item), where new_last_item is a resolved Move to the center of the ellipse.

A pen that can be used to draw glyphs into a PaintedPath.

Takes a 'glyphSet' argument (dict), in which the glyphs that are referenced as components are looked up by their name.

If the optional 'reverseFlipped' argument is True, components whose transformation matrix has a negative determinant will be decomposed with a reversed path direction to compensate for the flip.

The optional 'skipMissingComponents' argument can be set to True/False to override the homonymous class attribute for a given pen instance.

Fill/stroke paint using a gradient

Page-level container that collects drawable items and renders them into a PDF content stream.

Converts model coordinates to PDF user space by applying the provided scale and a vertical flip so (0, 0) is the top-left of the page.

Wraps output in a saved graphics state (q ‚Ä¶ Q) and registers any required resources (graphics state dictionaries, soft masks, dash pattern).

Child items are typically GraphicsContext, PaintedPath, or PaintComposite objects added via add_item(). By default, items are deep-copied on insert to avoid later mutations affecting the emitted stream.

The ClippingPath for this graphics context.

Add a path element to this graphics context.

Compute bbox of all path items. We: 1) recurse with accumulated CTM, 2) merge child bboxes already transformed to this level, 3) at the end, expand once for stroke using the worst-case CTM row norms.

Build a list composed of all all the individual elements rendered.

This is used by PaintedPath and ClippingPath to reuse the GraphicsContext rendering process while still being able to inject some path specific items (e.g. the painting directive) before the render is collapsed into a single string.

tuple[list[str], last_item] where last_item is the past path element in this GraphicsContext

Copy another GraphicsContext's path items into this one.

A class representing various style attributes that determine drawing appearance.

This class uses the convention that the global Python singleton ellipsis (‚Ä¶) is exclusively used to represent values that are inherited from the parent style. This is to disambiguate the value None which is used for several values to signal an explicitly disabled style. An example of this is the fill/stroke color styles, which use None as hints to the auto paint style detection code.

Singleton specifying a style parameter should be inherited from the parent context.

An ordered collection of properties to use when merging two GraphicsStyles.

An ordered collection of keys to directly emit when serializing the style.

An ordered collection of attributes not to emit in no transparency mode.

Merge parent and child into a single GraphicsStyle.

The result contains the properties of the parent as overridden by any properties explicitly set on the child. If both the parent and the child specify to inherit a given property, that property will preserve the inherit value.

If True, unclosed paths will be automatically closed before stroking.

The desired blend mode for this path/group.

The desired fill color for this path/group.

When setting this property, if the color specifies an opacity value, that will be used to set the fill_opacity property as well.

The desired fill opacity for this path/group.

The desired intersection rule for this path/group.

The paint rule to use for this path/group.

The desired stroke cap style for this path/group.

The desired stroke color for this path/group.

When setting this property, if the color specifies an opacity value, that will be used to set the fill_opacity property as well.

The desired stroke dash pattern for this path/group.

The desired stroke dash pattern phase offset for this path/group.

The desired stroke join style for this path/group.

The desired stroke miter limit for this path/group.

The desired stroke opacity for this path/group.

The desired stroke width for this path/group.

Resolve PathPaintRule.AUTO to a real paint rule based on this style.

the resolved PathPaintRule.

Convert this style object to a PDF dictionary with appropriate style keys.

Only explicitly specified values are emitted.

A path line element that takes its ordinate from the end of the previous element.

See: PaintedPath.horizontal_line_to()

The abscissa of the horizontal line's end point.

Compute the bounding box of a horizontal line from the start point to the new x.

Render this path element to its PDF representation.

a tuple of (str, new_last_item), where new_last_item is the resolved Line.

A path close element that is conditionally rendered depending on the value of GraphicsStyle.auto_close.

Return an empty bounding box; Close does not affect the geometry.

Render this path element to its PDF representation.

a tuple of (str, new_last_item), where new_last_item is whatever the old last_item was.

This draws a straight line from the end point of the previous path element to the point specified by pt.

See: PaintedPath.line_to()

The end point of this path element.

The point to which the line is drawn.

Compute the bounding box of a line from the start point to the end point.

Render this path element to its PDF representation.

a tuple of (str, new_last_item), where new_last_item is self

If a path has been created but not yet painted, this will create a new subpath.

See: PaintedPath.move_to()

The end point of this path element.

The point to which to move.

Render this path element to its PDF representation.

a tuple of (str, new_last_item), where new_last_item is self

Wraps a vector path as a PDF soft mask (SMask) that can be attached to a graphics state.

The provided mask_path is deep-copied and forced to render as an opaque grayscale fill (white, alpha=1, nonzero rule, transparency disabled). During rendering, the mask‚Äôs content stream is generated and its resource dictionary is collected so it can be embedded as a Form XObject and referenced from an ExtGState.

Build a GraphicsContext that encodes the alpha ramps contributed by any GradientPaint used by node. Each contributing PaintedPath yields one rectangle covering its content-space bounding box; that rectangle is filled with an _AlphaGradientPaint (the gradient‚Äôs alpha channel only). Rectangles are stacked with BM=Multiply so multiple alpha sources combine multiplicatively.

Return a deep-copied version of node whose appearance encodes only its geometric coverage: every shape is converted to an opaque white fill (nonzero rule), with no stroke, no soft mask, and inherited blend mode.

The transform/clipping/structure of the original node is preserved; only paint-related attributes are normalized. This is intended for building the ‚ÄúB‚Äù term of soft-mask expressions (coverage), where inside = 1 and outside = 0.

Construct a luminosity soft mask from two ingredients:

The mask luminance is: - A √ó B when invert = False - A √ó (1 ‚àí B) when invert = True

Implementation outline: 1. Compute the union bbox of A and B (no stroke expansion). 2. Paint a background rectangle: black for A√óB or white for A√ó(1‚àíB). 3. Paint B; when invert=True, set BM=Difference to obtain 1‚àíB from the white background. 4. If A is present, paint it with BM=Multiply to apply the alpha ramp. 5. Wrap the result as a Form XObject and attach it as /SMask with /S /Luminosity.

Build the resource dictionary for this soft mask, resolving GS & Pattern ids.

A path to be drawn by the PDF renderer.

A painted path is defined by a style and an arbitrary sequence of path elements, which include the primitive path elements (Move, Line, BezierCurve, ‚Ä¶) as well as arbitrarily nested GraphicsContext containing their own sequence of primitive path elements and GraphicsContext.

If true, the path should automatically close itself before painting.

Set the clipping path for this path.

Manually specify the PathPaintRule to use for rendering the path.

The GraphicsStyle applied to all elements of this path.

The Transform that applies to all of the elements of this path.

Add the given element as a path item of this path.

Append an elliptical arc from the end of the previous path point to an offset point.

The arc is approximated using B√©zier curves, so it is not perfectly accurate. However, the error is small enough to not be noticeable at any reasonable (and even most unreasonable) scales, with a worst-case deviation of around 3‚Ä±.

Append an elliptical arc from the end of the previous path point to the specified end point.

The arc is approximated using B√©zier curves, so it is not perfectly accurate. However, the error is small enough to not be noticeable at any reasonable (and even most unreasonable) scales, with a worst-case deviation of around 3‚Ä±.

Compute the bounding box of this painted path, including nested contexts and transformations.

Append a circle as a closed subpath to the current path.

The path, to allow chaining method calls.

Explicitly close the current (sub)path.

Append a cubic B√©zier curve whose points are expressed relative to the end point of the previous path element.

E.g. with a start point of (0, 0), given (1, 1), (2, 2), (3, 3), the output curve would have the points:

(0, 0) c1 (1, 1) c2 (3, 3) e (6, 6)

The path, to allow chaining method calls.

Append a cubic B√©zier curve to this path.

The path, to allow chaining method calls.

Append an ellipse as a closed subpath to the current path.

The path, to allow chaining method calls.

Append a straight horizontal line to the given offset from the previous path element. The ordinate is retrieved from the end point of the previous path element.

The path, to allow chaining method calls.

Append a straight horizontal line to the given abscissa. The ordinate is retrieved from the end point of the previous path element.

The path, to allow chaining method calls.

Append a straight line whose end is computed as an offset from the end of the previous path element.

The path, to allow chaining method calls.

Append a straight line to this path.

The path, to allow chaining method calls.

Start a new subpath or move the path start point relative to the previous point.

If no path elements have been added yet, this will change the path starting point. If path elements have been added, this will insert an implicit close in order to start a new subpath.

This will overwrite an absolute move_to as long as no non-move path items have been appended. The relative position is resolved from the previous item when the path is being rendered, or from 0, 0 if it is the first item.

Start a new subpath or move the path starting point.

If no path elements have been added yet, this will change the path starting point. If path elements have been added, this will insert an implicit close in order to start a new subpath.

The path, to allow chaining method calls.

Append a cubic B√©zier curve mimicking the specified quadratic B√©zier curve.

The path, to allow chaining method calls.

Append a cubic B√©zier curve mimicking the specified quadratic B√©zier curve.

The path, to allow chaining method calls.

Append a rectangle as a closed subpath to the current path.

If the width or the height are 0, the rectangle will be collapsed to a line (unless they're both 0, in which case it's collapsed to nothing).

The path, to allow chaining method calls.

Append a text run at (x, y) to this path.

The baseline is at (x, y). text_anchor controls alignment about x. font_style accepts "", "B", "I", or "BI". font_family can be a single name or a comma-separated fallback list (handled at render-time).

self (to allow chaining)

Apply the provided Transform to all points added within this context.

Append a straight vertical line to the given offset from the previous path element. The abscissa is retrieved from the end point of the previous path element.

The path, to allow chaining method calls.

Append a straight vertical line to the given ordinate. The abscissa is retrieved from the end point of the previous path element.

The path, to allow chaining method calls.

Base class for drawing pens. You must override _moveTo, _lineTo and _curveToOne. You may additionally override _closePath, _endPath, addComponent, addVarComponent, and/or _qCurveToOne. You should not override any other methods.

Takes a 'glyphSet' argument (dict), in which the glyphs that are referenced as components are looked up by their name.

If the optional 'reverseFlipped' argument is True, components whose transformation matrix has a negative determinant will be decomposed with a reversed path direction to compensate for the flip.

The optional 'skipMissingComponents' argument can be set to True/False to override the homonymous class attribute for a given pen instance.

A quadratic B√©zier curve path element.

This draws a B√©zier curve parameterized by the end point of the previous path element, one off-curve control point, and an end point.

See: PaintedPath.quadratic_curve_to()

The curve's control point.

The curve's end point.

The end point of this path element.

Compute the bounding box of this quadratic B√©zier curve by converting it to a cubic B√©zier.

Render this path element to its PDF representation.

a tuple of (str, new_last_item), where new_last_item is self.

A pdf primitive rectangle.

The end point of a rectangle is the origin.

The top-left corner of the rectangle.

The width and height of the rectangle.

Compute the bounding box of this rectangle.

Render this path element to its PDF representation.

a tuple of (str, new_last_item), where new_last_item is a Line back to the rectangle's origin.

An elliptical arc path element.

The arc is drawn from the end of the current path element to its specified end point using a number of parameters to determine how it is constructed.

See: PaintedPath.arc_relative()

The end point of the arc relative to the end of the previous path element.

If True, sweep the arc over an angle greater than or equal to 180 degrees.

The x- and y-radii of the arc. If radii.x == radii.y the arc will be circular.

The rotation of the arc's major/minor axes relative to the coordinate frame.

If True, the arc is swept in the positive angular direction.

Compute the bounding box of the resolved arc from the given start point.

Render this path element to its PDF representation.

a tuple of (str, new_last_item), where new_last_item is a resolved BezierCurve.

A cubic B√©zier curve path element whose points are specified relative to the end point of the previous path element.

See: PaintedPath.curve_relative()

The curve's first control point relative to the end of the previous path element.

The curve's second control point relative to the end of the previous path element.

The curve's end point relative to the end of the previous path element.

Compute the bounding box of this relative cubic B√©zier curve.

A tuple containing: - BoundingBox: the axis-aligned bounding box containing the entire curve. - Point: the end point of the curve.

Render this path element to its PDF representation.

a tuple of (str, new_last_item), where new_last_item is the resolved BezierCurve.

A path line element that takes its ordinate from the end of the previous element and computes its abscissa offset from the end of that element.

See: PaintedPath.horizontal_line_relative()

The abscissa of the horizontal line's end point relative to the abscissa of the previous path element.

Compute the bounding box of a relative horizontal line.

Render this path element to its PDF representation.

a tuple of (str, new_last_item), where new_last_item is the resolved Line.

A path line element with an endpoint relative to the end of the previous element.

This draws a straight line from the end point of the previous path element to the point specified by last_item.end_point + pt. The absolute coordinates of the end point are resolved during the rendering process.

See: PaintedPath.line_relative()

The endpoint of the line relative to the previous path element.

Compute the bounding box of a relative line from the start point to the new end point.

Render this path element to its PDF representation.

a tuple of (str, new_last_item), where new_last_item is the resolved Line.

A path move element with an end point relative to the end of the previous path element.

If a path has been created but not yet painted, this will create a new subpath.

See: PaintedPath.move_relative()

The offset by which to move.

RelativeMove doesn't draw anything, so it has no bounding box.

Render this path element to its PDF representation.

a tuple of (str, new_last_item), where new_last_item is the resolved Move

A quadratic B√©zier curve path element whose points are specified relative to the end point of the previous path element.

See: PaintedPath.quadratic_curve_relative()

The curve's control point relative to the end of the previous path element.

The curve's end point relative to the end of the previous path element.

Compute the bounding box of this relative quadratic B√©zier curve.

Render this path element to its PDF representation.

a tuple of (str, new_last_item), where new_last_item is the resolved QuadraticBezierCurve.

A path line element that takes its abscissa from the end of the previous element and computes its ordinate offset from the end of that element.

See: PaintedPath.vertical_line_relative()

The ordinate of the vertical line's end point relative to the ordinate of the previous path element.

Compute the bounding box of this relative vertical line.

Render this path element to its PDF representation.

a tuple of (str, new_last_item), where new_last_item is the resolved Line.

Structural type for things that can render themselves into PDF operators and report a geometric bounding box.

A rectangle with rounded corners.

See: PaintedPath.rectangle()

The x- and y-radius of the corners.

The top-left corner of the rectangle.

The width and height of the rectangle.

Compute the bounding box of this rounded rectangle by decomposing into primitives and merging their individual bounding boxes.

Render this path element to its PDF representation.

a tuple of (str, new_last_item), where new_last_item is a resolved Line.

SVG-like text renderable. Stores the anchor position (x, y) and one or more TextRuns that include relative positioning offsets. Accurate glyph positioning is resolved during rendering once font metrics are available.

Alias for field number 3

Alias for field number 2

Alias for field number 0

Alias for field number 1

Compute a conservative bbox for the text.

Font metrics are not available at this stage so the layout relies on approximate glyph widths proportional to the run font size. The actual layout is computed precisely in render().

Emit PDF text operators:

BT Tf Tr (map from GraphicsStyle->PathPaintRule) 1 0 0 1 x y Tm (escaped-text) Tj ET

TextRun(text, family, emphasis, size, dx, dy, abs_x, abs_y, transform, run_style)

Alias for field number 6

Alias for field number 7

Alias for field number 4

Alias for field number 5

Alias for field number 2

Alias for field number 1

Alias for field number 9

Alias for field number 3

Alias for field number 0

Alias for field number 8

A path line element that takes its abscissa from the end of the previous element.

See: PaintedPath.vertical_line_to()

The ordinate of the vertical line's end point.

Compute the bounding box of this vertical line.

Render this path element to its PDF representation.

a tuple of (str, new_last_item), where new_last_item is the resolved Line.

**Examples:**

Example 1 (python):
```python
def clone_structure(
    node: GraphicsContext | PaintedPath,
) -> GraphicsContext | PaintedPath:
    new: GraphicsContext | PaintedPath
    if isinstance(node, GraphicsContext):
        new = GraphicsContext()
        new.style = deepcopy(node.style)
        new.transform = node.transform
        new.clipping_path = node.clipping_path
        new.path_items = [
            (
                clone_structure(ch)
                if isinstance(ch, (GraphicsContext, PaintedPath))
                else ch
            )
            for ch in node.path_items
        ]
        return new

    new = PaintedPath.__new__(PaintedPath)
    root = clone_structure(node.get_graphics_context())
    object.__setattr__(new, "_root_graphics_context", root)
    object.__setattr__(new, "_graphics_context", root)
    object.__setattr__(
        new, "_closed", node._closed  # pyright: ignore[reportPrivateUsage]
    )
    object.__setattr__(new, "_close_context", root)
    object.__setattr__(
        new,
        "_starter_move",
        node._starter_move,  # pyright: ignore[reportPrivateUsage]
    )
    return new
```

Example 2 (python):
```python
class Arc(NamedTuple):
    """
    An elliptical arc path element.

    The arc is drawn from the end of the current path element to its specified end point
    using a number of parameters to determine how it is constructed.

    See: `PaintedPath.arc_to`
    """

    radii: Point
    """
    The x- and y-radii of the arc. If `radii.x == radii.y` the arc will be circular.
    """
    rotation: Number
    """The rotation of the arc's major/minor axes relative to the coordinate frame."""
    large: bool
    """If True, sweep the arc over an angle greater than or equal to 180 degrees."""
    sweep: bool
    """If True, the arc is swept in the positive angular direction."""
    end: Point
    """The end point of the arc."""

    @property
    def end_point(self) -> Point:
        """The end point of this path element."""
        return self.end

    @staticmethod
    @force_nodocument
    def subdivide_sweep(
        sweep_angle: float,
    ) -> Generator[tuple[Point, Point, Point], None, None]:
        """
        A generator that subdivides a swept angle into segments no larger than a quarter
        turn.

        Any sweep that is larger than a quarter turn is subdivided into as many equally
        sized segments as necessary to prevent any individual segment from being larger
        than a quarter turn.

        This is used for approximating a circular curve segment using cubic B√©zier
        curves. This computes the parameters used for the B√©zier approximation up
        front, as well as the transform necessary to place the segment in the correct
        position.

        Args:
            sweep_angle (float): the angle to subdivide.

        Yields:
            A tuple of (ctrl1, ctrl2, end) representing the control and end points of
            the cubic B√©zier curve approximating the segment as a unit circle centered
            at the origin.
        """
        sweep_angle = abs(sweep_angle)
        sweep_left = sweep_angle

        quarterturn = math.pi / 2
        chunks = math.ceil(sweep_angle / quarterturn)

        sweep_segment = sweep_angle / chunks
        cos_t = math.cos(sweep_segment)
        sin_t = math.sin(sweep_segment)
        kappa = 4 / 3 * math.tan(sweep_segment / 4)

        ctrl1 = Point(1, kappa)
        ctrl2 = Point(cos_t + kappa * sin_t, sin_t - kappa * cos_t)
        end = Point(cos_t, sin_t)

        for _ in range(chunks):
            offset = sweep_angle - sweep_left

            transform = Transform.rotation(offset)
            yield ctrl1 @ transform, ctrl2 @ transform, end @ transform

            sweep_left -= sweep_segment

    def _approximate_arc(self, last_item: Renderable) -> list[BezierCurve]:
        """
        Approximate this arc with a sequence of `BezierCurve`.

        Args:
            last_item: the previous path element (used for its end point)

        Returns:
            a list of `BezierCurve`.
        """
        radii = self.radii

        reverse = Transform.rotation(-self.rotation)
        forward = Transform.rotation(self.rotation)

        prime = ((last_item.end_point - self.end) * 0.5) @ reverse

        lam_da = (prime.x / radii.x) ** 2 + (prime.y / radii.y) ** 2

        if lam_da > 1:
            radii = Point(x=(lam_da**0.5) * radii.x, y=(lam_da**0.5) * radii.y)

        sign = (self.large != self.sweep) - (self.large == self.sweep)
        rxry2 = (radii.x * radii.y) ** 2
        rxpy2 = (radii.x * prime.y) ** 2
        rypx2 = (radii.y * prime.x) ** 2

        centerprime = (
            sign
            * math.sqrt(round(rxry2 - rxpy2 - rypx2, 8) / (rxpy2 + rypx2))
            * Point(
                x=radii.x * prime.y / radii.y,
                y=-radii.y * prime.x / radii.x,
            )
        )

        center = (centerprime @ forward) + ((last_item.end_point + self.end) * 0.5)

        arcstart = Point(
            x=(prime.x - centerprime.x) / radii.x,
            y=(prime.y - centerprime.y) / radii.y,
        )
        arcend = Point(
            x=(-prime.x - centerprime.x) / radii.x,
            y=(-prime.y - centerprime.y) / radii.y,
        )

        theta = Point(1, 0).angle(arcstart)
        deltatheta = arcstart.angle(arcend)

        if (self.sweep is False) and (deltatheta > 0):
            deltatheta -= math.tau
        elif (self.sweep is True) and (deltatheta < 0):
            deltatheta += math.tau

        sweep_sign = (deltatheta >= 0) - (deltatheta < 0)
        final_tf = (
            Transform.scaling(x=1, y=sweep_sign)  # flip negative sweeps
            .rotate(theta)  # rotate start of arc to correct position
            .scale(radii.x, radii.y)  # scale unit circle into the final ellipse shape
            .rotate(self.rotation)  # rotate the ellipse the specified angle
            .translate(center.x, center.y)  # translate to the final coordinates
        )

        curves: list[BezierCurve] = []

        for ctrl1, ctrl2, end in self.subdivide_sweep(deltatheta):
            curves.append(
                BezierCurve(ctrl1 @ final_tf, ctrl2 @ final_tf, end @ final_tf)
            )

        return curves

    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:
        """
        Compute the bounding box of this arc by approximating it with a series of
        Bezier curves and aggregating their bounding boxes.
        """
        bbox = BoundingBox.empty()
        prev: Renderable = Move(start)

        for curve in self._approximate_arc(prev):
            segment_bbox, _ = curve.bounding_box(prev.end_point)
            bbox = bbox.merge(segment_bbox)
            prev = curve

        return bbox, self.end

    @force_nodocument
    def render(
        self,
        resource_registry: "ResourceCatalog",
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
    ) -> tuple[str, Renderable, Point]:
        """
        Render this path element to its PDF representation.

        Args:
            resource_registry (ResourceCatalog): the owner's graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a "M" or "m" command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is a resolved
            `BezierCurve`.
        """
        curves = self._approximate_arc(last_item)

        if not curves:
            return "", last_item, initial_point

        return (
            " ".join(
                curve.render(resource_registry, style, prev, initial_point)[0]
                for prev, curve in zip([last_item, *curves[:-1]], curves)
            ),
            curves[-1],
            initial_point,
        )
```

Example 3 (python):
```python
@staticmethod
@force_nodocument
def subdivide_sweep(
    sweep_angle: float,
) -> Generator[tuple[Point, Point, Point], None, None]:
    """
    A generator that subdivides a swept angle into segments no larger than a quarter
    turn.

    Any sweep that is larger than a quarter turn is subdivided into as many equally
    sized segments as necessary to prevent any individual segment from being larger
    than a quarter turn.

    This is used for approximating a circular curve segment using cubic B√©zier
    curves. This computes the parameters used for the B√©zier approximation up
    front, as well as the transform necessary to place the segment in the correct
    position.

    Args:
        sweep_angle (float): the angle to subdivide.

    Yields:
        A tuple of (ctrl1, ctrl2, end) representing the control and end points of
        the cubic B√©zier curve approximating the segment as a unit circle centered
        at the origin.
    """
    sweep_angle = abs(sweep_angle)
    sweep_left = sweep_angle

    quarterturn = math.pi / 2
    chunks = math.ceil(sweep_angle / quarterturn)

    sweep_segment = sweep_angle / chunks
    cos_t = math.cos(sweep_segment)
    sin_t = math.sin(sweep_segment)
    kappa = 4 / 3 * math.tan(sweep_segment / 4)

    ctrl1 = Point(1, kappa)
    ctrl2 = Point(cos_t + kappa * sin_t, sin_t - kappa * cos_t)
    end = Point(cos_t, sin_t)

    for _ in range(chunks):
        offset = sweep_angle - sweep_left

        transform = Transform.rotation(offset)
        yield ctrl1 @ transform, ctrl2 @ transform, end @ transform

        sweep_left -= sweep_segment
```

Example 4 (python):
```python
class Arc(NamedTuple):
    """
    An elliptical arc path element.

    The arc is drawn from the end of the current path element to its specified end point
    using a number of parameters to determine how it is constructed.

    See: `PaintedPath.arc_to`
    """

    radii: Point
    """
    The x- and y-radii of the arc. If `radii.x == radii.y` the arc will be circular.
    """
    rotation: Number
    """The rotation of the arc's major/minor axes relative to the coordinate frame."""
    large: bool
    """If True, sweep the arc over an angle greater than or equal to 180 degrees."""
    sweep: bool
    """If True, the arc is swept in the positive angular direction."""
    end: Point
    """The end point of the arc."""

    @property
    def end_point(self) -> Point:
        """The end point of this path element."""
        return self.end

    @staticmethod
    @force_nodocument
    def subdivide_sweep(
        sweep_angle: float,
    ) -> Generator[tuple[Point, Point, Point], None, None]:
        """
        A generator that subdivides a swept angle into segments no larger than a quarter
        turn.

        Any sweep that is larger than a quarter turn is subdivided into as many equally
        sized segments as necessary to prevent any individual segment from being larger
        than a quarter turn.

        This is used for approximating a circular curve segment using cubic B√©zier
        curves. This computes the parameters used for the B√©zier approximation up
        front, as well as the transform necessary to place the segment in the correct
        position.

        Args:
            sweep_angle (float): the angle to subdivide.

        Yields:
            A tuple of (ctrl1, ctrl2, end) representing the control and end points of
            the cubic B√©zier curve approximating the segment as a unit circle centered
            at the origin.
        """
        sweep_angle = abs(sweep_angle)
        sweep_left = sweep_angle

        quarterturn = math.pi / 2
        chunks = math.ceil(sweep_angle / quarterturn)

        sweep_segment = sweep_angle / chunks
        cos_t = math.cos(sweep_segment)
        sin_t = math.sin(sweep_segment)
        kappa = 4 / 3 * math.tan(sweep_segment / 4)

        ctrl1 = Point(1, kappa)
        ctrl2 = Point(cos_t + kappa * sin_t, sin_t - kappa * cos_t)
        end = Point(cos_t, sin_t)

        for _ in range(chunks):
            offset = sweep_angle - sweep_left

            transform = Transform.rotation(offset)
            yield ctrl1 @ transform, ctrl2 @ transform, end @ transform

            sweep_left -= sweep_segment

    def _approximate_arc(self, last_item: Renderable) -> list[BezierCurve]:
        """
        Approximate this arc with a sequence of `BezierCurve`.

        Args:
            last_item: the previous path element (used for its end point)

        Returns:
            a list of `BezierCurve`.
        """
        radii = self.radii

        reverse = Transform.rotation(-self.rotation)
        forward = Transform.rotation(self.rotation)

        prime = ((last_item.end_point - self.end) * 0.5) @ reverse

        lam_da = (prime.x / radii.x) ** 2 + (prime.y / radii.y) ** 2

        if lam_da > 1:
            radii = Point(x=(lam_da**0.5) * radii.x, y=(lam_da**0.5) * radii.y)

        sign = (self.large != self.sweep) - (self.large == self.sweep)
        rxry2 = (radii.x * radii.y) ** 2
        rxpy2 = (radii.x * prime.y) ** 2
        rypx2 = (radii.y * prime.x) ** 2

        centerprime = (
            sign
            * math.sqrt(round(rxry2 - rxpy2 - rypx2, 8) / (rxpy2 + rypx2))
            * Point(
                x=radii.x * prime.y / radii.y,
                y=-radii.y * prime.x / radii.x,
            )
        )

        center = (centerprime @ forward) + ((last_item.end_point + self.end) * 0.5)

        arcstart = Point(
            x=(prime.x - centerprime.x) / radii.x,
            y=(prime.y - centerprime.y) / radii.y,
        )
        arcend = Point(
            x=(-prime.x - centerprime.x) / radii.x,
            y=(-prime.y - centerprime.y) / radii.y,
        )

        theta = Point(1, 0).angle(arcstart)
        deltatheta = arcstart.angle(arcend)

        if (self.sweep is False) and (deltatheta > 0):
            deltatheta -= math.tau
        elif (self.sweep is True) and (deltatheta < 0):
            deltatheta += math.tau

        sweep_sign = (deltatheta >= 0) - (deltatheta < 0)
        final_tf = (
            Transform.scaling(x=1, y=sweep_sign)  # flip negative sweeps
            .rotate(theta)  # rotate start of arc to correct position
            .scale(radii.x, radii.y)  # scale unit circle into the final ellipse shape
            .rotate(self.rotation)  # rotate the ellipse the specified angle
            .translate(center.x, center.y)  # translate to the final coordinates
        )

        curves: list[BezierCurve] = []

        for ctrl1, ctrl2, end in self.subdivide_sweep(deltatheta):
            curves.append(
                BezierCurve(ctrl1 @ final_tf, ctrl2 @ final_tf, end @ final_tf)
            )

        return curves

    def bounding_box(self, start: Point) -> tuple[BoundingBox, Point]:
        """
        Compute the bounding box of this arc by approximating it with a series of
        Bezier curves and aggregating their bounding boxes.
        """
        bbox = BoundingBox.empty()
        prev: Renderable = Move(start)

        for curve in self._approximate_arc(prev):
            segment_bbox, _ = curve.bounding_box(prev.end_point)
            bbox = bbox.merge(segment_bbox)
            prev = curve

        return bbox, self.end

    @force_nodocument
    def render(
        self,
        resource_registry: "ResourceCatalog",
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
    ) -> tuple[str, Renderable, Point]:
        """
        Render this path element to its PDF representation.

        Args:
            resource_registry (ResourceCatalog): the owner's graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a "M" or "m" command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is a resolved
            `BezierCurve`.
        """
        curves = self._approximate_arc(last_item)

        if not curves:
            return "", last_item, initial_point

        return (
            " ".join(
                curve.render(resource_registry, style, prev, initial_point)[0]
                for prev, curve in zip([last_item, *curves[:-1]], curves)
            ),
            curves[-1],
            initial_point,
        )
```

---

## Presentations¬∂

**URL:** https://py-pdf.github.io/fpdf2/Presentations.html

**Contents:**
- Presentations¬∂
- Page display duration¬∂
- Transitions¬∂

Presentation mode can usually be enabled with the CTRL + L shortcut.

As of june 2021, the features described below are honored by Adobe Acrobat reader, but ignored by Sumatra PDF reader.

Pages can be associated with a "display duration" until when the viewer application automatically advances to the next page:

It can also be configured globally through the page_duration FPDF property.

Pages can be associated with visual transitions to use when moving from another page to the given page during a presentation:

It can also be configured globally through the page_transition FPDF property.

**Examples:**

Example 1 (python):
```python
from fpdf import FPDF

pdf = fpdf.FPDF()
pdf.set_font("Helvetica", size=120)
pdf.add_page(duration=3)
pdf.cell(text="Page 1")
pdf.page_duration = .5
pdf.add_page()
pdf.cell(text="Page 2")
pdf.add_page()
pdf.cell(text="Page 3")
pdf.output("presentation.pdf")
```

Example 2 (swift):
```swift
from fpdf import FPDF
from fpdf.transitions import *

pdf = fpdf.FPDF()
pdf.set_font("Helvetica", size=120)
pdf.add_page()
pdf.text(x=40, y=150, text="Page 0")
pdf.add_page(transition=SplitTransition("V", "O"))
pdf.text(x=40, y=150, text="Page 1")
pdf.add_page(transition=BlindsTransition("H"))
pdf.text(x=40, y=150, text="Page 2")
pdf.add_page(transition=BoxTransition("I"))
pdf.text(x=40, y=150, text="Page 3")
pdf.add_page(transition=WipeTransition(90))
pdf.text(x=40, y=150, text="Page 4")
pdf.add_page(transition=DissolveTransition())
pdf.text(x=40, y=150, text="Page 5")
pdf.add_page(transition=GlitterTransition(315))
pdf.text(x=40, y=150, text="Page 6")
pdf.add_page(transition=FlyTransition("H"))
pdf.text(x=40, y=150, text="Page 7")
pdf.add_page(transition=PushTransition(270))
pdf.text(x=40, y=150, text="Page 8")
pdf.add_page(transition=CoverTransition(270))
pdf.text(x=40, y=150, text="Page 9")
pdf.add_page(transition=UncoverTransition(270))
pdf.text(x=40, y=150, text="Page 10")
pdf.add_page(transition=FadeTransition())
pdf.text(x=40, y=150, text="Page 11")
pdf.output("transitions.pdf")
```

---

## Module fpdf.line_break

**URL:** https://py-pdf.github.io/fpdf2/fpdf/line_break.html

**Contents:**
- Module fpdf.line_break
- Classes
  - Instance variables
  - Methods
  - Subclasses
  - Instance variables
  - Methods
- Args
  - Ancestors
  - Instance variables

Routines for organizing lines and larger blocks of text, with manual and automatic line wrapping.

The contents of this module are internal to fpdf2, and not part of the public API. They may change at any time without prior warning or any deprecation period, in non-backward-compatible ways.

Usage documentation at: https://py-pdf.github.io/fpdf2/LineBreaks.html

Per-line text fragment management for use by MultiLineBreak. Args: print_sh (bool): If true, a soft-hyphen will be rendered normally, instead of triggering a line break. Default: False

A fragment of text with font/size/style and other associated information.

Return the width of a single character out of the stored text.

Return the width of the string with the given font/size/style/etc.

Returns if 2 fragments are equivalent other than the characters/string

HyphenHint(original_fragment_index, original_character_index, current_line_fragment_index, current_line_character_index, line_width, number_of_spaces, curchar, curchar_width, graphics_state, k)

Alias for field number 6

Alias for field number 7

Alias for field number 3

Alias for field number 2

Alias for field number 8

Alias for field number 9

Alias for field number 4

Alias for field number 5

Alias for field number 1

Alias for field number 0

Accept text as Fragments, to be split into individual lines depending on line width and text height.

SpaceHint(original_fragment_index, original_character_index, current_line_fragment_index, current_line_character_index, line_width, number_of_spaces)

Alias for field number 3

Alias for field number 2

Alias for field number 4

Alias for field number 5

Alias for field number 1

Alias for field number 0

TextLine(fragments, text_width, number_of_spaces, align, height, max_width, trailing_nl, trailing_form_feed, indent)

Alias for field number 3

Alias for field number 0

Alias for field number 4

Alias for field number 8

Alias for field number 5

Alias for field number 2

Alias for field number 1

Alias for field number 7

Alias for field number 6

A special type of text fragment that represents a placeholder for the total number of pages in a PDF document.

A placeholder will be generated during the initial content rendering phase of a PDF document. This placeholder is later replaced by the total number of pages in the document when the final output is being produced.

Inherited from: Fragment.get_character_width

Return the width of a single character out of the stored text.

This method returns a placeholder string containing a universally unique identifier (UUID4), ensuring that the placeholder is distinct and does not conflict with other placeholders within the document.

Inherited from: Fragment.get_width

Return the width of the string with the given font/size/style/etc ‚Ä¶

Inherited from: Fragment.has_same_style

Returns if 2 fragments are equivalent other than the characters/string

This method is invoked during the page content rendering phase, which is common to all Fragment instances. It stores the provided arguments and keyword arguments to preserve the necessary information and graphic state for the final substitution rendering.

The method then returns the unique placeholder string.

This method is invoked at the output phase. It calls render_pdf_text() from the superclass to render the fragment with the preserved rendering state (stored in _render_args and _render_kwargs) and insert the final text in place of the placeholder.

**Examples:**

Example 1 (python):
```python
class CurrentLine:
    def __init__(
        self, max_width: float, print_sh: bool = False, indent: float = 0
    ) -> None:
        """
        Per-line text fragment management for use by MultiLineBreak.
            Args:
                print_sh (bool): If true, a soft-hyphen will be rendered
                    normally, instead of triggering a line break. Default: False
        """
        self.max_width = max_width
        self.print_sh = print_sh
        self.indent = indent
        self.fragments: List[Fragment] = []
        self.height: float = 0
        self.number_of_spaces: int = 0

        # automatic break hints
        # CurrentLine class remembers 3 positions
        # 1 - position of last inserted character.
        #     class attributes (`width`, `fragments`)
        #     is used for this purpose
        # 2 - position of last inserted space
        #     SpaceHint is used for this purpose.
        # 3 - position of last inserted soft-hyphen
        #     HyphenHint is used for this purpose.
        # The purpose of multiple positions tracking - to have an ability
        # to break in multiple places, depending on condition.
        self.space_break_hint: Optional[SpaceHint] = None
        self.hyphen_break_hint: Optional[HyphenHint] = None

    @property
    def width(self) -> float:
        width: float = 0
        for i, fragment in enumerate(self.fragments):
            width += fragment.get_width(initial_cs=i > 0)
        return width

    def add_character(
        self,
        character: str,
        character_width: float,
        original_fragment: Fragment | HyphenHint,
        original_fragment_index: int,
        original_character_index: int,
        height: float,
        url: Optional[str | int] = None,
    ) -> None:
        assert character != NEWLINE
        self.height = height
        if not self.fragments:
            assert isinstance(original_fragment, Fragment)
            self.fragments.append(
                original_fragment.__class__(
                    characters="",
                    graphics_state=original_fragment.graphics_state,
                    k=original_fragment.k,
                    link=url,
                )
            )

        # characters are expected to be grouped into fragments by font and
        # character attributes. If the last existing fragment doesn't match
        # the properties of the pending character -> add a new fragment.
        elif isinstance(original_fragment, Fragment):
            if isinstance(
                self.fragments[-1], Fragment
            ) and not original_fragment.has_same_style(self.fragments[-1]):
                self.fragments.append(
                    original_fragment.__class__(
                        characters="",
                        graphics_state=original_fragment.graphics_state,
                        k=original_fragment.k,
                        link=url,
                    )
                )
        active_fragment = self.fragments[-1]

        if character in BREAKING_SPACE_SYMBOLS_STR:
            self.space_break_hint = SpaceHint(
                original_fragment_index,
                original_character_index,
                len(self.fragments),
                len(active_fragment.characters),
                self.width,
                self.number_of_spaces,
            )
            self.number_of_spaces += 1
        elif character == NBSP:
            # PDF viewers ignore NBSP for word spacing with "Tw".
            character = SPACE
            self.number_of_spaces += 1
        elif character == SOFT_HYPHEN and not self.print_sh:
            self.hyphen_break_hint = HyphenHint(
                original_fragment_index,
                original_character_index,
                len(self.fragments),
                len(active_fragment.characters),
                self.width,
                self.number_of_spaces,
                HYPHEN,
                character_width,
                original_fragment.graphics_state,
                original_fragment.k,
            )

        if character != SOFT_HYPHEN or self.print_sh:
            active_fragment.characters.append(character)

    def trim_trailing_spaces(self) -> None:
        if not self.fragments:
            return
        last_frag = self.fragments[-1]
        last_char = last_frag.characters[-1]
        while last_char == " ":
            last_frag.trim(-1)
            if not last_frag.characters:
                del self.fragments[-1]
            if not self.fragments:
                return
            last_frag = self.fragments[-1]
            last_char = last_frag.characters[-1]

    def _apply_automatic_hint(self, break_hint: SpaceHint | HyphenHint) -> None:
        """
        This function mutates the current_line, applying one of the states
        observed in the past and stored in
        `hyphen_break_hint` or `space_break_hint` attributes.
        """
        self.fragments = self.fragments[: break_hint.current_line_fragment_index]
        if self.fragments:
            self.fragments[-1].trim(break_hint.current_line_character_index)
        self.number_of_spaces = break_hint.number_of_spaces

    def manual_break(
        self, align: Align, trailing_nl: bool = False, trailing_form_feed: bool = False
    ) -> TextLine:
        return TextLine(
            fragments=self.fragments,
            text_width=self.width,
            number_of_spaces=self.number_of_spaces,
            align=align,
            height=self.height,
            max_width=self.max_width - self.indent,
            trailing_nl=trailing_nl,
            trailing_form_feed=trailing_form_feed,
            indent=self.indent,
        )

    def automatic_break_possible(self) -> bool:
        return self.hyphen_break_hint is not None or self.space_break_hint is not None

    def automatic_break(self, align: Align) -> Tuple[int, int, TextLine]:
        assert self.automatic_break_possible()
        if self.hyphen_break_hint is not None and (
            self.space_break_hint is None
            or self.hyphen_break_hint.line_width > self.space_break_hint.line_width
        ):
            self._apply_automatic_hint(self.hyphen_break_hint)
            self.add_character(
                self.hyphen_break_hint.curchar,
                self.hyphen_break_hint.curchar_width,
                self.hyphen_break_hint,
                self.hyphen_break_hint.original_fragment_index,
                self.hyphen_break_hint.original_character_index,
                self.height,
            )
            return (
                self.hyphen_break_hint.original_fragment_index,
                self.hyphen_break_hint.original_character_index,
                self.manual_break(align),
            )
        assert self.space_break_hint is not None
        self._apply_automatic_hint(self.space_break_hint)
        return (
            self.space_break_hint.original_fragment_index,
            self.space_break_hint.original_character_index,
            self.manual_break(align),
        )
```

Example 2 (python):
```python
@property
def width(self) -> float:
    width: float = 0
    for i, fragment in enumerate(self.fragments):
        width += fragment.get_width(initial_cs=i > 0)
    return width
```

Example 3 (python):
```python
def add_character(
    self,
    character: str,
    character_width: float,
    original_fragment: Fragment | HyphenHint,
    original_fragment_index: int,
    original_character_index: int,
    height: float,
    url: Optional[str | int] = None,
) -> None:
    assert character != NEWLINE
    self.height = height
    if not self.fragments:
        assert isinstance(original_fragment, Fragment)
        self.fragments.append(
            original_fragment.__class__(
                characters="",
                graphics_state=original_fragment.graphics_state,
                k=original_fragment.k,
                link=url,
            )
        )

    # characters are expected to be grouped into fragments by font and
    # character attributes. If the last existing fragment doesn't match
    # the properties of the pending character -> add a new fragment.
    elif isinstance(original_fragment, Fragment):
        if isinstance(
            self.fragments[-1], Fragment
        ) and not original_fragment.has_same_style(self.fragments[-1]):
            self.fragments.append(
                original_fragment.__class__(
                    characters="",
                    graphics_state=original_fragment.graphics_state,
                    k=original_fragment.k,
                    link=url,
                )
            )
    active_fragment = self.fragments[-1]

    if character in BREAKING_SPACE_SYMBOLS_STR:
        self.space_break_hint = SpaceHint(
            original_fragment_index,
            original_character_index,
            len(self.fragments),
            len(active_fragment.characters),
            self.width,
            self.number_of_spaces,
        )
        self.number_of_spaces += 1
    elif character == NBSP:
        # PDF viewers ignore NBSP for word spacing with "Tw".
        character = SPACE
        self.number_of_spaces += 1
    elif character == SOFT_HYPHEN and not self.print_sh:
        self.hyphen_break_hint = HyphenHint(
            original_fragment_index,
            original_character_index,
            len(self.fragments),
            len(active_fragment.characters),
            self.width,
            self.number_of_spaces,
            HYPHEN,
            character_width,
            original_fragment.graphics_state,
            original_fragment.k,
        )

    if character != SOFT_HYPHEN or self.print_sh:
        active_fragment.characters.append(character)
```

Example 4 (python):
```python
def automatic_break(self, align: Align) -> Tuple[int, int, TextLine]:
    assert self.automatic_break_possible()
    if self.hyphen_break_hint is not None and (
        self.space_break_hint is None
        or self.hyphen_break_hint.line_width > self.space_break_hint.line_width
    ):
        self._apply_automatic_hint(self.hyphen_break_hint)
        self.add_character(
            self.hyphen_break_hint.curchar,
            self.hyphen_break_hint.curchar_width,
            self.hyphen_break_hint,
            self.hyphen_break_hint.original_fragment_index,
            self.hyphen_break_hint.original_character_index,
            self.height,
        )
        return (
            self.hyphen_break_hint.original_fragment_index,
            self.hyphen_break_hint.original_character_index,
            self.manual_break(align),
        )
    assert self.space_break_hint is not None
    self._apply_automatic_hint(self.space_break_hint)
    return (
        self.space_break_hint.original_fragment_index,
        self.space_break_hint.original_character_index,
        self.manual_break(align),
    )
```

---

## File attachments¬∂

**URL:** https://py-pdf.github.io/fpdf2/FileAttachments.html

**Contents:**
- File attachments¬∂
- Embedded file streams¬∂
- Annotations¬∂

Embedded file streams [allow] the contents of referenced files to be embedded directly within the body of the PDF file. This makes the PDF file a self-contained unit that can be stored or transmitted as a single entity.

fpdf2 gives access to this feature through the method embed_file():

A file attachment annotation contains a reference to a file, which typically shall be embedded in the PDF file.

fpdf2 gives access to this feature through the method file_attachment_annotation():

Resulting PDF: file_attachment_annotation.pdf

Browser PDF viewers do not usually display embedded files & file attachment annotations, so you may want to download this file and open it with your desktop PDF viewer in order to visualize the file attachments.

**Examples:**

Example 1 (unknown):
```unknown
pdf = FPDF()
pdf.add_page()
pdf.embed_file(__file__, desc="Source Python code", compress=True)
pdf.output("embedded_file.pdf")
```

Example 2 (unknown):
```unknown
pdf = FPDF()
pdf.add_page()
pdf.file_attachment_annotation(__file__, x=50, y=50)
pdf.output("file_attachment_annotation.pdf")
```

---

## Page breaks¬∂

**URL:** https://py-pdf.github.io/fpdf2/PageBreaks.html

**Contents:**
- Page breaks¬∂
- Manually trigger a page break¬∂
- Inserting the final number of pages of the document¬∂
- will_page_break¬∂
- Unbreakable sections¬∂

By default, fpdf2 will automatically perform page breaks whenever a cell or the text from a write() is rendered at the bottom of a page with a height greater than the page bottom margin.

This behaviour can be controlled using those methods:

Simply call .add_page().

The special string {nb} will be substituted by the total number of pages on document closure. This special value can changed by calling alias_nb_pages().

This is currently incompatible with text shaping.cf. GitHub issue #1090

will_page_break(height) lets you know if adding an element will trigger a page break, based on its height and the current ordinate (y position).

In order to render content, like tables, with the insurance that no page break will be performed in it, on the can use the FPDF.unbreakable() context-manager:

An alternative approach is offset_rendering() that allows to test the results of some operations on the global layout before performing them "for real":

**Examples:**

Example 1 (sql):
```sql
pdf = fpdf.FPDF()
pdf.add_page()
pdf.set_font("Times", size=16)
line_height = pdf.font_size * 2
col_width = pdf.epw / 4  # distribute content evenly
for i in range(4):  # repeat table 4 times
    with pdf.unbreakable() as doc:
        for row in data:  # data comes from snippets on the Tables documentation page
            for datum in row:
                doc.cell(col_width, line_height, f"{datum} ({i})", border=1)
            doc.ln(line_height)
    print('page_break_triggered:', doc.page_break_triggered)
    pdf.ln(line_height * 2)
pdf.output("unbreakable_tables.pdf")
```

Example 2 (markdown):
```markdown
with pdf.offset_rendering() as dummy:
    # Dummy rendering:
    dummy.multi_cell(...)
if dummy.page_break_triggered:
    # We trigger a page break manually beforehand:
    pdf.add_page()
    # We duplicate the section header:
    pdf.cell(text="Appendix C")
# Now performing our rendering for real:
pdf.multi_cell(...)
```

---

## Barcodes¬∂

**URL:** https://py-pdf.github.io/fpdf2/Barcodes.html

**Contents:**
- Barcodes¬∂
- Code 39¬∂
- Interleaved 2 of 5¬∂
- PDF-417¬∂
- QRCode¬∂
- DataMatrix¬∂
  - Extend FPDF with a datamatrix() method¬∂
- Aztec Code¬∂
- Code128¬∂

Here is an example on how to generate a Code 39 barcode:

Here is an example on how to generate an Interleaved 2 of 5 barcode:

Here is an example on how to generate a PDF-417 barcode using the pdf417 lib:

Here is an example on how to generate a QR Code using the python-qrcode lib:

fpdf2 can be combined with the pystrich library to generate DataMatrix barcodes: pystrich generates pilimages, which can then be inserted into the PDF file via the FPDF.image() method.

The code above could be added to the FPDF class as an extension method in the following way:

fpdf2 can be combined with the aztec_code_generator Pypi library to generate Aztec codes. It can be installed by running pip install aztec_code_generator:

Here is an example on how to generate a Code 128 barcode using the python-barcode lib, that can be installed by running pip install python-barcode:

**Examples:**

Example 1 (python):
```python
from fpdf import FPDF

pdf = FPDF()
pdf.add_page()
pdf.code39("*fpdf2*", x=30, y=50, w=4, h=20)
pdf.output("code39.pdf")
```

Example 2 (python):
```python
from fpdf import FPDF

pdf = FPDF()
pdf.add_page()
pdf.interleaved2of5("1337", x=50, y=50, w=4, h=20)
pdf.output("interleaved2of5.pdf")
```

Example 3 (swift):
```swift
from fpdf import FPDF
from pdf417 import encode, render_image

pdf = FPDF()
pdf.add_page()
img = render_image(encode("Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed non risus. Suspendisse lectus tortor, dignissim sit amet, adipiscing nec, ultricies sed, dolor. Cras elementum ultrices diam."))
pdf.image(img, x=10, y=50)
pdf.output("pdf417.pdf")
```

Example 4 (swift):
```swift
from fpdf import FPDF
import qrcode

pdf = FPDF()
pdf.add_page()
img = qrcode.make("fpdf2")
pdf.image(img.get_image(), x=50, y=50)
pdf.output("qrcode.pdf")
```

---

## Line breaks¬∂

**URL:** https://py-pdf.github.io/fpdf2/LineBreaks.html

**Contents:**
- Line breaks¬∂

When using multi_cell() or write(), each time a line reaches the right extremity of the cell or a carriage return character (\n) is met, a line break is issued and a new line automatically created under the current one.

An automatic break is performed at the location of the nearest space or soft-hyphen (\u00ad) character before the right limit. A soft-hyphen will be replaced by a normal hyphen when triggering a line break, and ignored otherwise.

If the parameter print_sh=False in multi_cell() or write() is set to True, then they will print the soft-hyphen character to the document (as a normal hyphen with most fonts) instead of using it as a line break opportunity.

---

## Tables¬∂

**URL:** https://py-pdf.github.io/fpdf2/Tables.html

**Contents:**
- Tables¬∂
- Features¬∂
- Setting table & column widths¬∂
- Setting text alignment¬∂
- Setting cell padding¬∂
- Setting vertical alignment of text in cells¬∂
- Setting row height¬∂
- Disable table headings¬∂
- Style table headings¬∂
- Set cells background¬∂

Tables can be built using the table() method. Here is a simple example:

The col_widths optional parameter can be provided to configure this.

If a single number is provided as col_widths, it is interpreted as a fixed column width in document units.

If an array of numbers is provided as col_widths, the values are considered to be fractions of the full effective page width, meaning that col_widths=(1, 1, 2) is strictly equivalent to col_widths=(25, 25, 50).

align can be passed to table() to set the table horizontal position relative to the page, when it's not using the full page width. It's centered by default.

This can be set globally, or on a per-column basis:

Cell padding (the space between the cells content and the edge of the cell) can be set globally or on a per-cell basis.

Following the CCS standard the padding can be specified using 1,2 3 or 4 values.

(also an example of coloring individual cells)

Note: the c_margin parameter (default 1.0) also controls the horizontal margins in a cell. If a non-zero padding for left and right is supplied then c_margin is ignored.

Can be set globally, per row or per cell, by passing a string or a VAlign enum value as v_align: ... with pdf.table(v_align=VAlign.M) as table: ... row.cell(f"custom v-align", v_align="TOP")

First, line_height can be provided to set the height of every individual line of text: ... with pdf.table(line_height=2.5 * pdf.font_size) as table: ...

Second, a global min_row_height can be set, or configured per row as min_height: ... with pdf.table(min_row_height=30) as table: row = table.row() row.cell("A") row.cell("B") row = table.row(min_height=50) row.cell("C") row.cell("D")

By default, fpdf2 considers that the first row of tables contains its headings. This can however be disabled:

The repetition of table headings on every page can also be disabled:

"ON_TOP_OF_EVERY_PAGE" is an equivalent valid value for repeat_headings , cf. documentation on TableHeadingsDisplay.

It's possible to override the style of individual cells in the heading. The overriding style will take precedence for any specified values, while retaining the default style for unspecified values: ... headings_style = FontFace(emphasis="ITALICS", color=blue, fill_color=grey) override_style = FontFace(emphasis="BOLD") with pdf.table(headings_style=headings_style) as table: headings = table.row() headings.cell("First name", style=override_style) headings.cell("Last name", style=override_style) headings.cell("Age") headings.cell("City") ...

The cell color is set following those settings, ordered by priority:

Finally, it is possible to define your own cell-filling logic:

It is also possible to create a custom border layout, controlling thickness, color, and dash pattern: from fpdf.table import TableBordersLayout, TableBorderStyle, TableCellStyle gray = (150, 150, 150) red = (255, 0, 0) custom_layout = TableBordersLayout( cell_style_getter=lambda row_num, col_num, num_heading_rows, num_rows, num_cols: TableCellStyle( left=( True if col_num == 0 else TableBorderStyle(color=(150, 150, 150), dash=2) if col_num == 2 else False ), bottom=True if row_num == num_rows - 1 else False, right=True if col_num == num_cols - 1 else False, top=( True if row_num == 0 else TableBorderStyle(thickness=1) if row_num == num_heading_rows else TableBorderStyle(color=red, dash=2) ), ) ) with pdf.table(borders_layout=custom_layout) as table: ...

All the possible layout values are described there: TableBordersLayout.

All the possible borders values are described there: CellBordersLayout.

By default, images height & width are constrained by the row height (based on text content) and the column width. To render bigger images, you can set the line_height to increase the row height, or pass img_fill_width=True to .cell():

To simplify table() usage, shorter, alternative usage forms are allowed.

Can be shortened to the following code, by passing lists of strings as the cells optional argument of .row():

And even shortened further to a single line, by passing lists of lists of strings as the rows optional argument of .table():

Spacing can be introduced between rows and/or columns:

Cells spanning multiple columns or rows can be defined by passing a colspan or rowspan argument to .cell(). Only the cells with data in them need to be defined. This means that the number of cells on each row can be different.

Alternatively, the spans can be defined using the placeholder elements TableSpan.COL and TableSpan.ROW. These elements merge the current cell with the previous column or row respectively.

For example, the previous example table can be defined as follows:

The number of heading rows is defined by passing the num_heading_rows argument to Table(). The default value is 1. To guarantee backwards compatibility with the first_row_as_headings argument, the following applies: - If num_heading_rows==1: The value of first_row_as_headings defines whether the first row is treated as heading or standard row. - Otherwise, the value of num_heading_rows decides the number of heading rows. with pdf.table(TABLE_DATA, num_heading_rows=2): pass

We have dedicated pages about those topics:

Tables can also be defined in HTML using FPDF.write_html. With the same data as above, and column widths defined as percent of the effective width:

Note that write_html has some limitations, notably regarding multi-lines cells.

The PDF file format is not designed to embed structured tables. Hence, it can be tricky to extract tables data from PDF documents.

In our tests suite, we ensure that several PDF-tables parsing Python libraries can successfully extract tables in documents generated with fpdf2. Namely, we test camelot-py & tabula-py: test/table/test_table_extraction.py.

Based on those tests, if you want to ease table extraction from the documents you produce, we recommend the following guidelines:

**Examples:**

Example 1 (typescript):
```typescript
from fpdf import FPDF

TABLE_DATA = (
    ("First name", "Last name", "Age", "City"),
    ("Jules", "Smith", "34", "San Juan"),
    ("Mary", "Ramos", "45", "Orlando"),
    ("Carlson", "Banks", "19", "Los Angeles"),
    ("Lucas", "Cimon", "31", "Angers"),
)
pdf = FPDF()
pdf.add_page()
pdf.set_font("Times", size=16)
with pdf.table() as table:
    for data_row in TABLE_DATA:
        row = table.row()
        for datum in data_row:
            row.cell(datum)
pdf.output('table.pdf')
```

Example 2 (typescript):
```typescript
...
with pdf.table(width=150, col_widths=(30, 30, 10, 30)) as table:
    ...
```

Example 3 (typescript):
```typescript
...
with pdf.table(text_align="CENTER") as table:
    ...
pdf.ln()
with pdf.table(text_align=("CENTER", "CENTER", "RIGHT", "LEFT")) as table:
    ...
```

Example 4 (typescript):
```typescript
...
red = (255, 0, 0)
style = FontFace(color=black, fill_color=red)
with pdf.table(line_height=pdf.font_size, padding=2) as table:
    for irow in range(5):
        row = table.row()
        for icol in range(5):
            datum = "Circus"
            if irow == 3 and icol % 2 == 0:
                row.cell("custom padding", style=style, padding=(2 * icol, 8, 8, 8))
            else:
                row.cell(datum)
```

---

## Tutorial¬∂

**URL:** https://py-pdf.github.io/fpdf2/Tutorial-pl.html

**Contents:**
- Tutorial¬∂
- Tuto 1 - Minimalny Przyk≈Çad¬∂
- Tuto 2 - Nag≈Ç√≥wek, stopka, podzia≈Ç strony i obraz¬∂
- Tuto 3 - ≈Åamanie wierszy i kolory¬∂
- Tuto 4 - Wiele kolumn¬∂
- Tuto 5 - Tworzenie tabel¬∂
- Tuto 6 - Tworzenie link√≥w i mieszanie styl√≥w tekstu¬∂

Pe≈Çna dokumentacja metod: fpdf.FPDF API doc

Zacznijmy od klasycznego przyk≈Çadu:

Po do≈ÇƒÖczeniu pliku biblioteki tworzymy obiekt FPDF. U≈ºywany jest tutaj konstruktor FPDF z domy≈õlnymi warto≈õciami: strony sƒÖ w formacie A4 w pionie, a jednostkƒÖ miary jest milimetr. Mo≈ºna by≈Ço to okre≈õliƒá jawnie za pomocƒÖ:

Mo≈ºliwe jest ustawienie formatu PDF w trybie poziomym (L) lub u≈ºycie innych format√≥w stron. (takich jak Letter i Legal) oraz jednostek miary (pt, cm, in).

Na razie nie ma strony, wiƒôc musimy jƒÖ dodaƒá za pomocƒÖ add_page. PoczƒÖtek znajduje siƒô w lewym g√≥rnym rogu, a bie≈ºƒÖca pozycja domy≈õlnie ustawiona jest na 1 cm od krawƒôdzi; marginesy mo≈ºna zmieniƒá za pomocƒÖ set_margins.

Zanim bƒôdziemy mogli drukowaƒá tekst, konieczne jest wybranie czcionki za pomocƒÖ set_font, w przeciwnym razie dokument bƒôdzie nieprawid≈Çowy. Wybieramy czcionkƒô Helvetica pogrubionƒÖ o rozmiarze 16:

Mo≈ºna by≈Ço okre≈õliƒá kursywƒô za pomocƒÖ I, podkre≈õlenie za pomocƒÖ U lub zwyk≈ÇƒÖ czcionkƒô za pomocƒÖ pustego ≈Ça≈Ñcucha (lub dowolnej kombinacji). Nale≈ºy pamiƒôtaƒá, ≈ºe rozmiar czcionki jest podany w punktach, a nie w milimetrach (lub innej jednostce u≈ºytkownika); jest to jedyny wyjƒÖtek. Inne wbudowane czcionki to Times, Courier, Symbol i ZapfDingbats.

Teraz mo≈ºemy wydrukowaƒá kom√≥rkƒô za pomocƒÖ cell. Kom√≥rka to prostokƒÖtny obszar, ewentualnie obramowany, zawierajƒÖcy tekst. Jest renderowany w bie≈ºƒÖcej pozycji. Okre≈õlamy jej wymiary, jej tekst (wy≈õrodkowany lub wyr√≥wnany), czy powinny byƒá rysowane ramki i gdzie przesunie siƒô bie≈ºƒÖca pozycja po niej (w prawo, poni≈ºej lub na poczƒÖtek nastƒôpnego wiersza). Aby dodaƒá ramkƒô, postƒôpujemy tak:

Aby dodaƒá obok niego nowƒÖ kom√≥rkƒô z wy≈õrodkowanym tekstem i przej≈õƒá do nastƒôpnego wiersza, wykonaliby≈õmy:

Uwaga: ≈Çamanie wiersza mo≈ºna r√≥wnie≈º wykonaƒá za pomocƒÖ ln. Ta metoda pozwala dodatkowo okre≈õliƒá wysoko≈õƒá przerwy.

Na koniec dokument jest zamykany i zapisywany pod podanƒÖ ≈õcie≈ºkƒÖ pliku za pomocƒÖ output. Bez podanego parametru output() zwraca bufor PDF bytearray.

Oto przyk≈Çad dwustronicowy z nag≈Ç√≥wkiem, stopkƒÖ i logo:

Ten przyk≈Çad wykorzystuje metody header i footer do przetwarzania nag≈Ç√≥wk√≥w i stopek stron. SƒÖ one wywo≈Çywane automatycznie. IstniejƒÖ ju≈º w klasie FPDF, ale nic nie robiƒÖ, dlatego musimy rozszerzyƒá klasƒô i je nadpisaƒá.

Logo jest drukowane za pomocƒÖ metody image, kt√≥ra okre≈õla jego g√≥rny lewy r√≥g i szeroko≈õƒá. Wysoko≈õƒá jest automatycznie obliczana, aby zachowaƒá proporcje obrazu.

Aby wydrukowaƒá numer strony, jako szeroko≈õƒá kom√≥rki przekazywana jest warto≈õƒá null. Oznacza to, ≈ºe kom√≥rka powinna rozciƒÖgaƒá siƒô do prawego marginesu strony; jest to przydatne do centrowania tekstu. Bie≈ºƒÖcy numer strony zwracany jest przez metodƒô page_no; Ca≈Çkowita liczba stron jest uzyskiwana za pomocƒÖ specjalnej warto≈õci {nb}, kt√≥ra zostanie zastƒÖpiona przy zamykaniu dokumentu (tƒô warto≈õƒá specjalnƒÖ mo≈ºna zmieniƒá za pomocƒÖ metody alias_nb_pages()). Nale≈ºy zwr√≥ciƒá uwagƒô na u≈ºycie metody set_y, kt√≥ra pozwala ustawiƒá pozycjƒô w dowolnym miejscu na stronie, zaczynajƒÖc od g√≥ry lub od do≈Çu.

KolejnƒÖ interesujƒÖcƒÖ funkcjƒÖ stosowanƒÖ tutaj jest automatyczne ≈Çamanie strony. Gdy tylko kom√≥rka przekroczy limit strony (domy≈õlnie 2 centymetry od do≈Çu), nastƒôpuje ≈Çamanie i przywr√≥cenie czcionki. Chocia≈º nag≈Ç√≥wek i stopka wybierajƒÖ w≈ÇasnƒÖ czcionkƒô (helvetica), tre≈õƒá dokumentu jest kontynuowana czcionkƒÖ Times. Ten mechanizm automatycznego przywracania dotyczy r√≥wnie≈º kolor√≥w i grubo≈õci linii. Limit wywo≈ÇujƒÖcy ≈Çamanie strony mo≈ºna ustawiƒá za pomocƒÖ metody set_auto_page_break.

Kontynuujmy przyk≈Çadem drukowania wyjustowanych akapit√≥w. Ilustruje on r√≥wnie≈º zastosowanie kolor√≥w.

Metoda get_string_width pozwala okre≈õliƒá d≈Çugo≈õƒá ≈Ça≈Ñcucha znak√≥w w bie≈ºƒÖcej czcionce. U≈ºywana jest tutaj do obliczenia pozycji i szeroko≈õci ramki otaczajƒÖcej tytu≈Ç. Nastƒôpnie ustawiane sƒÖ kolory (za pomocƒÖ metod set_draw_color, set_fill_color i set_text_color) oraz grubo≈õƒá linii na 1 mm (domy≈õlnie jest to 0,2 mm) za pomocƒÖ metody set_line_width. Na koniec wyprowadzana jest kom√≥rka (ostatni parametr ustawiony na true oznacza, ≈ºe t≈Ço musi byƒá wype≈Çnione).

MetodƒÖ u≈ºywanƒÖ do drukowania akapit√≥w jest multi_cell. Text is justified by default. Domy≈õlnie tekst jest wyjustowany. Za ka≈ºdym razem, gdy linia osiƒÖga prawy koniec kom√≥rki lub napotkany zostanie znak nowej linii (\n), nastƒôpuje ≈Çamanie wiersza i automatyczne utworzenie nowej kom√≥rki pod bie≈ºƒÖcƒÖ. Automatyczne ≈Çamanie wiersza nastƒôpuje w miejscu najbli≈ºszej spacji lub miƒôkkiego ≈ÇƒÖcznika (\u00ad) przed prawƒÖ krawƒôdziƒÖ. Miƒôkki ≈ÇƒÖcznik zostanie zastƒÖpiony zwyk≈Çym ≈ÇƒÖcznikiem podczas ≈Çamania wiersza, a w przeciwnym razie zostanie zignorowany.

W dokumencie definiowane sƒÖ dwie w≈Ça≈õciwo≈õci: tytu≈Ç (set_title) i autor (set_author). W≈Ça≈õciwo≈õci mo≈ºna wy≈õwietliƒá na dwa sposoby. Pierwszy to bezpo≈õrednie otwarcie dokumentu w programie Acrobat Reader, przej≈õcie do menu Plik i wybranie opcji W≈Ça≈õciwo≈õci dokumentu. Drugi spos√≥b, r√≥wnie≈º dostƒôpny z wtyczki, polega na klikniƒôciu prawym przyciskiem myszy i wybraniu opcji W≈Ça≈õciwo≈õci dokumentu.

Ten przyk≈Çad jest wariantem poprzedniego, pokazujƒÖcym jak roz≈Ço≈ºyƒá tekst na wiele kolumn.

G≈Ç√≥wna r√≥≈ºnica w stosunku do poprzedniego tutoriala polega na u≈ºyciu metody text_columns. Gromadzi ona ca≈Çy tekst, mo≈ºliwie w czƒô≈õciach, i rozdziela go na ≈ºƒÖdanƒÖ liczbƒô kolumn, automatycznie wstawiajƒÖc ≈Çamanie strony w razie potrzeby. Nale≈ºy zauwa≈ºyƒá, ≈ºe dop√≥ki instancja TextColumns jest aktywna jako mened≈ºer kontekstu, style tekstu i inne w≈Ça≈õciwo≈õci czcionki mo≈ºna zmieniaƒá. Zmiany te bƒôdƒÖ ograniczone do kontekstu. Po jego zamkniƒôciu zostanƒÖ przywr√≥cone poprzednie ustawienia.

W tym tutorialu om√≥wione zostanie tworzenie dw√≥ch r√≥≈ºnych tabel, aby pokazaƒá, co mo≈ºna osiƒÖgnƒÖƒá za pomocƒÖ prostych modyfikacji.

Plik wynikowy PDF - Dane CSV z krajami

Pierwszy przyk≈Çad przedstawia najprostszy spos√≥b przekazania danych do funkcji FPDF.table(). Wynik jest podstawowy, ale bardzo szybki do uzyskania.

Druga tabela zawiera pewne ulepszenia: kolory, ograniczona szeroko≈õƒá tabeli, zmniejszona wysoko≈õƒá linii, wy≈õrodkowane tytu≈Çy, kolumny o niestandardowych szeroko≈õciach, wyr√≥wnane do prawej cyfry... Ponadto usuniƒôto linie poziome. Zrealizowano to poprzez wybranie borders_layout spo≈õr√≥d dostƒôpnych warto≈õci: TableBordersLayout.

W tym samouczku om√≥wione zostanƒÖ r√≥≈ºne sposoby wstawiania ≈ÇƒÖczy w dokumencie PDF, a tak≈ºe dodawania ≈ÇƒÖczy do ≈∫r√≥de≈Ç zewnƒôtrznych.

Poka≈ºe r√≥wnie≈º kilka sposob√≥w, w jakie mo≈ºemy u≈ºywaƒá r√≥≈ºnych styl√≥w tekstu, (pogrubienie, kursywa, podkre≈õlenie) w ramach tego samego tekstu.

Plik wynikowy PDF - fpdf2-logo

Nowa metoda drukowania tekstu pokazana tutaj to write() . Jest bardzo podobna do multi_cell() , przy czym g≈Ç√≥wne r√≥≈ºnice polegajƒÖ na:

Dlatego metoda pozwala nam napisaƒá fragment tekstu, zmieniƒá styl czcionki i kontynuowaƒá dok≈Çadnie od miejsca, w kt√≥rym sko≈Ñczyli≈õmy. Z drugiej strony, jej g≈Ç√≥wnƒÖ wadƒÖ jest to, ≈ºe nie mo≈ºemy wyjustowaƒá tekstu tak jak robimy to za pomocƒÖ metody multi_cell() .

W pierwszej stronie przyk≈Çadu u≈ºyli≈õmy do tego celu metody write() PoczƒÖtek zdania zapisany jest zwyk≈ÇƒÖ czcionkƒÖ, nastƒôpnie za pomocƒÖ metody set_font() prze≈ÇƒÖczyli≈õmy siƒô na podkre≈õlenie i doko≈Ñczyli≈õmy zdanie.

Aby dodaƒá link wewnƒôtrzny prowadzƒÖcy do drugiej strony, u≈ºyli≈õmy metody add_link() , kt√≥ra tworzy klikalny obszar nazwany przez nas "link", kt√≥ry kieruje do innej strony w dokumencie.

Do utworzenia linku zewnƒôtrznego za pomocƒÖ obrazu u≈ºyli≈õmy metody image() . Metoda ta ma opcjƒô przekazania linku jako jednego z argument√≥w. Link mo≈ºe byƒá zar√≥wno wewnƒôtrzny, jak i zewnƒôtrzny.

Alternatywnie, innƒÖ opcjƒÖ zmiany stylu czcionki i dodawania link√≥w jest u≈ºycie metody z write_html(). Jest to parser html, kt√≥ry pozwala na dodawanie tekstu, zmianƒô stylu czcionki i dodawanie link√≥w za pomocƒÖ html.

**Examples:**

Example 1 (python):
```python
from fpdf import FPDF

pdf = FPDF()
pdf.add_page()
pdf.set_font("helvetica", style="B", size=16)
pdf.cell(40, 10, "Hello World!")
pdf.output("tuto1.pdf")
```

Example 2 (unknown):
```unknown
pdf = FPDF(orientation="P", unit="mm", format="A4")
```

Example 3 (unknown):
```unknown
pdf.set_font('Helvetica', style='B', size=16)
```

Example 4 (unknown):
```unknown
pdf.cell(40, 10, 'Hello World!', 1)
```

---

## Document Outline & Table of Contents¬∂

**URL:** https://py-pdf.github.io/fpdf2/DocumentOutlineAndTableOfContents.html

**Contents:**
- Document Outline & Table of Contents¬∂
- Overview¬∂
- Document Outline (Bookmarks)¬∂
  - Nested outlines¬∂
- Table of Contents¬∂
  - Inserting a Table of Contents¬∂
  - Reference Implementation¬∂
- Using Outlines and ToC with HTML¬∂
- Additional Code Samples¬∂
- Manually Adjusting pdf.page¬∂

This document explains how to implement and customize the Document Outline (also known as Bookmarks) and Table of Contents (ToC) features in fpdf2.

Document outlines allow users to navigate quickly through sections in the PDF by creating a hierarchical structure of clickable links.

Quoting the 6th edition of the PDF format reference (v1.7 - 2006) :

A PDF document may optionally display a document outline on the screen, allowing the user to navigate interactively from one part of the document to another. The outline consists of a tree-structured hierarchy of outline items (sometimes called bookmarks), which serve as a visual table of contents to display the document‚Äôs structure to the user.

For example, there is how a document outline looks like in Sumatra PDF Reader:

Since fpdf2.3.3, you can use the start_section method to add entries in the internal "outline" table, which is used to render both the outline and ToC.

Note that by default, calling start_section only records the current position in the PDF and renders nothing. However, you can configure global title styles by calling set_section_title_styles, after which calls to start_section will render titles visually using the styles defined.

To provide a document outline to the PDF you generate, you just have to call the start_section method for every hierarchical section you want to define.

Outlines can be nested by specifying different levels. Higher-level outlines (e.g., level 0) appear at the top, while sub-levels (e.g., level 1, level 2) are indented.

Quoting Wikipedia, a table of contents is:

a list, usually found on a page before the start of a written work, of its chapter or section titles or brief descriptions with their commencing page numbers.

Use the insert_toc_placeholder method to define a placeholder for the ToC. A page break is triggered after inserting the ToC.

Note: Enabling allow_extra_pages may affect page numbering for headers or footers. Since extra ToC pages are added after the document content, they might cause page numbers to appear out of sequence. To maintain consistent numbering, use (Page Labels)[PageLabels.md] to assign a specific numbering style to the ToC pages. When using Page Labels, any extra ToC pages will follow the numbering style of the first ToC page.

The fpdf.outline.TableOfContents class provides a reference implementation of the ToC, which can be used as-is or subclassed.

When using FPDF.write_html, a document outline is automatically generated, and a ToC can be added with the <toc> tag.

To customize ToC styling, override the render_toc method in a subclass:

The regression tests are a good place to find code samples.

For example, the test_simple_outline test function generates the PDF document simple_outline.pdf.

Similarly, test_html_toc generates test_html_toc.pdf.

‚ö†Ô∏è Setting pdf.page manually may result in unexpected behavior. pdf.add_page() takes special care to ensure the page's content stream matches fpdf's instance attributes. Manually setting the page does not.

**Examples:**

Example 1 (unknown):
```unknown
pdf.start_section(name="Chapter 1: Introduction", level=0)
pdf.start_section(name="Section 1.1: Background", level=1)
```

Example 2 (python):
```python
from fpdf import FPDF
from fpdf.outline import TableOfContents

pdf = FPDF()
pdf.add_page()
toc = TableOfContents()
pdf.insert_toc_placeholder(toc.render_toc, allow_extra_pages=True)
```

Example 3 (python):
```python
from fpdf import FPDF, HTML2FPDF

class CustomHTML2FPDF(HTML2FPDF):
    def render_toc(self, pdf, outline):
        pdf.cell(text='Table of contents:', new_x="LMARGIN", new_y="NEXT")
        for section in outline:
            pdf.cell(text=f'* {section.name} (page {section.page_number})', new_x="LMARGIN", new_y="NEXT")

class PDF(FPDF):
    HTML2FPDF_CLASS = CustomHTML2FPDF

pdf = PDF()
pdf.add_page()
pdf.write_html("""<toc></toc>
    <h1>Level 1</h1>
    <h2>Level 2</h2>
    <h3>Level 3</h3>
    <h4>Level 4</h4>
    <h5>Level 5</h5>
    <h6>Level 6</h6>
    <p>paragraph<p>""")
pdf.output("html_toc.pdf")
```

---

## Module fpdf.unicode_script

**URL:** https://py-pdf.github.io/fpdf2/fpdf/unicode_script.html

**Contents:**
- Module fpdf.unicode_script
- Functions
- Classes
  - Ancestors
  - Class variables

The hardcoded information on this module was loaded from the Unicode file Scripts-16.0.0.txt https://www.unicode.org/Public/UNIDATA/Scripts.txt Python's standard "unicodedata" library doesn't offer this table.

Enum where members are also (and must be) ints

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

The type of the None singleton.

**Examples:**

Example 1 (python):
```python
@lru_cache(maxsize=None)
def get_unicode_script(char: str) -> UnicodeScript:
    chr_search = ord(char)
    for range_start, range_end, script_code in UNICODE_RANGE_TO_SCRIPT:
        if range_start <= chr_search <= range_end:
            return UnicodeScript(script_code)
        if chr_search < range_start:
            break
    return UnicodeScript(999)  # default to Unknown
```

Example 2 (python):
```python
class UnicodeScript(IntEnum):
    COMMON = 0
    LATIN = 1
    GREEK = 2
    CYRILLIC = 3
    ARMENIAN = 4
    HEBREW = 5
    ARABIC = 6
    SYRIAC = 7
    THAANA = 8
    DEVANAGARI = 9
    BENGALI = 10
    GURMUKHI = 11
    GUJARATI = 12
    ORIYA = 13
    TAMIL = 14
    TELUGU = 15
    KANNADA = 16
    MALAYALAM = 17
    SINHALA = 18
    THAI = 19
    LAO = 20
    TIBETAN = 21
    MYANMAR = 22
    GEORGIAN = 23
    HANGUL = 24
    ETHIOPIC = 25
    CHEROKEE = 26
    CANADIAN_ABORIGINAL = 27
    OGHAM = 28
    RUNIC = 29
    KHMER = 30
    MONGOLIAN = 31
    HIRAGANA = 32
    KATAKANA = 33
    BOPOMOFO = 34
    HAN = 35
    YI = 36
    OLD_ITALIC = 37
    GOTHIC = 38
    DESERET = 39
    INHERITED = 40
    TAGALOG = 41
    HANUNOO = 42
    BUHID = 43
    TAGBANWA = 44
    LIMBU = 45
    TAI_LE = 46
    LINEAR_B = 47
    UGARITIC = 48
    SHAVIAN = 49
    OSMANYA = 50
    CYPRIOT = 51
    BRAILLE = 52
    BUGINESE = 53
    COPTIC = 54
    NEW_TAI_LUE = 55
    GLAGOLITIC = 56
    TIFINAGH = 57
    SYLOTI_NAGRI = 58
    OLD_PERSIAN = 59
    KHAROSHTHI = 60
    BALINESE = 61
    CUNEIFORM = 62
    PHOENICIAN = 63
    PHAGS_PA = 64
    NKO = 65
    SUNDANESE = 66
    LEPCHA = 67
    OL_CHIKI = 68
    VAI = 69
    SAURASHTRA = 70
    KAYAH_LI = 71
    REJANG = 72
    LYCIAN = 73
    CARIAN = 74
    LYDIAN = 75
    CHAM = 76
    TAI_THAM = 77
    TAI_VIET = 78
    AVESTAN = 79
    EGYPTIAN_HIEROGLYPHS = 80
    SAMARITAN = 81
    LISU = 82
    BAMUM = 83
    JAVANESE = 84
    MEETEI_MAYEK = 85
    IMPERIAL_ARAMAIC = 86
    OLD_SOUTH_ARABIAN = 87
    INSCRIPTIONAL_PARTHIAN = 88
    INSCRIPTIONAL_PAHLAVI = 89
    OLD_TURKIC = 90
    KAITHI = 91
    BATAK = 92
    BRAHMI = 93
    MANDAIC = 94
    CHAKMA = 95
    MEROITIC_CURSIVE = 96
    MEROITIC_HIEROGLYPHS = 97
    MIAO = 98
    SHARADA = 99
    SORA_SOMPENG = 100
    TAKRI = 101
    CAUCASIAN_ALBANIAN = 102
    BASSA_VAH = 103
    DUPLOYAN = 104
    ELBASAN = 105
    GRANTHA = 106
    PAHAWH_HMONG = 107
    KHOJKI = 108
    LINEAR_A = 109
    MAHAJANI = 110
    MANICHAEAN = 111
    MENDE_KIKAKUI = 112
    MODI = 113
    MRO = 114
    OLD_NORTH_ARABIAN = 115
    NABATAEAN = 116
    PALMYRENE = 117
    PAU_CIN_HAU = 118
    OLD_PERMIC = 119
    PSALTER_PAHLAVI = 120
    SIDDHAM = 121
    KHUDAWADI = 122
    TIRHUTA = 123
    WARANG_CITI = 124
    AHOM = 125
    ANATOLIAN_HIEROGLYPHS = 126
    HATRAN = 127
    MULTANI = 128
    OLD_HUNGARIAN = 129
    SIGNWRITING = 130
    ADLAM = 131
    BHAIKSUKI = 132
    MARCHEN = 133
    NEWA = 134
    OSAGE = 135
    TANGUT = 136
    MASARAM_GONDI = 137
    NUSHU = 138
    SOYOMBO = 139
    ZANABAZAR_SQUARE = 140
    DOGRA = 141
    GUNJALA_GONDI = 142
    MAKASAR = 143
    MEDEFAIDRIN = 144
    HANIFI_ROHINGYA = 145
    SOGDIAN = 146
    OLD_SOGDIAN = 147
    ELYMAIC = 148
    NANDINAGARI = 149
    NYIAKENG_PUACHUE_HMONG = 150
    WANCHO = 151
    CHORASMIAN = 152
    DIVES_AKURU = 153
    KHITAN_SMALL_SCRIPT = 154
    YEZIDI = 155
    CYPRO_MINOAN = 156
    OLD_UYGHUR = 157
    TANGSA = 158
    TOTO = 159
    VITHKUQI = 160
    KAWI = 161
    NAG_MUNDARI = 162
    GARAY = 163
    GURUNG_KHEMA = 164
    KIRAT_RAI = 165
    OL_ONAL = 166
    SUNUWAR = 167
    TODHRI = 168
    TULU_TIGALARI = 169
    UNKNOWN = 999
```

---

## Usage in web APIs¬∂

**URL:** https://py-pdf.github.io/fpdf2/UsageInWebAPI.html

**Contents:**
- Usage in web APIs¬∂
- Django¬∂
- WSGI applications¬∂
  - Flask¬∂
  - Bottle¬∂
  - CherryPy¬∂
- AWS lambda¬∂
- streamlit¬∂
- FastAPI¬∂
- Plone¬∂

Note that FPDF instance objects are not designed to be reusable: content cannot be added once output() has been called.

Hence, even if the FPDF class should be thread-safe, we recommend that you either create an instance for every request, or if you want to use a global / shared object, to only store the bytes returned from output().

a high-level Python web framework that encourages rapid development and clean, pragmatic design

There is how you can return a PDF document from a Django view:

The following code can be placed in a fpdf2_app.py to make a WSGI application

This script can then be served as a HTTP application using either:

Flask is a micro web framework written in Python.

The following code can be placed in a app.py file and launched using flask run:

Bottle is a fast, simple and lightweight WSGI micro web-framework for Python. It is distributed as a single file module and has no dependencies other than the Python Standard Library.

The following code can be placed in a app.py file and launched using python3 app.py

a pythonic, object-oriented web framework, allowing developers to build web applications in much the same way they would build any other object-oriented Python program.

The following code can be placed in a app.py file and launched using python3 app.py

The following code demonstrates some minimal AWS lambda handler function that returns a PDF file as binary output: from base64 import b64encode from fpdf import FPDF def handler(event, context): pdf = FPDF() pdf.add_page() pdf.set_font("Helvetica", size=24) pdf.cell(text="hello world") return { 'statusCode': 200, 'headers': { 'Content-Type': 'application/json', }, 'body': b64encode(pdf.output()).decode('utf-8'), 'isBase64Encoded': True }

This AWS lambda function can then be linked to a HTTP endpoint using API Gateway, or simply exposed as a Lambda Function URL. More information on those pages:

For reference, the test lambda function was initiated using the following AWS CLI commands:

Those commands do not cover the creation of the lambda-fpdf2-role role, nor configuring the lambda access permissions, for example with a FunctionURLAllowPublicAccess resource-based policy.

a Python library that makes it easy to create and share custom web apps for data science

The following code demonstrates how to display a PDF and add a button allowing to download it:

a modern, fast (high-performance), web framework for building APIs with Python 3.7+ based on standard Python type hints.

The following code shows how to generate a PDF file via a POST endpoint that receives a JSON object. The JSON object can be used to write into the PDF file. The generated PDF file will be returned back to the user/frontend as the response.

a powerful open source Content Management System built on Python and the Zope application server

Plone is widely used for building secure and scalable web applications. Here's how to generate and serve PDF documents with fpdf2 in Plone.

The most common approach is to create a browser view that generates and returns a PDF:

Register the view in your package's configure.zcml:

The PDF can then be accessed at: http://yoursite.com/path/to/content/@@pdf-report

For a custom Dexterity content type, you can add a method that generates PDFs:

Then create a view to serve it:

Register this view in configure.zcml:

Generate PDFs from catalog search results:

Check tutorial/notebook.ipynb

Usage of the original PyFPDF library with web2py is described here: https://github.com/reingart/pyfpdf/blob/master/docs/Web2Py.md

v1.7.2 of PyFPDF is included in web2py since release 1.85.2: https://github.com/web2py/web2py/tree/master/gluon/contrib/fpdf

**Examples:**

Example 1 (python):
```python
from django.http import HttpResponse
from fpdf import FPDF

def report(request):
    pdf = FPDF()
    pdf.add_page()
    pdf.set_font("Helvetica", size=24)
    pdf.cell(text="hello world")
    return HttpResponse(bytes(pdf.output()), content_type="application/pdf")
```

Example 2 (python):
```python
from fpdf import FPDF

def app(environ, start_response):
    pdf = FPDF()
    pdf.add_page()
    pdf.set_font("Helvetica", size=12)
    pdf.cell(text="Hello world!")
    data = bytes(pdf.output())
    start_response("200 OK", [
        ("Content-Type", "application/pdf"),
        ("Content-Length", str(len(data)))
    ])
    return iter([data])
```

Example 3 (python):
```python
from flask import Flask, make_response
from fpdf import FPDF

app = Flask(__name__)

@app.route("/")
def hello_world():
    pdf = FPDF()
    pdf.add_page()
    pdf.set_font("Helvetica", size=24)
    pdf.cell(text="hello world")
    response = make_response(bytes(pdf.output()))
    response.headers["Content-Type"] = "application/pdf"
    return response
```

Example 4 (python):
```python
from bottle import route, run, response
from fpdf import FPDF

@route('/')
def hello():
    pdf = FPDF()
    pdf.add_page()
    pdf.set_font("Helvetica", size=24)
    pdf.cell(text="hello world")
    pdf_bytes = bytes(pdf.output())

    response.set_header('Content-Type', 'application/pdf')
    response.status = 200
    response.content_length = len(pdf_bytes)

    return pdf_bytes

if __name__ == '__main__':
    run(host='localhost', port=8080, debug=True)
```

---

## ◊û◊ì◊®◊ô◊ö¬∂

**URL:** https://py-pdf.github.io/fpdf2/Tutorial-he.html

**Contents:**
- ◊û◊ì◊®◊ô◊ö¬∂
- 1 - ◊ì◊ï◊í◊û◊ê ◊û◊ô◊†◊ô◊û◊ú◊ô◊™¬∂
- 2 - ◊õ◊ï◊™◊®◊™ ◊¢◊ú◊ô◊ï◊†◊î, ◊õ◊ï◊™◊®◊™ ◊™◊ó◊™◊ï◊†◊î, ◊û◊¢◊ë◊® ◊¢◊û◊ï◊ì ◊ï◊™◊û◊ï◊†◊ï◊™¬∂
- 3 - ◊©◊ï◊®◊ï◊™ ◊®◊ï◊ï◊ó ◊ï◊¶◊ë◊¢◊ô◊ù¬∂
- 4 - ◊¢◊û◊ï◊ì◊ï◊™ ◊û◊®◊ï◊ë◊ï◊™¬∂
- 5 - ◊ô◊¶◊ô◊®◊™ ◊ò◊ë◊ú◊ê◊ï◊™¬∂
- 6 - ◊ô◊¶◊ô◊®◊™ ◊ß◊ô◊©◊ï◊®◊ô◊ù ◊ï◊¢◊®◊ë◊ï◊ë ◊°◊í◊†◊ï◊†◊ï◊™ ◊ò◊ß◊°◊ò¬∂

◊™◊ô◊¢◊ï◊ì ◊û◊ú◊ê: fpdf.FPDF API doc

◊ê◊ó◊®◊ô ◊©◊õ◊ú◊ú◊†◊ï ◊ê◊™ ◊ß◊ï◊ë◊• ◊î◊°◊§◊®◊ô◊î, ◊ô◊¶◊®◊†◊ï ◊ê◊ï◊ë◊ô◊ô◊ß◊ò FPDF. ◊î◊ë◊†◊ê◊ô ◊©◊ú FPDF ◊û◊©◊™◊û◊© ◊õ◊ê◊ü ◊ë◊¢◊®◊õ◊ô◊ù ◊ì◊ô◊§◊ï◊ú◊ò◊ô◊ë◊ô◊ô◊ù: ◊ì◊§◊ô◊ù ◊ë◊§◊ï◊®◊û◊ò A4 ◊ú◊ê◊ï◊®◊ö ◊ï◊î◊û◊ô◊ì◊ï◊™ ◊ë◊û◊ô◊ú◊ô◊û◊ò◊®◊ô◊ù. ◊†◊ô◊™◊ü ◊ú◊¶◊ô◊ô◊ü ◊ñ◊ê◊™ ◊ë◊û◊§◊ï◊®◊© ◊ë◊ê◊û◊¶◊¢◊ï◊™:

pdf = FPDF(orientation="P", unit="mm", format="A4") ◊†◊ô◊™◊ü ◊ú◊î◊í◊ì◊ô◊® ◊ê◊™ ◊îPDF ◊ú◊®◊ï◊ó◊ë (L) ◊ê◊ï ◊ú◊î◊©◊™◊û◊© ◊ë◊™◊ë◊†◊ô◊ï◊™ ◊©◊ï◊†◊ï◊™ (◊õ◊û◊ï Letter ◊ê◊ï Legal) ◊ï◊û◊ô◊ì◊ï◊™ ◊©◊ï◊†◊ï◊™ (◊õ◊û◊ï pt, cm, in).

◊õ◊®◊í◊¢ ◊ê◊ô◊ü ◊¢◊û◊ï◊ì◊ô◊ù, ◊†◊¶◊ò◊®◊ö ◊ú◊î◊ï◊°◊ô◊£ ◊ê◊ó◊ì ◊ë◊¢◊ñ◊®◊™ add_page. ◊î◊û◊ß◊ï◊® ◊î◊ï◊ê ◊ë◊§◊ô◊†◊î ◊î◊©◊û◊ê◊ú◊ô◊™ ◊¢◊ú◊ô◊ï◊†◊î ◊ï◊î◊§◊ï◊ñ◊ô◊¶◊ô◊î ◊î◊†◊ï◊õ◊ó◊ô◊™ ◊ë◊ë◊®◊ô◊®◊™ ◊î◊û◊ó◊ì◊ú ◊î◊ô◊ê ◊°◊†◊ò◊ô◊û◊ò◊® ◊ê◊ó◊ì ◊û◊î◊í◊ë◊ï◊ú◊ï◊™; ◊†◊ô◊™◊ü ◊ú◊©◊†◊ï◊™ ◊ê◊™ ◊î◊©◊ï◊ú◊ô◊ô◊ù ◊¢◊ú ◊ô◊ì◊ô set_margins.

◊ú◊§◊†◊ô ◊©◊†◊ï◊õ◊ú ◊ú◊î◊ì◊§◊ô◊° ◊ò◊ß◊°◊ò, ◊ó◊ï◊ë◊î ◊ú◊ë◊ó◊ï◊® ◊í◊ï◊§◊ü ◊ë◊¢◊ñ◊®◊™ set_font, ◊ê◊ó◊®◊™ ◊î◊û◊°◊û◊ö ◊ú◊ê ◊ô◊î◊ô◊î ◊™◊ß◊ô◊ü. ◊ê◊†◊ó◊†◊ï ◊ë◊ï◊ó◊®◊ô◊ù ◊ë◊í◊ï◊§◊ü helvetica ◊û◊ï◊ì◊í◊© ◊ë◊í◊ï◊ì◊ú 16:

◊ô◊õ◊ï◊ú◊†◊ï ◊ú◊ë◊ó◊ï◊® ◊î◊ò◊ô◊ô◊î ◊¢◊ù I, ◊ß◊ï ◊™◊ó◊™◊ï◊ü ◊¢◊ù U, ◊ê◊ï ◊í◊ï◊§◊ü ◊®◊í◊ô◊ú ◊¢◊ù ◊û◊ó◊®◊ï◊ñ◊™ ◊®◊ô◊ß◊î (◊ê◊ï ◊õ◊ú ◊©◊ô◊ú◊ï◊ë ◊©◊ú ◊î◊†"◊ú). ◊©◊ô◊û◊ï ◊ú◊ë ◊©◊í◊ï◊ì◊ú ◊î◊í◊ï◊§◊ü ◊î◊ï◊ê ◊ë◊†◊ß◊ï◊ì◊ï◊™ ◊ï◊ú◊ê ◊û◊ô◊ú◊ô◊û◊ò◊®◊ô◊ù ◊ê◊ï ◊õ◊ú ◊ô◊ó◊ô◊ì◊™ ◊û◊ô◊ì◊î ◊ê◊ó◊®◊™. ◊ñ◊î ◊ô◊ï◊¶◊ê ◊î◊ì◊ï◊§◊ü ◊î◊ô◊ó◊ô◊ì. ◊î◊í◊ï◊§◊†◊ô◊ù ◊î◊û◊ï◊ë◊†◊ô◊ù ◊î◊ê◊ó◊®◊ô◊ù ◊î◊ù Times, Courier, Symbol, ZapfDingbats.

◊õ◊¢◊™ ◊†◊ï◊õ◊ú ◊ú◊î◊ì◊§◊ô◊° ◊™◊ê ◊¢◊ù cell. ◊™◊ê ◊î◊ï◊ê ◊ê◊ô◊ñ◊ï◊® ◊û◊ú◊ë◊†◊ô, ◊ê◊ï◊ú◊ô ◊û◊û◊ï◊°◊í◊®, ◊©◊û◊õ◊ô◊ú ◊ò◊ß◊°◊ò. ◊†◊ï◊¶◊® ◊ë◊§◊ï◊ñ◊ô◊¶◊ô◊î ◊î◊†◊ï◊õ◊ó◊ô◊™. ◊ê◊†◊ó◊†◊ï ◊û◊¶◊ô◊ô◊†◊ô◊ù ◊ê◊™ ◊î◊û◊ô◊ì◊ï◊™ ◊©◊ú◊ï, ◊ò◊ß◊°◊ò (◊û◊û◊ï◊®◊õ◊ñ ◊ê◊ï ◊û◊ô◊ï◊©◊®), ◊î◊ê◊ù ◊ú◊¶◊ô◊ô◊® ◊í◊ë◊ï◊ú◊ï◊™, ◊ï◊ú◊ê◊ü ◊™◊ñ◊ï◊ñ ◊î◊§◊ï◊ñ◊ô◊¶◊ô◊î ◊î◊†◊ï◊õ◊ó◊ô◊™ ◊ú◊ê◊ó◊® ◊î◊™◊ê (◊û◊ô◊û◊ô◊ü, ◊ú◊û◊ò◊î ◊ê◊ï ◊ë◊™◊ó◊ô◊ú◊™ ◊î◊©◊ï◊®◊î ◊î◊ë◊ê◊î). ◊õ◊ì◊ô ◊ú◊î◊ï◊°◊ô◊£ ◊û◊°◊í◊®◊™, ◊†◊®◊ô◊•:

◊õ◊ì◊ô ◊ú◊î◊ï◊°◊ô◊£ ◊ú◊ô◊ì ◊î◊™◊ê ◊î◊ß◊ï◊ì◊ù ◊™◊ê ◊¢◊ù ◊ò◊ß◊°◊ò ◊û◊û◊ï◊®◊õ◊ñ ◊ï◊ê◊ñ ◊ú◊ú◊õ◊™ ◊ú◊©◊ï◊®◊î ◊î◊ë◊ê◊î, ◊†◊®◊ô◊•:

◊î◊¢◊®◊î: ◊ê◊§◊©◊® ◊ú◊ô◊¶◊ï◊® ◊©◊ï◊®◊î ◊®◊ï◊ï◊ó ◊í◊ù ◊ë◊¢◊ñ◊®◊™ ln. ◊î◊©◊ô◊ò◊î ◊î◊ñ◊ï ◊û◊ê◊§◊©◊®◊™ ◊í◊ù ◊ú◊¶◊ô◊ô◊ü ◊ê◊™ ◊í◊ï◊ë◊î ◊î◊®◊ï◊ï◊ó.

◊ú◊ë◊°◊ï◊£, ◊î◊ß◊ï◊ë◊• ◊†◊°◊í◊® ◊ï◊†◊©◊û◊® ◊™◊ó◊™ ◊î◊õ◊™◊ï◊ë◊™ ◊©◊°◊ï◊§◊ß◊î ◊ë◊ê◊û◊¶◊¢◊ï◊™ output. ◊ú◊ú◊ê ◊§◊®◊û◊ò◊®◊ô◊ù ◊†◊ï◊°◊§◊ô◊ù, ()output ◊û◊ó◊ñ◊ô◊® ◊ê◊™ ◊î◊ë◊ê◊§◊® bytearray ◊©◊ú ◊îPDF.

◊ì◊ï◊í◊û◊ê ◊ë◊¢◊ú◊™ ◊©◊†◊ô ◊¢◊û◊ï◊ì◊ô◊ù ◊¢◊ù ◊õ◊ï◊™◊®◊™ ◊¢◊ú◊ô◊ï◊†◊î, ◊õ◊ï◊™◊®◊™ ◊™◊ó◊™◊ï◊†◊î ◊ï◊ú◊ï◊í◊ï:

◊î◊ì◊ï◊í◊û◊ê ◊û◊©◊™◊û◊©◊™ ◊ë◊û◊™◊ï◊ì◊ï◊™ header ◊ïfooter ◊¢◊ú ◊û◊†◊™ ◊ú◊¢◊ë◊ì ◊õ◊ï◊™◊®◊ï◊™ ◊¢◊û◊ï◊ì. ◊î◊ü ◊†◊ß◊®◊ê◊ï◊™ ◊ê◊ï◊ò◊ï◊û◊ò◊ô◊™. ◊î◊ü ◊õ◊ë◊® ◊ß◊ô◊ô◊û◊ï◊™ ◊ë◊û◊ó◊ú◊ß◊î FPDF ◊ï◊ú◊ê ◊¢◊ï◊©◊ï◊™ ◊õ◊ú◊ï◊ù, ◊ú◊õ◊ü ◊†◊¶◊ò◊®◊ö ◊ú◊î◊®◊ó◊ô◊ë ◊ê◊™ ◊î◊û◊ó◊ú◊ß◊î ◊ï◊ú◊ì◊®◊ï◊° ◊ê◊ï◊™◊ü.

◊î◊ú◊ï◊í◊ï ◊û◊ï◊ì◊§◊° ◊¢◊ù ◊û◊™◊ï◊ì◊™ ◊îimage ◊¢"◊ô ◊¶◊ô◊ï◊ü ◊î◊†◊ß◊ï◊ì◊î ◊î◊©◊û◊ê◊ú◊ô◊™-◊¢◊ú◊ô◊ï◊†◊î ◊ï◊ê◊™ ◊î◊®◊ï◊ó◊ë. ◊î◊í◊ï◊ë◊î ◊û◊ó◊ï◊©◊ë ◊ê◊ï◊ò◊ï◊û◊ò◊ô◊™ ◊ú◊§◊ô ◊û◊ô◊ì◊ï◊™ ◊î◊™◊û◊ï◊†◊î.

◊¢◊ú ◊û◊†◊™ ◊ú◊î◊ì◊§◊ô◊° ◊ê◊™ ◊û◊°◊§◊® ◊î◊¢◊û◊ï◊ì, ◊†◊ô◊™◊ü ◊ú◊î◊¢◊ë◊ô◊® ◊¢◊®◊ö null ◊õ◊®◊ï◊ó◊ë ◊î◊™◊ê. ◊õ◊ö ◊î◊™◊ê ◊ô◊™◊®◊ó◊ë ◊¢◊ì ◊î◊©◊ï◊ú ◊î◊ô◊û◊†◊ô ◊©◊ú ◊î◊¢◊û◊ï◊ì; ◊ñ◊î ◊©◊ô◊û◊ï◊©◊ô ◊õ◊ê◊©◊® ◊¶◊®◊ô◊ö ◊ú◊û◊®◊õ◊ñ ◊ê◊™ ◊î◊ò◊ß◊°◊ò. ◊û◊°◊§◊® ◊î◊¢◊û◊ï◊ì ◊î◊†◊ï◊õ◊ó◊ô ◊ó◊ï◊ñ◊® ◊û◊û◊™◊ï◊ì◊™ ◊îpage_no; ◊ú◊í◊ë◊ô ◊û◊°◊§◊® ◊î◊¢◊û◊ï◊ì◊ô◊ù ◊î◊õ◊ï◊ú◊ú, ◊†◊ô◊™◊ü ◊ú◊î◊©◊ô◊í ◊†◊™◊ï◊ü ◊ñ◊î ◊û◊î◊¢◊®◊ö ◊î◊û◊ô◊ï◊ó◊ì {nb} ◊©◊ô◊ï◊ó◊ú◊£ ◊ë◊°◊í◊ô◊®◊™ ◊î◊û◊°◊û◊ö (◊†◊ô◊™◊ü ◊ú◊©◊†◊ï◊™ ◊¢◊®◊ö ◊ñ◊î ◊¢"◊ô ◊©◊ô◊û◊ï◊© ◊ë()alias_nb_pages). ◊©◊ô◊û◊ï ◊ú◊ë ◊ú◊û◊™◊ï◊ì◊î set_y ◊©◊û◊ê◊§◊©◊®◊™ ◊ú◊î◊í◊ì◊ô◊® ◊§◊ï◊ñ◊ô◊¶◊ô◊î ◊ê◊ë◊°◊ï◊ú◊ï◊ò◊ô◊™ ◊ë◊ì◊£, ◊û◊®◊ê◊© ◊ê◊ï ◊™◊ó◊™◊ô◊™ ◊î◊¢◊û◊ï◊ì.

◊†◊¢◊©◊î ◊í◊ù ◊©◊ô◊û◊ï◊© ◊ë◊§◊ô◊¶'◊® ◊†◊ï◊°◊£ ◊õ◊ê◊ü: ◊û◊¢◊ë◊® ◊¢◊û◊ï◊ì ◊ê◊ï◊ò◊ï◊û◊ò◊ô. ◊ë◊®◊í◊¢ ◊©◊™◊ê ◊ô◊ó◊®◊ï◊í ◊û◊í◊ë◊ï◊ú◊ï◊™ ◊î◊ì◊£ (◊ë◊ë◊®◊ô◊®◊™ ◊û◊ó◊ì◊ú 2 ◊°◊†◊ò◊ô◊û◊ò◊® ◊û◊î◊°◊ï◊£), ◊û◊™◊™◊ë◊¶◊¢ ◊û◊¢◊ë◊® ◊¢◊û◊ï◊ì ◊ï◊î◊í◊ï◊§◊ü ◊ó◊ï◊ñ◊® ◊ú◊î◊ô◊ï◊™ ◊û◊î ◊©◊î◊ï◊í◊ì◊® ◊¢◊ë◊ï◊® ◊í◊ï◊£ ◊î◊¢◊û◊ï◊ì. ◊ú◊û◊®◊ï◊™ ◊©◊î◊õ◊ï◊™◊®◊™ ◊î◊¢◊ú◊ô◊ï◊†◊î ◊ï◊î◊™◊ó◊™◊ï◊†◊î ◊û◊©◊™◊û◊©◊ï◊™ ◊ë◊í◊ï◊§◊ü (helvetica), ◊í◊ï◊£ ◊î◊¢◊û◊ï◊ì ◊û◊û◊©◊ô◊ö ◊¢◊ù Times. ◊î◊û◊†◊í◊†◊ï◊ü ◊î◊ñ◊î ◊™◊ß◊£ ◊í◊ù ◊ú◊í◊ë◊ô ◊¶◊ë◊¢ ◊ï◊®◊ï◊ó◊ë ◊©◊ï◊®◊î. ◊î◊í◊ë◊ï◊ú ◊©◊û◊§◊¢◊ô◊ú ◊ê◊™ ◊û◊¢◊ë◊® ◊î◊¢◊û◊ï◊ì ◊î◊ê◊ï◊ò◊ï◊û◊ò◊ô ◊†◊ô◊™◊ü ◊ú◊©◊ô◊†◊ï◊ô ◊ë◊ê◊û◊¶◊¢◊ï◊™ set_auto_page_break.

◊†◊û◊©◊ô◊ö ◊¢◊ù ◊ì◊ï◊í◊û◊ê ◊©◊û◊ì◊§◊ô◊°◊î ◊§◊°◊ß◊ê◊ï◊™ ◊ï◊û◊ì◊í◊ô◊û◊î ◊©◊ô◊û◊ï◊© ◊ë◊¶◊ë◊¢◊ô◊ù.

◊û◊™◊ï◊ì◊™ ◊îget_string_width ◊û◊ê◊§◊©◊®◊™ ◊ú◊ß◊ë◊ï◊¢ ◊ê◊ï◊®◊ö ◊û◊ó◊®◊ï◊ñ◊™ ◊ë◊í◊ï◊§◊ü ◊î◊†◊ï◊õ◊ó◊ô, ◊©◊ë◊ì◊ï◊í◊û◊ê ◊ñ◊ï ◊û◊©◊û◊© ◊õ◊ì◊ô ◊ú◊ó◊©◊ë ◊ê◊™ ◊î◊§◊ï◊ñ◊ô◊¶◊ô◊î ◊ï◊î◊®◊ï◊ó◊ë ◊©◊ú ◊î◊û◊°◊í◊®◊™ ◊î◊û◊ß◊ô◊§◊î ◊ê◊™ ◊î◊õ◊ï◊™◊®◊™. ◊ú◊ê◊ó◊® ◊û◊õ◊ü ◊û◊ï◊í◊ì◊®◊ô◊ù ◊¶◊ë◊¢◊ô◊ù (◊ë◊ê◊û◊¶◊¢◊ï◊™ set_draw_color, set_fill_color ◊ï set_text_color) ◊ï◊¢◊ï◊ë◊ô ◊î◊©◊ï◊®◊î ◊û◊ï◊í◊ì◊® ◊ú◊û◊ô◊ú◊ô◊û◊ò◊® (◊ë◊†◊ô◊í◊ï◊ì ◊ú0.2 ◊û◊ô◊ú◊ô◊û◊ò◊® ◊õ◊ë◊®◊ô◊®◊™ ◊û◊ó◊ì◊ú) ◊ë◊ê◊û◊¶◊¢◊ï◊™ set_line_width. ◊ú◊ë◊°◊ï◊£ ◊ê◊†◊ó◊†◊ï ◊û◊ì◊§◊ô◊°◊ô◊ù ◊ê◊™ ◊î◊™◊ê (◊î◊§◊®◊û◊ò◊® ◊î◊ê◊ó◊®◊ï◊ü true ◊û◊¢◊ô◊ì ◊©◊î◊®◊ß◊¢ ◊¶◊®◊ô◊ö ◊ú◊î◊ô◊ï◊™ ◊û◊ú◊ê).

◊î◊û◊™◊ï◊ì◊î ◊ë◊î ◊û◊©◊™◊û◊©◊ô◊ù ◊ú◊î◊ì◊§◊°◊™ ◊î◊§◊°◊ß◊ê ◊î◊ô◊ê multi_cell. ◊ò◊ß◊°◊ò ◊†◊ó◊™◊ö ◊ê◊ï◊ò◊ï◊û◊ò◊ô◊™ ◊ë◊°◊ï◊£ ◊î◊©◊ï◊®◊î ◊õ◊ë◊®◊ô◊®◊™ ◊û◊ó◊ì◊ú. ◊ë◊õ◊ú ◊§◊¢◊ù ◊©◊©◊ï◊®◊î ◊û◊í◊ô◊¢◊î ◊ú◊ß◊¶◊î ◊î◊ô◊û◊†◊ô ◊©◊ú ◊î◊™◊ê ◊ê◊ï ◊©◊†◊û◊¶◊ê ◊î◊™◊ï (n\), ◊†◊ï◊¶◊®◊™ ◊©◊ï◊®◊î ◊ó◊ì◊©◊î ◊ë◊™◊ê ◊ó◊ì◊© ◊û◊™◊ó◊™ ◊ú◊†◊ï◊õ◊ó◊ô. ◊î◊§◊°◊ß◊™ ◊©◊ï◊®◊î ◊ê◊ï◊ò◊ï◊û◊ò◊ô◊™ ◊†◊ï◊¶◊®◊™ ◊ë◊û◊ô◊ß◊ï◊ù ◊©◊ú ◊î◊®◊ï◊ï◊ó ◊î◊ß◊®◊ï◊ë ◊ê◊ï ◊™◊ï ◊ë◊ú◊™◊ô-◊†◊®◊ê◊î (u00ad\) ◊ú◊§◊†◊ô ◊°◊ï◊£ ◊î◊©◊ï◊®◊î. ◊î◊™◊ï ◊ô◊ï◊ó◊ú◊£ ◊ë◊û◊ß◊£ ◊ê◊ù ◊î◊ï◊§◊¢◊ú◊î ◊î◊§◊°◊ß◊™ ◊©◊ï◊®◊î.

◊©◊™◊ô ◊™◊õ◊ï◊†◊ï◊™ ◊û◊°◊û◊ö ◊î◊ï◊í◊ì◊®◊ï: ◊©◊ù ◊î◊û◊°◊û◊ö (set_title) ◊ï◊ô◊ï◊¶◊® (set_author). ◊†◊ô◊™◊ü ◊ú◊¶◊§◊ï◊™ ◊ë◊™◊õ◊ï◊†◊ï◊™ ◊ë◊©◊†◊ô ◊ê◊ï◊§◊†◊ô◊ù: ◊ê◊ï◊§◊¶◊ô◊î ◊®◊ê◊©◊ï◊†◊î ◊î◊ô◊ê ◊ú◊§◊™◊ï◊ó ◊ê◊™ ◊î◊û◊°◊û◊ö ◊ëAdobe Reader ◊ô◊©◊ô◊®◊ï◊™, ◊ï◊ê◊ñ ◊ë'◊™◊§◊®◊ô◊ò' ◊ú◊ë◊ó◊ï◊® '◊™◊õ◊ï◊†◊ï◊™ ◊û◊°◊û◊ö'. ◊ê◊ï◊§◊¶◊ô◊î ◊©◊†◊ô◊î, ◊ñ◊û◊ô◊†◊î ◊í◊ù ◊ë◊ê◊û◊¶◊¢◊ï◊™ ◊™◊ï◊°◊£, ◊ñ◊î ◊ú◊ó◊¶◊ü ◊ô◊û◊†◊ô ◊ï◊ê◊ñ ◊ú◊ë◊ó◊ï◊® ◊™◊õ◊ï◊†◊ï◊™ ◊û◊°◊û◊ö.

◊î◊ì◊ï◊í◊û◊ê ◊î◊ñ◊ï ◊ì◊ï◊û◊î ◊ú◊ß◊ï◊ì◊û◊™ ◊ï◊û◊®◊ê◊î ◊ê◊ô◊ö ◊ú◊§◊®◊ï◊° ◊ò◊ß◊°◊ò ◊¢◊ú ◊§◊†◊ô ◊û◊°◊§◊® ◊¢◊û◊ï◊ì◊ï◊™.

◊î◊î◊ë◊ì◊ú ◊î◊¢◊ô◊ß◊®◊ô ◊û◊î◊ì◊ï◊í◊û◊ê ◊î◊ß◊ï◊ì◊û◊™ ◊î◊ï◊ê ◊î◊©◊ô◊û◊ï◊© ◊ë◊û◊™◊ï◊ì◊™ ◊î text_columns. ◊î◊ô◊ê ◊ê◊ï◊°◊§◊™ ◊ê◊™ ◊õ◊ú ◊î◊ò◊ß◊°◊ò, ◊ï◊û◊§◊ñ◊®◊™ ◊ê◊ï◊™◊ï ◊¢◊ú ◊û◊°◊§◊® ◊î◊¢◊û◊ï◊ì◊ï◊™ ◊î◊û◊ë◊ï◊ß◊© (◊ú◊§◊¢◊û◊ô◊ù ◊û◊í◊ì◊ô◊ú◊î ◊ê◊ï◊™◊ï), ◊ï◊ê◊ï◊ò◊ï◊û◊ò◊ô◊™ ◊û◊¢◊ë◊ô◊®◊î ◊¢◊û◊ï◊ì ◊õ◊©◊¶◊®◊ô◊ö. ◊©◊ô◊û◊ï ◊ú◊ë ◊©◊ë◊ñ◊û◊ü ◊©◊û◊ï◊§◊¢ ◊©◊ú TextColumns ◊§◊ï◊¢◊ú ◊õ◊û◊†◊î◊ú ◊î◊ß◊©◊® (context manager), ◊¢◊ô◊¶◊ï◊ë ◊©◊ú ◊ò◊ß◊°◊ò ◊ï◊ê◊ú◊û◊†◊ò◊ô◊ù ◊†◊ï◊°◊§◊ô◊ù ◊¢◊©◊ï◊ô◊ô◊ù ◊ú◊î◊©◊™◊†◊ï◊™. ◊©◊ô◊†◊ï◊ô◊ô◊ù ◊ê◊ú◊î ◊û◊ï◊õ◊ú◊ô◊ù ◊ë◊î◊ß◊©◊®. ◊ë◊®◊í◊¢ ◊©◊î◊û◊ï◊§◊¢ ◊†◊°◊í◊®, ◊î◊î◊í◊ì◊®◊ï◊™ ◊î◊ß◊ï◊ì◊û◊ï◊™ ◊ô◊ï◊ó◊ú◊ï ◊©◊ï◊ë.

◊ì◊ï◊í◊û◊ê ◊ñ◊ï ◊û◊°◊ë◊ô◊®◊î ◊õ◊ô◊¶◊ì ◊†◊ô◊™◊ü ◊ú◊ô◊¶◊ï◊® ◊©◊™◊ô ◊ò◊ë◊ú◊ê◊ï◊™◊©◊ï◊†◊ï◊™, ◊¢◊ú ◊û◊†◊™ ◊ú◊î◊ì◊í◊ô◊ù ◊û◊î ◊†◊ô◊™◊ü ◊ú◊î◊©◊ô◊í ◊ë◊ê◊û◊¶◊¢◊ï◊™ ◊î◊™◊ê◊û◊ï◊™ ◊ß◊ò◊†◊ï◊™.

◊™◊ï◊¶◊® - Countries CSV data

◊ê◊™ ◊î◊ò◊ë◊ú◊ê ◊î◊®◊ê◊©◊ï◊†◊î ◊†◊ô◊™◊ü ◊ú◊ô◊ô◊¶◊® ◊ë◊ì◊®◊ö ◊î◊§◊©◊ï◊ò◊î ◊ë◊ô◊ï◊™◊®, ◊¢◊ú ◊ô◊ì◊ô ◊î◊ñ◊†◊™ ◊ì◊ê◊ò◊î FPDF.table(). ◊î◊™◊ï◊¶◊ê◊î ◊î◊ô◊ê ◊ë◊°◊ô◊°◊ô◊™ ◊ê◊ë◊ú ◊ß◊ú◊î ◊ï◊û◊î◊ô◊®◊î.

The second table brings some improvements: colors, limited table width, reduced line height, ◊î◊ò◊ë◊ú◊ê ◊î◊©◊†◊ô◊î ◊û◊¶◊ô◊í◊î ◊û◊°◊§◊® ◊©◊ô◊§◊ï◊®◊ô◊ù: ◊¶◊ë◊¢◊ô◊ù◊™ ◊®◊ï◊ó◊ë ◊ò◊ë◊ê ◊û◊ï◊í◊ë◊ú◊™ ◊í◊ï◊ë◊î ◊ß◊ï◊ï◊ô◊ù ◊û◊ï◊§◊ó, ◊õ◊ï◊™◊®◊ï◊™ ◊û◊û◊ï◊®◊õ◊ñ◊ï◊™, ◊®◊ï◊ó◊ë ◊¢◊û◊ï◊ì◊ï◊™ ◊û◊ï◊™◊ê◊ù ◊ê◊ô◊©◊ô◊™, ◊ô◊ô◊©◊ï◊® ◊ú◊ô◊û◊ô◊ü... ◊ë◊†◊ï◊°◊£, ◊ß◊ï◊ï◊ô◊ù ◊ê◊ï◊§◊ß◊ô◊ô◊ù ◊î◊ï◊°◊®◊ï. ◊ñ◊î ◊†◊¢◊©◊î ◊¢◊ú ◊ô◊ì◊ô ◊ë◊ó◊ô◊®◊™ borders_layout ◊¢◊ù ◊î◊¢◊®◊õ◊ô◊ù ◊î◊ñ◊û◊ô◊†◊ô◊ù: TableBordersLayout.

‚ö†Ô∏è This section has changed a lot and requires a new translation: https://github.com/py-pdf/fpdf2/issues/267

◊ì◊ï◊í◊û◊ê ◊ñ◊ï ◊û◊¶◊ô◊í◊î ◊û◊°◊§◊® ◊ì◊®◊õ◊ô◊ù ◊ú◊î◊ï◊°◊ô◊£ ◊ß◊ô◊©◊ï◊®◊ô◊ù ◊ú◊û◊°◊û◊ö ◊ï◊ß◊ô◊©◊ï◊®◊ô◊ù ◊ó◊ô◊¶◊ï◊†◊ô◊ô◊ù. ◊ë◊†◊ï◊°◊£ ◊î◊ì◊ï◊í◊û◊ê ◊û◊û◊ó◊ô◊©◊î ◊©◊ô◊û◊ï◊© ◊ë◊°◊í◊†◊ï◊†◊ï◊™ ◊©◊ï◊†◊ô◊ù ◊©◊ú ◊¢◊ô◊¶◊ï◊ë ◊ò◊ß◊°◊ò (◊û◊ï◊ì◊í◊©, ◊†◊ò◊ï◊ô, ◊ß◊ï ◊™◊ó◊™◊ï◊ü) ◊ë◊ê◊ï◊™◊ï ◊ò◊ß◊°◊ò.

◊î◊û◊™◊ï◊ì◊î ◊î◊ó◊ì◊©◊î ◊©◊û◊©◊ï◊û◊©◊™ ◊õ◊ê◊ü ◊õ◊ì◊ô ◊ú◊î◊ì◊§◊ô◊° ◊ò◊ß◊°◊ò ◊î◊ô◊ê ()write. ◊ì◊ï◊û◊î ◊û◊ê◊ï◊ì ◊ú()multi_cell, ◊õ◊ê◊©◊® ◊î◊î◊ë◊ì◊ú◊ô◊ù ◊î◊¢◊ô◊ß◊®◊ô◊ô◊ù ◊î◊ù:

◊ú◊§◊ô◊õ◊ö ◊î◊û◊™◊ï◊ì◊î ◊û◊ê◊§◊©◊®◊™ ◊ú◊†◊ï ◊ú◊õ◊™◊ï◊ë ◊ß◊ò◊¢ ◊ò◊ß◊°◊ò, ◊ú◊©◊†◊ï◊™ ◊ê◊™ ◊°◊í◊†◊ï◊ü ◊î◊í◊ï◊§◊ü, ◊ï◊ú◊î◊û◊©◊ô◊ö ◊û◊ê◊ï◊™◊ï ◊û◊ß◊ï◊ù ◊©◊¢◊¶◊®◊†◊ï. ◊û◊¶◊ì ◊©◊†◊ô, ◊î◊ó◊°◊®◊ï◊ü ◊î◊¢◊ô◊ß◊®◊ô ◊î◊ï◊ê ◊©◊ú◊ê ◊†◊ô◊™◊ü ◊ú◊ô◊ô◊©◊® ◊ê◊™ ◊î◊ò◊ß◊°◊ò ◊õ◊û◊ï ◊ë()multi_cell.

◊ë◊¢◊û◊ï◊ì ◊î◊®◊ê◊©◊ï◊ü ◊©◊ú ◊î◊ì◊ï◊í◊û◊ê ◊î◊©◊™◊û◊©◊†◊ï ()write ◊ú◊û◊ò◊®◊î ◊ñ◊ï. ◊™◊ó◊ô◊ú◊™ ◊î◊û◊©◊§◊ò ◊†◊õ◊™◊ë ◊ë◊°◊í◊†◊ï◊ü ◊ò◊ß◊°◊ò ◊®◊í◊ô◊ú ◊ï◊ê◊ñ ◊¢◊ú ◊ô◊ì◊ô ◊©◊ô◊û◊ï◊© ◊ë◊û◊™◊ï◊ì◊î ()set_font ◊î◊ó◊ú◊§◊†◊ï ◊ú◊ò◊ß◊°◊ò ◊¢◊ù ◊ß◊ï ◊™◊ó◊™◊ï◊ü ◊ú◊°◊ô◊ï◊ù ◊î◊û◊©◊§◊ò.

◊õ◊ì◊ô ◊ú◊î◊ï◊°◊ô◊£ ◊ß◊ô◊©◊ï◊® ◊§◊†◊ô◊û◊ô ◊©◊û◊ï◊ë◊ô◊ú ◊ú◊¢◊û◊ï◊ì ◊î◊©◊†◊ô ◊î◊©◊™◊û◊©◊†◊ï ◊ë◊û◊™◊ï◊ì◊î ()add_link ◊©◊ï◊¶◊®◊™ ◊ê◊ô◊ñ◊ï◊® ◊†◊ô◊™◊ü ◊ú◊î◊ß◊ú◊ß◊î ◊©◊†◊™◊†◊ï ◊ú◊ï ◊ê◊™ ◊î◊©◊ù "◊ß◊ô◊©◊ï◊®" ◊©◊û◊ï◊ë◊ô◊ú ◊ú◊ê◊ô◊ñ◊ï◊® ◊ê◊ó◊® ◊ë◊ê◊ï◊™◊ï ◊î◊û◊°◊û◊ö.

◊¢◊ú ◊û◊†◊™ ◊ú◊ô◊¶◊ï◊® ◊ß◊ô◊©◊ï◊® ◊ó◊ô◊¶◊†◊ô ◊ë◊ê◊û◊¶◊¢◊ï◊™ ◊™◊û◊ï◊†◊î, ◊î◊©◊™◊û◊©◊†◊ï ◊ë◊û◊™◊ï◊ì◊î ()image. ◊ú◊û◊™◊ï◊ì◊î ◊ô◊© ◊ê◊ï◊§◊¶◊ô◊î ◊ú◊ß◊ë◊ú ◊ß◊ô◊©◊ï◊® ◊õ◊ê◊ó◊ì ◊î◊§◊®◊û◊ò◊®◊ô◊ù ◊©◊ú◊î. ◊î◊ß◊ô◊©◊ï◊® ◊ô◊õ◊ï◊ú ◊ú◊î◊ô◊ï◊™ ◊§◊†◊ô◊û◊ô ◊ê◊ï ◊ó◊ô◊¶◊ï◊†◊ô.

◊†◊ô◊™◊ü ◊í◊ù ◊ú◊î◊©◊™◊û◊© ◊ë◊û◊™◊ï◊ì◊î ()write_html ◊õ◊ì◊ô ◊ú◊©◊†◊ï◊™ ◊°◊í◊†◊ï◊†◊ï◊™ ◊í◊ï◊§◊ü ◊ï◊ú◊î◊ï◊°◊ô◊£ ◊ß◊ô◊©◊ï◊®◊ô◊ù. ◊ñ◊î◊ï ◊§◊ê◊®◊°◊® ◊©◊ú html, ◊©◊û◊ê◊§◊©◊® ◊ú◊î◊ï◊°◊ô◊£ ◊ò◊ß◊°◊ò, ◊ú◊©◊†◊ï◊™ ◊ê◊™ ◊î◊°◊í◊†◊ï◊ü ◊ï◊ú◊î◊ï◊°◊ô◊£ ◊ß◊ô◊©◊ï◊®◊ô◊ù ◊ë◊ê◊û◊¶◊¢◊ï◊™ html.

**Examples:**

Example 1 (python):
```python
from fpdf import FPDF

pdf = FPDF()
pdf.add_page()
pdf.set_font("helvetica", style="B", size=16)
pdf.cell(40, 10, "Hello World!")
pdf.output("tuto1.pdf")
```

Example 2 (unknown):
```unknown
pdf = FPDF(orientation="P", unit="mm", format="A4")
```

Example 3 (unknown):
```unknown
pdf.set_font('Helvetica', style='B', size=16)
```

Example 4 (unknown):
```unknown
pdf.cell(40, 10, 'Hello World!', 1)
```

---

## Images¬∂

**URL:** https://py-pdf.github.io/fpdf2/Images.html

**Contents:**
- Images¬∂
- Simple example¬∂
- Alpha / transparency¬∂
- Assembling images¬∂
  - Side by side images, full height, landscape page¬∂
  - Fitting an image inside a rectangle¬∂
    - Image alignment in the bounding box¬∂
  - Blending images¬∂
- Image clipping¬∂
- Alternative description¬∂

When rendering an image, its size on the page can be specified in several ways:

Note that if an image is displayed several times, only one copy is embedded in the file.

By default an image is rendered with a resolution of 72 dpi, but you can control its dimension on the page using the w= & h= parameters of the image() method.

fpdf2 allows to embed images with alpha pixels.

Technically, it is implemented by extracting an /SMask from images with transparency, and inserting it along with the image data in the PDF document. Related code is in the image_parsing module.

The following code snippets provide examples of some basic layouts for assembling images into PDF files.

When you want to scale an image to fill a rectangle, while keeping its aspect ratio, and ensuring it does not overflow the rectangle width nor height in the process, you can set w / h and also provide keep_aspect_ratio=True to the image() method. This will place the image at the centre of the bounding box.

The following unit tests illustrate that:

To anchor the image to a specific corner, you can use this function:

You can control the color blending mode of overlapping images. Valid values for blend_mode are Normal, Multiply, Screen, Overlay, Darken, Lighten, ColorDodge, ColorBurn, HardLight, SoftLight, Difference, Exclusion, Hue, Saturation, Color and Luminosity.

Demo of all color blend modes: blending_images.pdf

You can select only a portion of the image to render using clipping methods:

A textual description of the image can be provided, for accessibility purposes:

You can perform image manipulations using the Pillow library, and easily embed the result:

SVG images passed to the image() method will be embedded as PDF paths: from fpdf import FPDF pdf = FPDF() pdf.add_page() pdf.image("SVG_logo.svg", w=100) pdf.output("pdf-with-vector-image.pdf")

URLs to images can be directly passed to the image() method:

By default, fpdf2 will avoid altering or recompressing your images: when possible, the original bytes from the JPG or TIFF file will be used directly. Bitonal images are by default compressed as TIFF Group4.

However, you can easily tell fpdf2 to embed all images as JPEGs in order to reduce your PDF size, using set_image_filter():

The allowed image_filter values are listed in the set_image_filter() method documentation.

Beware that "flattening" images into JPEGs this way will fill transparent areas of your images with color (usually black).

Output Intents [allow] the contents of referenced icc profiles to be embedded directly within the body of the PDF file. This makes the PDF file a self-contained unit that can be stored or transmitted as a single entity.

The dedicated method for adding output intent to a PDF is add_output_intent().

You can optionally provide a PDFICCProfileObject as icc_profile.

Example: from pathlib import Path from fpdf import FPDF from fpdf.enums import OutputIntentSubType from fpdf.output import PDFICCProfileObject HERE = Path(__file__).resolve().parent pdf = FPDF() with open(HERE / "sRGB2014.icc", "rb") as iccp_file: icc_profile = PDFICCProfileObject( contents=iccp_file.read(), n=3, alternate="DeviceRGB" ) pdf.add_output_intent( OutputIntentSubType.PDFA, "sRGB", 'IEC 61966-2-1:1999', "http://www.color.org", icc_file, "sRGB2014 (v2)", )

The needed profiles and descriptions can be found at International Color Consortium.

The ICC profile of the included images are read through the PIL function Image.info.get("icc_profile)" and are included in the PDF as objects.

An ICC profile can also be added by using the .add_output_intent() method, as described in the previous section.

If the resulting PDF size is a concern, you may want to check if some inserted images are oversized, meaning their resolution is unnecessarily high given the size they are displayed.

There is how to enable this detection mechanism with fpdf2:

After setting this property, a WARNING log will be displayed whenever an oversized image is inserted.

fpdf2 is also able to automatically downscale such oversized images:

After this, oversized images will be automatically resized, generating DEBUG logs like this: OVERSIZED: Generated new low-res image with name=lowres-test.png dims=(319, 451) id=2

For finer control, you can set pdf.oversized_images_ratio to set the threshold determining if an image is oversized.

If the concepts of "image compression" or "image resolution" are a bit obscure for you, this article is a recommended reading: The 5 minute guide to image quality

By default images transparency is preserved: alpha channels are extracted and converted to an embedded SMask. This can be disabled by setting .allow_images_transparency, e.g. to allow compliance with PDF/A-1:

This will fill transparent areas of your images with color (usually black).

cf. also documentation on controlling transparency.

cf. Per-page format, orientation and background

Image parsing is often the most CPU & memory intensive step when inserting pictures in a PDF.

If you create several PDF files that use the same illustrations, you can share the images cache among FPDF instances:

This recipe is valid for fpdf2 v2.5.7+. For previous versions of fpdf2, a deepcopy of .images must be made, (cf. issue #501).

**Examples:**

Example 1 (swift):
```swift
from fpdf import FPDF

pdf = FPDF()
pdf.add_page()
pdf.image("docs/fpdf2-logo.png", x=20, y=60)
pdf.output("pdf-with-image.pdf")
```

Example 2 (swift):
```swift
from fpdf import FPDF

pdf = FPDF(orientation="landscape")
pdf.set_margin(0)
pdf.add_page()
pdf.image("imgA.png", h=pdf.eph, w=pdf.epw/2)               # full page height, half page width
pdf.set_y(0)
pdf.image("imgB.jpg", h=pdf.eph, w=pdf.epw/2, x=pdf.epw/2)  # full page height, half page width, right half of the page
pdf.output("side-by-side.pdf")
```

Example 3 (python):
```python
from typing import Literal, TypedDict
from fpdf import FPDF
from fpdf.image_parsing import preload_image

class FpdfBoundingBox(TypedDict):
    x: float
    y: float
    w: float
    h: float

def scale_and_position_image(
    pdf: FPDF,
    image_path: str,
    bounding_box: FpdfBoundingBox,
    anchor: Literal["TL", "TR", "BL", "BR", "C"],
) -> None:
    if anchor == "C":
        pdf.image(
            str(image_path),
            x=bounding_box["x"],
            y=bounding_box["y"],
            w=bounding_box["w"],
            h=bounding_box["h"],
            keep_aspect_ratio=True,
        )
        return

    info = preload_image(pdf.image_cache, str(image_path))[2]
    _, _, scaled_w, scaled_h = info.scale_inside_box(**bounding_box)

    # default to top left
    x, y = bounding_box["x"], bounding_box["y"]
    if "B" in anchor:
        y = bounding_box["y"] + bounding_box["h"] - scaled_h
    if "R" in anchor:
        x = bounding_box["x"] + bounding_box["w"] - scaled_w

    pdf.image(
        str(image_path),
        x=x,
        y=y,
        w=scaled_w,
        h=scaled_h,
        keep_aspect_ratio=True,
    )

# Usage example:
pdf = FPDF()
pdf.add_page()
bounding_box = FpdfBoundingBox(x=pdf.w-pdf.r_margin-100, y=pdf.t_margin, w=100, h=50)
# Render the bounding box:
pdf.set_draw_color(255, 0, 0)
pdf.rect(**bounding_box, style="D")
# Insert image:
scale_and_position_image(pdf, "./test/image/png_indexed/flower1.png", bounding_box, "BR")
pdf.output("image_in_bounding_box_example.pdf")
```

Example 4 (python):
```python
from fpdf import FPDF

pdf = FPDF()
pdf.add_page()
pdf.image("imgA.png", ...)
with pdf.local_context(blend_mode="ColorBurn"):
    pdf.image("imgB.jpg", ...)
pdf.output("blended-images.pdf")
```

---

## Module fpdf.util

**URL:** https://py-pdf.github.io/fpdf2/fpdf/util.html

**Contents:**
- Module fpdf.util
- Functions
- Returns
- Args
- Returns
- Raises
- Args
- Returns
- Classes
  - Ancestors

Various utilities that could not be gathered logically in a specific module.

The contents of this module are internal to fpdf2, and not part of the public API. They may change at any time without prior warning or any deprecation period, in non-backward-compatible ways.

Convert a number or sequence of numbers from one unit to another.

If either unit is a number it will be treated as the number of points per unit. So 72 would mean 1 inch.

Args: to_convert (float, int, Iterable): The number / list of numbers, or points, to convert old_unit (str, float, int): A unit accepted by FPDF or a number new_unit (str, float, int): A unit accepted by FPDF or a number

(float, tuple): to_convert converted from old_unit to new_unit or a tuple of the same

Add a backslash character before , ( and )

Parse unicode_range parameter into a set of codepoints.

Supports CSS-style formats:

Returns a set of integer codepoints.

Get how many pts are in a unit. (k)

Convert an integer to Roman numeral

Convert an integer to a letter value (A to Z for the first 26, then AA to ZZ, and so on)

Convert a decimal number to a minimal string representation (no trailing 0 or .).

The number's string representation.

Padding(top, right, bottom, left)

Return a 4-tuple of padding values from a single value or a 2, 3 or 4-tuple according to CSS rules

Alias for field number 2

Alias for field number 3

Alias for field number 1

Alias for field number 0

**Examples:**

Example 1 (python):
```python
def buffer_subst(buffer: bytearray, placeholder: str, value: str) -> bytearray:
    buffer_size = len(buffer)
    assert len(placeholder) == len(value), f"placeholder={placeholder} value={value}"
    buffer = buffer.replace(placeholder.encode(), value.encode(), 1)
    assert len(buffer) == buffer_size
    return buffer
```

Example 2 (python):
```python
def builtin_srgb2014_bytes() -> bytes:
    pkg = "fpdf.data.color_profiles"
    return (resources.files(pkg) / "sRGB2014.icc").read_bytes()
```

Example 3 (python):
```python
def convert_unit(
    to_convert: Number | Iterable[Any],
    old_unit: Union[str, Number],
    new_unit: Union[str, Number],
) -> Union[float, tuple[Any, ...]]:
    """
     Convert a number or sequence of numbers from one unit to another.

     If either unit is a number it will be treated as the number of points per unit.  So 72 would mean 1 inch.

     Args:
        to_convert (float, int, Iterable): The number / list of numbers, or points, to convert
        old_unit (str, float, int): A unit accepted by `fpdf.fpdf.FPDF` or a number
        new_unit (str, float, int): A unit accepted by `fpdf.fpdf.FPDF` or a number
    Returns:
        (float, tuple): to_convert converted from old_unit to new_unit or a tuple of the same
    """
    unit_conversion_factor = get_scale_factor(new_unit) / get_scale_factor(old_unit)
    if isinstance(to_convert, Iterable):
        return tuple(convert_unit(i, 1, unit_conversion_factor) for i in to_convert)
    return float(to_convert) / unit_conversion_factor
```

Example 4 (python):
```python
def escape_parens(s: _StrBytes) -> _StrBytes:
    """Add a backslash character before , ( and )"""
    if isinstance(s, str):
        return (
            s.replace("\\", "\\\\")
            .replace(")", "\\)")
            .replace("(", "\\(")
            .replace("\r", "\\r")
        )
    return (
        s.replace(b"\\", b"\\\\")
        .replace(b")", b"\\)")
        .replace(b"(", b"\\(")
        .replace(b"\r", b"\\r")
    )
```

---

## Package fpdf

**URL:** https://py-pdf.github.io/fpdf2/fpdf/

**Contents:**
- Package fpdf
- Sub-modules
- Global variables

Root module. Gives direct access to some classes defined in submodules:

Usage documentation at: https://py-pdf.github.io/fpdf2/Annotations.html

Utilities to manage deprecation errors & warnings ‚Ä¶

Vector drawing: managing colors, graphics states, paths, transforms ‚Ä¶

Core drawing primitives for fpdf2 ‚Ä¶

Utilities to perform encryption following the PDF standards ‚Ä¶

This module provides support for embedding and rendering various color font formats in PDF documents using Type 3 fonts. It defines classes and ‚Ä¶

Font-related classes & constants. Includes the definition of the character widths of all PDF standard fonts ‚Ä¶

Mixin class for managing a stack of graphics state variables ‚Ä¶

Routines for organizing lines and larger blocks of text, with manual and automatic line wrapping ‚Ä¶

This module is in work-in-progress state. Hint tables / hint streams have not been implemented yet, and there are a few "TODO" comment remaining. cf ‚Ä¶

Quoting section 8.2.2 "Document Outline" of the 2006 PDF spec 1.7:

The document outline consists of a tree-structured hierarchy of outline items ‚Ä¶

This module contains the serialization logic that produces a PDF document from a FPDF instance. Most of the code in this module is used when ‚Ä¶

Handles the creation of patterns and gradients ‚Ä¶

Usage documentation at: https://py-pdf.github.io/fpdf2/PageFormatAndOrientation.html#viewer-preferences

A wrapper class to allow rewinding/replaying changes made to a FPDF instance ‚Ä¶

Module dedicated to document signature generation ‚Ä¶

Quoting the PDF spec:

PDF‚Äôs logical structure facilities provide a mechanism for incorporating structural information about a document‚Äôs content ‚Ä¶

Utilities to parse SVG graphics into fpdf.drawing objects ‚Ä¶

Classes & functions that represent core elements of the PDF syntax ‚Ä¶

Usage documentation at: https://py-pdf.github.io/fpdf2/Tables.html

PDF template helpers for fpdf2 ‚Ä¶

Usage documentation at: https://py-pdf.github.io/fpdf2/TextRegion.html

Usage documentation at: https://py-pdf.github.io/fpdf2/Presentations.html#transitions

The hardcoded information on this module was loaded from the Unicode file Scripts-16.0.0.txt https://www.unicode.org/Public/UNIDATA/Scripts.txt ‚Ä¶

Various utilities that could not be gathered logically in a specific module ‚Ä¶

Extra filesystem folder where fpdf2 looks for fonts files, after the current directory

Current fpdf2 version, also available as __version__

---

## PDF/A with fpdf2¬∂

**URL:** https://py-pdf.github.io/fpdf2/pdfa.html

**Contents:**
- PDF/A with fpdf2¬∂
- What is PDF/A¬∂
- Choosing a PDF/A Profile¬∂
- How to produce PDF/A with fpdf2¬∂
  - Pick a profile at construction time¬∂
  - Quick example¬∂
- Future: Accessible documents (WCAG/PDF/UA)¬∂

PDF/A is the ISO standard for long-term archiving of PDFs. It restricts features that aren‚Äôt stable for preservation (e.g., JavaScript, encryption, multimedia) and requires self-containment (fonts embedded, color spaces defined, predictable rendering).

To enable PDF/A 2A and 3A compliance FPDF needs to be able to produce accessible documents. Those features need to be implemented:

**Examples:**

Example 1 (python):
```python
from fpdf import FPDF
from fpdf.enums import DocumentCompliance

pdf = FPDF(enforce_compliance=DocumentCompliance.PDFA_4)
```

Example 2 (unknown):
```unknown
pdf = FPDF(enforce_compliance=DocumentCompliance.PDFA_4)
pdf.add_page()
pdf.set_font("Helvetica", size=12)
pdf.cell(0, 10, "Modern archival PDF, PDF 2.0 based.")
pdf.output("example-4.pdf")
```

---

## Annotations¬∂

**URL:** https://py-pdf.github.io/fpdf2/Annotations.html

**Contents:**
- Annotations¬∂
- Text annotations¬∂
- Free Text Annotations¬∂
- Highlights¬∂
- Ink annotations¬∂
- File attachments¬∂
- Named actions¬∂
- Launch actions¬∂

The PDF format allows to add various annotations to a document.

They are rendered this way by Sumatra PDF reader:

Method documentation: FPDF.text_annotation

They are rendered this way by Adobe Acrobat Reader:

from fpdf import FPDF pdf = FPDF() pdf.add_page() pdf.set_font("Helvetica",size=24) pdf.text(x=60, y=140, text="Some text.") pdf.set_draw_color(255,0,0) pdf.set_font_size(12) pdf.free_text_annotation( x=100, y=130, text="This is a free text annotation.", w=150, h=15, ) pdf.output("free_text_annotation.pdf") Method documentation: FPDF.free_text_annotation

Rendering by Sumatra PDF reader:

Method documentation: FPDF.highlight

The appearance of the "highlight effect" can be controlled through the type argument: it can be Highlight (default), Underline, Squiggly or StrikeOut.

Those annotations allow to draw paths around parts of a document to highlight them: from fpdf import FPDF pdf = FPDF() pdf.ink_annotation([(100, 200), (200, 100), (300, 200), (200, 300), (100, 200)], title="Lucas", contents="Hello world!") pdf.output("ink_annotation_demo.pdf")

Rendering by Firefox internal PDF viewer:

Method documentation: FPDF.ink_annotation

cf. the dedicated page: File attachments

The four standard PDF named actions provide some basic navigation relative to the current page: NextPage, PrevPage, FirstPage and LastPage.

Used to launch an application or open or print a document:

**Examples:**

Example 1 (swift):
```swift
from fpdf import FPDF

pdf = FPDF()
pdf.add_page()
pdf.set_font("Helvetica", size=24)
pdf.text(x=60, y=140, text="Some text.")
pdf.text_annotation(
    x=100,
    y=130,
    text="This is a text annotation.",
)
pdf.output("text_annotation.pdf")
```

Example 2 (swift):
```swift
from fpdf import FPDF

pdf = FPDF()
pdf.add_page()
pdf.set_font("Helvetica",size=24)
pdf.text(x=60, y=140, text="Some text.")
pdf.set_draw_color(255,0,0)
pdf.set_font_size(12)
pdf.free_text_annotation(
    x=100,
    y=130,
    text="This is a free text annotation.",
    w=150,
    h=15,
)
pdf.output("free_text_annotation.pdf")
```

Example 3 (swift):
```swift
from fpdf import FPDF

pdf = FPDF()
pdf.add_page()
pdf.set_font("Helvetica", size=24)
with pdf.highlight("Highlight comment"):
    pdf.text(50, 50, "Line 1")
    pdf.set_y(50)
    pdf.multi_cell(w=30, text="Line 2")
pdf.cell(w=60, text="Not highlighted", border=1)
pdf.output("highlighted.pdf")
```

Example 4 (python):
```python
from fpdf import FPDF

pdf = FPDF()
pdf.ink_annotation([(100, 200), (200, 100), (300, 200), (200, 300), (100, 200)],
                   title="Lucas", contents="Hello world!")
pdf.output("ink_annotation_demo.pdf")
```

---
